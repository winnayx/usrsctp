use ::c2rust_bitfields;
use ::libc;
extern "C" {
    pub type accept_filter;
    pub type label;
    pub type ifnet;
    pub type aiocblist;
    pub type sigio;
    pub type iface;
    /*-
     * Copyright (c) 1982, 1986, 1990, 1993
     *	The Regents of the University of California.  All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions
     * are met:
     * 1. Redistributions of source code must retain the above copyright
     *    notice, this list of conditions and the following disclaimer.
     * 2. Redistributions in binary form must reproduce the above copyright
     *    notice, this list of conditions and the following disclaimer in the
     *    documentation and/or other materials provided with the distribution.
     * 4. Neither the name of the University nor the names of its contributors
     *    may be used to endorse or promote products derived from this software
     *    without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
     * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
     * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
     * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
     * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
     * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
     * SUCH DAMAGE.
     *
     *	@(#)in_pcb.h	8.1 (Berkeley) 6/10/93
     * $FreeBSD: src/sys/netinet/in_pcb.h,v 1.100.2.1 2007/12/07 05:46:08 kmacy Exp $
     */
    pub type inpcbpolicy;
    /*
     * PCB with AF_INET6 null bind'ed laddr can receive AF_INET input packet.
     * So, AF_INET6 null laddr is also used as AF_INET null laddr, by utilizing
     * the following structure.
     */
    /*
     * NOTE: ipv6 addrs should be 64-bit aligned, per RFC 2553.  in_conninfo has
     * some extra padding to accomplish this.
     */
    /* foreign port */
    /* local port */
    /* protocol dependent part, local and foreign addr */
    /* foreign host table entry */
    /* local host table entry */
    /*
     * XXX The defines for inc_* are hacks and should be changed to direct
     * references.
     */
    /* XXX alignment for in_endpoints */
    /* protocol dependent part */
    /* temp compatibility */
    pub type icmp6_filter;
    pub type ip6_pktopts;
    pub type ip_moptions;
    pub type uma_zone;
    pub type llentry;
    pub type rtentry;
    #[no_mangle]
    fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    #[no_mangle]
    fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    #[no_mangle]
    fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    #[no_mangle]
    fn snprintf(
        _: *mut libc::c_char,
        _: libc::c_ulong,
        _: *const libc::c_char,
        _: ...
    ) -> libc::c_int;
    #[no_mangle]
    fn memcpy(_: *mut libc::c_void, _: *const libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
    #[no_mangle]
    fn memset(_: *mut libc::c_void, _: libc::c_int, _: libc::c_ulong) -> *mut libc::c_void;
    #[no_mangle]
    fn strncmp(_: *const libc::c_char, _: *const libc::c_char, _: libc::c_ulong) -> libc::c_int;
    #[no_mangle]
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    #[no_mangle]
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    #[no_mangle]
    fn free(__ptr: *mut libc::c_void);
    /* XXX */
    /* _KERNEL */
    /*-------------------------------------------------------------*/
    /*-------------------------------------------------------------*/
    /*                   __Userspace__                             */
    /*-------------------------------------------------------------*/
    /*-------------------------------------------------------------*/
    /* this new __Userspace__ section is to copy portions of the _KERNEL block
     *  above into, avoiding having to port the entire thing at once...
     *  For function prototypes, the full bodies are in user_socket.c .
     */
    /* ---------------------------------------------------------- */
    /* --- function prototypes (implemented in user_socket.c) --- */
    /* ---------------------------------------------------------- */
    #[no_mangle]
    fn soisconnecting(so: *mut socket);
    /*__Userspace__ */
    #[no_mangle]
    fn uiomove(cp: *mut libc::c_void, n: libc::c_int, uio: *mut uio) -> libc::c_int;
    #[no_mangle]
    fn sbwait(sb: *mut sockbuf) -> libc::c_int;
    #[no_mangle]
    fn read_random(buf: *mut libc::c_void, count: libc::c_int) -> libc::c_int;
    /* errno's may differ per OS.  errno.h now included in sctp_os_userspace.h */
    /* Source: /usr/src/sys/sys/errno.h */
    /* #define	ENOSPC		28 */
    /* No space left on device */
    /* #define	ENOBUFS		55 */
    /* No buffer space available */
    /* #define	ENOMEM		12 */
    /* Cannot allocate memory */
    /* #define	EACCES		13 */
    /* Permission denied */
    /* #define	EFAULT		14 */
    /* Bad address */
    /* #define	EHOSTDOWN	64 */
    /* Host is down */
    /* #define	EHOSTUNREACH	65 */
    /* No route to host */
    /* Source ip_output.c. extern'd in ip_var.h */
    #[no_mangle]
    static mut ip_id: u_short;
    /* necessary for sctp_pcb.c */
    #[no_mangle]
    static mut ip_defttl: libc::c_int;
    #[no_mangle]
    fn m_free(m: *mut mbuf) -> *mut mbuf;
    #[no_mangle]
    fn m_uiotombuf(
        uio: *mut uio,
        how: libc::c_int,
        len: libc::c_int,
        align: libc::c_int,
        flags: libc::c_int,
    ) -> *mut mbuf;
    #[no_mangle]
    fn m_length(m0: *mut mbuf, last: *mut *mut mbuf) -> u_int;
    #[no_mangle]
    fn m_last(m: *mut mbuf) -> *mut mbuf;
    #[no_mangle]
    fn m_adj(_: *mut mbuf, _: libc::c_int);
    #[no_mangle]
    fn m_freem(_: *mut mbuf);
    #[no_mangle]
    fn m_copym(_: *mut mbuf, _: libc::c_int, _: libc::c_int, _: libc::c_int) -> *mut mbuf;
    #[no_mangle]
    fn m_prepend(_: *mut mbuf, _: libc::c_int, _: libc::c_int) -> *mut mbuf;
    #[no_mangle]
    fn m_copydata(_: *const mbuf, _: libc::c_int, _: libc::c_int, _: caddr_t);
    #[no_mangle]
    static mut max_linkhdr: libc::c_int;
    #[no_mangle]
    fn ntohl(__netlong: uint32_t) -> uint32_t;
    #[no_mangle]
    fn ntohs(__netshort: uint16_t) -> uint16_t;
    #[no_mangle]
    fn htonl(__hostlong: uint32_t) -> uint32_t;
    #[no_mangle]
    fn htons(__hostshort: uint16_t) -> uint16_t;
    #[no_mangle]
    fn sctp_os_timer_stop(_: *mut sctp_os_timer_t) -> libc::c_int;
    #[no_mangle]
    fn sctp_userspace_ip_output(
        result: *mut libc::c_int,
        o_pak: *mut mbuf,
        ro: *mut sctp_route_t,
        stcb: *mut libc::c_void,
        vrf_id: uint32_t,
    );
    #[no_mangle]
    fn sctp_get_mbuf_for_msg(
        space_needed: libc::c_uint,
        want_header: libc::c_int,
        how: libc::c_int,
        allonebuf: libc::c_int,
        type_0: libc::c_int,
    ) -> *mut mbuf;
    #[no_mangle]
    fn sctp_userspace_ip6_output(
        result: *mut libc::c_int,
        o_pak: *mut mbuf,
        ro: *mut route_in6,
        stcb: *mut libc::c_void,
        vrf_id: uint32_t,
    );
    #[no_mangle]
    fn gettimeofday(__tv: *mut timeval, __tz: __timezone_ptr_t) -> libc::c_int;
    #[no_mangle]
    fn sctp_auth_get_chklist_size(list: *const sctp_auth_chklist_t) -> size_t;
    #[no_mangle]
    fn sctp_serialize_auth_chunks(
        list: *const sctp_auth_chklist_t,
        ptr: *mut uint8_t,
    ) -> libc::c_int;
    /*-
     * For this call ep_addr, the to is the destination endpoint address of the
     * peer (relative to outbound). The from field is only used if the TCP model
     * is enabled and helps distingush amongst the subset bound (non-boundall).
     * The TCP model MAY change the actual ep field, this is why it is passed.
     */
    /* proc will be NULL for __Userspace__ */
    #[no_mangle]
    fn sctp_add_remote_addr(
        _: *mut sctp_tcb,
        _: *mut sockaddr,
        _: *mut *mut sctp_nets,
        _: uint16_t,
        _: libc::c_int,
        _: libc::c_int,
    ) -> libc::c_int;
    #[no_mangle]
    fn sctp_find_ifn(ifn: *mut libc::c_void, ifn_index: uint32_t) -> *mut sctp_ifn;
    #[no_mangle]
    fn sctp_find_vrf(vrfid: uint32_t) -> *mut sctp_vrf;
    #[no_mangle]
    fn sctp_add_local_addr_restricted(_: *mut sctp_tcb, _: *mut sctp_ifa);
    #[no_mangle]
    fn sctp_fill_hmac_digest_m(
        m: *mut mbuf,
        auth_offset: uint32_t,
        auth: *mut sctp_auth_chunk,
        stcb: *mut sctp_tcb,
        key_id: uint16_t,
    );
    #[no_mangle]
    fn sctp_auth_key_release(stcb: *mut sctp_tcb, keyid: uint16_t, so_locked: libc::c_int);
    #[no_mangle]
    fn sctp_aloc_assoc(
        _: *mut sctp_inpcb,
        _: *mut sockaddr,
        _: *mut libc::c_int,
        _: uint32_t,
        _: uint32_t,
        _: uint16_t,
        _: uint16_t,
        _: *mut proc_0,
        _: libc::c_int,
    ) -> *mut sctp_tcb;
    #[no_mangle]
    fn sctp_set_primary_addr(_: *mut sctp_tcb, _: *mut sockaddr, _: *mut sctp_nets) -> libc::c_int;
    #[no_mangle]
    fn sctp_free_ifa(sctp_ifap: *mut sctp_ifa);
    #[no_mangle]
    fn sctp_findassociation_ep_addr(
        _: *mut *mut sctp_inpcb,
        _: *mut sockaddr,
        _: *mut *mut sctp_nets,
        _: *mut sockaddr,
        _: *mut sctp_tcb,
    ) -> *mut sctp_tcb;
    #[no_mangle]
    fn sctp_findassociation_ep_asocid(
        _: *mut sctp_inpcb,
        _: sctp_assoc_t,
        _: libc::c_int,
    ) -> *mut sctp_tcb;
    #[no_mangle]
    static mut system_base_info: sctp_base_info;
    /* void sctp_drain(void); */
    /*-
     * Null in last arg inpcb indicate run on ALL ep's. Specific inp in last arg
     * indicates run on ONLY assoc's of the specified endpoint.
     */
    #[no_mangle]
    fn sctp_initiate_iterator(
        inpf: inp_func,
        af: asoc_func,
        inpe: inp_func,
        _: uint32_t,
        _: uint32_t,
        _: uint32_t,
        _: *mut libc::c_void,
        _: uint32_t,
        ef: end_func,
        _: *mut sctp_inpcb,
        co_off: uint8_t,
    ) -> libc::c_int;
    #[no_mangle]
    fn sctp_get_hmac_digest_len(hmac_algo: uint16_t) -> uint32_t;
    #[no_mangle]
    fn sctp_serialize_hmaclist(list: *mut sctp_hmaclist_t, ptr: *mut uint8_t) -> libc::c_int;
    #[no_mangle]
    fn sctp_findnet(_: *mut sctp_tcb, _: *mut sockaddr) -> *mut sctp_nets;
    #[no_mangle]
    fn sctp_free_assoc(
        _: *mut sctp_inpcb,
        _: *mut sctp_tcb,
        _: libc::c_int,
        _: libc::c_int,
    ) -> libc::c_int;
    #[no_mangle]
    fn SCTP6_ARE_ADDR_EQUAL(a: *mut sockaddr_in6, b: *mut sockaddr_in6) -> libc::c_int;
    #[no_mangle]
    fn sctp_get_auth_chunk_len(hmac_algo: uint16_t) -> uint32_t;
    #[no_mangle]
    fn sctp_auth_key_acquire(stcb: *mut sctp_tcb, keyid: uint16_t);
    #[no_mangle]
    fn sctp_is_address_on_local_host(addr: *mut sockaddr, vrf_id: uint32_t) -> libc::c_int;
    #[no_mangle]
    fn sctp_hmac_m(
        hmac_algo: uint16_t,
        key: *mut uint8_t,
        keylen: uint32_t,
        m: *mut mbuf,
        m_offset: uint32_t,
        digest: *mut uint8_t,
        trailer: uint32_t,
    ) -> uint32_t;
    #[no_mangle]
    fn sctp_select_initial_TSN(_: *mut sctp_pcb) -> uint32_t;
    #[no_mangle]
    fn sctp_select_a_tag(
        _: *mut sctp_inpcb,
        lport: uint16_t,
        rport: uint16_t,
        _: libc::c_int,
    ) -> uint32_t;
    #[no_mangle]
    fn sctp_timer_start(_: libc::c_int, _: *mut sctp_inpcb, _: *mut sctp_tcb, _: *mut sctp_nets);
    #[no_mangle]
    fn sctp_timer_stop(
        _: libc::c_int,
        _: *mut sctp_inpcb,
        _: *mut sctp_tcb,
        _: *mut sctp_nets,
        _: uint32_t,
    );
    #[no_mangle]
    fn sctp_mtu_size_reset(_: *mut sctp_inpcb, _: *mut sctp_association, _: uint32_t);
    #[no_mangle]
    fn sctp_calculate_len(_: *mut mbuf) -> uint32_t;
    #[no_mangle]
    fn sctp_m_getptr(_: *mut mbuf, _: libc::c_int, _: libc::c_int, _: *mut uint8_t) -> caddr_t;
    #[no_mangle]
    fn sctp_get_next_param(
        _: *mut mbuf,
        _: libc::c_int,
        _: *mut sctp_paramhdr,
        _: libc::c_int,
    ) -> *mut sctp_paramhdr;
    #[no_mangle]
    fn sctp_add_pad_tombuf(_: *mut mbuf, _: libc::c_int) -> *mut mbuf;
    #[no_mangle]
    fn sctp_pad_lastmbuf(_: *mut mbuf, _: libc::c_int, _: *mut mbuf) -> *mut mbuf;
    #[no_mangle]
    fn sctp_ulp_notify(
        _: uint32_t,
        _: *mut sctp_tcb,
        _: uint32_t,
        _: *mut libc::c_void,
        _: libc::c_int,
    );
    #[no_mangle]
    fn sctp_stop_timers_for_shutdown(_: *mut sctp_tcb);
    /* We choose to abort via user input */
    #[no_mangle]
    fn sctp_abort_an_association(
        _: *mut sctp_inpcb,
        _: *mut sctp_tcb,
        _: *mut mbuf,
        _: libc::c_int,
    );
    #[no_mangle]
    fn sctp_is_there_an_abort_here(_: *mut mbuf, _: libc::c_int, _: *mut uint32_t) -> libc::c_int;
    #[no_mangle]
    fn sctp_print_address(_: *mut sockaddr);
    #[no_mangle]
    fn sctp_release_pr_sctp_chunk(
        _: *mut sctp_tcb,
        _: *mut sctp_tmit_chunk,
        _: uint8_t,
        _: libc::c_int,
    ) -> libc::c_int;
    #[no_mangle]
    fn sctp_generate_cause(_: uint16_t, _: *mut libc::c_char) -> *mut mbuf;
    #[no_mangle]
    fn sctp_misc_ints(from: uint8_t, a: uint32_t, b: uint32_t, c: uint32_t, d: uint32_t);
    #[no_mangle]
    fn sctp_log_nagle_event(stcb: *mut sctp_tcb, action: libc::c_int);
    #[no_mangle]
    fn sctp_log_cwnd(stcb: *mut sctp_tcb, _: *mut sctp_nets, _: libc::c_int, _: uint8_t);
    #[no_mangle]
    fn sctp_log_maxburst(
        stcb: *mut sctp_tcb,
        _: *mut sctp_nets,
        _: libc::c_int,
        _: libc::c_int,
        _: uint8_t,
    );
    #[no_mangle]
    fn sctp_log_block(_: uint8_t, _: *mut sctp_association, _: ssize_t);
    #[no_mangle]
    fn sctp_log_rwnd(_: uint8_t, _: uint32_t, _: uint32_t, _: uint32_t);
    #[no_mangle]
    fn sctp_set_state(_: *mut sctp_tcb, _: libc::c_int);
    #[no_mangle]
    fn sctp_add_substate(_: *mut sctp_tcb, _: libc::c_int);
    /*-
     * SPDX-License-Identifier: BSD-3-Clause
     *
     * Copyright (c) 2001-2007, by Cisco Systems, Inc. All rights reserved.
     * Copyright (c) 2008-2012, by Randall Stewart. All rights reserved.
     * Copyright (c) 2008-2012, by Michael Tuexen. All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * a) Redistributions of source code must retain the above copyright notice,
     *    this list of conditions and the following disclaimer.
     *
     * b) Redistributions in binary form must reproduce the above copyright
     *    notice, this list of conditions and the following disclaimer in
     *    the documentation and/or other materials provided with the distribution.
     *
     * c) Neither the name of Cisco Systems, Inc. nor the names of its
     *    contributors may be used to endorse or promote products derived
     *    from this software without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
     * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
     * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
     * THE POSSIBILITY OF SUCH DAMAGE.
     */
    #[no_mangle]
    fn sctp_find_alternate_net(
        _: *mut sctp_tcb,
        _: *mut sctp_nets,
        mode: libc::c_int,
    ) -> *mut sctp_nets;
    #[no_mangle]
    fn sctp_compose_asconf(_: *mut sctp_tcb, _: *mut libc::c_int, _: libc::c_int) -> *mut mbuf;
    #[no_mangle]
    fn sctp_is_addr_pending(_: *mut sctp_tcb, _: *mut sctp_ifa) -> libc::c_int;
    #[no_mangle]
    fn sctp_set_rwnd(_: *mut sctp_tcb, _: *mut sctp_association);
    #[no_mangle]
    fn sctp_slide_mapping_arrays(stcb: *mut sctp_tcb);
    #[no_mangle]
    fn sctp_gather_internal_ifa_flags(ifa: *mut sctp_ifa);
    #[no_mangle]
    fn sctp_is_there_unsent_data(stcb: *mut sctp_tcb, so_locked: libc::c_int) -> libc::c_int;
    #[no_mangle]
    fn sctp_calculate_cksum(_: *mut mbuf, _: uint32_t) -> uint32_t;
    /*-
     * SPDX-License-Identifier: BSD-3-Clause
     *
     * Copyright (c) 2001-2007, by Cisco Systems, Inc. All rights reserved.
     * Copyright (c) 2008-2012, by Randall Stewart. All rights reserved.
     * Copyright (c) 2008-2012, by Michael Tuexen. All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * a) Redistributions of source code must retain the above copyright notice,
     *    this list of conditions and the following disclaimer.
     *
     * b) Redistributions in binary form must reproduce the above copyright
     *    notice, this list of conditions and the following disclaimer in
     *    the documentation and/or other materials provided with the distribution.
     *
     * c) Neither the name of Cisco Systems, Inc. nor the names of its
     *    contributors may be used to endorse or promote products derived
     *    from this software without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
     * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
     * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
     * THE POSSIBILITY OF SUCH DAMAGE.
     */
    #[no_mangle]
    fn in6_sin6_2_sin(_: *mut sockaddr_in, _: *mut sockaddr_in6);
}
pub type size_t = libc::c_ulong;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut libc::c_void,
    pub iov_len: size_t,
}
pub type __u_char = libc::c_uchar;
pub type __u_short = libc::c_ushort;
pub type __u_int = libc::c_uint;
pub type __u_long = libc::c_ulong;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __uint64_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __off_t = libc::c_long;
pub type __pid_t = libc::c_int;
pub type __time_t = libc::c_long;
pub type __suseconds_t = libc::c_long;
pub type __ssize_t = libc::c_long;
pub type __caddr_t = *mut libc::c_char;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type gid_t = __gid_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type ssize_t = __ssize_t;
pub type caddr_t = __caddr_t;
pub type int16_t = __int16_t;
pub type int32_t = __int32_t;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
pub type __pthread_list_t = __pthread_internal_list;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: libc::c_int,
    pub __count: libc::c_uint,
    pub __owner: libc::c_int,
    pub __nusers: libc::c_uint,
    pub __kind: libc::c_int,
    pub __spins: libc::c_short,
    pub __elision: libc::c_short,
    pub __list: __pthread_list_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub c2rust_unnamed: C2RustUnnamed_385,
    pub c2rust_unnamed_0: C2RustUnnamed_383,
    pub __g_refs: [libc::c_uint; 2],
    pub __g_size: [libc::c_uint; 2],
    pub __g1_orig_size: libc::c_uint,
    pub __wrefs: libc::c_uint,
    pub __g_signals: [libc::c_uint; 2],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union C2RustUnnamed_383 {
    pub __g1_start: libc::c_ulonglong,
    pub __g1_start32: C2RustUnnamed_384,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_384 {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union C2RustUnnamed_385 {
    pub __wseq: libc::c_ulonglong,
    pub __wseq32: C2RustUnnamed_386,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_386 {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}
pub type pthread_t = libc::c_ulong;

#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [libc::c_char; 4],
    pub __align: libc::c_int,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [libc::c_char; 40],
    pub __align: libc::c_long,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [libc::c_char; 48],
    pub __align: libc::c_longlong,
}
pub type sa_family_t = libc::c_ushort;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [libc::c_char; 14],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct cmsghdr {
    pub cmsg_len: size_t,
    pub cmsg_level: libc::c_int,
    pub cmsg_type: libc::c_int,
    pub __cmsg_data: [libc::c_uchar; 0],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ucred {
    pub pid: pid_t,
    pub uid: uid_t,
    pub gid: gid_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: uint32_t,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: uint32_t,
}
pub type uint32_t = __uint32_t;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: C2RustUnnamed_387,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union C2RustUnnamed_387 {
    pub __u6_addr8: [uint8_t; 16],
    pub __u6_addr16: [uint16_t; 8],
    pub __u6_addr32: [uint32_t; 4],
}
pub type uint16_t = __uint16_t;
pub type uint8_t = __uint8_t;
pub type in_port_t = uint16_t;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [libc::c_uchar; 8],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
pub type in_addr_t = uint32_t;
/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 2006-2007, by Cisco Systems, Inc. All rights reserved.
 * Copyright (c) 2008-2011, by Randall Stewart. All rights reserved.
 * Copyright (c) 2008-2011, by Michael Tuexen. All rights reserved.
 * Copyright (c) 2008-2011, by Brad Penoff. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * a) Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * b) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *   the documentation and/or other materials provided with the distribution.
 *
 * c) Neither the name of Cisco Systems, Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Userspace includes
 * All the opt_xxx.h files are placed in the kernel build directory.
 * We will place them in userspace stack build directory.
 */
/* !defined(Userspace_os_Windows) */
pub type userland_mutex_t = pthread_mutex_t;
pub type userland_cond_t = pthread_cond_t;
pub type userland_thread_t = pthread_t;
/* sys/mutex.h typically on FreeBSD */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct mtx {
    pub dummy: libc::c_int,
}
pub type uint64_t = __uint64_t;
pub type uintptr_t = libc::c_ulong;
/*-
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
/* __Userspace__ version of <sys/socketvar.h> goes here.*/
/* #include <sys/selinfo.h> */
/*__Userspace__ alternative?*/
/* for struct selinfo */
/* #include <sys/_lock.h>  was 0 byte file */
/* #include <sys/_mutex.h> was 0 byte file */
/* #include <sys/_sx.h> */
/*__Userspace__ alternative?*/
/* SCTP notification */
pub type uio_rw = libc::c_uint;
pub const UIO_WRITE: uio_rw = 1;
pub const UIO_READ: uio_rw = 0;
/* Segment flag values. */
pub type uio_seg = libc::c_uint;
/* from system space */
/* from user data space */
pub const UIO_SYSSPACE: uio_seg = 1;
pub const UIO_USERSPACE: uio_seg = 0;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct proc_0 {
    pub stub: libc::c_int,
}
/* __Userspace__ Are these all the fields we need?
 * Removing struct thread *uio_td;    owner field
*/

#[repr(C)]
#[derive(Copy, Clone)]
pub struct uio {
    pub uio_iov: *mut iovec,
    pub uio_iovcnt: libc::c_int,
    pub uio_offset: off_t,
    pub uio_resid: ssize_t,
    pub uio_segflg: uio_seg,
    pub uio_rw: uio_rw,
}
/* operation */
/* __Userspace__ */
/*
 * Kernel structure per socket.
 * Contains send and receive buffer queues,
 * handle on protocol and pointer to protocol
 * private data and error information.
 */
/*-
 * Locking key to struct socket:
 * (a) constant after allocation, no locking required.
 * (b) locked by SOCK_LOCK(so).
 * (c) locked by SOCKBUF_LOCK(&so->so_rcv).
 * (d) locked by SOCKBUF_LOCK(&so->so_snd).
 * (e) locked by ACCEPT_LOCK().
 * (f) not locked since integer reads/writes are atomic.
 * (g) used only as a sleep/wakeup address, no value.
 * (h) locked by global mutex so_global_mtx.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct socket {
    pub so_count: libc::c_int,
    pub so_type: libc::c_short,
    pub so_options: libc::c_short,
    pub so_linger: libc::c_short,
    pub so_state: libc::c_short,
    pub so_qstate: libc::c_int,
    pub so_pcb: *mut libc::c_void,
    pub so_dom: libc::c_int,
    pub so_head: *mut socket,
    pub so_incomp: C2RustUnnamed_395,
    pub so_comp: C2RustUnnamed_394,
    pub so_list: C2RustUnnamed_393,
    pub so_qlen: u_short,
    pub so_incqlen: u_short,
    pub so_qlimit: u_short,
    pub so_timeo: libc::c_short,
    pub timeo_cond: userland_cond_t,
    pub so_error: u_short,
    pub so_sigio: *mut sigio,
    pub so_oobmark: u_long,
    pub so_aiojobq: C2RustUnnamed_392,
    pub so_rcv: sockbuf,
    pub so_snd: sockbuf,
    pub so_upcall:
        Option<unsafe extern "C" fn(_: *mut socket, _: *mut libc::c_void, _: libc::c_int) -> ()>,
    pub so_upcallarg: *mut libc::c_void,
    pub so_cred: *mut ucred,
    pub so_label: *mut label,
    pub so_peerlabel: *mut label,
    pub so_gencnt: uint32_t,
    pub so_emuldata: *mut libc::c_void,
    pub so_accf: *mut so_accf,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct so_accf {
    pub so_accept_filter: *mut accept_filter,
    pub so_accept_filter_arg: *mut libc::c_void,
    pub so_accept_filter_str: *mut libc::c_char,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockbuf {
    pub sb_cond: userland_cond_t,
    pub sb_mtx: userland_mutex_t,
    pub sb_state: libc::c_short,
    pub sb_mb: *mut mbuf,
    pub sb_mbtail: *mut mbuf,
    pub sb_lastrecord: *mut mbuf,
    pub sb_sndptr: *mut mbuf,
    pub sb_sndptroff: u_int,
    pub sb_cc: u_int,
    pub sb_hiwat: u_int,
    pub sb_mbcnt: u_int,
    pub sb_mbmax: u_int,
    pub sb_ctl: u_int,
    pub sb_lowat: libc::c_int,
    pub sb_timeo: libc::c_int,
    pub sb_flags: libc::c_short,
}
/* type of external storage */
/*
 * The core of the mbuf object along with some shortcut defined for practical
 * purposes.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbuf {
    pub m_hdr: m_hdr,
    pub M_dat: C2RustUnnamed_388,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union C2RustUnnamed_388 {
    pub MH: C2RustUnnamed_389,
    pub M_databuf: [libc::c_char; 216],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_389 {
    pub MH_pkthdr: pkthdr,
    pub MH_dat: C2RustUnnamed_390,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union C2RustUnnamed_390 {
    pub MH_ext: m_ext,
    pub MH_databuf: [libc::c_char; 176],
}
/*-
 * Copyright (c) 1982, 1986, 1988, 1993
 *      The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
/* __Userspace__ header file for mbufs */
/* For Linux */
/* #define MSIZE 1024 */
/* mbuf initialization function */
/* modified for __Userspace__ */
/* Length to m_copy to copy all. */
/* umem_cache_t is defined in user_include/umem.h as
 * typedef struct umem_cache umem_cache_t;
 * Note:umem_zone_t is a pointer.
 */
/*-
 * Macros for type conversion:
 * mtod(m, t)	-- Convert mbuf pointer to data pointer of correct type.
 * dtom(x)	-- Convert data pointer within mbuf to mbuf pointer (XXX).
 */
/* Flags for mbuf being allocated */
/* Type of mbuf being allocated */
/* Not a type but a flag to allocate
a non-initialized mbuf */
/*
 * General mbuf allocator statistics structure.
 * __Userspace__ mbstat may be useful for gathering statistics.
 * In the kernel many of these statistics are no longer used as
 * they track allocator statistics through kernel UMA's built in statistics mechanism.
 */
/* XXX */
/* XXX */
/* times drained protocols for space */
/* XXX: times m_copym failed */
/* XXX: times m_pullup failed */
/* length of an mbuf */
/* length of an mbuf cluster */
/* min length of data to allocate a cluster */
/* length of data in an mbuf */
/* length of data in a header mbuf */
/* Number of mbtypes (gives # elems in mbtypes[] array: */
/* XXX: Sendfile stats should eventually move to their own struct */
/* times sendfile had to do disk I/O */
/* times sfbuf allocation failed */
/* times sfbuf allocation had to wait */
/*
 * Mbufs are of a single size, MSIZE (sys/param.h), which includes overhead.
 * An mbuf may add a single "mbuf cluster" of size MCLBYTES (also in
 * sys/param.h), which has no additional overhead and is used instead of the
 * internal data area; this is done when at least MINCLSIZE of data must be
 * stored.  Additionally, it is possible to allocate a separate buffer
 * externally and attach it to the mbuf in a way similar to that of mbuf
 * clusters.
 */
/* normal data len */
/* data len w/pkthdr */
/* smallest amount to put in cluster */
/* max amount to copy for compression */
/*
 * Header present at the beginning of every mbuf.
 */
/* next buffer in chain */
/* next chain in queue/record */
/* location of data */
/* amount of data in this mbuf */
/* flags; see below */
/* type of data in this mbuf */
/* word align                  */
/*
 * Packet tag structure (see below for details).
 */
/* List of packet tags */
/* Tag ID */
/* Length of data */
/* ABI/Module ID */
/*
 * Record/packet header in first mbuf of chain; valid only if M_PKTHDR is set.
 */
/* rcv interface */
/* variables for ip and tcp reassembly */
/* pointer to packet header */
/* total packet length */
/* variables for hardware checksum */
/* flags regarding checksum */
/* data field used by csum routines */
/* TSO segment size */
/* Ethernet 802.1p+q vlan tag */
/* list of packet tags */
/*
 * Description of external storage mapped into mbuf; valid only if M_EXT is
 * set.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct m_ext {
    pub ext_buf: caddr_t,
    pub ext_free: Option<unsafe extern "C" fn(_: *mut libc::c_void, _: *mut libc::c_void) -> ()>,
    pub ext_args: *mut libc::c_void,
    pub ext_size: u_int,
    pub ref_cnt: *mut u_int,
    pub ext_type: libc::c_int,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pkthdr {
    pub rcvif: *mut ifnet,
    pub header: *mut libc::c_void,
    pub len: libc::c_int,
    pub csum_flags: libc::c_int,
    pub csum_data: libc::c_int,
    pub tso_segsz: u_int16_t,
    pub ether_vtag: u_int16_t,
    pub tags: packet_tags,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct packet_tags {
    pub slh_first: *mut m_tag,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct m_tag {
    pub m_tag_link: C2RustUnnamed_391,
    pub m_tag_id: u_int16_t,
    pub m_tag_len: u_int16_t,
    pub m_tag_cookie: u_int32_t,
    pub m_tag_free: Option<unsafe extern "C" fn(_: *mut m_tag) -> ()>,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_391 {
    pub sle_next: *mut m_tag,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct m_hdr {
    pub mh_next: *mut mbuf,
    pub mh_nextpkt: *mut mbuf,
    pub mh_data: caddr_t,
    pub mh_len: libc::c_int,
    pub mh_flags: libc::c_int,
    pub mh_type: libc::c_short,
    pub pad: [uint8_t; 6],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_392 {
    pub tqh_first: *mut aiocblist,
    pub tqh_last: *mut *mut aiocblist,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_393 {
    pub tqe_next: *mut socket,
    pub tqe_prev: *mut *mut socket,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_394 {
    pub tqh_first: *mut socket,
    pub tqh_last: *mut *mut socket,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_395 {
    pub tqh_first: *mut socket,
    pub tqh_last: *mut *mut socket,
}
pub type sctp_zone_t = size_t;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifaddr {
    pub ifa_addr: sockaddr,
    pub ifa_ifu: C2RustUnnamed_396,
    pub ifa_ifp: *mut iface,
    pub ifa_next: *mut ifaddr,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union C2RustUnnamed_396 {
    pub ifu_broadaddr: sockaddr,
    pub ifu_dstaddr: sockaddr,
}
pub type C2RustUnnamed_397 = libc::c_uint;
pub const IPPROTO_MAX: C2RustUnnamed_397 = 256;
pub const IPPROTO_RAW: C2RustUnnamed_397 = 255;
pub const IPPROTO_MPLS: C2RustUnnamed_397 = 137;
pub const IPPROTO_UDPLITE: C2RustUnnamed_397 = 136;
pub const IPPROTO_SCTP: C2RustUnnamed_397 = 132;
pub const IPPROTO_COMP: C2RustUnnamed_397 = 108;
pub const IPPROTO_PIM: C2RustUnnamed_397 = 103;
pub const IPPROTO_ENCAP: C2RustUnnamed_397 = 98;
pub const IPPROTO_BEETPH: C2RustUnnamed_397 = 94;
pub const IPPROTO_MTP: C2RustUnnamed_397 = 92;
pub const IPPROTO_AH: C2RustUnnamed_397 = 51;
pub const IPPROTO_ESP: C2RustUnnamed_397 = 50;
pub const IPPROTO_GRE: C2RustUnnamed_397 = 47;
pub const IPPROTO_RSVP: C2RustUnnamed_397 = 46;
pub const IPPROTO_IPV6: C2RustUnnamed_397 = 41;
pub const IPPROTO_DCCP: C2RustUnnamed_397 = 33;
pub const IPPROTO_TP: C2RustUnnamed_397 = 29;
pub const IPPROTO_IDP: C2RustUnnamed_397 = 22;
pub const IPPROTO_UDP: C2RustUnnamed_397 = 17;
pub const IPPROTO_PUP: C2RustUnnamed_397 = 12;
pub const IPPROTO_EGP: C2RustUnnamed_397 = 8;
pub const IPPROTO_TCP: C2RustUnnamed_397 = 6;
pub const IPPROTO_IPIP: C2RustUnnamed_397 = 4;
pub const IPPROTO_IGMP: C2RustUnnamed_397 = 2;
pub const IPPROTO_ICMP: C2RustUnnamed_397 = 1;
pub const IPPROTO_IP: C2RustUnnamed_397 = 0;

#[repr(C)]
#[derive(Copy, Clone, BitfieldStruct)]
pub struct ip {
    #[bitfield(name = "ip_hl", ty = "libc::c_uint", bits = "0..=3")]
    #[bitfield(name = "ip_v", ty = "libc::c_uint", bits = "4..=7")]
    pub ip_hl_ip_v: [u8; 1],
    pub ip_tos: uint8_t,
    pub ip_len: libc::c_ushort,
    pub ip_id: libc::c_ushort,
    pub ip_off: libc::c_ushort,
    pub ip_ttl: uint8_t,
    pub ip_p: uint8_t,
    pub ip_sum: libc::c_ushort,
    pub ip_src: in_addr,
    pub ip_dst: in_addr,
}
/*-
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
/*
 * Kernel resident routing tables.
 *
 * The routing tables are initialized when interface addresses
 * are set by making entries for all directly connected interfaces.
 */
/*
 * A route consists of a destination address and a reference
 * to a routing entry.  These are often held by protocols
 * in their control blocks, e.g. inpcb.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_route {
    pub ro_rt: *mut sctp_rtentry,
    pub ro_dst: sockaddr,
}
/* MTU for this path */
/*
 * We distinguish between routes to hosts and routes to networks,
 * preferring the former if available.  For each route we infer
 * the interface to use from the gateway address supplied when
 * the route was entered.  Routes that forward packets through
 * gateways are marked so that the output routines know to address the
 * gateway rather than the ultimate destination.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_rtentry {
    pub rt_ifp: *mut ifnet,
    pub rt_ifa: *mut ifaddr,
    pub rt_rmx: sctp_rt_metrics_lite,
    pub rt_refcnt: libc::c_long,
    pub rt_mtx: mtx,
}
/*
 * These numbers are used by reliable protocols for determining
 * retransmission behavior and are included in the routing structure.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_rt_metrics_lite {
    pub rmx_mtu: uint32_t,
}
/*
 * Struct inpcb is the ommon structure pcb for the Internet Protocol
 * implementation.
 *
 * Pointers to local and foreign host table entries, local and foreign socket
 * numbers, and pointers up (to a socket structure) and down (to a
 * protocol-specific control block) are stored here.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct inpcbhead {
    pub lh_first: *mut inpcb,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct inpcb {
    pub inp_hash: C2RustUnnamed_405,
    pub inp_list: C2RustUnnamed_404,
    pub inp_ppcb: *mut libc::c_void,
    pub inp_pcbinfo: *mut inpcbinfo,
    pub inp_socket: *mut socket,
    pub inp_flow: u_int32_t,
    pub inp_flags: libc::c_int,
    pub inp_vflag: u_char,
    pub inp_ip_ttl: u_char,
    pub inp_ip_p: u_char,
    pub inp_ip_minttl: u_char,
    pub inp_ispare1: uint32_t,
    pub inp_pspare: [*mut libc::c_void; 2],
    pub inp_inc: in_conninfo,
    pub inp_label: *mut label,
    pub inp_sp: *mut inpcbpolicy,
    pub inp_depend4: C2RustUnnamed_401,
    pub inp_depend6: C2RustUnnamed_400,
    pub inp_portlist: C2RustUnnamed_399,
    pub inp_phd: *mut inpcbport,
    pub inp_mtx: mtx,
}
/* default hop limit */
/* for KAME src sync over BSD*'s */
/* for KAME src sync over BSD*'s */
/* for KAME src sync over BSD*'s */
/* for KAME src sync over BSD*'s */
/* for KAME src sync over BSD*'s */
/*
 * The range of the generation count, as used in this implementation, is 9e19.
 * We would have to create 300 billion connections per second for this number
 * to roll over in a year.  This seems sufficiently unlikely that we simply
 * don't concern ourselves with that possibility.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct inpcbport {
    pub phd_hash: C2RustUnnamed_398,
    pub phd_pcblist: inpcbhead,
    pub phd_port: u_short,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_398 {
    pub le_next: *mut inpcbport,
    pub le_prev: *mut *mut inpcbport,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_399 {
    pub le_next: *mut inpcb,
    pub le_prev: *mut *mut inpcb,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_400 {
    pub inp6_options: *mut mbuf,
    pub inp6_outputopts: *mut ip6_pktopts,
    pub inp6_icmp6filt: *mut crate::sctp6_usrreq::icmp6_filter,
    pub inp6_cksum: libc::c_int,
    pub inp6_hops: libc::c_short,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_401 {
    pub inp4_ip_tos: u_char,
    pub inp4_options: *mut mbuf,
    pub inp4_moptions: *mut ip_moptions,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct in_conninfo {
    pub inc_flags: u_int8_t,
    pub inc_len: u_int8_t,
    pub inc_pad: u_int16_t,
    pub inc_ie: in_endpoints,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct in_endpoints {
    pub ie_fport: u_int16_t,
    pub ie_lport: u_int16_t,
    pub ie_dependfaddr: C2RustUnnamed_403,
    pub ie_dependladdr: C2RustUnnamed_402,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union C2RustUnnamed_402 {
    pub ie46_local: in_addr_4in6,
    pub ie6_local: in6_addr,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct in_addr_4in6 {
    pub ia46_pad32: [u_int32_t; 3],
    pub ia46_addr4: in_addr,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union C2RustUnnamed_403 {
    pub ie46_foreign: in_addr_4in6,
    pub ie6_foreign: in6_addr,
}
/*
 * Global data structure for each high-level protocol (UDP, TCP, ...) in both
 * IPv4 and IPv6.  Holds inpcb lists and information for managing them.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct inpcbinfo {
    pub ipi_listhead: *mut inpcbhead,
    pub ipi_count: u_int,
    pub ipi_hashbase: *mut inpcbhead,
    pub ipi_hashmask: u_long,
    pub ipi_porthashbase: *mut inpcbporthead,
    pub ipi_porthashmask: u_long,
    pub ipi_lastport: u_short,
    pub ipi_lastlow: u_short,
    pub ipi_lasthi: u_short,
    pub ipi_zone: *mut uma_zone,
    pub ipi_mtx: mtx,
    pub ipi_pspare: [*mut libc::c_void; 2],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct inpcbporthead {
    pub lh_first: *mut inpcbport,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_404 {
    pub le_next: *mut inpcb,
    pub le_prev: *mut *mut inpcb,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_405 {
    pub le_next: *mut inpcb,
    pub le_prev: *mut *mut inpcb,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_hdr {
    pub ip6_ctlun: C2RustUnnamed_406,
    pub ip6_src: in6_addr,
    pub ip6_dst: in6_addr,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union C2RustUnnamed_406 {
    pub ip6_un1: ip6_hdrctl,
    pub ip6_un2_vfc: uint8_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_hdrctl {
    pub ip6_un1_flow: uint32_t,
    pub ip6_un1_plen: uint16_t,
    pub ip6_un1_nxt: uint8_t,
    pub ip6_un1_hlim: uint8_t,
}
/*-
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
/*-
 * Copyright (c) 1982, 1986, 1993
 *      The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct route_in6 {
    pub ro_rt: *mut rtentry,
    pub ro_lle: *mut llentry,
    pub ro_ia6: *mut in6_addr,
    pub ro_flags: libc::c_int,
    pub ro_dst: sockaddr_in6,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct calloutlist {
    pub tqh_first: *mut sctp_callout,
    pub tqh_last: *mut *mut sctp_callout,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_callout {
    pub tqe: C2RustUnnamed_407,
    pub c_time: uint32_t,
    pub c_arg: *mut libc::c_void,
    pub c_func: Option<unsafe extern "C" fn(_: *mut libc::c_void) -> ()>,
    pub c_flags: libc::c_int,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_407 {
    pub tqe_next: *mut sctp_callout,
    pub tqe_prev: *mut *mut sctp_callout,
}
/* state of this entry */
pub type sctp_os_timer_t = sctp_callout;
pub type sctp_route_t = sctp_route;
pub type sctp_rtentry_t = sctp_rtentry;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_tmit_chunk {
    pub rec: C2RustUnnamed_436,
    pub asoc: *mut sctp_association,
    pub sent_rcv_time: timeval,
    pub data: *mut mbuf,
    pub last_mbuf: *mut mbuf,
    pub whoTo: *mut sctp_nets,
    pub sctp_next: C2RustUnnamed_408,
    pub sent: int32_t,
    pub snd_count: uint16_t,
    pub flags: uint16_t,
    pub send_size: uint16_t,
    pub book_size: uint16_t,
    pub mbcnt: uint16_t,
    pub auth_keyid: uint16_t,
    pub holds_key_ref: uint8_t,
    pub pad_inplace: uint8_t,
    pub do_rtt: uint8_t,
    pub book_size_scale: uint8_t,
    pub no_fr_allowed: uint8_t,
    pub copy_by_ref: uint8_t,
    pub window_probe: uint8_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_408 {
    pub tqe_next: *mut sctp_tmit_chunk,
    pub tqe_prev: *mut *mut sctp_tmit_chunk,
}
/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 2001-2008, by Cisco Systems, Inc. All rights reserved.
 * Copyright (c) 2008-2012, by Randall Stewart. All rights reserved.
 * Copyright (c) 2008-2012, by Michael Tuexen. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * a) Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * b) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the distribution.
 *
 * c) Neither the name of Cisco Systems, Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
/* managing mobility_feature in inpcb (by micchie) */
/*
 * I tried to cache the readq entries at one point. But the reality
 * is that it did not add any performance since this meant we had to
 * lock the STCB on read. And at that point once you have to do an
 * extra lock, it really does not matter if the lock is in the ZONE
 * stuff or in our code. Note that this same problem would occur with
 * an mbuf cache as well so it is not really worth doing, at least
 * right now :-D
 */
/* FreeBSD Version <= 500000 or non-FreeBSD */
/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 2001-2008, by Cisco Systems, Inc. All rights reserved.
 * Copyright (c) 2008-2012, by Randall Stewart. All rights reserved.
 * Copyright (c) 2008-2012, by Michael Tuexen. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * a) Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * b) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the distribution.
 *
 * c) Neither the name of Cisco Systems, Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Depending on the timer type these will be setup and cast with the
 * appropriate entity.
 */
/* for sanity checking */
/*
 * This is the information we track on each interface that we know about from
 * the distant end.
 */
/*
 * Users of the iterator need to malloc a iterator with a call to
 * sctp_initiate_iterator(inp_func, assoc_func, inp_func,  pcb_flags, pcb_features,
 *     asoc_state, void-ptr-arg, uint32-arg, end_func, inp);
 *
 * Use the following two defines if you don't care what pcb flags are on the EP
 * and/or you don't care what state the association is in.
 *
 * Note that if you specify an INP as the last argument then ONLY each
 * association of that single INP will be executed upon. Note that the pcb
 * flags STILL apply so if the inp you specify has different pcb_flags then
 * what you put in pcb_flags nothing will happen. use SCTP_PCB_ANY_FLAGS to
 * assure the inp you specify gets treated.
 */
/* current endpoint */
/* current* assoc */
/* special hook to skip to */
/* per assoc function */
/* per endpoint function */
/* end INP function */
/* iterator completion function */
/* pointer for apply func to use */
/* value for apply func to use */
/* endpoint flags being checked */
/* endpoint features being checked */
/* assoc state being checked */
/* iterator_flags values */
/* ep */
/* remote peer addr */
/* our selected src addr */
/* Fixed point arith, << 7 */
/* Fixed point arith, << 7 */
/* Delay modeswitch until we had at least one congestion event */
/* Time since last congestion event end */
/* Bandwidth estimation */
/* The time we started the sending  */
/* Our last estimated bw */
/* RTT at bw estimate */
/* The total bytes since this sending began */
/* The total time since sending began */
/* temp holding the new value */
/* What bw_bytes was at last rtt calc */
/* Cwnd at last bw saved - lbw */
/* cnt of voluntary reductions */
/* The number required to be in steady state*/
/* The current number */
/* When all things are equal what do I return 0/1 - 1 no cc advance */
/* Flag to enable DCCC ECN */
/* Flag to indicate we need to set tls 0 or 1 means set at send 2 not */
/* Last state if steady state stepdown is on */
/* Flag saying this sack had RTT calc on it */
/* Last saved inst indication */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_nets {
    pub sctp_next: C2RustUnnamed_414,
    pub pmtu_timer: sctp_timer,
    pub hb_timer: sctp_timer,
    pub ro: sctp_net_route,
    pub mtu: uint32_t,
    pub ssthresh: uint32_t,
    pub last_cwr_tsn: uint32_t,
    pub cwr_window_tsn: uint32_t,
    pub ecn_ce_pkt_cnt: uint32_t,
    pub lost_cnt: uint32_t,
    pub lastsa: libc::c_int,
    pub lastsv: libc::c_int,
    pub rtt: uint64_t,
    pub RTO: libc::c_uint,
    pub rxt_timer: sctp_timer,
    pub last_sent_time: timeval,
    pub cc_mod: cc_control_data,
    pub ref_count: libc::c_int,
    pub flight_size: uint32_t,
    pub cwnd: uint32_t,
    pub prev_cwnd: uint32_t,
    pub ecn_prev_cwnd: uint32_t,
    pub partial_bytes_acked: uint32_t,
    pub net_ack: libc::c_uint,
    pub net_ack2: libc::c_uint,
    pub last_active: uint32_t,
    pub this_sack_highest_newack: uint32_t,
    pub pseudo_cumack: uint32_t,
    pub rtx_pseudo_cumack: uint32_t,
    pub fast_recovery_tsn: uint32_t,
    pub heartbeat_random1: uint32_t,
    pub heartbeat_random2: uint32_t,
    pub flowlabel: uint32_t,
    pub dscp: uint8_t,
    pub start_time: timeval,
    pub marked_retrans: uint32_t,
    pub marked_fastretrans: uint32_t,
    pub heart_beat_delay: uint32_t,
    pub dest_state: uint16_t,
    pub failure_threshold: uint16_t,
    pub pf_threshold: uint16_t,
    pub error_count: uint16_t,
    pub port: uint16_t,
    pub fast_retran_loss_recovery: uint8_t,
    pub will_exit_fast_recovery: uint8_t,
    pub fast_retran_ip: uint8_t,
    pub hb_responded: uint8_t,
    pub saw_newack: uint8_t,
    pub src_addr_selected: uint8_t,
    pub indx_of_eligible_next_to_use: uint8_t,
    pub addr_is_local: uint8_t,
    pub find_pseudo_cumack: uint8_t,
    pub find_rtx_pseudo_cumack: uint8_t,
    pub new_pseudo_cumack: uint8_t,
    pub window_probe: uint8_t,
    pub RTO_measured: uint8_t,
    pub last_hs_used: uint8_t,
    pub lan_type: uint8_t,
    pub rto_needed: uint8_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union cc_control_data {
    pub htcp_ca: htcp,
    pub rtcc: rtcc_cc,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct rtcc_cc {
    pub tls: timeval,
    pub lbw: uint64_t,
    pub lbw_rtt: uint64_t,
    pub bw_bytes: uint64_t,
    pub bw_tot_time: uint64_t,
    pub new_tot_time: uint64_t,
    pub bw_bytes_at_last_rttc: uint64_t,
    pub cwnd_at_bw_set: uint32_t,
    pub vol_reduce: uint32_t,
    pub steady_step: uint16_t,
    pub step_cnt: uint16_t,
    pub ret_from_eq: uint8_t,
    pub use_dccc_ecn: uint8_t,
    pub tls_needs_set: uint8_t,
    pub last_step_state: uint8_t,
    pub rtt_set_this_sack: uint8_t,
    pub last_inst_ind: uint8_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct htcp {
    pub alpha: uint16_t,
    pub beta: uint8_t,
    pub modeswitch: uint8_t,
    pub last_cong: uint32_t,
    pub undo_last_cong: uint32_t,
    pub bytes_acked: uint16_t,
    pub bytecount: uint32_t,
    pub minRTT: uint32_t,
    pub maxRTT: uint32_t,
    pub undo_maxRTT: uint32_t,
    pub undo_old_maxB: uint32_t,
    pub minB: uint32_t,
    pub maxB: uint32_t,
    pub old_maxB: uint32_t,
    pub Bi: uint32_t,
    pub lasttime: uint32_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_timer {
    pub timer: sctp_os_timer_t,
    pub type_0: libc::c_int,
    pub ep: *mut libc::c_void,
    pub tcb: *mut libc::c_void,
    pub net: *mut libc::c_void,
    pub self_0: *mut libc::c_void,
    pub ticks: uint32_t,
    pub stopped_from: uint32_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_net_route {
    pub ro_rt: *mut sctp_rtentry_t,
    pub _l_addr: sctp_sockstore,
    pub _s_addr: *mut sctp_ifa,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_ifa {
    pub next_ifa: C2RustUnnamed_413,
    pub next_bucket: C2RustUnnamed_412,
    pub ifn_p: *mut sctp_ifn,
    pub ifa: *mut libc::c_void,
    pub address: sctp_sockstore,
    pub refcount: uint32_t,
    pub flags: uint32_t,
    pub localifa_flags: uint32_t,
    pub vrf_id: uint32_t,
    pub src_is_loop: uint8_t,
    pub src_is_priv: uint8_t,
    pub src_is_glob: uint8_t,
    pub resv: uint8_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union sctp_sockstore {
    pub sin: sockaddr_in,
    pub sin6: sockaddr_in6,
    pub sconn: sockaddr_conn,
    pub sa: sockaddr,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_conn {
    pub sconn_family: uint16_t,
    pub sconn_port: uint16_t,
    pub sconn_addr: *mut libc::c_void,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_ifn {
    pub ifalist: sctp_ifalist,
    pub vrf: *mut sctp_vrf,
    pub next_ifn: C2RustUnnamed_410,
    pub next_bucket: C2RustUnnamed_409,
    pub ifn_p: *mut libc::c_void,
    pub ifn_mtu: uint32_t,
    pub ifn_type: uint32_t,
    pub ifn_index: uint32_t,
    pub refcount: uint32_t,
    pub ifa_count: uint32_t,
    pub num_v6: uint32_t,
    pub num_v4: uint32_t,
    pub registered_af: uint32_t,
    pub ifn_name: [libc::c_char; 16],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_409 {
    pub le_next: *mut sctp_ifn,
    pub le_prev: *mut *mut sctp_ifn,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_410 {
    pub le_next: *mut sctp_ifn,
    pub le_prev: *mut *mut sctp_ifn,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_vrf {
    pub next_vrf: C2RustUnnamed_411,
    pub vrf_addr_hash: *mut sctp_ifalist,
    pub ifnlist: sctp_ifnlist,
    pub vrf_id: uint32_t,
    pub tbl_id_v4: uint32_t,
    pub tbl_id_v6: uint32_t,
    pub total_ifa_count: uint32_t,
    pub vrf_addr_hashmark: u_long,
    pub refcount: uint32_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_ifnlist {
    pub lh_first: *mut sctp_ifn,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_ifalist {
    pub lh_first: *mut sctp_ifa,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_411 {
    pub le_next: *mut sctp_vrf,
    pub le_prev: *mut *mut sctp_vrf,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_412 {
    pub le_next: *mut sctp_ifa,
    pub le_prev: *mut *mut sctp_ifa,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_413 {
    pub le_next: *mut sctp_ifa,
    pub le_prev: *mut *mut sctp_ifa,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_414 {
    pub tqe_next: *mut sctp_nets,
    pub tqe_prev: *mut *mut sctp_nets,
}
/*
 * Here we have information about each individual association that we track.
 * We probably in production would be more dynamic. But for ease of
 * implementation we will have a fixed array that we hunt for in a linear
 * fashion.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_association {
    pub state: libc::c_int,
    pub asconf_queue: sctp_asconf_addrhead,
    pub time_entered: timeval,
    pub time_last_rcvd: timeval,
    pub time_last_sent: timeval,
    pub time_last_sat_advance: timeval,
    pub def_send: sctp_nonpad_sndrcvinfo,
    pub dack_timer: sctp_timer,
    pub asconf_timer: sctp_timer,
    pub strreset_timer: sctp_timer,
    pub shut_guard_timer: sctp_timer,
    pub autoclose_timer: sctp_timer,
    pub delayed_event_timer: sctp_timer,
    pub delete_prim_timer: sctp_timer,
    pub sctp_restricted_addrs: sctpladdr,
    pub asconf_addr_del_pending: *mut sctp_ifa,
    pub deleted_primary: *mut sctp_nets,
    pub nets: sctpnetlisthead,
    pub free_chunks: sctpchunk_listhead,
    pub control_send_queue: sctpchunk_listhead,
    pub asconf_send_queue: sctpchunk_listhead,
    pub sent_queue: sctpchunk_listhead,
    pub send_queue: sctpchunk_listhead,
    pub ss_data: scheduling_data,
    pub stcb_starting_point_for_iterator: *mut sctp_iterator,
    pub asconf_ack_sent: sctp_asconf_ackhead,
    pub str_reset: *mut sctp_tmit_chunk,
    pub last_used_address: *mut sctp_laddr,
    pub strmin: *mut sctp_stream_in,
    pub strmout: *mut sctp_stream_out,
    pub mapping_array: *mut uint8_t,
    pub primary_destination: *mut sctp_nets,
    pub alternate: *mut sctp_nets,
    pub last_net_cmt_send_started: *mut sctp_nets,
    pub last_data_chunk_from: *mut sctp_nets,
    pub last_control_chunk_from: *mut sctp_nets,
    pub resetHead: sctp_resethead,
    pub pending_reply_queue: sctp_readhead,
    pub cc_functions: sctp_cc_functions,
    pub congestion_control_module: uint32_t,
    pub ss_functions: sctp_ss_functions,
    pub stream_scheduling_module: uint32_t,
    pub vrf_id: uint32_t,
    pub cookie_preserve_req: uint32_t,
    pub asconf_seq_out: uint32_t,
    pub asconf_seq_out_acked: uint32_t,
    pub asconf_seq_in: uint32_t,
    pub str_reset_seq_out: uint32_t,
    pub str_reset_seq_in: uint32_t,
    pub my_vtag: uint32_t,
    pub peer_vtag: uint32_t,
    pub my_vtag_nonce: uint32_t,
    pub peer_vtag_nonce: uint32_t,
    pub assoc_id: uint32_t,
    pub smallest_mtu: uint32_t,
    pub this_sack_highest_gap: uint32_t,
    pub last_acked_seq: uint32_t,
    pub sending_seq: uint32_t,
    pub init_seq_number: uint32_t,
    pub advanced_peer_ack_point: uint32_t,
    pub cumulative_tsn: uint32_t,
    pub mapping_array_base_tsn: uint32_t,
    pub highest_tsn_inside_map: uint32_t,
    pub nr_mapping_array: *mut uint8_t,
    pub highest_tsn_inside_nr_map: uint32_t,
    pub fast_recovery_tsn: uint32_t,
    pub sat_t3_recovery_tsn: uint32_t,
    pub tsn_last_delivered: uint32_t,
    pub control_pdapi: *mut sctp_queued_to_read,
    pub tsn_of_pdapi_last_delivered: uint32_t,
    pub pdapi_ppid: uint32_t,
    pub context: uint32_t,
    pub last_reset_action: [uint32_t; 2],
    pub last_sending_seq: [uint32_t; 2],
    pub last_base_tsnsent: [uint32_t; 2],
    pub peers_rwnd: uint32_t,
    pub my_rwnd: uint32_t,
    pub my_last_reported_rwnd: uint32_t,
    pub sctp_frag_point: uint32_t,
    pub total_output_queue_size: uint32_t,
    pub sb_cc: uint32_t,
    pub sb_send_resv: uint32_t,
    pub my_rwnd_control_len: uint32_t,
    pub default_flowlabel: uint32_t,
    pub pr_sctp_cnt: uint32_t,
    pub ctrl_queue_cnt: libc::c_int,
    pub stream_queue_cnt: libc::c_uint,
    pub send_queue_cnt: libc::c_uint,
    pub sent_queue_cnt: libc::c_uint,
    pub sent_queue_cnt_removeable: libc::c_uint,
    pub sent_queue_retran_cnt: libc::c_uint,
    pub size_on_reasm_queue: libc::c_uint,
    pub cnt_on_reasm_queue: libc::c_uint,
    pub fwd_tsn_cnt: libc::c_uint,
    pub total_flight: libc::c_uint,
    pub total_flight_count: libc::c_uint,
    pub numnets: libc::c_uint,
    pub overall_error_count: libc::c_uint,
    pub cnt_msg_on_sb: libc::c_uint,
    pub size_on_all_streams: libc::c_uint,
    pub cnt_on_all_streams: libc::c_uint,
    pub heart_beat_delay: uint32_t,
    pub sctp_autoclose_ticks: libc::c_uint,
    pub pre_open_streams: libc::c_uint,
    pub max_inbound_streams: libc::c_uint,
    pub cookie_life: libc::c_uint,
    pub delayed_ack: libc::c_uint,
    pub old_delayed_ack: libc::c_uint,
    pub sack_freq: libc::c_uint,
    pub data_pkts_seen: libc::c_uint,
    pub numduptsns: libc::c_uint,
    pub dup_tsns: [libc::c_int; 20],
    pub initial_init_rto_max: libc::c_uint,
    pub initial_rto: libc::c_uint,
    pub minrto: libc::c_uint,
    pub maxrto: libc::c_uint,
    pub local_auth_chunks: *mut sctp_auth_chklist_t,
    pub peer_auth_chunks: *mut sctp_auth_chklist_t,
    pub local_hmacs: *mut sctp_hmaclist_t,
    pub peer_hmacs: *mut sctp_hmaclist_t,
    pub shared_keys: sctp_keyhead,
    pub authinfo: sctp_authinfo_t,
    pub refcnt: uint32_t,
    pub chunks_on_out_queue: uint32_t,
    pub peers_adaptation: uint32_t,
    pub default_mtu: uint32_t,
    pub peer_hmac_id: uint16_t,
    pub stale_cookie_count: uint16_t,
    pub str_of_pdapi: uint16_t,
    pub ssn_of_pdapi: uint16_t,
    pub streamincnt: uint16_t,
    pub streamoutcnt: uint16_t,
    pub strm_realoutsize: uint16_t,
    pub strm_pending_add_size: uint16_t,
    pub max_init_times: uint16_t,
    pub max_send_times: uint16_t,
    pub def_net_failure: uint16_t,
    pub def_net_pf_threshold: uint16_t,
    pub mapping_array_size: uint16_t,
    pub last_strm_seq_delivered: uint16_t,
    pub last_strm_no_delivered: uint16_t,
    pub last_revoke_count: uint16_t,
    pub num_send_timers_up: int16_t,
    pub stream_locked_on: uint16_t,
    pub ecn_echo_cnt_onq: uint16_t,
    pub free_chunk_cnt: uint16_t,
    pub stream_locked: uint8_t,
    pub authenticated: uint8_t,
    pub send_sack: uint8_t,
    pub max_burst: uint32_t,
    pub fr_max_burst: uint32_t,
    pub sat_network: uint8_t,
    pub sat_network_lockout: uint8_t,
    pub burst_limit_applied: uint8_t,
    pub hb_random_values: [uint8_t; 4],
    pub fragmented_delivery_inprogress: uint8_t,
    pub fragment_flags: uint8_t,
    pub last_flags_delivered: uint8_t,
    pub hb_ect_randombit: uint8_t,
    pub hb_random_idx: uint8_t,
    pub default_dscp: uint8_t,
    pub asconf_del_pending: uint8_t,
    pub trigger_reset: uint8_t,
    pub ecn_supported: uint8_t,
    pub prsctp_supported: uint8_t,
    pub auth_supported: uint8_t,
    pub asconf_supported: uint8_t,
    pub reconfig_supported: uint8_t,
    pub nrsack_supported: uint8_t,
    pub pktdrop_supported: uint8_t,
    pub idata_supported: uint8_t,
    pub peer_req_out: uint8_t,
    pub local_strreset_support: uint8_t,
    pub peer_supports_nat: uint8_t,
    pub scope: sctp_scoping,
    pub used_alt_asconfack: uint8_t,
    pub fast_retran_loss_recovery: uint8_t,
    pub sat_t3_loss_recovery: uint8_t,
    pub dropped_special_cnt: uint8_t,
    pub seen_a_sack_this_pkt: uint8_t,
    pub stream_reset_outstanding: uint8_t,
    pub stream_reset_out_is_outstanding: uint8_t,
    pub delayed_connection: uint8_t,
    pub ifp_had_enobuf: uint8_t,
    pub saw_sack_with_frags: uint8_t,
    pub saw_sack_with_nr_frags: uint8_t,
    pub in_asocid_hash: uint8_t,
    pub assoc_up_sent: uint8_t,
    pub adaptation_needed: uint8_t,
    pub adaptation_sent: uint8_t,
    pub cmt_dac_pkts_rcvd: uint8_t,
    pub sctp_cmt_on_off: uint8_t,
    pub iam_blocking: uint8_t,
    pub cookie_how: [uint8_t; 8],
    pub sctp_cmt_pf: uint8_t,
    pub use_precise_time: uint8_t,
    pub sctp_features: uint64_t,
    pub max_cwnd: uint32_t,
    pub port: uint16_t,
    pub marked_retrans: uint32_t,
    pub timoinit: uint32_t,
    pub timodata: uint32_t,
    pub timosack: uint32_t,
    pub timoshutdown: uint32_t,
    pub timoheartbeat: uint32_t,
    pub timocookie: uint32_t,
    pub timoshutdownack: uint32_t,
    pub start_time: timeval,
    pub discontinuity_time: timeval,
    pub abandoned_unsent: [uint64_t; 4],
    pub abandoned_sent: [uint64_t; 4],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_scoping {
    pub ipv4_addr_legal: uint8_t,
    pub ipv6_addr_legal: uint8_t,
    pub conn_addr_legal: uint8_t,
    pub loopback_scope: uint8_t,
    pub ipv4_local_scope: uint8_t,
    pub local_scope: uint8_t,
    pub site_scope: uint8_t,
}
/* authentication info */
pub type sctp_authinfo_t = sctp_authinformation;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_authinformation {
    pub random: *mut sctp_key_t,
    pub random_len: uint32_t,
    pub peer_random: *mut sctp_key_t,
    pub assoc_key: *mut sctp_key_t,
    pub recv_key: *mut sctp_key_t,
    pub active_keyid: uint16_t,
    pub assoc_keyid: uint16_t,
    pub recv_keyid: uint16_t,
}
pub type sctp_key_t = sctp_key;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_key {
    pub keylen: uint32_t,
    pub key: [uint8_t; 0],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_keyhead {
    pub lh_first: *mut sctp_shared_key,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_shared_key {
    pub next: C2RustUnnamed_415,
    pub key: *mut sctp_key_t,
    pub refcount: uint32_t,
    pub keyid: uint16_t,
    pub deactivated: uint8_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_415 {
    pub le_next: *mut sctp_shared_key,
    pub le_prev: *mut *mut sctp_shared_key,
}
/* local random key (concatenated) */
/* local random number length for param */
/* peer's random key (concatenated) */
/* cached concatenated send key */
/* cached concatenated recv key */
/* active send keyid */
/* current send keyid (cached) */
/* last recv keyid (cached) */
/* hmac algos supported list */
pub type sctp_hmaclist_t = sctp_hmaclist;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_hmaclist {
    pub max_algo: uint16_t,
    pub num_algo: uint16_t,
    pub hmac: [uint16_t; 0],
}
/* max algorithms allocated */
/* num algorithms used */
/* authentication chunks list */
pub type sctp_auth_chklist_t = sctp_auth_chklist;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_auth_chklist {
    pub chunks: [uint8_t; 256],
    pub num_chunks: uint8_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_queued_to_read {
    pub sinfo_stream: uint16_t,
    pub sinfo_flags: uint16_t,
    pub sinfo_ppid: uint32_t,
    pub sinfo_context: uint32_t,
    pub sinfo_timetolive: uint32_t,
    pub sinfo_tsn: uint32_t,
    pub sinfo_cumtsn: uint32_t,
    pub sinfo_assoc_id: sctp_assoc_t,
    pub mid: uint32_t,
    pub length: uint32_t,
    pub held_length: uint32_t,
    pub top_fsn: uint32_t,
    pub fsn_included: uint32_t,
    pub whoFrom: *mut sctp_nets,
    pub data: *mut mbuf,
    pub tail_mbuf: *mut mbuf,
    pub aux_data: *mut mbuf,
    pub stcb: *mut sctp_tcb,
    pub next: C2RustUnnamed_417,
    pub next_instrm: C2RustUnnamed_416,
    pub reasm: sctpchunk_listhead,
    pub port_from: uint16_t,
    pub spec_flags: uint16_t,
    pub do_not_ref_stcb: uint8_t,
    pub end_added: uint8_t,
    pub pdapi_aborted: uint8_t,
    pub pdapi_started: uint8_t,
    pub some_taken: uint8_t,
    pub last_frag_seen: uint8_t,
    pub first_frag_seen: uint8_t,
    pub on_read_q: uint8_t,
    pub on_strm_q: uint8_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctpchunk_listhead {
    pub tqh_first: *mut sctp_tmit_chunk,
    pub tqh_last: *mut *mut sctp_tmit_chunk,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_416 {
    pub tqe_next: *mut sctp_queued_to_read,
    pub tqe_prev: *mut *mut sctp_queued_to_read,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_417 {
    pub tqe_next: *mut sctp_queued_to_read,
    pub tqe_prev: *mut *mut sctp_queued_to_read,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_tcb {
    pub sctp_socket: *mut socket,
    pub sctp_ep: *mut sctp_inpcb,
    pub sctp_tcbhash: C2RustUnnamed_421,
    pub sctp_tcblist: C2RustUnnamed_420,
    pub sctp_tcbasocidhash: C2RustUnnamed_419,
    pub sctp_asocs: C2RustUnnamed_418,
    pub block_entry: *mut sctp_block_entry,
    pub asoc: sctp_association,
    pub freed_by_sorcv_sincelast: uint32_t,
    pub total_sends: uint32_t,
    pub total_recvs: uint32_t,
    pub freed_from_where: libc::c_int,
    pub rport: uint16_t,
    pub resv: uint16_t,
    pub tcb_mtx: userland_mutex_t,
    pub tcb_send_mtx: userland_mutex_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_block_entry {
    pub error: libc::c_int,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_418 {
    pub le_next: *mut sctp_tcb,
    pub le_prev: *mut *mut sctp_tcb,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_419 {
    pub le_next: *mut sctp_tcb,
    pub le_prev: *mut *mut sctp_tcb,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_420 {
    pub le_next: *mut sctp_tcb,
    pub le_prev: *mut *mut sctp_tcb,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_421 {
    pub le_next: *mut sctp_tcb,
    pub le_prev: *mut *mut sctp_tcb,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_inpcb {
    pub ip_inp: C2RustUnnamed_426,
    pub read_queue: sctp_readhead,
    pub sctp_list: C2RustUnnamed_425,
    pub sctp_hash: C2RustUnnamed_424,
    pub laddr_count: libc::c_int,
    pub sctp_addr_list: sctpladdr,
    pub next_addr_touse: *mut sctp_laddr,
    pub sctp_socket: *mut socket,
    pub sctp_features: uint64_t,
    pub sctp_flags: uint32_t,
    pub sctp_mobility_features: uint32_t,
    pub sctp_ep: sctp_pcb,
    pub sctp_tcbhash: *mut sctpasochead,
    pub sctp_hashmark: u_long,
    pub sctp_asoc_list: sctpasochead,
    pub inp_starting_point_for_iterator: *mut sctp_iterator,
    pub sctp_frag_point: uint32_t,
    pub partial_delivery_point: uint32_t,
    pub sctp_context: uint32_t,
    pub max_cwnd: uint32_t,
    pub local_strreset_support: uint8_t,
    pub sctp_cmt_on_off: uint32_t,
    pub ecn_supported: uint8_t,
    pub prsctp_supported: uint8_t,
    pub auth_supported: uint8_t,
    pub idata_supported: uint8_t,
    pub asconf_supported: uint8_t,
    pub reconfig_supported: uint8_t,
    pub nrsack_supported: uint8_t,
    pub pktdrop_supported: uint8_t,
    pub def_send: sctp_nonpad_sndrcvinfo,
    pub pkt: *mut mbuf,
    pub pkt_last: *mut mbuf,
    pub control: *mut mbuf,
    pub inp_mtx: userland_mutex_t,
    pub inp_create_mtx: userland_mutex_t,
    pub inp_rdata_mtx: userland_mutex_t,
    pub refcount: int32_t,
    pub def_vrf_id: uint32_t,
    pub fibnum: uint16_t,
    pub total_sends: uint32_t,
    pub total_recvs: uint32_t,
    pub last_abort_code: uint32_t,
    pub total_nospaces: uint32_t,
    pub sctp_asocidhash: *mut sctpasochead,
    pub hashasocidmark: u_long,
    pub sctp_associd_counter: uint32_t,
    pub ulp_info: *mut libc::c_void,
    pub recv_callback: Option<
        unsafe extern "C" fn(
            _: *mut socket,
            _: sctp_sockstore,
            _: *mut libc::c_void,
            _: size_t,
            _: sctp_rcvinfo,
            _: libc::c_int,
            _: *mut libc::c_void,
        ) -> libc::c_int,
    >,
    pub send_sb_threshold: uint32_t,
    pub send_callback: Option<unsafe extern "C" fn(_: *mut socket, _: uint32_t) -> libc::c_int>,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_rcvinfo {
    pub rcv_sid: uint16_t,
    pub rcv_ssn: uint16_t,
    pub rcv_flags: uint16_t,
    pub rcv_ppid: uint32_t,
    pub rcv_tsn: uint32_t,
    pub rcv_cumtsn: uint32_t,
    pub rcv_context: uint32_t,
    pub rcv_assoc_id: sctp_assoc_t,
}
pub type sctp_assoc_t = uint32_t;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctpasochead {
    pub lh_first: *mut sctp_tcb,
}
/* The lower byte is used to enumerate PR_SCTP policies */
/* The upper byte is used as a bit mask */
/* bp to asoc this belongs to */
/* filled in if RTT being calculated */
/* pointer to mbuf chain of data */
/* pointer to last mbuf in chain */
/* next link */
/* the send status */
/* number of times I sent */
/* flags, such as FRAGMENT_OK */
/* flag if auth keyid refcount is held */
/* sinfo structure Pluse more */
/* off the wire */
/* SCTP_UNORDERED from wire use SCTP_EOF for
 * EOR */
/* off the wire */
/* pick this up from assoc def context? */
/* not used by kernel */
/* Use this in reassembly as first TSN */
/* Use this in reassembly as last TSN */
/* our assoc id */
/* Non sinfo stuff */
/* Fragment Index */
/* length of data */
/* length held in sb */
/* Highest FSN in queue */
/* Highest FSN in *data portion */
/* where it came from */
/* front of the mbuf chain of data with
 * PKT_HDR */
/* used for multi-part data */
/* used to hold/cache  control if o/s does not take it from us */
/* assoc, used for window update */
/* Flags to hold the notification field */
/* This data structure will be on the outbound
 * stream queues. Data will be pulled off from
 * the front of the mbuf data and chunk-ified
 * by the output routines. We will custom
 * fit every chunk we pull to the send/sent
 * queue to make up the next full packet
 * if we can. An entry cannot be removed
 * from the stream_out queue until
 * the msg_is_complete flag is set. This
 * means at times data/tail_mbuf MIGHT
 * be NULL.. If that occurs it happens
 * for one of two reasons. Either the user
 * is blocked on a send() call and has not
 * awoken to copy more data down... OR
 * the user is in the explict MSG_EOR mode
 * and wrote some data, but has not completed
 * sending.
 */
/*
 * this struct contains info that is used to track inbound stream data and
 * help with ordering.
 */
/* used for re-order */
/* Round-robin schedulers */
/* next link in wheel */
/* Priority scheduler */
/* next link in wheel */
/* priority id */
/* Fair Bandwidth scheduler */
/* next link in wheel */
/* stores message size */
/*
 * This union holds all data necessary for
 * different stream schedulers.
 */
/* circular looking for output selection */
/*
 * This union holds all parameters per stream
 * necessary for different stream schedulers.
 */
/* States for outgoing streams */
/* This struct is used to track the traffic on outbound streams */
/* send queue and sent queue */
/* Only the aggregation */
/* For associations using DATA chunks, the lower 16-bit of
 * next_mid_ordered are used as the next SSN.
 */
/* used to keep track of the addresses yet to try to add/delete */
/* save the ifa for add/del ip */
/* has this been sent yet? */
/* not to be used in lookup */
/* This struct is here to cut out the compatiabilty
 * pad that bulks up both the inp and stcb. The non
 * pad portion MUST stay in complete sync with
 * sctp_sndrcvinfo... i.e. if sinfo_xxxx is added
 * this must be done here too.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_nonpad_sndrcvinfo {
    pub sinfo_stream: uint16_t,
    pub sinfo_ssn: uint16_t,
    pub sinfo_flags: uint16_t,
    pub sinfo_ppid: uint32_t,
    pub sinfo_context: uint32_t,
    pub sinfo_timetolive: uint32_t,
    pub sinfo_tsn: uint32_t,
    pub sinfo_cumtsn: uint32_t,
    pub sinfo_assoc_id: sctp_assoc_t,
    pub sinfo_keynumber: uint16_t,
    pub sinfo_keynumber_valid: uint16_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_iterator {
    pub sctp_nxt_itr: C2RustUnnamed_422,
    pub tmr: sctp_timer,
    pub inp: *mut sctp_inpcb,
    pub stcb: *mut sctp_tcb,
    pub next_inp: *mut sctp_inpcb,
    pub function_assoc: asoc_func,
    pub function_inp: inp_func,
    pub function_inp_end: inp_func,
    pub function_atend: end_func,
    pub pointer: *mut libc::c_void,
    pub val: uint32_t,
    pub pcb_flags: uint32_t,
    pub pcb_features: uint32_t,
    pub asoc_state: uint32_t,
    pub iterator_flags: uint32_t,
    pub no_chunk_output: uint8_t,
    pub done_current_ep: uint8_t,
}
pub type end_func = Option<unsafe extern "C" fn(_: *mut libc::c_void, _: uint32_t) -> ()>;
pub type inp_func = Option<
    unsafe extern "C" fn(_: *mut sctp_inpcb, _: *mut libc::c_void, _: uint32_t) -> libc::c_int,
>;
pub type asoc_func = Option<
    unsafe extern "C" fn(
        _: *mut sctp_inpcb,
        _: *mut sctp_tcb,
        _: *mut libc::c_void,
        _: uint32_t,
    ) -> (),
>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_422 {
    pub tqe_next: *mut sctp_iterator,
    pub tqe_prev: *mut *mut sctp_iterator,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_pcb {
    pub time_of_secret_change: libc::c_uint,
    pub secret_key: [[uint32_t; 8]; 2],
    pub size_of_a_cookie: libc::c_uint,
    pub sctp_timeoutticks: [libc::c_uint; 7],
    pub sctp_minrto: libc::c_uint,
    pub sctp_maxrto: libc::c_uint,
    pub initial_rto: libc::c_uint,
    pub initial_init_rto_max: libc::c_int,
    pub sctp_sack_freq: libc::c_uint,
    pub sctp_sws_sender: uint32_t,
    pub sctp_sws_receiver: uint32_t,
    pub sctp_default_cc_module: uint32_t,
    pub sctp_default_ss_module: uint32_t,
    pub shared_keys: sctp_keyhead,
    pub local_auth_chunks: *mut sctp_auth_chklist_t,
    pub local_hmacs: *mut sctp_hmaclist_t,
    pub default_keyid: uint16_t,
    pub default_mtu: uint32_t,
    pub max_init_times: uint16_t,
    pub max_send_times: uint16_t,
    pub def_net_failure: uint16_t,
    pub def_net_pf_threshold: uint16_t,
    pub pre_open_stream_count: uint16_t,
    pub max_open_streams_intome: uint16_t,
    pub random_counter: uint32_t,
    pub random_numbers: [uint8_t; 20],
    pub random_store: [uint8_t; 20],
    pub signature_change: sctp_timer,
    pub def_cookie_life: uint32_t,
    pub auto_close_time: libc::c_int,
    pub initial_sequence_debug: uint32_t,
    pub adaptation_layer_indicator: uint32_t,
    pub adaptation_layer_indicator_provided: uint8_t,
    pub store_at: uint32_t,
    pub max_burst: uint32_t,
    pub fr_max_burst: uint32_t,
    pub default_flowlabel: uint32_t,
    pub default_dscp: uint8_t,
    pub current_secret_number: libc::c_char,
    pub last_secret_number: libc::c_char,
    pub port: uint16_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_laddr {
    pub sctp_nxt_addr: C2RustUnnamed_423,
    pub ifa: *mut sctp_ifa,
    pub action: uint32_t,
    pub start_time: timeval,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_423 {
    pub le_next: *mut sctp_laddr,
    pub le_prev: *mut *mut sctp_laddr,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctpladdr {
    pub lh_first: *mut sctp_laddr,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_424 {
    pub le_next: *mut sctp_inpcb,
    pub le_prev: *mut *mut sctp_inpcb,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_425 {
    pub le_next: *mut sctp_inpcb,
    pub le_prev: *mut *mut sctp_inpcb,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_readhead {
    pub tqh_first: *mut sctp_queued_to_read,
    pub tqh_last: *mut *mut sctp_queued_to_read,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union C2RustUnnamed_426 {
    pub inp: inpcb,
    pub align: [libc::c_char; 256],
}
/*
 * RS - Structure to hold function pointers to the functions responsible
 * for stream scheduling.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_ss_functions {
    pub sctp_ss_init: Option<
        unsafe extern "C" fn(_: *mut sctp_tcb, _: *mut sctp_association, _: libc::c_int) -> (),
    >,
    pub sctp_ss_clear: Option<
        unsafe extern "C" fn(
            _: *mut sctp_tcb,
            _: *mut sctp_association,
            _: libc::c_int,
            _: libc::c_int,
        ) -> (),
    >,
    pub sctp_ss_init_stream: Option<
        unsafe extern "C" fn(
            _: *mut sctp_tcb,
            _: *mut sctp_stream_out,
            _: *mut sctp_stream_out,
        ) -> (),
    >,
    pub sctp_ss_add_to_stream: Option<
        unsafe extern "C" fn(
            _: *mut sctp_tcb,
            _: *mut sctp_association,
            _: *mut sctp_stream_out,
            _: *mut sctp_stream_queue_pending,
            _: libc::c_int,
        ) -> (),
    >,
    pub sctp_ss_is_empty:
        Option<unsafe extern "C" fn(_: *mut sctp_tcb, _: *mut sctp_association) -> libc::c_int>,
    pub sctp_ss_remove_from_stream: Option<
        unsafe extern "C" fn(
            _: *mut sctp_tcb,
            _: *mut sctp_association,
            _: *mut sctp_stream_out,
            _: *mut sctp_stream_queue_pending,
            _: libc::c_int,
        ) -> (),
    >,
    pub sctp_ss_select_stream: Option<
        unsafe extern "C" fn(
            _: *mut sctp_tcb,
            _: *mut sctp_nets,
            _: *mut sctp_association,
        ) -> *mut sctp_stream_out,
    >,
    pub sctp_ss_scheduled: Option<
        unsafe extern "C" fn(
            _: *mut sctp_tcb,
            _: *mut sctp_nets,
            _: *mut sctp_association,
            _: *mut sctp_stream_out,
            _: libc::c_int,
        ) -> (),
    >,
    pub sctp_ss_packet_done: Option<
        unsafe extern "C" fn(_: *mut sctp_tcb, _: *mut sctp_nets, _: *mut sctp_association) -> (),
    >,
    pub sctp_ss_get_value: Option<
        unsafe extern "C" fn(
            _: *mut sctp_tcb,
            _: *mut sctp_association,
            _: *mut sctp_stream_out,
            _: *mut uint16_t,
        ) -> libc::c_int,
    >,
    pub sctp_ss_set_value: Option<
        unsafe extern "C" fn(
            _: *mut sctp_tcb,
            _: *mut sctp_association,
            _: *mut sctp_stream_out,
            _: uint16_t,
        ) -> libc::c_int,
    >,
    pub sctp_ss_is_user_msgs_incomplete:
        Option<unsafe extern "C" fn(_: *mut sctp_tcb, _: *mut sctp_association) -> libc::c_int>,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_stream_out {
    pub outqueue: sctp_streamhead,
    pub ss_params: scheduling_parameters,
    pub chunks_on_queues: uint32_t,
    pub abandoned_unsent: [uint32_t; 1],
    pub abandoned_sent: [uint32_t; 1],
    pub next_mid_ordered: uint32_t,
    pub next_mid_unordered: uint32_t,
    pub sid: uint16_t,
    pub last_msg_incomplete: uint8_t,
    pub state: uint8_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union scheduling_parameters {
    pub rr: ss_rr,
    pub prio: ss_prio,
    pub fb: ss_fb,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ss_fb {
    pub next_spoke: C2RustUnnamed_427,
    pub rounds: int32_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_427 {
    pub tqe_next: *mut sctp_stream_out,
    pub tqe_prev: *mut *mut sctp_stream_out,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ss_prio {
    pub next_spoke: C2RustUnnamed_428,
    pub priority: uint16_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_428 {
    pub tqe_next: *mut sctp_stream_out,
    pub tqe_prev: *mut *mut sctp_stream_out,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ss_rr {
    pub next_spoke: C2RustUnnamed_429,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_429 {
    pub tqe_next: *mut sctp_stream_out,
    pub tqe_prev: *mut *mut sctp_stream_out,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_streamhead {
    pub tqh_first: *mut sctp_stream_queue_pending,
    pub tqh_last: *mut *mut sctp_stream_queue_pending,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_stream_queue_pending {
    pub data: *mut mbuf,
    pub tail_mbuf: *mut mbuf,
    pub ts: timeval,
    pub net: *mut sctp_nets,
    pub next: C2RustUnnamed_431,
    pub ss_next: C2RustUnnamed_430,
    pub fsn: uint32_t,
    pub length: uint32_t,
    pub timetolive: uint32_t,
    pub ppid: uint32_t,
    pub context: uint32_t,
    pub sinfo_flags: uint16_t,
    pub sid: uint16_t,
    pub act_flags: uint16_t,
    pub auth_keyid: uint16_t,
    pub holds_key_ref: uint8_t,
    pub msg_is_complete: uint8_t,
    pub some_taken: uint8_t,
    pub sender_all_done: uint8_t,
    pub put_last_out: uint8_t,
    pub discard_rest: uint8_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_430 {
    pub tqe_next: *mut sctp_stream_queue_pending,
    pub tqe_prev: *mut *mut sctp_stream_queue_pending,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_431 {
    pub tqe_next: *mut sctp_stream_queue_pending,
    pub tqe_prev: *mut *mut sctp_stream_queue_pending,
}
/*
 * JRS - Structure to hold function pointers to the functions responsible
 * for congestion control.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_cc_functions {
    pub sctp_set_initial_cc_param:
        Option<unsafe extern "C" fn(_: *mut sctp_tcb, _: *mut sctp_nets) -> ()>,
    pub sctp_cwnd_update_after_sack: Option<
        unsafe extern "C" fn(
            _: *mut sctp_tcb,
            _: *mut sctp_association,
            _: libc::c_int,
            _: libc::c_int,
            _: libc::c_int,
        ) -> (),
    >,
    pub sctp_cwnd_update_exit_pf:
        Option<unsafe extern "C" fn(_: *mut sctp_tcb, _: *mut sctp_nets) -> ()>,
    pub sctp_cwnd_update_after_fr:
        Option<unsafe extern "C" fn(_: *mut sctp_tcb, _: *mut sctp_association) -> ()>,
    pub sctp_cwnd_update_after_timeout:
        Option<unsafe extern "C" fn(_: *mut sctp_tcb, _: *mut sctp_nets) -> ()>,
    pub sctp_cwnd_update_after_ecn_echo: Option<
        unsafe extern "C" fn(
            _: *mut sctp_tcb,
            _: *mut sctp_nets,
            _: libc::c_int,
            _: libc::c_int,
        ) -> (),
    >,
    pub sctp_cwnd_update_after_packet_dropped: Option<
        unsafe extern "C" fn(
            _: *mut sctp_tcb,
            _: *mut sctp_nets,
            _: *mut sctp_pktdrop_chunk,
            _: *mut uint32_t,
            _: *mut uint32_t,
        ) -> (),
    >,
    pub sctp_cwnd_update_after_output:
        Option<unsafe extern "C" fn(_: *mut sctp_tcb, _: *mut sctp_nets, _: libc::c_int) -> ()>,
    pub sctp_cwnd_update_packet_transmitted:
        Option<unsafe extern "C" fn(_: *mut sctp_tcb, _: *mut sctp_nets) -> ()>,
    pub sctp_cwnd_update_tsn_acknowledged:
        Option<unsafe extern "C" fn(_: *mut sctp_nets, _: *mut sctp_tmit_chunk) -> ()>,
    pub sctp_cwnd_new_transmission_begins:
        Option<unsafe extern "C" fn(_: *mut sctp_tcb, _: *mut sctp_nets) -> ()>,
    pub sctp_cwnd_prepare_net_for_sack:
        Option<unsafe extern "C" fn(_: *mut sctp_tcb, _: *mut sctp_nets) -> ()>,
    pub sctp_cwnd_socket_option: Option<
        unsafe extern "C" fn(
            _: *mut sctp_tcb,
            _: libc::c_int,
            _: *mut sctp_cc_option,
        ) -> libc::c_int,
    >,
    pub sctp_rtt_calculated:
        Option<unsafe extern "C" fn(_: *mut sctp_tcb, _: *mut sctp_nets, _: *mut timeval) -> ()>,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_cc_option {
    pub option: libc::c_int,
    pub aid_value: sctp_assoc_value,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_assoc_value {
    pub assoc_id: sctp_assoc_t,
    pub assoc_value: uint32_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_pktdrop_chunk {
    pub ch: sctp_chunkhdr,
    pub bottle_bw: uint32_t,
    pub current_onq: uint32_t,
    pub trunc_len: uint16_t,
    pub reserved: uint16_t,
    pub data: [uint8_t; 0],
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_chunkhdr {
    pub chunk_type: uint8_t,
    pub chunk_flags: uint8_t,
    pub chunk_length: uint16_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_resethead {
    pub tqh_first: *mut sctp_stream_reset_list,
    pub tqh_last: *mut *mut sctp_stream_reset_list,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_stream_reset_list {
    pub next_resp: C2RustUnnamed_432,
    pub seq: uint32_t,
    pub tsn: uint32_t,
    pub number_entries: uint32_t,
    pub list_of_streams: [uint16_t; 0],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_432 {
    pub tqe_next: *mut sctp_stream_reset_list,
    pub tqe_prev: *mut *mut sctp_stream_reset_list,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_stream_in {
    pub inqueue: sctp_readhead,
    pub uno_inqueue: sctp_readhead,
    pub last_mid_delivered: uint32_t,
    pub sid: uint16_t,
    pub delivery_started: uint8_t,
    pub pd_api_started: uint8_t,
}
/* used to save ASCONF-ACK chunks for retransmission */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_asconf_ackhead {
    pub tqh_first: *mut sctp_asconf_ack,
    pub tqh_last: *mut *mut sctp_asconf_ack,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_asconf_ack {
    pub next: C2RustUnnamed_433,
    pub serial_number: uint32_t,
    pub last_sent_to: *mut sctp_nets,
    pub data: *mut mbuf,
    pub len: uint16_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_433 {
    pub tqe_next: *mut sctp_asconf_ack,
    pub tqe_prev: *mut *mut sctp_asconf_ack,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct scheduling_data {
    pub locked_on_sending: *mut sctp_stream_out,
    pub last_out_stream: *mut sctp_stream_out,
    pub out: C2RustUnnamed_434,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union C2RustUnnamed_434 {
    pub wheel: sctpwheel_listhead,
    pub list: sctplist_listhead,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctplist_listhead {
    pub tqh_first: *mut sctp_stream_queue_pending,
    pub tqh_last: *mut *mut sctp_stream_queue_pending,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctpwheel_listhead {
    pub tqh_first: *mut sctp_stream_out,
    pub tqh_last: *mut *mut sctp_stream_out,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctpnetlisthead {
    pub tqh_first: *mut sctp_nets,
    pub tqh_last: *mut *mut sctp_nets,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_asconf_addrhead {
    pub tqh_first: *mut sctp_asconf_addr,
    pub tqh_last: *mut *mut sctp_asconf_addr,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_asconf_addr {
    pub next: C2RustUnnamed_435,
    pub ap: sctp_asconf_addr_param,
    pub ifa: *mut sctp_ifa,
    pub sent: uint8_t,
    pub special_del: uint8_t,
}
/* correlation id for this param */

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_asconf_addr_param {
    pub aph: sctp_asconf_paramhdr,
    pub addrp: sctp_ipv6addr_param,
}
/* IPV4 address */

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_ipv6addr_param {
    pub ph: sctp_paramhdr,
    pub addr: [uint8_t; 16],
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_paramhdr {
    pub param_type: uint16_t,
    pub param_length: uint16_t,
}
/* draft-ietf-tsvwg-addip-sctp */

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_asconf_paramhdr {
    pub ph: sctp_paramhdr,
    pub correlation_id: uint32_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_435 {
    pub tqe_next: *mut sctp_asconf_addr,
    pub tqe_prev: *mut *mut sctp_asconf_addr,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union C2RustUnnamed_436 {
    pub data: sctp_data_chunkrec,
    pub chunk_id: chk_id,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct chk_id {
    pub id: uint8_t,
    pub can_take_data: uint8_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_data_chunkrec {
    pub tsn: uint32_t,
    pub mid: uint32_t,
    pub sid: uint16_t,
    pub ppid: uint32_t,
    pub context: uint32_t,
    pub cwnd_at_send: uint32_t,
    pub fast_retran_tsn: uint32_t,
    pub timetodrop: timeval,
    pub fsn: uint32_t,
    pub doing_fast_retransmit: uint8_t,
    pub rcv_flags: uint8_t,
    pub state_flags: uint8_t,
    pub chunk_was_revoked: uint8_t,
    pub fwd_tsn_cnt: uint8_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: libc::c_int,
    pub tz_dsttime: libc::c_int,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_auth_chunk {
    pub ch: sctp_chunkhdr,
    pub shared_key_id: uint16_t,
    pub hmac_id: uint16_t,
    pub hmac: [uint8_t; 0],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_sndrcvinfo {
    pub sinfo_stream: uint16_t,
    pub sinfo_ssn: uint16_t,
    pub sinfo_flags: uint16_t,
    pub sinfo_ppid: uint32_t,
    pub sinfo_context: uint32_t,
    pub sinfo_timetolive: uint32_t,
    pub sinfo_tsn: uint32_t,
    pub sinfo_cumtsn: uint32_t,
    pub sinfo_assoc_id: sctp_assoc_t,
    pub sinfo_keynumber: uint16_t,
    pub sinfo_keynumber_valid: uint16_t,
    pub __reserve_pad: [uint8_t; 92],
}
/* not currently used*/
/* struct sctp_gap_ack_block's follow */
/* uint32_t duplicate_tsn's follow */

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_nr_sack_chunk {
    pub ch: sctp_chunkhdr,
    pub nr_sack: sctp_nr_sack,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_nr_sack {
    pub cum_tsn_ack: uint32_t,
    pub a_rwnd: uint32_t,
    pub num_gap_ack_blks: uint16_t,
    pub num_nr_gap_ack_blks: uint16_t,
    pub num_dup_tsns: uint16_t,
    pub reserved: uint16_t,
}
/* number of duplicate TSNs */
/* struct sctp_gap_ack_block's follow */
/* uint32_t duplicate_tsn's follow */

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_sack_chunk {
    pub ch: sctp_chunkhdr,
    pub sack: sctp_sack,
}
/* Gap Ack block end */

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_sack {
    pub cum_tsn_ack: uint32_t,
    pub a_rwnd: uint32_t,
    pub num_gap_ack_blks: uint16_t,
    pub num_dup_tsns: uint16_t,
}
/* stream/sequence pairs (sctp_strseq) follow */

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_strseq {
    pub sid: uint16_t,
    pub ssn: uint16_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_copy_all {
    pub inp: *mut sctp_inpcb,
    pub m: *mut mbuf,
    pub sndrcv: sctp_sndrcvinfo,
    pub sndlen: ssize_t,
    pub cnt_sent: libc::c_int,
    pub cnt_failed: libc::c_int,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct udphdr {
    pub c2rust_unnamed: C2RustUnnamed_437,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union C2RustUnnamed_437 {
    pub c2rust_unnamed: C2RustUnnamed_439,
    pub c2rust_unnamed_0: C2RustUnnamed_438,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_438 {
    pub source: uint16_t,
    pub dest: uint16_t,
    pub len: uint16_t,
    pub check: uint16_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_439 {
    pub uh_sport: uint16_t,
    pub uh_dport: uint16_t,
    pub uh_ulen: uint16_t,
    pub uh_sum: uint16_t,
}
/* user data follows */

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_data_chunk {
    pub ch: sctp_chunkhdr,
    pub dp: sctp_data,
}
/*
 * Structures for DATA chunks
 */

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_data {
    pub tsn: uint32_t,
    pub sid: uint16_t,
    pub ssn: uint16_t,
    pub ppid: uint32_t,
}
/* user data follows */

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_idata_chunk {
    pub ch: sctp_chunkhdr,
    pub dp: sctp_idata,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_idata {
    pub tsn: uint32_t,
    pub sid: uint16_t,
    pub reserved: uint16_t,
    pub mid: uint32_t,
    pub ppid_fsn: C2RustUnnamed_440,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union C2RustUnnamed_440 {
    pub ppid: uint32_t,
    pub fsn: uint32_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_strseq_mid {
    pub sid: uint16_t,
    pub flags: uint16_t,
    pub mid: uint32_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctphdr {
    pub src_port: uint16_t,
    pub dest_port: uint16_t,
    pub v_tag: uint32_t,
    pub checksum: uint32_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_gen_error_cause {
    pub code: uint16_t,
    pub length: uint16_t,
    pub info: [uint8_t; 0],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_initmsg {
    pub sinit_num_ostreams: uint16_t,
    pub sinit_max_instreams: uint16_t,
    pub sinit_max_attempts: uint16_t,
    pub sinit_max_init_timeo: uint16_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_sndinfo {
    pub snd_sid: uint16_t,
    pub snd_flags: uint16_t,
    pub snd_ppid: uint32_t,
    pub snd_context: uint32_t,
    pub snd_assoc_id: sctp_assoc_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_prinfo {
    pub pr_policy: uint16_t,
    pub pr_value: uint32_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_authinfo {
    pub auth_keynumber: uint16_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_timeval {
    pub tv_sec: uint32_t,
    pub tv_usec: uint32_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctpstat {
    pub sctps_discontinuitytime: sctp_timeval,
    pub sctps_currestab: uint32_t,
    pub sctps_activeestab: uint32_t,
    pub sctps_restartestab: uint32_t,
    pub sctps_collisionestab: uint32_t,
    pub sctps_passiveestab: uint32_t,
    pub sctps_aborted: uint32_t,
    pub sctps_shutdown: uint32_t,
    pub sctps_outoftheblue: uint32_t,
    pub sctps_checksumerrors: uint32_t,
    pub sctps_outcontrolchunks: uint32_t,
    pub sctps_outorderchunks: uint32_t,
    pub sctps_outunorderchunks: uint32_t,
    pub sctps_incontrolchunks: uint32_t,
    pub sctps_inorderchunks: uint32_t,
    pub sctps_inunorderchunks: uint32_t,
    pub sctps_fragusrmsgs: uint32_t,
    pub sctps_reasmusrmsgs: uint32_t,
    pub sctps_outpackets: uint32_t,
    pub sctps_inpackets: uint32_t,
    pub sctps_recvpackets: uint32_t,
    pub sctps_recvdatagrams: uint32_t,
    pub sctps_recvpktwithdata: uint32_t,
    pub sctps_recvsacks: uint32_t,
    pub sctps_recvdata: uint32_t,
    pub sctps_recvdupdata: uint32_t,
    pub sctps_recvheartbeat: uint32_t,
    pub sctps_recvheartbeatack: uint32_t,
    pub sctps_recvecne: uint32_t,
    pub sctps_recvauth: uint32_t,
    pub sctps_recvauthmissing: uint32_t,
    pub sctps_recvivalhmacid: uint32_t,
    pub sctps_recvivalkeyid: uint32_t,
    pub sctps_recvauthfailed: uint32_t,
    pub sctps_recvexpress: uint32_t,
    pub sctps_recvexpressm: uint32_t,
    pub sctps_recv_spare: uint32_t,
    pub sctps_recvswcrc: uint32_t,
    pub sctps_recvhwcrc: uint32_t,
    pub sctps_sendpackets: uint32_t,
    pub sctps_sendsacks: uint32_t,
    pub sctps_senddata: uint32_t,
    pub sctps_sendretransdata: uint32_t,
    pub sctps_sendfastretrans: uint32_t,
    pub sctps_sendmultfastretrans: uint32_t,
    pub sctps_sendheartbeat: uint32_t,
    pub sctps_sendecne: uint32_t,
    pub sctps_sendauth: uint32_t,
    pub sctps_senderrors: uint32_t,
    pub sctps_send_spare: uint32_t,
    pub sctps_sendswcrc: uint32_t,
    pub sctps_sendhwcrc: uint32_t,
    pub sctps_pdrpfmbox: uint32_t,
    pub sctps_pdrpfehos: uint32_t,
    pub sctps_pdrpmbda: uint32_t,
    pub sctps_pdrpmbct: uint32_t,
    pub sctps_pdrpbwrpt: uint32_t,
    pub sctps_pdrpcrupt: uint32_t,
    pub sctps_pdrpnedat: uint32_t,
    pub sctps_pdrppdbrk: uint32_t,
    pub sctps_pdrptsnnf: uint32_t,
    pub sctps_pdrpdnfnd: uint32_t,
    pub sctps_pdrpdiwnp: uint32_t,
    pub sctps_pdrpdizrw: uint32_t,
    pub sctps_pdrpbadd: uint32_t,
    pub sctps_pdrpmark: uint32_t,
    pub sctps_timoiterator: uint32_t,
    pub sctps_timodata: uint32_t,
    pub sctps_timowindowprobe: uint32_t,
    pub sctps_timoinit: uint32_t,
    pub sctps_timosack: uint32_t,
    pub sctps_timoshutdown: uint32_t,
    pub sctps_timoheartbeat: uint32_t,
    pub sctps_timocookie: uint32_t,
    pub sctps_timosecret: uint32_t,
    pub sctps_timopathmtu: uint32_t,
    pub sctps_timoshutdownack: uint32_t,
    pub sctps_timoshutdownguard: uint32_t,
    pub sctps_timostrmrst: uint32_t,
    pub sctps_timoearlyfr: uint32_t,
    pub sctps_timoasconf: uint32_t,
    pub sctps_timodelprim: uint32_t,
    pub sctps_timoautoclose: uint32_t,
    pub sctps_timoassockill: uint32_t,
    pub sctps_timoinpkill: uint32_t,
    pub sctps_spare: [uint32_t; 11],
    pub sctps_hdrops: uint32_t,
    pub sctps_badsum: uint32_t,
    pub sctps_noport: uint32_t,
    pub sctps_badvtag: uint32_t,
    pub sctps_badsid: uint32_t,
    pub sctps_nomem: uint32_t,
    pub sctps_fastretransinrtt: uint32_t,
    pub sctps_markedretrans: uint32_t,
    pub sctps_naglesent: uint32_t,
    pub sctps_naglequeued: uint32_t,
    pub sctps_maxburstqueued: uint32_t,
    pub sctps_ifnomemqueued: uint32_t,
    pub sctps_windowprobed: uint32_t,
    pub sctps_lowlevelerr: uint32_t,
    pub sctps_lowlevelerrusr: uint32_t,
    pub sctps_datadropchklmt: uint32_t,
    pub sctps_datadroprwnd: uint32_t,
    pub sctps_ecnereducedcwnd: uint32_t,
    pub sctps_vtagexpress: uint32_t,
    pub sctps_vtagbogus: uint32_t,
    pub sctps_primary_randry: uint32_t,
    pub sctps_cmt_randry: uint32_t,
    pub sctps_slowpath_sack: uint32_t,
    pub sctps_wu_sacks_sent: uint32_t,
    pub sctps_sends_with_flags: uint32_t,
    pub sctps_sends_with_unord: uint32_t,
    pub sctps_sends_with_eof: uint32_t,
    pub sctps_sends_with_abort: uint32_t,
    pub sctps_protocol_drain_calls: uint32_t,
    pub sctps_protocol_drains_done: uint32_t,
    pub sctps_read_peeks: uint32_t,
    pub sctps_cached_chk: uint32_t,
    pub sctps_cached_strmoq: uint32_t,
    pub sctps_left_abandon: uint32_t,
    pub sctps_send_burst_avoid: uint32_t,
    pub sctps_send_cwnd_avoid: uint32_t,
    pub sctps_fwdtsn_map_over: uint32_t,
    pub sctps_queue_upd_ecne: uint32_t,
    pub sctps_reserved: [uint32_t; 31],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_base_info {
    pub sctppcbinfo: sctp_epinfo,
    pub sctpstat: sctpstat,
    pub sctpsysctl: sctp_sysctl,
    pub first_time: uint8_t,
    pub sctp_pcb_initialized: libc::c_char,
    pub timer_mtx: userland_mutex_t,
    pub timer_thread: userland_thread_t,
    pub timer_thread_should_exit: libc::c_int,
    pub mtx_attr: pthread_mutexattr_t,
    pub userspace_route: libc::c_int,
    pub recvthreadroute: userland_thread_t,
    pub userspace_rawsctp: libc::c_int,
    pub userspace_udpsctp: libc::c_int,
    pub recvthreadraw: userland_thread_t,
    pub recvthreadudp: userland_thread_t,
    pub userspace_rawsctp6: libc::c_int,
    pub userspace_udpsctp6: libc::c_int,
    pub recvthreadraw6: userland_thread_t,
    pub recvthreadudp6: userland_thread_t,
    pub conn_output: Option<
        unsafe extern "C" fn(
            _: *mut libc::c_void,
            _: *mut libc::c_void,
            _: size_t,
            _: uint8_t,
            _: uint8_t,
        ) -> libc::c_int,
    >,
    pub debug_printf: Option<unsafe extern "C" fn(_: *const libc::c_char, _: ...) -> ()>,
    pub crc32c_offloaded: libc::c_int,
}
/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 2007, by Cisco Systems, Inc. All rights reserved.
 * Copyright (c) 2008-2012, by Randall Stewart. All rights reserved.
 * Copyright (c) 2008-2012, by Michael Tuexen. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * a) Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * b) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the distribution.
 *
 * c) Neither the name of Cisco Systems, Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_sysctl {
    pub sctp_sendspace: uint32_t,
    pub sctp_recvspace: uint32_t,
    pub sctp_auto_asconf: uint32_t,
    pub sctp_multiple_asconfs: uint32_t,
    pub sctp_ecn_enable: uint32_t,
    pub sctp_pr_enable: uint32_t,
    pub sctp_auth_enable: uint32_t,
    pub sctp_asconf_enable: uint32_t,
    pub sctp_reconfig_enable: uint32_t,
    pub sctp_nrsack_enable: uint32_t,
    pub sctp_pktdrop_enable: uint32_t,
    pub sctp_fr_max_burst_default: uint32_t,
    pub sctp_no_csum_on_loopback: uint32_t,
    pub sctp_peer_chunk_oh: uint32_t,
    pub sctp_max_burst_default: uint32_t,
    pub sctp_max_chunks_on_queue: uint32_t,
    pub sctp_hashtblsize: uint32_t,
    pub sctp_pcbtblsize: uint32_t,
    pub sctp_min_split_point: uint32_t,
    pub sctp_chunkscale: uint32_t,
    pub sctp_delayed_sack_time_default: uint32_t,
    pub sctp_sack_freq_default: uint32_t,
    pub sctp_system_free_resc_limit: uint32_t,
    pub sctp_asoc_free_resc_limit: uint32_t,
    pub sctp_heartbeat_interval_default: uint32_t,
    pub sctp_pmtu_raise_time_default: uint32_t,
    pub sctp_shutdown_guard_time_default: uint32_t,
    pub sctp_secret_lifetime_default: uint32_t,
    pub sctp_rto_max_default: uint32_t,
    pub sctp_rto_min_default: uint32_t,
    pub sctp_rto_initial_default: uint32_t,
    pub sctp_init_rto_max_default: uint32_t,
    pub sctp_valid_cookie_life_default: uint32_t,
    pub sctp_init_rtx_max_default: uint32_t,
    pub sctp_assoc_rtx_max_default: uint32_t,
    pub sctp_path_rtx_max_default: uint32_t,
    pub sctp_path_pf_threshold: uint32_t,
    pub sctp_add_more_threshold: uint32_t,
    pub sctp_nr_incoming_streams_default: uint32_t,
    pub sctp_nr_outgoing_streams_default: uint32_t,
    pub sctp_cmt_on_off: uint32_t,
    pub sctp_cmt_use_dac: uint32_t,
    pub sctp_use_cwnd_based_maxburst: uint32_t,
    pub sctp_nat_friendly: uint32_t,
    pub sctp_L2_abc_variable: uint32_t,
    pub sctp_mbuf_threshold_count: uint32_t,
    pub sctp_do_drain: uint32_t,
    pub sctp_hb_maxburst: uint32_t,
    pub sctp_abort_if_one_2_one_hits_limit: uint32_t,
    pub sctp_min_residual: uint32_t,
    pub sctp_max_retran_chunk: uint32_t,
    pub sctp_logging_level: uint32_t,
    pub sctp_default_cc_module: uint32_t,
    pub sctp_default_ss_module: uint32_t,
    pub sctp_default_frag_interleave: uint32_t,
    pub sctp_mobility_base: uint32_t,
    pub sctp_mobility_fasthandoff: uint32_t,
    pub sctp_inits_include_nat_friendly: uint32_t,
    pub sctp_rttvar_bw: uint32_t,
    pub sctp_rttvar_rtt: uint32_t,
    pub sctp_rttvar_eqret: uint32_t,
    pub sctp_steady_step: uint32_t,
    pub sctp_use_dccc_ecn: uint32_t,
    pub sctp_diag_info_code: uint32_t,
    pub sctp_udp_tunneling_port: uint32_t,
    pub sctp_enable_sack_immediately: uint32_t,
    pub sctp_vtag_time_wait: uint32_t,
    pub sctp_buffer_splitting: uint32_t,
    pub sctp_initial_cwnd: uint32_t,
    pub sctp_blackhole: uint32_t,
    pub sctp_sendall_limit: uint32_t,
    pub sctp_debug_on: uint32_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_epinfo {
    pub sctp_asochash: *mut sctpasochead,
    pub hashasocmark: u_long,
    pub sctp_ephash: *mut sctppcbhead,
    pub hashmark: u_long,
    pub sctp_tcpephash: *mut sctppcbhead,
    pub hashtcpmark: u_long,
    pub hashtblsize: uint32_t,
    pub sctp_vrfhash: *mut sctp_vrflist,
    pub hashvrfmark: u_long,
    pub vrf_ifn_hash: *mut sctp_ifnlist,
    pub vrf_ifn_hashmark: u_long,
    pub listhead: sctppcbhead,
    pub addr_wq: sctpladdr,
    pub ipi_zone_ep: sctp_zone_t,
    pub ipi_zone_asoc: sctp_zone_t,
    pub ipi_zone_laddr: sctp_zone_t,
    pub ipi_zone_net: sctp_zone_t,
    pub ipi_zone_chunk: sctp_zone_t,
    pub ipi_zone_readq: sctp_zone_t,
    pub ipi_zone_strmoq: sctp_zone_t,
    pub ipi_zone_asconf: sctp_zone_t,
    pub ipi_zone_asconf_ack: sctp_zone_t,
    pub ipi_ep_mtx: userland_mutex_t,
    pub ipi_addr_mtx: userland_mutex_t,
    pub ipi_count_mtx: userland_mutex_t,
    pub ipi_pktlog_mtx: userland_mutex_t,
    pub wq_addr_mtx: userland_mutex_t,
    pub ipi_count_ep: uint32_t,
    pub ipi_count_asoc: uint32_t,
    pub ipi_count_laddr: uint32_t,
    pub ipi_count_raddr: uint32_t,
    pub ipi_count_chunk: uint32_t,
    pub ipi_count_readq: uint32_t,
    pub ipi_count_strmoq: uint32_t,
    pub ipi_count_vrfs: uint32_t,
    pub ipi_count_ifns: uint32_t,
    pub ipi_count_ifas: uint32_t,
    pub ipi_free_chunks: uint32_t,
    pub ipi_free_strmoq: uint32_t,
    pub vtag_timewait: [sctpvtaghead; 32],
    pub addr_wq_timer: sctp_timer,
    pub callqueue: calloutlist,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctpvtaghead {
    pub lh_first: *mut sctp_tagblock,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_tagblock {
    pub sctp_nxt_tagblock: C2RustUnnamed_441,
    pub vtag_block: [sctp_timewait; 15],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_timewait {
    pub tv_sec_at_expire: uint32_t,
    pub v_tag: uint32_t,
    pub lport: uint16_t,
    pub rport: uint16_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_441 {
    pub le_next: *mut sctp_tagblock,
    pub le_prev: *mut *mut sctp_tagblock,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctppcbhead {
    pub lh_first: *mut sctp_inpcb,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_vrflist {
    pub lh_first: *mut sctp_vrf,
}
pub type __timezone_ptr_t = *mut timezone;
/* ... used for both INIT and INIT ACK */
/* Selective Ack (SACK) */

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_gap_ack_block {
    pub start: uint16_t,
    pub end: uint16_t,
}
/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 2001-2008, by Cisco Systems, Inc. All rights reserved.
 * Copyright (c) 2008-2012, by Randall Stewart. All rights reserved.
 * Copyright (c) 2008-2012, by Michael Tuexen. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * a) Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * b) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the distribution.
 *
 * c) Neither the name of Cisco Systems, Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
/* (on Ubuntu at least) enables UDP header field names like BSD in RFC 768 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sack_track {
    pub right_edge: uint8_t,
    pub left_edge: uint8_t,
    pub num_entries: uint8_t,
    pub spare: uint8_t,
    pub gaps: [sctp_gap_ack_block; 4],
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_stream_reset_out_request {
    pub ph: sctp_paramhdr,
    pub request_seq: uint32_t,
    pub response_seq: uint32_t,
    pub send_reset_at_tsn: uint32_t,
    pub list_of_streams: [uint16_t; 0],
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_init_chunk {
    pub ch: sctp_chunkhdr,
    pub init: sctp_init,
}
/*
 * Structures for the control chunks
 */
/* Initiate (INIT)/Initiate Ack (INIT ACK) */

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_init {
    pub initiate_tag: uint32_t,
    pub a_rwnd: uint32_t,
    pub num_outbound_streams: uint16_t,
    pub num_inbound_streams: uint16_t,
    pub initial_tsn: uint32_t,
}
/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 2001-2007, by Cisco Systems, Inc. All rights reserved.
 * Copyright (c) 2008-2012, by Randall Stewart. All rights reserved.
 * Copyright (c) 2008-2012, by Michael Tuexen. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * a) Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * b) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the distribution.
 *
 * c) Neither the name of Cisco Systems, Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Parameter structures
 */

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_ipv4addr_param {
    pub ph: sctp_paramhdr,
    pub addr: uint32_t,
}
/* supported address type */

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_supported_addr_param {
    pub ph: sctp_paramhdr,
    pub addr_type: [uint16_t; 2],
}
/* IPV6 address */
/* Cookie Preservative */

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_cookie_perserve_param {
    pub ph: sctp_paramhdr,
    pub time: uint32_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_auth_chunk_list {
    pub ph: sctp_paramhdr,
    pub chunk_types: [uint8_t; 0],
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_auth_hmac_algo {
    pub ph: sctp_paramhdr,
    pub hmac_ids: [uint16_t; 0],
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_auth_random {
    pub ph: sctp_paramhdr,
    pub random_data: [uint8_t; 0],
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_supported_chunk_types_param {
    pub ph: sctp_paramhdr,
    pub chunk_types: [uint8_t; 0],
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_adaptation_layer_indication {
    pub ph: sctp_paramhdr,
    pub indication: uint32_t,
}
/* Shutdown Association (SHUTDOWN) */

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_shutdown_chunk {
    pub ch: sctp_chunkhdr,
    pub cumulative_tsn_ack: uint32_t,
}
/* optional error cause may follow */

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_abort_msg {
    pub sh: sctphdr,
    pub msg: sctp_abort_chunk,
}
/* ... used for Heartbeat Ack (HEARTBEAT ACK) */
/* Abort Asssociation (ABORT) */

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_abort_chunk {
    pub ch: sctp_chunkhdr,
}
/* array of supported address types */
/* heartbeat info parameter */

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_heartbeat_info_param {
    pub ph: sctp_paramhdr,
    pub time_value_1: uint32_t,
    pub time_value_2: uint32_t,
    pub random_value1: uint32_t,
    pub random_value2: uint32_t,
    pub addr_family: uint8_t,
    pub addr_len: uint8_t,
    pub padding: [uint8_t; 2],
    pub address: [libc::c_char; 16],
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_asconf_addrv4_param {
    pub aph: sctp_asconf_paramhdr,
    pub addrp: sctp_ipv4addr_param,
}
/* state cookie header */

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_state_cookie {
    pub identification: [uint8_t; 16],
    pub time_entered: timeval,
    pub cookie_life: uint32_t,
    pub tie_tag_my_vtag: uint32_t,
    pub tie_tag_peer_vtag: uint32_t,
    pub peers_vtag: uint32_t,
    pub my_vtag: uint32_t,
    pub address: [uint32_t; 4],
    pub addr_type: uint32_t,
    pub laddress: [uint32_t; 4],
    pub laddr_type: uint32_t,
    pub scope_id: uint32_t,
    pub peerport: uint16_t,
    pub myport: uint16_t,
    pub ipv4_addr_legal: uint8_t,
    pub ipv6_addr_legal: uint8_t,
    pub conn_addr_legal: uint8_t,
    pub local_scope: uint8_t,
    pub site_scope: uint8_t,
    pub ipv4_scope: uint8_t,
    pub loopback_scope: uint8_t,
    pub reserved: [uint8_t; 5],
}
/* Heartbeat Request (HEARTBEAT) */

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_heartbeat {
    pub hb_info: sctp_heartbeat_info_param,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_heartbeat_chunk {
    pub ch: sctp_chunkhdr,
    pub heartbeat: sctp_heartbeat,
}
/* Shutdown Acknowledgment (SHUTDOWN ACK) */

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_shutdown_ack_chunk {
    pub ch: sctp_chunkhdr,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_ecne_chunk {
    pub ch: sctp_chunkhdr,
    pub tsn: uint32_t,
    pub num_pkts_since_cwr: uint32_t,
}
/* Congestion Window Reduced (CWR) */

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_cwr_chunk {
    pub ch: sctp_chunkhdr,
    pub tsn: uint32_t,
}
/* Shutdown Complete (SHUTDOWN COMPLETE) */

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_shutdown_complete_chunk {
    pub ch: sctp_chunkhdr,
}
/*
 * draft-ietf-tsvwg-addip-sctp
 */
/* Address/Stream Configuration Change (ASCONF) */

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_asconf_chunk {
    pub ch: sctp_chunkhdr,
    pub serial_number: uint32_t,
}
/* asconf parameters follow */
/* draft-ietf-tsvwg-prsctp */
/* Forward Cumulative TSN (FORWARD TSN) */

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_forward_tsn_chunk {
    pub ch: sctp_chunkhdr,
    pub new_cumulative_tsn: uint32_t,
}
/* if not all list of streams */

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_stream_reset_in_request {
    pub ph: sctp_paramhdr,
    pub request_seq: uint32_t,
    pub list_of_streams: [uint16_t; 0],
}
/* if not all list of streams */

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_stream_reset_tsn_request {
    pub ph: sctp_paramhdr,
    pub request_seq: uint32_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_stream_reset_response {
    pub ph: sctp_paramhdr,
    pub response_seq: uint32_t,
    pub result: uint32_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_stream_reset_response_tsn {
    pub ph: sctp_paramhdr,
    pub response_seq: uint32_t,
    pub result: uint32_t,
    pub senders_next_tsn: uint32_t,
    pub receivers_next_tsn: uint32_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_stream_reset_add_strm {
    pub ph: sctp_paramhdr,
    pub request_seq: uint32_t,
    pub number_of_streams: uint16_t,
    pub reserved: uint16_t,
}
#[inline]
unsafe extern "C" fn sctp_userspace_rtalloc(mut ro: *mut sctp_route_t) {
    if !(*ro).ro_rt.is_null() {
        (*(*ro).ro_rt).rt_refcnt += 1;
        return;
    }
    (*ro).ro_rt =
        malloc(::std::mem::size_of::<sctp_rtentry_t>() as libc::c_ulong) as *mut sctp_rtentry_t;
    if (*ro).ro_rt.is_null() {
        return;
    }
    memset(
        (*ro).ro_rt as *mut libc::c_void,
        0i32,
        ::std::mem::size_of::<sctp_rtentry_t>() as libc::c_ulong,
    );
    (*(*ro).ro_rt).rt_refcnt = 1i64;
    (*(*ro).ro_rt).rt_rmx.rmx_mtu = 1500u32;
}
#[inline]
unsafe extern "C" fn sctp_userspace_rtfree(mut rt: *mut sctp_rtentry_t) {
    if rt.is_null() {
        return;
    }
    (*rt).rt_refcnt -= 1;
    if (*rt).rt_refcnt > 0i64 {
        return;
    }
    free(rt as *mut libc::c_void);
    rt = 0 as *mut sctp_rtentry_t;
}
#[no_mangle]
pub static mut sack_array: [sack_track; 256] = [
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 0u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 4u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 0u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 0u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 6u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 4u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 4u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 4u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 4u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 4u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 4u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 4u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 5u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 7u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 4u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 4u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 6u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 3u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 5u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 3u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 2u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 4u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 1u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 3u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 2u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 2u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 0u8,
            left_edge: 1u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 1u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
    {
        let mut init = sack_track {
            right_edge: 1u8,
            left_edge: 1u8,
            num_entries: 1u8,
            spare: 0u8,
            gaps: [
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 7u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
                {
                    let mut init = sctp_gap_ack_block {
                        start: 0u16,
                        end: 0u16,
                    };
                    init
                },
            ],
        };
        init
    },
];
#[no_mangle]
pub unsafe extern "C" fn sctp_is_address_in_scope(
    mut ifa: *mut sctp_ifa,
    mut scope: *mut sctp_scoping,
    mut do_update: libc::c_int,
) -> libc::c_int {
    if (*scope).loopback_scope as libc::c_int == 0i32
        && !(*ifa).ifn_p.is_null()
        && strncmp(
            (*(*ifa).ifn_p).ifn_name.as_mut_ptr(),
            b"lo\x00" as *const u8 as *const libc::c_char,
            2u64,
        ) == 0i32
    {
        /*
         * skip loopback if not in scope *
         */
        return 0i32;
    }
    match (*ifa).address.sa.sa_family as libc::c_int {
        2 => {
            if (*scope).ipv4_addr_legal != 0 {
                let mut sin = 0 as *mut sockaddr_in;
                sin = &mut (*ifa).address.sin;
                if (*sin).sin_addr.s_addr == 0u32 {
                    /* not in scope , unspecified */
                    return 0i32;
                }
                if (*scope).ipv4_local_scope as libc::c_int == 0i32
                    && (*(&mut (*sin).sin_addr.s_addr as *mut in_addr_t as *mut uint8_t)
                        .offset(0isize) as libc::c_int
                        == 10i32
                        || *(&mut (*sin).sin_addr.s_addr as *mut in_addr_t as *mut uint8_t)
                            .offset(0isize) as libc::c_int
                            == 172i32
                            && *(&mut (*sin).sin_addr.s_addr as *mut in_addr_t as *mut uint8_t)
                                .offset(1isize) as libc::c_int
                                >= 16i32
                            && *(&mut (*sin).sin_addr.s_addr as *mut in_addr_t as *mut uint8_t)
                                .offset(1isize) as libc::c_int
                                <= 32i32
                        || *(&mut (*sin).sin_addr.s_addr as *mut in_addr_t as *mut uint8_t)
                            .offset(0isize) as libc::c_int
                            == 192i32
                            && *(&mut (*sin).sin_addr.s_addr as *mut in_addr_t as *mut uint8_t)
                                .offset(1isize) as libc::c_int
                                == 168i32)
                {
                    /* private address not in scope */
                    return 0i32;
                }
            } else {
                return 0i32;
            }
        }
        10 => {
            if (*scope).ipv6_addr_legal != 0 {
                let mut sin6 = 0 as *mut sockaddr_in6;
                /* Must update the flags,  bummer, which
                 * means any IFA locks must now be applied HERE <->
                 */
                if do_update != 0 {
                    sctp_gather_internal_ifa_flags(ifa);
                }
                if (*ifa).localifa_flags & 0x8u32 != 0 {
                    return 0i32;
                }
                /* ok to use deprecated addresses? */
                sin6 = &mut (*ifa).address.sin6;
                if ({
                    let mut __a = &mut (*sin6).sin6_addr as *mut in6_addr as *const in6_addr;
                    ((*__a).__in6_u.__u6_addr32[0usize] == 0u32
                        && (*__a).__in6_u.__u6_addr32[1usize] == 0u32
                        && (*__a).__in6_u.__u6_addr32[2usize] == 0u32
                        && (*__a).__in6_u.__u6_addr32[3usize] == 0u32)
                        as libc::c_int
                }) != 0
                {
                    /* skip unspecifed addresses */
                    return 0i32;
                }
                if ({
                    let mut __a = &mut (*sin6).sin6_addr as *mut in6_addr as *const in6_addr;
                    ((*__a).__in6_u.__u6_addr32[0usize] & htonl(0xffc00000u32)
                        == htonl(0xfe800000u32)) as libc::c_int
                }) != 0
                {
                    return 0i32;
                }
                if (*scope).site_scope as libc::c_int == 0i32
                    && ({
                        let mut __a = &mut (*sin6).sin6_addr as *mut in6_addr as *const in6_addr;
                        ((*__a).__in6_u.__u6_addr32[0usize] & htonl(0xffc00000u32)
                            == htonl(0xfec00000u32)) as libc::c_int
                    }) != 0
                {
                    return 0i32;
                }
            } else {
                return 0i32;
            }
        }
        123 => {
            if (*scope).conn_addr_legal == 0 {
                return 0i32;
            }
        }
        _ => return 0i32,
    }
    return 1i32;
}
unsafe extern "C" fn sctp_add_addr_to_mbuf(
    mut m: *mut mbuf,
    mut ifa: *mut sctp_ifa,
    mut len: *mut uint16_t,
) -> *mut mbuf {
    let mut paramh = 0 as *mut sctp_paramhdr;
    let mut mret = 0 as *mut mbuf;
    let mut plen = 0;
    match (*ifa).address.sa.sa_family as libc::c_int {
        2 => plen = ::std::mem::size_of::<sctp_ipv4addr_param>() as uint16_t,
        10 => plen = ::std::mem::size_of::<sctp_ipv6addr_param>() as uint16_t,
        _ => return m,
    }
    if (if (*m).m_hdr.mh_flags & 0x1i32 != 0 {
        (if (*m).m_hdr.mh_flags & 0x8i32 == 0
            && ((*m).m_hdr.mh_flags & 0x1i32 == 0 || *(*m).M_dat.MH.MH_dat.MH_ext.ref_cnt == 1u32)
        {
            (*m).M_dat
                .MH
                .MH_dat
                .MH_ext
                .ext_buf
                .offset((*m).M_dat.MH.MH_dat.MH_ext.ext_size as isize)
                .wrapping_offset_from((*m).m_hdr.mh_data.offset((*m).m_hdr.mh_len as isize))
                as libc::c_long
        } else {
            0i64
        })
    } else {
        (&mut *(*m).M_dat.M_databuf.as_mut_ptr().offset(
            (256u64).wrapping_sub(::std::mem::size_of::<m_hdr>() as libc::c_ulong) as libc::c_int
                as isize,
        ) as *mut libc::c_char)
            .wrapping_offset_from((*m).m_hdr.mh_data.offset((*m).m_hdr.mh_len as isize))
            as libc::c_long
    }) >= plen as libc::c_long
    {
        /* easy side we just drop it on the end */
        paramh = (*m).m_hdr.mh_data.offset((*m).m_hdr.mh_len as isize) as *mut sctp_paramhdr;
        mret = m
    } else {
        /* Need more space */
        mret = m;
        while !(*mret).m_hdr.mh_next.is_null() {
            mret = (*mret).m_hdr.mh_next
        }
        (*mret).m_hdr.mh_next =
            sctp_get_mbuf_for_msg(plen as libc::c_uint, 0i32, 0x1i32, 1i32, 1i32);
        if (*mret).m_hdr.mh_next.is_null() {
            /* We are hosed, can't add more addresses */
            return m;
        }
        mret = (*mret).m_hdr.mh_next;
        paramh = (*mret).m_hdr.mh_data as *mut sctp_paramhdr
    }
    /* now add the parameter */
    match (*ifa).address.sa.sa_family as libc::c_int {
        2 => {
            let mut ipv4p = 0 as *mut sctp_ipv4addr_param;
            let mut sin = 0 as *mut sockaddr_in;
            sin = &mut (*ifa).address.sin;
            ipv4p = paramh as *mut sctp_ipv4addr_param;
            (*paramh).param_type = htons(0x5u16);
            (*paramh).param_length = htons(plen);
            (*ipv4p).addr = (*sin).sin_addr.s_addr;
            (*mret).m_hdr.mh_len += plen as libc::c_int
        }
        10 => {
            let mut ipv6p = 0 as *mut sctp_ipv6addr_param;
            let mut sin6 = 0 as *mut sockaddr_in6;
            sin6 = &mut (*ifa).address.sin6;
            ipv6p = paramh as *mut sctp_ipv6addr_param;
            (*paramh).param_type = htons(0x6u16);
            (*paramh).param_length = htons(plen);
            memcpy(
                (*ipv6p).addr.as_mut_ptr() as *mut libc::c_void,
                &mut (*sin6).sin6_addr as *mut in6_addr as *const libc::c_void,
                ::std::mem::size_of::<[uint8_t; 16]>() as libc::c_ulong,
            );
            (*mret).m_hdr.mh_len += plen as libc::c_int
        }
        _ => return m,
    }
    if !len.is_null() {
        *len = (*len as libc::c_int + plen as libc::c_int) as uint16_t
    }
    return mret;
}
/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 2001-2007, by Cisco Systems, Inc. All rights reserved.
 * Copyright (c) 2008-2012, by Randall Stewart. All rights reserved.
 * Copyright (c) 2008-2012, by Michael Tuexen. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * a) Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * b) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the distribution.
 *
 * c) Neither the name of Cisco Systems, Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
#[no_mangle]
pub unsafe extern "C" fn sctp_add_addresses_to_i_ia(
    mut inp: *mut sctp_inpcb,
    mut stcb: *mut sctp_tcb,
    mut scope: *mut sctp_scoping,
    mut m_at: *mut mbuf,
    mut cnt_inits_to: libc::c_int,
    mut padding_len: *mut uint16_t,
    mut chunk_len: *mut uint16_t,
) -> *mut mbuf {
    let mut vrf = 0 as *mut sctp_vrf;
    let mut cnt = 0;
    let mut vrf_id = 0;
    vrf_id = (*inp).def_vrf_id;
    pthread_mutex_lock(&mut system_base_info.sctppcbinfo.ipi_addr_mtx);
    vrf = sctp_find_vrf(vrf_id);
    if vrf.is_null() {
        pthread_mutex_unlock(&mut system_base_info.sctppcbinfo.ipi_addr_mtx);
        return m_at;
    }
    if (*inp).sctp_flags & 0x4u32 != 0 {
        let mut limit_out = 0i32;
        let mut sctp_ifap = 0 as *mut sctp_ifa;
        let mut sctp_ifnp = 0 as *mut sctp_ifn;
        cnt = cnt_inits_to;
        if (*vrf).total_ifa_count > 40u32 {
            limit_out = 1i32;
            cnt = 1080i32
        } else {
            sctp_ifnp = (*vrf).ifnlist.lh_first;
            while !sctp_ifnp.is_null() {
                if !((*scope).loopback_scope as libc::c_int == 0i32
                    && strncmp(
                        (*sctp_ifnp).ifn_name.as_mut_ptr(),
                        b"lo\x00" as *const u8 as *const libc::c_char,
                        2u64,
                    ) == 0i32)
                {
                    sctp_ifap = (*sctp_ifnp).ifalist.lh_first;
                    while !sctp_ifap.is_null() {
                        if !(sctp_is_addr_restricted(stcb, sctp_ifap) != 0) {
                            if !((*sctp_ifap).address.sa.sa_family as libc::c_int == 123i32) {
                                if !(sctp_is_address_in_scope(sctp_ifap, scope, 1i32) == 0i32) {
                                    cnt += 1;
                                    if cnt > 1080i32 {
                                        break;
                                    }
                                }
                            }
                        }
                        sctp_ifap = (*sctp_ifap).next_ifa.le_next
                    }
                    if cnt > 1080i32 {
                        break;
                    }
                }
                /*
                 * Skip loopback devices if loopback_scope
                 * not set
                 */
                sctp_ifnp = (*sctp_ifnp).next_ifn.le_next
            }
        }
        if cnt > 1i32 {
            let mut total_count = 0;
            total_count = 0i32;
            sctp_ifnp = (*vrf).ifnlist.lh_first;
            while !sctp_ifnp.is_null() {
                cnt = 0i32;
                if !((*scope).loopback_scope as libc::c_int == 0i32
                    && strncmp(
                        (*sctp_ifnp).ifn_name.as_mut_ptr(),
                        b"lo\x00" as *const u8 as *const libc::c_char,
                        2u64,
                    ) == 0i32)
                {
                    sctp_ifap = (*sctp_ifnp).ifalist.lh_first;
                    while !sctp_ifap.is_null() {
                        if !(sctp_is_addr_restricted(stcb, sctp_ifap) != 0) {
                            if !((*sctp_ifap).address.sa.sa_family as libc::c_int == 123i32) {
                                if !(sctp_is_address_in_scope(sctp_ifap, scope, 0i32) == 0i32) {
                                    if !chunk_len.is_null()
                                        && !padding_len.is_null()
                                        && *padding_len as libc::c_int > 0i32
                                    {
                                        memset(
                                            (*m_at)
                                                .m_hdr
                                                .mh_data
                                                .offset(*chunk_len as libc::c_int as isize)
                                                as *mut libc::c_void,
                                            0i32,
                                            *padding_len as libc::c_ulong,
                                        );
                                        (*m_at).m_hdr.mh_len += *padding_len as libc::c_int;
                                        *chunk_len = (*chunk_len as libc::c_int
                                            + *padding_len as libc::c_int)
                                            as uint16_t;
                                        *padding_len = 0u16
                                    }
                                    m_at = sctp_add_addr_to_mbuf(m_at, sctp_ifap, chunk_len);
                                    if limit_out != 0 {
                                        cnt += 1;
                                        total_count += 1;
                                        if cnt >= 2i32 {
                                            /* two from each address */
                                            break;
                                        } else if total_count > 1080i32 {
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        sctp_ifap = (*sctp_ifap).next_ifa.le_next
                    }
                }
                /*
                 * Skip loopback devices if
                 * loopback_scope not set
                 */
                sctp_ifnp = (*sctp_ifnp).next_ifn.le_next
            }
        }
    } else {
        let mut laddr = 0 as *mut sctp_laddr;
        cnt = cnt_inits_to;
        /* First, how many ? */
        laddr = (*inp).sctp_addr_list.lh_first;
        while !laddr.is_null() {
            if !(*laddr).ifa.is_null() {
                if !((*(*laddr).ifa).localifa_flags & 0x2u32 != 0) {
                    if !((*laddr).action == 0xc002u32) {
                        if !((*(*laddr).ifa).address.sa.sa_family as libc::c_int == 123i32) {
                            if !(sctp_is_address_in_scope((*laddr).ifa, scope, 1i32) == 0i32) {
                                cnt += 1
                            }
                        }
                    }
                }
            }
            /* Address being deleted on this ep
             * don't list.
             */
            laddr = (*laddr).sctp_nxt_addr.le_next
        }
        /*
         * To get through a NAT we only list addresses if we have
         * more than one. That way if you just bind a single address
         * we let the source of the init dictate our address.
         */
        if cnt > 1i32 {
            cnt = cnt_inits_to;
            laddr = (*inp).sctp_addr_list.lh_first;
            while !laddr.is_null() {
                if !(*laddr).ifa.is_null() {
                    if !((*(*laddr).ifa).localifa_flags & 0x2u32 != 0) {
                        if !((*(*laddr).ifa).address.sa.sa_family as libc::c_int == 123i32) {
                            if !(sctp_is_address_in_scope((*laddr).ifa, scope, 0i32) == 0i32) {
                                if !chunk_len.is_null()
                                    && !padding_len.is_null()
                                    && *padding_len as libc::c_int > 0i32
                                {
                                    memset(
                                        (*m_at)
                                            .m_hdr
                                            .mh_data
                                            .offset(*chunk_len as libc::c_int as isize)
                                            as *mut libc::c_void,
                                        0i32,
                                        *padding_len as libc::c_ulong,
                                    );
                                    (*m_at).m_hdr.mh_len += *padding_len as libc::c_int;
                                    *chunk_len = (*chunk_len as libc::c_int
                                        + *padding_len as libc::c_int)
                                        as uint16_t;
                                    *padding_len = 0u16
                                }
                                m_at = sctp_add_addr_to_mbuf(m_at, (*laddr).ifa, chunk_len);
                                cnt += 1;
                                if cnt >= 1080i32 {
                                    break;
                                }
                            }
                        }
                    }
                }
                laddr = (*laddr).sctp_nxt_addr.le_next
            }
        }
    }
    pthread_mutex_unlock(&mut system_base_info.sctppcbinfo.ipi_addr_mtx);
    return m_at;
}
unsafe extern "C" fn sctp_is_ifa_addr_preferred(
    mut ifa: *mut sctp_ifa,
    mut dest_is_loop: uint8_t,
    mut dest_is_priv: uint8_t,
    mut fam: sa_family_t,
) -> *mut sctp_ifa {
    let mut dest_is_global = 0u8;
    /* dest_is_priv is true if destination is a private address */
    /* dest_is_loop is true if destination is a loopback addresses */
    /* *
     * Here we determine if its a preferred address. A preferred address
     * means it is the same scope or higher scope then the destination.
     * L = loopback, P = private, G = global
     * -----------------------------------------
     *    src    |  dest | result
     *  ----------------------------------------
     *     L     |    L  |    yes
     *  -----------------------------------------
     *     P     |    L  |    yes-v4 no-v6
     *  -----------------------------------------
     *     G     |    L  |    yes-v4 no-v6
     *  -----------------------------------------
     *     L     |    P  |    no
     *  -----------------------------------------
     *     P     |    P  |    yes
     *  -----------------------------------------
     *     G     |    P  |    no
     *   -----------------------------------------
     *     L     |    G  |    no
     *   -----------------------------------------
     *     P     |    G  |    no
     *    -----------------------------------------
     *     G     |    G  |    yes
     *    -----------------------------------------
     */
    if (*ifa).address.sa.sa_family as libc::c_int != fam as libc::c_int {
        /* forget mis-matched family */
        return 0 as *mut sctp_ifa;
    }
    if dest_is_priv as libc::c_int == 0i32 && dest_is_loop as libc::c_int == 0i32 {
        dest_is_global = 1u8
    }
    if system_base_info.sctpsysctl.sctp_debug_on & 0x20u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"Is destination preferred:\x00" as *const u8 as *const libc::c_char,
            );
        }
    }
    if system_base_info.sctpsysctl.sctp_debug_on & 0x20u32 != 0 {
        sctp_print_address(&mut (*ifa).address.sa);
    }
    /* Ok the address may be ok */
    if fam as libc::c_int == 10i32 {
        /* ok to use deprecated addresses? no lets not! */
        if (*ifa).localifa_flags & 0x8u32 != 0 {
            if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"NO:1\n\x00" as *const u8 as *const libc::c_char,
                    );
                }
            }
            return 0 as *mut sctp_ifa;
        }
        if (*ifa).src_is_priv as libc::c_int != 0 && (*ifa).src_is_loop == 0 {
            if dest_is_loop != 0 {
                if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
                    if system_base_info.debug_printf.is_some() {
                        system_base_info
                            .debug_printf
                            .expect("non-null function pointer")(
                            b"NO:2\n\x00" as *const u8 as *const libc::c_char,
                        );
                    }
                }
                return 0 as *mut sctp_ifa;
            }
        }
        if (*ifa).src_is_glob != 0 {
            if dest_is_loop != 0 {
                if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
                    if system_base_info.debug_printf.is_some() {
                        system_base_info
                            .debug_printf
                            .expect("non-null function pointer")(
                            b"NO:3\n\x00" as *const u8 as *const libc::c_char,
                        );
                    }
                }
                return 0 as *mut sctp_ifa;
            }
        }
    }
    /* Now that we know what is what, implement or table
     * this could in theory be done slicker (it used to be), but this
     * is straightforward and easier to validate :-)
     */
    if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"src_loop:%d src_priv:%d src_glob:%d\n\x00" as *const u8 as *const libc::c_char,
                (*ifa).src_is_loop as libc::c_int,
                (*ifa).src_is_priv as libc::c_int,
                (*ifa).src_is_glob as libc::c_int,
            );
        }
    }
    if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"dest_loop:%d dest_priv:%d dest_glob:%d\n\x00" as *const u8 as *const libc::c_char,
                dest_is_loop as libc::c_int,
                dest_is_priv as libc::c_int,
                dest_is_global as libc::c_int,
            );
        }
    }
    if (*ifa).src_is_loop as libc::c_int != 0 && dest_is_priv as libc::c_int != 0 {
        if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"NO:4\n\x00" as *const u8 as *const libc::c_char,
                );
            }
        }
        return 0 as *mut sctp_ifa;
    }
    if (*ifa).src_is_glob as libc::c_int != 0 && dest_is_priv as libc::c_int != 0 {
        if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"NO:5\n\x00" as *const u8 as *const libc::c_char,
                );
            }
        }
        return 0 as *mut sctp_ifa;
    }
    if (*ifa).src_is_loop as libc::c_int != 0 && dest_is_global as libc::c_int != 0 {
        if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"NO:6\n\x00" as *const u8 as *const libc::c_char,
                );
            }
        }
        return 0 as *mut sctp_ifa;
    }
    if (*ifa).src_is_priv as libc::c_int != 0 && dest_is_global as libc::c_int != 0 {
        if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"NO:7\n\x00" as *const u8 as *const libc::c_char,
                );
            }
        }
        return 0 as *mut sctp_ifa;
    }
    if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"YES\n\x00" as *const u8 as *const libc::c_char,
            );
        }
    }
    /* its a preferred address */
    return ifa;
}
unsafe extern "C" fn sctp_is_ifa_addr_acceptable(
    mut ifa: *mut sctp_ifa,
    mut dest_is_loop: uint8_t,
    mut dest_is_priv: uint8_t,
    mut fam: sa_family_t,
) -> *mut sctp_ifa {
    let mut dest_is_global = 0u8;
    /* *
     * Here we determine if its a acceptable address. A acceptable
     * address means it is the same scope or higher scope but we can
     * allow for NAT which means its ok to have a global dest and a
     * private src.
     *
     * L = loopback, P = private, G = global
     * -----------------------------------------
     *  src    |  dest | result
     * -----------------------------------------
     *   L     |   L   |    yes
     *  -----------------------------------------
     *   P     |   L   |    yes-v4 no-v6
     *  -----------------------------------------
     *   G     |   L   |    yes
     * -----------------------------------------
     *   L     |   P   |    no
     * -----------------------------------------
     *   P     |   P   |    yes
     * -----------------------------------------
     *   G     |   P   |    yes - May not work
     * -----------------------------------------
     *   L     |   G   |    no
     * -----------------------------------------
     *   P     |   G   |    yes - May not work
     * -----------------------------------------
     *   G     |   G   |    yes
     * -----------------------------------------
     */
    if (*ifa).address.sa.sa_family as libc::c_int != fam as libc::c_int {
        /* forget non matching family */
        if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"ifa_fam:%d fam:%d\n\x00" as *const u8 as *const libc::c_char,
                    (*ifa).address.sa.sa_family as libc::c_int,
                    fam as libc::c_int,
                );
            }
        }
        return 0 as *mut sctp_ifa;
    }
    /* Ok the address may be ok */
    if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
        sctp_print_address(&mut (*ifa).address.sa);
    }
    if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"dst_is_loop:%d dest_is_priv:%d\n\x00" as *const u8 as *const libc::c_char,
                dest_is_loop as libc::c_int,
                dest_is_priv as libc::c_int,
            );
        }
    }
    if dest_is_loop as libc::c_int == 0i32 && dest_is_priv as libc::c_int == 0i32 {
        dest_is_global = 1u8
    }
    if fam as libc::c_int == 10i32 {
        /* ok to use deprecated addresses? */
        if (*ifa).localifa_flags & 0x8u32 != 0 {
            return 0 as *mut sctp_ifa;
        }
        if (*ifa).src_is_priv != 0 {
            /* Special case, linklocal to loop */
            if dest_is_loop != 0 {
                return 0 as *mut sctp_ifa;
            }
        }
    }
    /*
     * Now that we know what is what, implement our table.
     * This could in theory be done slicker (it used to be), but this
     * is straightforward and easier to validate :-)
     */
    if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"ifa->src_is_loop:%d dest_is_priv:%d\n\x00" as *const u8 as *const libc::c_char,
                (*ifa).src_is_loop as libc::c_int,
                dest_is_priv as libc::c_int,
            );
        }
    }
    if (*ifa).src_is_loop as libc::c_int == 1i32 && dest_is_priv as libc::c_int != 0 {
        return 0 as *mut sctp_ifa;
    }
    if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"ifa->src_is_loop:%d dest_is_glob:%d\n\x00" as *const u8 as *const libc::c_char,
                (*ifa).src_is_loop as libc::c_int,
                dest_is_global as libc::c_int,
            );
        }
    }
    if (*ifa).src_is_loop as libc::c_int == 1i32 && dest_is_global as libc::c_int != 0 {
        return 0 as *mut sctp_ifa;
    }
    if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"address is acceptable\n\x00" as *const u8 as *const libc::c_char,
            );
        }
    }
    /* its an acceptable address */
    return ifa;
}
#[no_mangle]
pub unsafe extern "C" fn sctp_is_addr_restricted(
    mut stcb: *mut sctp_tcb,
    mut ifa: *mut sctp_ifa,
) -> libc::c_int {
    let mut laddr = 0 as *mut sctp_laddr;
    if stcb.is_null() {
        /* There are no restrictions, no TCB :-) */
        return 0i32;
    }
    laddr = (*stcb).asoc.sctp_restricted_addrs.lh_first;
    while !laddr.is_null() {
        if (*laddr).ifa.is_null() {
            if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"%s: NULL ifa\n\x00" as *const u8 as *const libc::c_char,
                        (*::std::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(
                            b"sctp_is_addr_restricted\x00",
                        ))
                        .as_ptr(),
                    );
                }
            }
        } else if (*laddr).ifa == ifa {
            /* Yes it is on the list */
            return 1i32;
        }
        laddr = (*laddr).sctp_nxt_addr.le_next
    }
    return 0i32;
}
#[no_mangle]
pub unsafe extern "C" fn sctp_is_addr_in_ep(
    mut inp: *mut sctp_inpcb,
    mut ifa: *mut sctp_ifa,
) -> libc::c_int {
    let mut laddr = 0 as *mut sctp_laddr;
    if ifa.is_null() {
        return 0i32;
    }
    laddr = (*inp).sctp_addr_list.lh_first;
    while !laddr.is_null() {
        if (*laddr).ifa.is_null() {
            if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"%s: NULL ifa\n\x00" as *const u8 as *const libc::c_char,
                        (*::std::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(
                            b"sctp_is_addr_in_ep\x00",
                        ))
                        .as_ptr(),
                    );
                }
            }
        } else if (*laddr).ifa == ifa && (*laddr).action == 0u32 {
            /* same pointer */
            return 1i32;
        }
        laddr = (*laddr).sctp_nxt_addr.le_next
    }
    return 0i32;
}
unsafe extern "C" fn sctp_choose_boundspecific_inp(
    mut inp: *mut sctp_inpcb,
    mut ro: *mut sctp_route_t,
    mut vrf_id: uint32_t,
    mut non_asoc_addr_ok: libc::c_int,
    mut dest_is_priv: uint8_t,
    mut dest_is_loop: uint8_t,
    mut fam: sa_family_t,
) -> *mut sctp_ifa {
    let mut laddr = 0 as *mut sctp_laddr;
    let mut starting_point = 0 as *mut sctp_laddr;
    let mut ifn = 0 as *mut libc::c_void;
    let mut resettotop = 0i32;
    let mut sctp_ifn = 0 as *mut sctp_ifn;
    let mut sifa = 0 as *mut sctp_ifa;
    let mut vrf = 0 as *mut sctp_vrf;
    let mut ifn_index = 0;
    vrf = sctp_find_vrf(vrf_id);
    if vrf.is_null() {
        return 0 as *mut sctp_ifa;
    }
    ifn = (*(*ro).ro_rt).rt_ifp as *mut libc::c_void;
    ifn_index = 1u32;
    sctp_ifn = sctp_find_ifn(ifn, ifn_index);
    /*
     * first question, is the ifn we will emit on in our list, if so, we
     * want such an address. Note that we first looked for a
     * preferred address.
     */
    if !sctp_ifn.is_null() {
        let mut sctp_ifa = 0 as *mut sctp_ifa;
        sctp_ifa = (*sctp_ifn).ifalist.lh_first;
        while !sctp_ifa.is_null() {
            if !((*sctp_ifa).localifa_flags & 0x4u32 != 0 && non_asoc_addr_ok == 0i32) {
                sifa = sctp_is_ifa_addr_preferred(sctp_ifa, dest_is_loop, dest_is_priv, fam);
                if !sifa.is_null() {
                    if sctp_is_addr_in_ep(inp, sifa) != 0 {
                        ::std::intrinsics::atomic_xadd(&mut (*sifa).refcount, 1u32);
                        return sifa;
                    }
                }
            }
            sctp_ifa = (*sctp_ifa).next_ifa.le_next
        }
    }
    /*
     * ok, now we now need to find one on the list of the addresses.
     * We can't get one on the emitting interface so let's find first
     * a preferred one. If not that an acceptable one otherwise...
     * we return NULL.
     */
    starting_point = (*inp).next_addr_touse;
    loop {
        if (*inp).next_addr_touse.is_null() {
            (*inp).next_addr_touse = (*inp).sctp_addr_list.lh_first;
            resettotop = 1i32
        }
        laddr = (*inp).next_addr_touse;
        while !laddr.is_null() {
            if !(*laddr).ifa.is_null() {
                if !((*laddr).action == 0xc002u32) {
                    sifa =
                        sctp_is_ifa_addr_preferred((*laddr).ifa, dest_is_loop, dest_is_priv, fam);
                    if !sifa.is_null() {
                        ::std::intrinsics::atomic_xadd(&mut (*sifa).refcount, 1u32);
                        return sifa;
                    }
                }
            }
            /* address is being deleted */
            laddr = (*laddr).sctp_nxt_addr.le_next
        }
        if !(resettotop == 0i32) {
            break;
        }
        (*inp).next_addr_touse = 0 as *mut sctp_laddr
    }
    (*inp).next_addr_touse = starting_point;
    resettotop = 0i32;
    loop {
        if (*inp).next_addr_touse.is_null() {
            (*inp).next_addr_touse = (*inp).sctp_addr_list.lh_first;
            resettotop = 1i32
        }
        /* ok, what about an acceptable address in the inp */
        laddr = (*inp).next_addr_touse;
        while !laddr.is_null() {
            if !(*laddr).ifa.is_null() {
                if !((*laddr).action == 0xc002u32) {
                    sifa =
                        sctp_is_ifa_addr_acceptable((*laddr).ifa, dest_is_loop, dest_is_priv, fam);
                    if !sifa.is_null() {
                        ::std::intrinsics::atomic_xadd(&mut (*sifa).refcount, 1u32);
                        return sifa;
                    }
                }
            }
            /* address is being deleted */
            laddr = (*laddr).sctp_nxt_addr.le_next
        }
        if !(resettotop == 0i32) {
            break;
        }
        (*inp).next_addr_touse = 0 as *mut sctp_laddr
    }
    /*
     * no address bound can be a source for the destination we are in
     * trouble
     */
    return 0 as *mut sctp_ifa;
}
unsafe extern "C" fn sctp_choose_boundspecific_stcb(
    mut inp: *mut sctp_inpcb,
    mut stcb: *mut sctp_tcb,
    mut ro: *mut sctp_route_t,
    mut vrf_id: uint32_t,
    mut dest_is_priv: uint8_t,
    mut dest_is_loop: uint8_t,
    mut non_asoc_addr_ok: libc::c_int,
    mut fam: sa_family_t,
) -> *mut sctp_ifa {
    let mut laddr = 0 as *mut sctp_laddr;
    let mut starting_point = 0 as *mut sctp_laddr;
    let mut ifn = 0 as *mut libc::c_void;
    let mut sctp_ifn = 0 as *mut sctp_ifn;
    let mut sifa = 0 as *mut sctp_ifa;
    let mut start_at_beginning = 0u8;
    let mut vrf = 0 as *mut sctp_vrf;
    let mut ifn_index = 0;
    /*
     * first question, is the ifn we will emit on in our list, if so, we
     * want that one.
     */
    vrf = sctp_find_vrf(vrf_id);
    if vrf.is_null() {
        return 0 as *mut sctp_ifa;
    }
    ifn = (*(*ro).ro_rt).rt_ifp as *mut libc::c_void;
    ifn_index = 1u32;
    sctp_ifn = sctp_find_ifn(ifn, ifn_index);
    /*
     * first question, is the ifn we will emit on in our list?  If so,
     * we want that one. First we look for a preferred. Second, we go
     * for an acceptable.
     */
    if !sctp_ifn.is_null() {
        let mut sctp_ifa = 0 as *mut sctp_ifa;
        sctp_ifa = (*sctp_ifn).ifalist.lh_first;
        while !sctp_ifa.is_null() {
            if !((*sctp_ifa).localifa_flags & 0x4u32 != 0 && non_asoc_addr_ok == 0i32) {
                if sctp_is_addr_in_ep(inp, sctp_ifa) != 0 {
                    sifa = sctp_is_ifa_addr_preferred(sctp_ifa, dest_is_loop, dest_is_priv, fam);
                    if !sifa.is_null() {
                        if !(non_asoc_addr_ok == 0i32 && sctp_is_addr_restricted(stcb, sifa) != 0
                            || non_asoc_addr_ok != 0
                                && sctp_is_addr_restricted(stcb, sifa) != 0
                                && sctp_is_addr_pending(stcb, sifa) == 0)
                        {
                            ::std::intrinsics::atomic_xadd(&mut (*sifa).refcount, 1u32);
                            return sifa;
                        }
                    }
                }
            }
            /* on the no-no list */
            sctp_ifa = (*sctp_ifa).next_ifa.le_next
        }
        /* next try for an acceptable address on the ep */
        sctp_ifa = (*sctp_ifn).ifalist.lh_first;
        while !sctp_ifa.is_null() {
            if !((*sctp_ifa).localifa_flags & 0x4u32 != 0 && non_asoc_addr_ok == 0i32) {
                if sctp_is_addr_in_ep(inp, sctp_ifa) != 0 {
                    sifa = sctp_is_ifa_addr_acceptable(sctp_ifa, dest_is_loop, dest_is_priv, fam);
                    if !sifa.is_null() {
                        if !(non_asoc_addr_ok == 0i32 && sctp_is_addr_restricted(stcb, sifa) != 0
                            || non_asoc_addr_ok != 0
                                && sctp_is_addr_restricted(stcb, sifa) != 0
                                && sctp_is_addr_pending(stcb, sifa) == 0)
                        {
                            ::std::intrinsics::atomic_xadd(&mut (*sifa).refcount, 1u32);
                            return sifa;
                        }
                    }
                }
            }
            /* on the no-no list */
            sctp_ifa = (*sctp_ifa).next_ifa.le_next
        }
    }
    /*
     * if we can't find one like that then we must look at all
     * addresses bound to pick one at first preferable then
     * secondly acceptable.
     */
    starting_point = (*stcb).asoc.last_used_address;
    loop {
        if (*stcb).asoc.last_used_address.is_null() {
            start_at_beginning = 1u8;
            (*stcb).asoc.last_used_address = (*inp).sctp_addr_list.lh_first
        }
        /* search beginning with the last used address */
        laddr = (*stcb).asoc.last_used_address;
        while !laddr.is_null() {
            if !(*laddr).ifa.is_null() {
                if !((*laddr).action == 0xc002u32) {
                    sifa =
                        sctp_is_ifa_addr_preferred((*laddr).ifa, dest_is_loop, dest_is_priv, fam);
                    if !sifa.is_null() {
                        if !(non_asoc_addr_ok == 0i32 && sctp_is_addr_restricted(stcb, sifa) != 0
                            || non_asoc_addr_ok != 0
                                && sctp_is_addr_restricted(stcb, sifa) != 0
                                && sctp_is_addr_pending(stcb, sifa) == 0)
                        {
                            (*stcb).asoc.last_used_address = laddr;
                            ::std::intrinsics::atomic_xadd(&mut (*sifa).refcount, 1u32);
                            return sifa;
                        }
                    }
                }
            }
            /* on the no-no list */
            laddr = (*laddr).sctp_nxt_addr.le_next
        }
        if !(start_at_beginning as libc::c_int == 0i32) {
            break;
        }
        (*stcb).asoc.last_used_address = 0 as *mut sctp_laddr
    }
    /* now try for any higher scope than the destination */
    (*stcb).asoc.last_used_address = starting_point;
    start_at_beginning = 0u8;
    loop {
        if (*stcb).asoc.last_used_address.is_null() {
            start_at_beginning = 1u8;
            (*stcb).asoc.last_used_address = (*inp).sctp_addr_list.lh_first
        }
        /* search beginning with the last used address */
        laddr = (*stcb).asoc.last_used_address;
        while !laddr.is_null() {
            if !(*laddr).ifa.is_null() {
                if !((*laddr).action == 0xc002u32) {
                    sifa =
                        sctp_is_ifa_addr_acceptable((*laddr).ifa, dest_is_loop, dest_is_priv, fam);
                    if !sifa.is_null() {
                        if !(non_asoc_addr_ok == 0i32 && sctp_is_addr_restricted(stcb, sifa) != 0
                            || non_asoc_addr_ok != 0
                                && sctp_is_addr_restricted(stcb, sifa) != 0
                                && sctp_is_addr_pending(stcb, sifa) == 0)
                        {
                            (*stcb).asoc.last_used_address = laddr;
                            ::std::intrinsics::atomic_xadd(&mut (*sifa).refcount, 1u32);
                            return sifa;
                        }
                    }
                }
            }
            /* on the no-no list */
            laddr = (*laddr).sctp_nxt_addr.le_next
        }
        if !(start_at_beginning as libc::c_int == 0i32) {
            break;
        }
        (*stcb).asoc.last_used_address = 0 as *mut sctp_laddr
    }
    return 0 as *mut sctp_ifa;
}
unsafe extern "C" fn sctp_select_nth_preferred_addr_from_ifn_boundall(
    mut ifn: *mut sctp_ifn,
    mut inp: *mut sctp_inpcb,
    mut stcb: *mut sctp_tcb,
    mut non_asoc_addr_ok: libc::c_int,
    mut dest_is_loop: uint8_t,
    mut dest_is_priv: uint8_t,
    mut addr_wanted: libc::c_int,
    mut fam: sa_family_t,
    mut ro: *mut sctp_route_t,
) -> *mut sctp_ifa {
    let mut ifa = 0 as *mut sctp_ifa;
    /* SCTP_EMBEDDED_V6_SCOPE */
    /* INET6 */
    ifa = (*ifn).ifalist.lh_first;
    while !ifa.is_null() {
        if !((*ifa).localifa_flags & 0x4u32 != 0 && non_asoc_addr_ok == 0i32) {
            let mut sifa = 0 as *mut sctp_ifa;
            sifa = sctp_is_ifa_addr_preferred(ifa, dest_is_loop, dest_is_priv, fam);
            if !sifa.is_null() {
                if !(fam as libc::c_int == 10i32
                    && dest_is_loop as libc::c_int != 0
                    && (*sifa).src_is_loop as libc::c_int != 0
                    && (*sifa).src_is_priv as libc::c_int != 0)
                {
                    let mut current_block_5: u64;
                    if !stcb.is_null()
                        && fam as libc::c_int == 10i32
                        && (*(*stcb).sctp_ep).sctp_mobility_features & 0x1u32 != 0
                    {
                        if sctp_v6src_match_nexthop(&mut (*sifa).address.sin6, ro) == 0i32 {
                            current_block_5 = 16559507199688588974;
                        } else {
                            current_block_5 = 7746791466490516765;
                        }
                    } else {
                        current_block_5 = 7746791466490516765;
                    }
                    match current_block_5 {
                        16559507199688588974 => {}
                        _ =>
                        /* Avoid topologically incorrect IPv4 address */
                        {
                            if !stcb.is_null()
                                && fam as libc::c_int == 2i32
                                && (*(*stcb).sctp_ep).sctp_mobility_features & 0x1u32 != 0
                            {
                                if sctp_v4src_match_nexthop(sifa, ro) == 0i32 {
                                    current_block_5 = 16559507199688588974;
                                } else {
                                    current_block_5 = 8236137900636309791;
                                }
                            } else {
                                current_block_5 = 8236137900636309791;
                            }
                            match current_block_5 {
                                16559507199688588974 => {}
                                _ => {
                                    if !stcb.is_null() {
                                        if sctp_is_address_in_scope(
                                            ifa,
                                            &mut (*stcb).asoc.scope,
                                            0i32,
                                        ) == 0i32
                                        {
                                            current_block_5 = 16559507199688588974;
                                        } else if non_asoc_addr_ok == 0i32
                                            && sctp_is_addr_restricted(stcb, sifa) != 0
                                            || non_asoc_addr_ok != 0
                                                && sctp_is_addr_restricted(stcb, sifa) != 0
                                                && sctp_is_addr_pending(stcb, sifa) == 0
                                        {
                                            current_block_5 = 16559507199688588974;
                                        } else {
                                            current_block_5 = 13797916685926291137;
                                        }
                                    } else {
                                        current_block_5 = 13797916685926291137;
                                    }
                                    match current_block_5 {
                                        16559507199688588974 => {}
                                        _ => {
                                            let mut num_eligible_addr = 0i32;
                                            if num_eligible_addr >= addr_wanted {
                                                return sifa;
                                            }
                                            num_eligible_addr += 1
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        /*
         * It is restricted for some reason..
         * probably not yet added.
         */
        ifa = (*ifa).next_ifa.le_next
    }
    return 0 as *mut sctp_ifa;
}
unsafe extern "C" fn sctp_count_num_preferred_boundall(
    mut ifn: *mut sctp_ifn,
    mut inp: *mut sctp_inpcb,
    mut stcb: *mut sctp_tcb,
    mut non_asoc_addr_ok: libc::c_int,
    mut dest_is_loop: uint8_t,
    mut dest_is_priv: uint8_t,
    mut fam: sa_family_t,
) -> libc::c_int {
    let mut ifa = 0 as *mut sctp_ifa;
    let mut num_eligible_addr = 0i32;
    ifa = (*ifn).ifalist.lh_first;
    while !ifa.is_null() {
        if !((*ifa).localifa_flags & 0x4u32 != 0 && non_asoc_addr_ok == 0i32) {
            let mut sifa = 0 as *mut sctp_ifa;
            sifa = sctp_is_ifa_addr_preferred(ifa, dest_is_loop, dest_is_priv, fam);
            if !sifa.is_null() {
                let mut current_block_2: u64;
                if !stcb.is_null() {
                    if sctp_is_address_in_scope(ifa, &mut (*stcb).asoc.scope, 0i32) == 0i32 {
                        current_block_2 = 16559507199688588974;
                    } else if non_asoc_addr_ok == 0i32 && sctp_is_addr_restricted(stcb, sifa) != 0
                        || non_asoc_addr_ok != 0
                            && sctp_is_addr_restricted(stcb, sifa) != 0
                            && sctp_is_addr_pending(stcb, sifa) == 0
                    {
                        current_block_2 = 16559507199688588974;
                    } else {
                        current_block_2 = 1856101646708284338;
                    }
                } else {
                    current_block_2 = 1856101646708284338;
                }
                match current_block_2 {
                    16559507199688588974 => {}
                    _ => num_eligible_addr += 1,
                }
            }
        }
        /*
         * It is restricted for some reason..
         * probably not yet added.
         */
        ifa = (*ifa).next_ifa.le_next
    }
    return num_eligible_addr;
}
unsafe extern "C" fn sctp_choose_boundall(
    mut inp: *mut sctp_inpcb,
    mut stcb: *mut sctp_tcb,
    mut net: *mut sctp_nets,
    mut ro: *mut sctp_route_t,
    mut vrf_id: uint32_t,
    mut dest_is_priv: uint8_t,
    mut dest_is_loop: uint8_t,
    mut non_asoc_addr_ok: libc::c_int,
    mut fam: sa_family_t,
) -> *mut sctp_ifa {
    let mut current_block: u64;
    let mut cur_addr_num = 0i32;
    let mut num_preferred = 0i32;
    let mut ifn = 0 as *mut libc::c_void;
    let mut sctp_ifn = 0 as *mut sctp_ifn;
    let mut looked_at = 0 as *mut sctp_ifn;
    let mut emit_ifn = 0 as *mut sctp_ifn;
    let mut sctp_ifa = 0 as *mut sctp_ifa;
    let mut sifa = 0 as *mut sctp_ifa;
    let mut ifn_index = 0;
    let mut vrf = 0 as *mut sctp_vrf;
    let mut retried = 0i32;
    /*-
     * For boundall we can use any address in the association.
     * If non_asoc_addr_ok is set we can use any address (at least in
     * theory). So we look for preferred addresses first. If we find one,
     * we use it. Otherwise we next try to get an address on the
     * interface, which we should be able to do (unless non_asoc_addr_ok
     * is false and we are routed out that way). In these cases where we
     * can't use the address of the interface we go through all the
     * ifn's looking for an address we can use and fill that in. Punting
     * means we send back address 0, which will probably cause problems
     * actually since then IP will fill in the address of the route ifn,
     * which means we probably already rejected it.. i.e. here comes an
     * abort :-<.
     */
    vrf = sctp_find_vrf(vrf_id);
    if vrf.is_null() {
        return 0 as *mut sctp_ifa;
    }
    ifn = (*(*ro).ro_rt).rt_ifp as *mut libc::c_void;
    ifn_index = 1u32;
    if system_base_info.sctpsysctl.sctp_debug_on & 0x20u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"ifn from route:%p ifn_index:%d\n\x00" as *const u8 as *const libc::c_char,
                ifn,
                ifn_index,
            );
        }
    }
    sctp_ifn = sctp_find_ifn(ifn, ifn_index);
    looked_at = sctp_ifn;
    emit_ifn = looked_at;
    if sctp_ifn.is_null() {
        /* ?? We don't have this guy ?? */
        if system_base_info.sctpsysctl.sctp_debug_on & 0x20u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"No ifn emit interface?\n\x00" as *const u8 as *const libc::c_char,
                );
            }
        }
    } else {
        if system_base_info.sctpsysctl.sctp_debug_on & 0x20u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"ifn_index:%d name:%s is emit interface\n\x00" as *const u8
                        as *const libc::c_char,
                    ifn_index,
                    (*sctp_ifn).ifn_name.as_mut_ptr(),
                );
            }
        }
        if !net.is_null() {
            cur_addr_num = (*net).indx_of_eligible_next_to_use as libc::c_int
        }
        num_preferred = sctp_count_num_preferred_boundall(
            sctp_ifn,
            inp,
            stcb,
            non_asoc_addr_ok,
            dest_is_loop,
            dest_is_priv,
            fam,
        );
        if system_base_info.sctpsysctl.sctp_debug_on & 0x20u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"Found %d preferred source addresses for intf:%s\n\x00" as *const u8
                        as *const libc::c_char,
                    num_preferred,
                    (*sctp_ifn).ifn_name.as_mut_ptr(),
                );
            }
        }
        if !(num_preferred == 0i32) {
            /*
             * Ok we have num_eligible_addr set with how many we can use, this
             * may vary from call to call due to addresses being deprecated
             * etc..
             */
            if cur_addr_num >= num_preferred {
                cur_addr_num = 0i32
            }
            /*
             * select the nth address from the list (where cur_addr_num is the
             * nth) and 0 is the first one, 1 is the second one etc...
             */
            if system_base_info.sctpsysctl.sctp_debug_on & 0x20u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"cur_addr_num:%d\n\x00" as *const u8 as *const libc::c_char,
                        cur_addr_num,
                    );
                }
            }
            sctp_ifa = sctp_select_nth_preferred_addr_from_ifn_boundall(
                sctp_ifn,
                inp,
                stcb,
                non_asoc_addr_ok,
                dest_is_loop,
                dest_is_priv,
                cur_addr_num,
                fam,
                ro,
            );
            /* if sctp_ifa is NULL something changed??, fall to plan b. */
            if !sctp_ifa.is_null() {
                ::std::intrinsics::atomic_xadd(&mut (*sctp_ifa).refcount, 1u32);
                if !net.is_null() {
                    /* save off where the next one we will want */
                    (*net).indx_of_eligible_next_to_use = (cur_addr_num + 1i32) as uint8_t
                }
                return sctp_ifa;
            }
        }
    }
    /*
     * plan_b: Look at all interfaces and find a preferred address. If
     * no preferred fall through to plan_c.
     */
    if system_base_info.sctpsysctl.sctp_debug_on & 0x20u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"Trying Plan B\n\x00" as *const u8 as *const libc::c_char,
            );
        }
    }
    sctp_ifn = (*vrf).ifnlist.lh_first;
    while !sctp_ifn.is_null() {
        if system_base_info.sctpsysctl.sctp_debug_on & 0x20u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"Examine interface %s\n\x00" as *const u8 as *const libc::c_char,
                    (*sctp_ifn).ifn_name.as_mut_ptr(),
                );
            }
        }
        if dest_is_loop as libc::c_int == 0i32
            && strncmp(
                (*sctp_ifn).ifn_name.as_mut_ptr(),
                b"lo\x00" as *const u8 as *const libc::c_char,
                2u64,
            ) == 0i32
        {
            /* wrong base scope */
            if system_base_info.sctpsysctl.sctp_debug_on & 0x20u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"skip\n\x00" as *const u8 as *const libc::c_char,
                    );
                }
            }
        } else if sctp_ifn == looked_at && !looked_at.is_null() {
            /* already looked at this guy */
            if system_base_info.sctpsysctl.sctp_debug_on & 0x20u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"already seen\n\x00" as *const u8 as *const libc::c_char,
                    );
                }
            }
        } else {
            num_preferred = sctp_count_num_preferred_boundall(
                sctp_ifn,
                inp,
                stcb,
                non_asoc_addr_ok,
                dest_is_loop,
                dest_is_priv,
                fam,
            );
            if system_base_info.sctpsysctl.sctp_debug_on & 0x20u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"Found ifn:%p %d preferred source addresses\n\x00" as *const u8
                            as *const libc::c_char,
                        ifn,
                        num_preferred,
                    );
                }
            }
            if num_preferred == 0i32 {
                /* None on this interface. */
                if system_base_info.sctpsysctl.sctp_debug_on & 0x20u32 != 0 {
                    if system_base_info.debug_printf.is_some() {
                        system_base_info
                            .debug_printf
                            .expect("non-null function pointer")(
                            b"No preferred -- skipping to next\n\x00" as *const u8
                                as *const libc::c_char,
                        );
                    }
                }
            } else {
                if system_base_info.sctpsysctl.sctp_debug_on & 0x20u32 != 0 {
                    if system_base_info.debug_printf.is_some() {
                        system_base_info
                            .debug_printf
                            .expect("non-null function pointer")(
                            b"num preferred:%d on interface:%p cur_addr_num:%d\n\x00" as *const u8
                                as *const libc::c_char,
                            num_preferred,
                            sctp_ifn as *mut libc::c_void,
                            cur_addr_num,
                        );
                    }
                }
                /*
                 * Ok we have num_eligible_addr set with how many we can
                 * use, this may vary from call to call due to addresses
                 * being deprecated etc..
                 */
                if cur_addr_num >= num_preferred {
                    cur_addr_num = 0i32
                }
                sifa = sctp_select_nth_preferred_addr_from_ifn_boundall(
                    sctp_ifn,
                    inp,
                    stcb,
                    non_asoc_addr_ok,
                    dest_is_loop,
                    dest_is_priv,
                    cur_addr_num,
                    fam,
                    ro,
                );
                if !sifa.is_null() {
                    if !net.is_null() {
                        (*net).indx_of_eligible_next_to_use = (cur_addr_num + 1i32) as uint8_t;
                        if system_base_info.sctpsysctl.sctp_debug_on & 0x20u32 != 0 {
                            if system_base_info.debug_printf.is_some() {
                                system_base_info
                                    .debug_printf
                                    .expect("non-null function pointer")(
                                    b"we selected %d\n\x00" as *const u8 as *const libc::c_char,
                                    cur_addr_num,
                                );
                            }
                        }
                        if system_base_info.sctpsysctl.sctp_debug_on & 0x20u32 != 0 {
                            if system_base_info.debug_printf.is_some() {
                                system_base_info
                                    .debug_printf
                                    .expect("non-null function pointer")(
                                    b"Source:\x00" as *const u8 as *const libc::c_char,
                                );
                            }
                        }
                        if system_base_info.sctpsysctl.sctp_debug_on & 0x20u32 != 0 {
                            sctp_print_address(&mut (*sifa).address.sa);
                        }
                        if system_base_info.sctpsysctl.sctp_debug_on & 0x20u32 != 0 {
                            if system_base_info.debug_printf.is_some() {
                                system_base_info
                                    .debug_printf
                                    .expect("non-null function pointer")(
                                    b"Dest:\x00" as *const u8 as *const libc::c_char,
                                );
                            }
                        }
                        if system_base_info.sctpsysctl.sctp_debug_on & 0x20u32 != 0 {
                            sctp_print_address(&mut (*net).ro._l_addr.sa);
                        }
                    }
                    ::std::intrinsics::atomic_xadd(&mut (*sifa).refcount, 1u32);
                    return sifa;
                }
            }
        }
        sctp_ifn = (*sctp_ifn).next_ifn.le_next
    }
    'c_19711: loop {
        /* plan_c: do we have an acceptable address on the emit interface */
        sifa = 0 as *mut sctp_ifa;
        if system_base_info.sctpsysctl.sctp_debug_on & 0x20u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"Trying Plan C: find acceptable on interface\n\x00" as *const u8
                        as *const libc::c_char,
                );
            }
        }
        if emit_ifn.is_null() {
            if system_base_info.sctpsysctl.sctp_debug_on & 0x20u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"Jump to Plan D - no emit_ifn\n\x00" as *const u8 as *const libc::c_char,
                    );
                }
            }
        } else {
            sctp_ifa = (*emit_ifn).ifalist.lh_first;
            while !sctp_ifa.is_null() {
                if system_base_info.sctpsysctl.sctp_debug_on & 0x20u32 != 0 {
                    if system_base_info.debug_printf.is_some() {
                        system_base_info
                            .debug_printf
                            .expect("non-null function pointer")(
                            b"ifa:%p\n\x00" as *const u8 as *const libc::c_char,
                            sctp_ifa as *mut libc::c_void,
                        );
                    }
                }
                if (*sctp_ifa).localifa_flags & 0x4u32 != 0 && non_asoc_addr_ok == 0i32 {
                    if system_base_info.sctpsysctl.sctp_debug_on & 0x20u32 != 0 {
                        if system_base_info.debug_printf.is_some() {
                            system_base_info
                                .debug_printf
                                .expect("non-null function pointer")(
                                b"Defer\n\x00" as *const u8 as *const libc::c_char,
                            );
                        }
                    }
                } else {
                    sifa = sctp_is_ifa_addr_acceptable(sctp_ifa, dest_is_loop, dest_is_priv, fam);
                    if sifa.is_null() {
                        if system_base_info.sctpsysctl.sctp_debug_on & 0x20u32 != 0 {
                            if system_base_info.debug_printf.is_some() {
                                system_base_info
                                    .debug_printf
                                    .expect("non-null function pointer")(
                                    b"IFA not acceptable\n\x00" as *const u8 as *const libc::c_char,
                                );
                            }
                        }
                    } else {
                        if stcb.is_null() {
                            current_block = 8483315232868171348;
                            break 'c_19711;
                        }
                        if sctp_is_address_in_scope(sifa, &mut (*stcb).asoc.scope, 0i32) == 0i32 {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x20u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"NOT in scope\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            sifa = 0 as *mut sctp_ifa
                        } else {
                            if !(non_asoc_addr_ok == 0i32
                                && sctp_is_addr_restricted(stcb, sifa) != 0
                                || non_asoc_addr_ok != 0
                                    && sctp_is_addr_restricted(stcb, sifa) != 0
                                    && sctp_is_addr_pending(stcb, sifa) == 0)
                            {
                                current_block = 8483315232868171348;
                                break 'c_19711;
                            }
                            /*
                             * It is restricted for some
                             * reason.. probably not yet added.
                             */
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x20u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"Its restricted\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            sifa = 0 as *mut sctp_ifa
                        }
                    }
                }
                sctp_ifa = (*sctp_ifa).next_ifa.le_next
            }
        }
        /*
         * plan_d: We are in trouble. No preferred address on the emit
         * interface. And not even a preferred address on all interfaces.
         * Go out and see if we can find an acceptable address somewhere
         * amongst all interfaces.
         */
        if system_base_info.sctpsysctl.sctp_debug_on & 0x20u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"Trying Plan D looked_at is %p\n\x00" as *const u8 as *const libc::c_char,
                    looked_at as *mut libc::c_void,
                );
            }
        }
        sctp_ifn = (*vrf).ifnlist.lh_first;
        while !sctp_ifn.is_null() {
            if !(dest_is_loop as libc::c_int == 0i32
                && strncmp(
                    (*sctp_ifn).ifn_name.as_mut_ptr(),
                    b"lo\x00" as *const u8 as *const libc::c_char,
                    2u64,
                ) == 0i32)
            {
                sctp_ifa = (*sctp_ifn).ifalist.lh_first;
                while !sctp_ifa.is_null() {
                    if !((*sctp_ifa).localifa_flags & 0x4u32 != 0 && non_asoc_addr_ok == 0i32) {
                        sifa =
                            sctp_is_ifa_addr_acceptable(sctp_ifa, dest_is_loop, dest_is_priv, fam);
                        if !sifa.is_null() {
                            if stcb.is_null() {
                                current_block = 10261053476134584224;
                                break 'c_19711;
                            }
                            if sctp_is_address_in_scope(sifa, &mut (*stcb).asoc.scope, 0i32) == 0i32
                            {
                                sifa = 0 as *mut sctp_ifa
                            } else {
                                if !(non_asoc_addr_ok == 0i32
                                    && sctp_is_addr_restricted(stcb, sifa) != 0
                                    || non_asoc_addr_ok != 0
                                        && sctp_is_addr_restricted(stcb, sifa) != 0
                                        && sctp_is_addr_pending(stcb, sifa) == 0)
                                {
                                    current_block = 10261053476134584224;
                                    break 'c_19711;
                                }
                                /*
                                 * It is restricted for some
                                 * reason.. probably not yet added.
                                 */
                                sifa = 0 as *mut sctp_ifa
                            }
                        }
                    }
                    sctp_ifa = (*sctp_ifa).next_ifa.le_next
                }
            }
            /* wrong base scope */
            sctp_ifn = (*sctp_ifn).next_ifn.le_next
        }
        if stcb.is_null() {
            current_block = 10261053476134584224;
            break;
        }
        if retried == 0i32 && (*stcb).asoc.scope.ipv4_local_scope as libc::c_int == 0i32 {
            (*stcb).asoc.scope.ipv4_local_scope = 1u8;
            retried = 1i32
        } else {
            if retried == 1i32 {
                (*stcb).asoc.scope.ipv4_local_scope = 0u8
            }
            current_block = 10261053476134584224;
            break;
        }
    }
    match current_block {
        8483315232868171348 => {
            ::std::intrinsics::atomic_xadd(&mut (*sifa).refcount, 1u32);
        }
        _ => {}
    }
    if !sifa.is_null() {
        if retried == 1i32 {
            sctp_ifn = (*vrf).ifnlist.lh_first;
            while !sctp_ifn.is_null() {
                if !(dest_is_loop as libc::c_int == 0i32
                    && strncmp(
                        (*sctp_ifn).ifn_name.as_mut_ptr(),
                        b"lo\x00" as *const u8 as *const libc::c_char,
                        2u64,
                    ) == 0i32)
                {
                    sctp_ifa = (*sctp_ifn).ifalist.lh_first;
                    while !sctp_ifa.is_null() {
                        if !((*sctp_ifa).localifa_flags & 0x4u32 != 0 && non_asoc_addr_ok == 0i32) {
                            let mut tmp_sifa = 0 as *mut sctp_ifa;
                            tmp_sifa = sctp_is_ifa_addr_acceptable(
                                sctp_ifa,
                                dest_is_loop,
                                dest_is_priv,
                                fam,
                            );
                            if !tmp_sifa.is_null() {
                                if !(tmp_sifa == sifa) {
                                    let mut current_block_298: u64;
                                    if !stcb.is_null() {
                                        if sctp_is_address_in_scope(
                                            tmp_sifa,
                                            &mut (*stcb).asoc.scope,
                                            0i32,
                                        ) == 0i32
                                        {
                                            current_block_298 = 1881650265884923011;
                                        } else if non_asoc_addr_ok == 0i32
                                            && sctp_is_addr_restricted(stcb, tmp_sifa) != 0
                                            || non_asoc_addr_ok != 0
                                                && sctp_is_addr_restricted(stcb, tmp_sifa) != 0
                                                && sctp_is_addr_pending(stcb, tmp_sifa) == 0
                                        {
                                            current_block_298 = 1881650265884923011;
                                        } else {
                                            current_block_298 = 3583881587047060489;
                                        }
                                    } else {
                                        current_block_298 = 3583881587047060489;
                                    }
                                    match current_block_298 {
                                        1881650265884923011 => {}
                                        _ => {
                                            if (*tmp_sifa).address.sin.sin_family as libc::c_int
                                                == 2i32
                                                && (*(&mut (*tmp_sifa).address.sin.sin_addr.s_addr
                                                    as *mut in_addr_t
                                                    as *mut uint8_t)
                                                    .offset(0isize)
                                                    as libc::c_int
                                                    == 10i32
                                                    || *(&mut (*tmp_sifa)
                                                        .address
                                                        .sin
                                                        .sin_addr
                                                        .s_addr
                                                        as *mut in_addr_t
                                                        as *mut uint8_t)
                                                        .offset(0isize)
                                                        as libc::c_int
                                                        == 172i32
                                                        && *(&mut (*tmp_sifa)
                                                            .address
                                                            .sin
                                                            .sin_addr
                                                            .s_addr
                                                            as *mut in_addr_t
                                                            as *mut uint8_t)
                                                            .offset(1isize)
                                                            as libc::c_int
                                                            >= 16i32
                                                        && *(&mut (*tmp_sifa)
                                                            .address
                                                            .sin
                                                            .sin_addr
                                                            .s_addr
                                                            as *mut in_addr_t
                                                            as *mut uint8_t)
                                                            .offset(1isize)
                                                            as libc::c_int
                                                            <= 32i32
                                                    || *(&mut (*tmp_sifa)
                                                        .address
                                                        .sin
                                                        .sin_addr
                                                        .s_addr
                                                        as *mut in_addr_t
                                                        as *mut uint8_t)
                                                        .offset(0isize)
                                                        as libc::c_int
                                                        == 192i32
                                                        && *(&mut (*tmp_sifa)
                                                            .address
                                                            .sin
                                                            .sin_addr
                                                            .s_addr
                                                            as *mut in_addr_t
                                                            as *mut uint8_t)
                                                            .offset(1isize)
                                                            as libc::c_int
                                                            == 168i32)
                                            {
                                                sctp_add_local_addr_restricted(stcb, tmp_sifa);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        /*
                         * It is restricted for some
                         * reason.. probably not yet added.
                         */
                        sctp_ifa = (*sctp_ifa).next_ifa.le_next
                    }
                }
                /* wrong base scope */
                sctp_ifn = (*sctp_ifn).next_ifn.le_next
            }
        }
        ::std::intrinsics::atomic_xadd(&mut (*sifa).refcount, 1u32);
    }
    return sifa;
}
/* tcb may be NULL */
#[no_mangle]
pub unsafe extern "C" fn sctp_source_address_selection(
    mut inp: *mut sctp_inpcb,
    mut stcb: *mut sctp_tcb,
    mut ro: *mut sctp_route_t,
    mut net: *mut sctp_nets,
    mut non_asoc_addr_ok: libc::c_int,
    mut vrf_id: uint32_t,
) -> *mut sctp_ifa {
    let mut answer = 0 as *mut sctp_ifa;
    let mut dest_is_priv = 0;
    let mut dest_is_loop = 0;
    let mut fam = 0;
    let mut to = &mut (*ro).ro_dst as *mut sockaddr as *mut sockaddr_in;
    let mut to6 = &mut (*ro).ro_dst as *mut sockaddr as *mut sockaddr_in6;
    /* *
     * Rules:
     * - Find the route if needed, cache if I can.
     * - Look at interface address in route, Is it in the bound list. If so we
     *   have the best source.
     * - If not we must rotate amongst the addresses.
     *
     * Cavets and issues
     *
     * Do we need to pay attention to scope. We can have a private address
     * or a global address we are sourcing or sending to. So if we draw
     * it out
     * zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
     * For V4
     * ------------------------------------------
     *      source     *      dest  *  result
     * -----------------------------------------
     * <a>  Private    *    Global  *  NAT
     * -----------------------------------------
     * <b>  Private    *    Private *  No problem
     * -----------------------------------------
     * <c>  Global     *    Private *  Huh, How will this work?
     * -----------------------------------------
     * <d>  Global     *    Global  *  No Problem
     *------------------------------------------
     * zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
     * For V6
     *------------------------------------------
     *      source     *      dest  *  result
     * -----------------------------------------
     * <a>  Linklocal  *    Global  *
     * -----------------------------------------
     * <b>  Linklocal  * Linklocal  *  No problem
     * -----------------------------------------
     * <c>  Global     * Linklocal  *  Huh, How will this work?
     * -----------------------------------------
     * <d>  Global     *    Global  *  No Problem
     *------------------------------------------
     * zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
     *
     * And then we add to that what happens if there are multiple addresses
     * assigned to an interface. Remember the ifa on a ifn is a linked
     * list of addresses. So one interface can have more than one IP
     * address. What happens if we have both a private and a global
     * address? Do we then use context of destination to sort out which
     * one is best? And what about NAT's sending P->G may get you a NAT
     * translation, or should you select the G thats on the interface in
     * preference.
     *
     * Decisions:
     *
     * - count the number of addresses on the interface.
     * - if it is one, no problem except case <c>.
     *   For <a> we will assume a NAT out there.
     * - if there are more than one, then we need to worry about scope P
     *   or G. We should prefer G -> G and P -> P if possible.
     *   Then as a secondary fall back to mixed types G->P being a last
     *   ditch one.
     * - The above all works for bound all, but bound specific we need to
     *   use the same concept but instead only consider the bound
     *   addresses. If the bound set is NOT assigned to the interface then
     *   we must use rotation amongst the bound addresses..
     */
    if (*ro).ro_rt.is_null() {
        /*
         * Need a route to cache.
         */
        sctp_userspace_rtalloc(ro);
    }
    if (*ro).ro_rt.is_null() {
        return 0 as *mut sctp_ifa;
    }
    fam = (*ro).ro_dst.sa_family;
    dest_is_loop = 0u8;
    dest_is_priv = dest_is_loop;
    /* Setup our scopes for the destination */
    match fam as libc::c_int {
        2 => {
            /* Scope based on outbound address */
            if *(&mut (*to).sin_addr.s_addr as *mut in_addr_t as *mut uint8_t).offset(0isize)
                as libc::c_int
                == 127i32
            {
                dest_is_loop = 1u8;
                if !net.is_null() {
                    /* mark it as local */
                    (*net).addr_is_local = 1u8
                }
            } else if *(&mut (*to).sin_addr.s_addr as *mut in_addr_t as *mut uint8_t).offset(0isize)
                as libc::c_int
                == 10i32
                || *(&mut (*to).sin_addr.s_addr as *mut in_addr_t as *mut uint8_t).offset(0isize)
                    as libc::c_int
                    == 172i32
                    && *(&mut (*to).sin_addr.s_addr as *mut in_addr_t as *mut uint8_t)
                        .offset(1isize) as libc::c_int
                        >= 16i32
                    && *(&mut (*to).sin_addr.s_addr as *mut in_addr_t as *mut uint8_t)
                        .offset(1isize) as libc::c_int
                        <= 32i32
                || *(&mut (*to).sin_addr.s_addr as *mut in_addr_t as *mut uint8_t).offset(0isize)
                    as libc::c_int
                    == 192i32
                    && *(&mut (*to).sin_addr.s_addr as *mut in_addr_t as *mut uint8_t)
                        .offset(1isize) as libc::c_int
                        == 168i32
            {
                dest_is_priv = 1u8
            }
        }
        10 => {
            /* Scope based on outbound address */
            if ({
                let mut __a = &mut (*to6).sin6_addr as *mut in6_addr as *const in6_addr;
                ((*__a).__in6_u.__u6_addr32[0usize] == 0u32
                    && (*__a).__in6_u.__u6_addr32[1usize] == 0u32
                    && (*__a).__in6_u.__u6_addr32[2usize] == 0u32
                    && (*__a).__in6_u.__u6_addr32[3usize] == htonl(1u32))
                    as libc::c_int
            }) != 0
                || 0i32 != 0
            {
                /*
                 * If the address is a loopback address, which
                 * consists of "::1" OR "fe80::1%lo0", we are loopback
                 * scope. But we don't use dest_is_priv (link local
                 * addresses).
                 */
                dest_is_loop = 1u8;
                if !net.is_null() {
                    /* mark it as local */
                    (*net).addr_is_local = 1u8
                }
            } else if ({
                let mut __a = &mut (*to6).sin6_addr as *mut in6_addr as *const in6_addr;
                ((*__a).__in6_u.__u6_addr32[0usize] & htonl(0xffc00000u32) == htonl(0xfe800000u32))
                    as libc::c_int
            }) != 0
            {
                dest_is_priv = 1u8
            }
        }
        _ => {}
    }
    if system_base_info.sctpsysctl.sctp_debug_on & 0x20u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"Select source addr for:\x00" as *const u8 as *const libc::c_char,
            );
        }
    }
    if system_base_info.sctpsysctl.sctp_debug_on & 0x20u32 != 0 {
        sctp_print_address(&mut (*ro).ro_dst as *mut sockaddr);
    }
    pthread_mutex_lock(&mut system_base_info.sctppcbinfo.ipi_addr_mtx);
    if (*inp).sctp_flags & 0x4u32 != 0 {
        /*
         * Bound all case
         */
        answer = sctp_choose_boundall(
            inp,
            stcb,
            net,
            ro,
            vrf_id,
            dest_is_priv,
            dest_is_loop,
            non_asoc_addr_ok,
            fam,
        );
        pthread_mutex_unlock(&mut system_base_info.sctppcbinfo.ipi_addr_mtx);
        return answer;
    }
    /*
     * Subset bound case
     */
    if !stcb.is_null() {
        answer = sctp_choose_boundspecific_stcb(
            inp,
            stcb,
            ro,
            vrf_id,
            dest_is_priv,
            dest_is_loop,
            non_asoc_addr_ok,
            fam,
        )
    } else {
        answer = sctp_choose_boundspecific_inp(
            inp,
            ro,
            vrf_id,
            non_asoc_addr_ok,
            dest_is_priv,
            dest_is_loop,
            fam,
        )
    }
    pthread_mutex_unlock(&mut system_base_info.sctppcbinfo.ipi_addr_mtx);
    return answer;
}
unsafe extern "C" fn sctp_find_cmsg(
    mut c_type: libc::c_int,
    mut data: *mut libc::c_void,
    mut control: *mut mbuf,
    mut cpsize: size_t,
) -> libc::c_int {
    let mut tot_len = 0;
    let mut off = 0;
    let mut found = 0;
    /*
     * Independent of how many mbufs, find the c_type inside the control
     * structure and copy out the data.
     */
    found = 0i32;
    tot_len = (*control).m_hdr.mh_len;
    off = 0i32;
    while off < tot_len {
        let mut cmh = cmsghdr {
            cmsg_len: 0,
            cmsg_level: 0,
            cmsg_type: 0,
            __cmsg_data: [],
        };
        let mut rem_len = 0;
        let mut cmsg_data_len = 0;
        let mut cmsg_data_off = 0;
        rem_len = tot_len - off;
        if rem_len
            < ((::std::mem::size_of::<cmsghdr>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<size_t>() as libc::c_ulong)
                .wrapping_sub(1u64)
                & !(::std::mem::size_of::<size_t>() as libc::c_ulong).wrapping_sub(1u64))
                as libc::c_int
        {
            /* There is not enough room for one more. */
            return found;
        }
        m_copydata(
            control,
            off,
            ::std::mem::size_of::<cmsghdr>() as libc::c_int,
            &mut cmh as *mut cmsghdr as caddr_t,
        );
        if cmh.cmsg_len
            < (::std::mem::size_of::<cmsghdr>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<size_t>() as libc::c_ulong)
                .wrapping_sub(1u64)
                & !(::std::mem::size_of::<size_t>() as libc::c_ulong).wrapping_sub(1u64)
        {
            /* We dont't have a complete CMSG header. */
            return found;
        }
        if cmh.cmsg_len > 2147483647u64 || cmh.cmsg_len as libc::c_int > rem_len {
            /* We don't have the complete CMSG. */
            return found;
        }
        cmsg_data_len = (cmh.cmsg_len as libc::c_int as libc::c_ulong).wrapping_sub(
            (::std::mem::size_of::<cmsghdr>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<size_t>() as libc::c_ulong)
                .wrapping_sub(1u64)
                & !(::std::mem::size_of::<size_t>() as libc::c_ulong).wrapping_sub(1u64),
        ) as libc::c_int;
        cmsg_data_off = (off as libc::c_ulong).wrapping_add(
            (::std::mem::size_of::<cmsghdr>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<size_t>() as libc::c_ulong)
                .wrapping_sub(1u64)
                & !(::std::mem::size_of::<size_t>() as libc::c_ulong).wrapping_sub(1u64),
        ) as libc::c_int;
        if cmh.cmsg_level == IPPROTO_SCTP as libc::c_int
            && (c_type == cmh.cmsg_type
                || c_type == 0x2i32
                    && (cmh.cmsg_type == 0x4i32
                        || cmh.cmsg_type == 0x7i32
                        || cmh.cmsg_type == 0x8i32))
        {
            if c_type == cmh.cmsg_type {
                if cpsize > 2147483647u64 {
                    return found;
                }
                if cmsg_data_len < cpsize as libc::c_int {
                    return found;
                }
                /* It is exactly what we want. Copy it out. */
                m_copydata(
                    control,
                    cmsg_data_off,
                    cpsize as libc::c_int,
                    data as caddr_t,
                );
                return 1i32;
            } else {
                let mut sndrcvinfo = 0 as *mut sctp_sndrcvinfo;
                sndrcvinfo = data as *mut sctp_sndrcvinfo;
                if found == 0i32 {
                    if cpsize < ::std::mem::size_of::<sctp_sndrcvinfo>() as libc::c_ulong {
                        return found;
                    }
                    memset(
                        sndrcvinfo as *mut libc::c_void,
                        0i32,
                        ::std::mem::size_of::<sctp_sndrcvinfo>() as libc::c_ulong,
                    );
                }
                match cmh.cmsg_type {
                    4 => {
                        let mut sndinfo = sctp_sndinfo {
                            snd_sid: 0,
                            snd_flags: 0,
                            snd_ppid: 0,
                            snd_context: 0,
                            snd_assoc_id: 0,
                        };
                        if cmsg_data_len < ::std::mem::size_of::<sctp_sndinfo>() as libc::c_int {
                            return found;
                        }
                        m_copydata(
                            control,
                            cmsg_data_off,
                            ::std::mem::size_of::<sctp_sndinfo>() as libc::c_int,
                            &mut sndinfo as *mut sctp_sndinfo as caddr_t,
                        );
                        (*sndrcvinfo).sinfo_stream = sndinfo.snd_sid;
                        (*sndrcvinfo).sinfo_flags = sndinfo.snd_flags;
                        (*sndrcvinfo).sinfo_ppid = sndinfo.snd_ppid;
                        (*sndrcvinfo).sinfo_context = sndinfo.snd_context;
                        (*sndrcvinfo).sinfo_assoc_id = sndinfo.snd_assoc_id
                    }
                    7 => {
                        let mut prinfo = sctp_prinfo {
                            pr_policy: 0,
                            pr_value: 0,
                        };
                        if cmsg_data_len < ::std::mem::size_of::<sctp_prinfo>() as libc::c_int {
                            return found;
                        }
                        m_copydata(
                            control,
                            cmsg_data_off,
                            ::std::mem::size_of::<sctp_prinfo>() as libc::c_int,
                            &mut prinfo as *mut sctp_prinfo as caddr_t,
                        );
                        if prinfo.pr_policy as libc::c_int != 0i32 {
                            (*sndrcvinfo).sinfo_timetolive = prinfo.pr_value
                        } else {
                            (*sndrcvinfo).sinfo_timetolive = 0u32
                        }
                        (*sndrcvinfo).sinfo_flags = ((*sndrcvinfo).sinfo_flags as libc::c_int
                            | prinfo.pr_policy as libc::c_int)
                            as uint16_t
                    }
                    8 => {
                        let mut authinfo = sctp_authinfo { auth_keynumber: 0 };
                        if cmsg_data_len < ::std::mem::size_of::<sctp_authinfo>() as libc::c_int {
                            return found;
                        }
                        m_copydata(
                            control,
                            cmsg_data_off,
                            ::std::mem::size_of::<sctp_authinfo>() as libc::c_int,
                            &mut authinfo as *mut sctp_authinfo as caddr_t,
                        );
                        (*sndrcvinfo).sinfo_keynumber_valid = 1u16;
                        (*sndrcvinfo).sinfo_keynumber = authinfo.auth_keynumber
                    }
                    _ => return found,
                }
                found = 1i32
            }
        }
        off = (off as libc::c_ulong).wrapping_add(
            cmh.cmsg_len
                .wrapping_add(::std::mem::size_of::<size_t>() as libc::c_ulong)
                .wrapping_sub(1u64)
                & !(::std::mem::size_of::<size_t>() as libc::c_ulong).wrapping_sub(1u64),
        ) as libc::c_int
    }
    return found;
}
unsafe extern "C" fn sctp_process_cmsgs_for_init(
    mut stcb: *mut sctp_tcb,
    mut control: *mut mbuf,
    mut error: *mut libc::c_int,
) -> libc::c_int {
    let mut tot_len = 0;
    let mut off = 0;
    tot_len = (*control).m_hdr.mh_len;
    off = 0i32;
    while off < tot_len {
        let mut cmh = cmsghdr {
            cmsg_len: 0,
            cmsg_level: 0,
            cmsg_type: 0,
            __cmsg_data: [],
        };
        let mut rem_len = 0;
        let mut cmsg_data_len = 0;
        let mut cmsg_data_off = 0;
        rem_len = tot_len - off;
        if rem_len
            < ((::std::mem::size_of::<cmsghdr>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<size_t>() as libc::c_ulong)
                .wrapping_sub(1u64)
                & !(::std::mem::size_of::<size_t>() as libc::c_ulong).wrapping_sub(1u64))
                as libc::c_int
        {
            /* There is not enough room for one more. */
            *error = 22i32;
            return 1i32;
        }
        m_copydata(
            control,
            off,
            ::std::mem::size_of::<cmsghdr>() as libc::c_int,
            &mut cmh as *mut cmsghdr as caddr_t,
        );
        if cmh.cmsg_len
            < (::std::mem::size_of::<cmsghdr>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<size_t>() as libc::c_ulong)
                .wrapping_sub(1u64)
                & !(::std::mem::size_of::<size_t>() as libc::c_ulong).wrapping_sub(1u64)
        {
            /* We dont't have a complete CMSG header. */
            *error = 22i32;
            return 1i32;
        }
        if cmh.cmsg_len > 2147483647u64 || cmh.cmsg_len as libc::c_int > rem_len {
            /* We don't have the complete CMSG. */
            *error = 22i32;
            return 1i32;
        }
        cmsg_data_len = (cmh.cmsg_len as libc::c_int as libc::c_ulong).wrapping_sub(
            (::std::mem::size_of::<cmsghdr>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<size_t>() as libc::c_ulong)
                .wrapping_sub(1u64)
                & !(::std::mem::size_of::<size_t>() as libc::c_ulong).wrapping_sub(1u64),
        ) as libc::c_int;
        cmsg_data_off = (off as libc::c_ulong).wrapping_add(
            (::std::mem::size_of::<cmsghdr>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<size_t>() as libc::c_ulong)
                .wrapping_sub(1u64)
                & !(::std::mem::size_of::<size_t>() as libc::c_ulong).wrapping_sub(1u64),
        ) as libc::c_int;
        if cmh.cmsg_level == IPPROTO_SCTP as libc::c_int {
            let mut sin = sockaddr_in {
                sin_family: 0,
                sin_port: 0,
                sin_addr: in_addr { s_addr: 0 },
                sin_zero: [0; 8],
            };
            match cmh.cmsg_type {
                1 => {
                    let mut initmsg = sctp_initmsg {
                        sinit_num_ostreams: 0,
                        sinit_max_instreams: 0,
                        sinit_max_attempts: 0,
                        sinit_max_init_timeo: 0,
                    };
                    if cmsg_data_len < ::std::mem::size_of::<sctp_initmsg>() as libc::c_int {
                        *error = 22i32;
                        return 1i32;
                    }
                    m_copydata(
                        control,
                        cmsg_data_off,
                        ::std::mem::size_of::<sctp_initmsg>() as libc::c_int,
                        &mut initmsg as *mut sctp_initmsg as caddr_t,
                    );
                    if initmsg.sinit_max_attempts != 0 {
                        (*stcb).asoc.max_init_times = initmsg.sinit_max_attempts
                    }
                    if initmsg.sinit_num_ostreams != 0 {
                        (*stcb).asoc.pre_open_streams = initmsg.sinit_num_ostreams as libc::c_uint
                    }
                    if initmsg.sinit_max_instreams != 0 {
                        (*stcb).asoc.max_inbound_streams =
                            initmsg.sinit_max_instreams as libc::c_uint
                    }
                    if initmsg.sinit_max_init_timeo != 0 {
                        (*stcb).asoc.initial_init_rto_max =
                            initmsg.sinit_max_init_timeo as libc::c_uint
                    }
                    if ((*stcb).asoc.streamoutcnt as libc::c_uint) < (*stcb).asoc.pre_open_streams {
                        let mut tmp_str = 0 as *mut sctp_stream_out;
                        let mut i = 0;
                        /* Default is NOT correct */
                        if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
                            if system_base_info.debug_printf.is_some() {
                                system_base_info
                                    .debug_printf
                                    .expect("non-null function pointer")(
                                    b"Ok, default:%d pre_open:%d\n\x00" as *const u8
                                        as *const libc::c_char,
                                    (*stcb).asoc.streamoutcnt as libc::c_int,
                                    (*stcb).asoc.pre_open_streams,
                                );
                            }
                        }
                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                        tmp_str = malloc(
                            ((*stcb).asoc.pre_open_streams as libc::c_ulong).wrapping_mul(
                                ::std::mem::size_of::<sctp_stream_out>() as libc::c_ulong,
                            ),
                        ) as *mut sctp_stream_out;
                        if 0x1i32 & 0x100i32 != 0 {
                            memset(
                                tmp_str as *mut libc::c_void,
                                0i32,
                                ((*stcb).asoc.pre_open_streams as libc::c_ulong).wrapping_mul(
                                    ::std::mem::size_of::<sctp_stream_out>() as libc::c_ulong,
                                ),
                            );
                        }
                        pthread_mutex_lock(&mut (*stcb).tcb_mtx);
                        if !tmp_str.is_null() {
                            free((*stcb).asoc.strmout as *mut libc::c_void);
                            (*stcb).asoc.strmout = tmp_str;
                            (*stcb).asoc.streamoutcnt = (*stcb).asoc.pre_open_streams as uint16_t;
                            (*stcb).asoc.strm_realoutsize = (*stcb).asoc.streamoutcnt
                        } else {
                            (*stcb).asoc.pre_open_streams =
                                (*stcb).asoc.streamoutcnt as libc::c_uint
                        }
                        i = 0u32;
                        while i < (*stcb).asoc.streamoutcnt as libc::c_uint {
                            let ref mut fresh0 = (*(*stcb).asoc.strmout.offset(i as isize))
                                .outqueue
                                .tqh_first;
                            *fresh0 = 0 as *mut sctp_stream_queue_pending;
                            let ref mut fresh1 =
                                (*(*stcb).asoc.strmout.offset(i as isize)).outqueue.tqh_last;
                            *fresh1 = &mut (*(*stcb).asoc.strmout.offset(i as isize))
                                .outqueue
                                .tqh_first;
                            (*(*stcb).asoc.strmout.offset(i as isize)).chunks_on_queues = 0u32;
                            (*(*stcb).asoc.strmout.offset(i as isize)).next_mid_ordered = 0u32;
                            (*(*stcb).asoc.strmout.offset(i as isize)).next_mid_unordered = 0u32;
                            (*(*stcb).asoc.strmout.offset(i as isize)).abandoned_sent[0usize] =
                                0u32;
                            (*(*stcb).asoc.strmout.offset(i as isize)).abandoned_unsent[0usize] =
                                0u32;
                            (*(*stcb).asoc.strmout.offset(i as isize)).sid = i as uint16_t;
                            (*(*stcb).asoc.strmout.offset(i as isize)).last_msg_incomplete = 0u8;
                            (*(*stcb).asoc.strmout.offset(i as isize)).state = 0x1u8;
                            (*stcb)
                                .asoc
                                .ss_functions
                                .sctp_ss_init_stream
                                .expect("non-null function pointer")(
                                stcb,
                                &mut *(*stcb).asoc.strmout.offset(i as isize),
                                0 as *mut sctp_stream_out,
                            );
                            i = i.wrapping_add(1)
                        }
                    }
                }
                9 => {
                    if cmsg_data_len < ::std::mem::size_of::<in_addr>() as libc::c_int {
                        *error = 22i32;
                        return 1i32;
                    }
                    memset(
                        &mut sin as *mut sockaddr_in as *mut libc::c_void,
                        0i32,
                        ::std::mem::size_of::<sockaddr_in>() as libc::c_ulong,
                    );
                    sin.sin_family = 2u16;
                    sin.sin_port = (*stcb).rport;
                    m_copydata(
                        control,
                        cmsg_data_off,
                        ::std::mem::size_of::<in_addr>() as libc::c_int,
                        &mut sin.sin_addr as *mut in_addr as caddr_t,
                    );
                    if sin.sin_addr.s_addr == 0u32
                        || sin.sin_addr.s_addr == 0xffffffffu32
                        || ntohl(sin.sin_addr.s_addr) & 0xf0000000u32 == 0xe0000000u32
                    {
                        *error = 22i32;
                        return 1i32;
                    }
                    if sctp_add_remote_addr(
                        stcb,
                        &mut sin as *mut sockaddr_in as *mut sockaddr,
                        0 as *mut *mut sctp_nets,
                        (*stcb).asoc.port,
                        0i32,
                        8i32,
                    ) != 0
                    {
                        *error = 105i32;
                        return 1i32;
                    }
                }
                10 => {
                    let mut sin6 = sockaddr_in6 {
                        sin6_family: 0,
                        sin6_port: 0,
                        sin6_flowinfo: 0,
                        sin6_addr: in6_addr {
                            __in6_u: C2RustUnnamed_387 {
                                __u6_addr8: [0; 16],
                            },
                        },
                        sin6_scope_id: 0,
                    };
                    if cmsg_data_len < ::std::mem::size_of::<in6_addr>() as libc::c_int {
                        *error = 22i32;
                        return 1i32;
                    }
                    memset(
                        &mut sin6 as *mut sockaddr_in6 as *mut libc::c_void,
                        0i32,
                        ::std::mem::size_of::<sockaddr_in6>() as libc::c_ulong,
                    );
                    sin6.sin6_family = 10u16;
                    sin6.sin6_port = (*stcb).rport;
                    m_copydata(
                        control,
                        cmsg_data_off,
                        ::std::mem::size_of::<in6_addr>() as libc::c_int,
                        &mut sin6.sin6_addr as *mut in6_addr as caddr_t,
                    );
                    if ({
                        let mut __a = &mut sin6.sin6_addr as *mut in6_addr as *const in6_addr;
                        ((*__a).__in6_u.__u6_addr32[0usize] == 0u32
                            && (*__a).__in6_u.__u6_addr32[1usize] == 0u32
                            && (*__a).__in6_u.__u6_addr32[2usize] == 0u32
                            && (*__a).__in6_u.__u6_addr32[3usize] == 0u32)
                            as libc::c_int
                    }) != 0
                        || *(&mut sin6.sin6_addr as *mut in6_addr as *const uint8_t).offset(0isize)
                            as libc::c_int
                            == 0xffi32
                    {
                        *error = 22i32;
                        return 1i32;
                    }
                    if ({
                        let mut __a = &mut sin6.sin6_addr as *mut in6_addr as *const in6_addr;
                        ((*__a).__in6_u.__u6_addr32[0usize] == 0u32
                            && (*__a).__in6_u.__u6_addr32[1usize] == 0u32
                            && (*__a).__in6_u.__u6_addr32[2usize] == htonl(0xffffu32))
                            as libc::c_int
                    }) != 0
                    {
                        in6_sin6_2_sin(&mut sin, &mut sin6);
                        if sin.sin_addr.s_addr == 0u32
                            || sin.sin_addr.s_addr == 0xffffffffu32
                            || ntohl(sin.sin_addr.s_addr) & 0xf0000000u32 == 0xe0000000u32
                        {
                            *error = 22i32;
                            return 1i32;
                        }
                        if sctp_add_remote_addr(
                            stcb,
                            &mut sin as *mut sockaddr_in as *mut sockaddr,
                            0 as *mut *mut sctp_nets,
                            (*stcb).asoc.port,
                            0i32,
                            8i32,
                        ) != 0
                        {
                            *error = 105i32;
                            return 1i32;
                        }
                    } else if sctp_add_remote_addr(
                        stcb,
                        &mut sin6 as *mut sockaddr_in6 as *mut sockaddr,
                        0 as *mut *mut sctp_nets,
                        (*stcb).asoc.port,
                        0i32,
                        8i32,
                    ) != 0
                    {
                        *error = 105i32;
                        return 1i32;
                    }
                }
                _ => {}
            }
        }
        off = (off as libc::c_ulong).wrapping_add(
            cmh.cmsg_len
                .wrapping_add(::std::mem::size_of::<size_t>() as libc::c_ulong)
                .wrapping_sub(1u64)
                & !(::std::mem::size_of::<size_t>() as libc::c_ulong).wrapping_sub(1u64),
        ) as libc::c_int
    }
    return 0i32;
}
unsafe extern "C" fn sctp_findassociation_cmsgs(
    mut inp_p: *mut *mut sctp_inpcb,
    mut port: uint16_t,
    mut control: *mut mbuf,
    mut net_p: *mut *mut sctp_nets,
    mut error: *mut libc::c_int,
) -> *mut sctp_tcb {
    let mut tot_len = 0;
    let mut off = 0;
    tot_len = (*control).m_hdr.mh_len;
    off = 0i32;
    while off < tot_len {
        let mut cmh = cmsghdr {
            cmsg_len: 0,
            cmsg_level: 0,
            cmsg_type: 0,
            __cmsg_data: [],
        };
        let mut rem_len = 0;
        let mut cmsg_data_len = 0;
        let mut cmsg_data_off = 0;
        rem_len = tot_len - off;
        if rem_len
            < ((::std::mem::size_of::<cmsghdr>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<size_t>() as libc::c_ulong)
                .wrapping_sub(1u64)
                & !(::std::mem::size_of::<size_t>() as libc::c_ulong).wrapping_sub(1u64))
                as libc::c_int
        {
            /* There is not enough room for one more. */
            *error = 22i32;
            return 0 as *mut sctp_tcb;
        }
        m_copydata(
            control,
            off,
            ::std::mem::size_of::<cmsghdr>() as libc::c_int,
            &mut cmh as *mut cmsghdr as caddr_t,
        );
        if cmh.cmsg_len
            < (::std::mem::size_of::<cmsghdr>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<size_t>() as libc::c_ulong)
                .wrapping_sub(1u64)
                & !(::std::mem::size_of::<size_t>() as libc::c_ulong).wrapping_sub(1u64)
        {
            /* We dont't have a complete CMSG header. */
            *error = 22i32;
            return 0 as *mut sctp_tcb;
        }
        if cmh.cmsg_len > 2147483647u64 || cmh.cmsg_len as libc::c_int > rem_len {
            /* We don't have the complete CMSG. */
            *error = 22i32;
            return 0 as *mut sctp_tcb;
        }
        cmsg_data_len = (cmh.cmsg_len as libc::c_int as libc::c_ulong).wrapping_sub(
            (::std::mem::size_of::<cmsghdr>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<size_t>() as libc::c_ulong)
                .wrapping_sub(1u64)
                & !(::std::mem::size_of::<size_t>() as libc::c_ulong).wrapping_sub(1u64),
        ) as libc::c_int;
        cmsg_data_off = (off as libc::c_ulong).wrapping_add(
            (::std::mem::size_of::<cmsghdr>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<size_t>() as libc::c_ulong)
                .wrapping_sub(1u64)
                & !(::std::mem::size_of::<size_t>() as libc::c_ulong).wrapping_sub(1u64),
        ) as libc::c_int;
        if cmh.cmsg_level == IPPROTO_SCTP as libc::c_int {
            let mut addr = 0 as *mut sockaddr;
            let mut sin = sockaddr_in {
                sin_family: 0,
                sin_port: 0,
                sin_addr: in_addr { s_addr: 0 },
                sin_zero: [0; 8],
            };
            match cmh.cmsg_type {
                9 => {
                    if cmsg_data_len < ::std::mem::size_of::<in_addr>() as libc::c_int {
                        *error = 22i32;
                        return 0 as *mut sctp_tcb;
                    }
                    memset(
                        &mut sin as *mut sockaddr_in as *mut libc::c_void,
                        0i32,
                        ::std::mem::size_of::<sockaddr_in>() as libc::c_ulong,
                    );
                    sin.sin_family = 2u16;
                    sin.sin_port = port;
                    m_copydata(
                        control,
                        cmsg_data_off,
                        ::std::mem::size_of::<in_addr>() as libc::c_int,
                        &mut sin.sin_addr as *mut in_addr as caddr_t,
                    );
                    addr = &mut sin as *mut sockaddr_in as *mut sockaddr
                }
                10 => {
                    let mut sin6 = sockaddr_in6 {
                        sin6_family: 0,
                        sin6_port: 0,
                        sin6_flowinfo: 0,
                        sin6_addr: in6_addr {
                            __in6_u: C2RustUnnamed_387 {
                                __u6_addr8: [0; 16],
                            },
                        },
                        sin6_scope_id: 0,
                    };
                    if cmsg_data_len < ::std::mem::size_of::<in6_addr>() as libc::c_int {
                        *error = 22i32;
                        return 0 as *mut sctp_tcb;
                    }
                    memset(
                        &mut sin6 as *mut sockaddr_in6 as *mut libc::c_void,
                        0i32,
                        ::std::mem::size_of::<sockaddr_in6>() as libc::c_ulong,
                    );
                    sin6.sin6_family = 10u16;
                    sin6.sin6_port = port;
                    m_copydata(
                        control,
                        cmsg_data_off,
                        ::std::mem::size_of::<in6_addr>() as libc::c_int,
                        &mut sin6.sin6_addr as *mut in6_addr as caddr_t,
                    );
                    if ({
                        let mut __a = &mut sin6.sin6_addr as *mut in6_addr as *const in6_addr;
                        ((*__a).__in6_u.__u6_addr32[0usize] == 0u32
                            && (*__a).__in6_u.__u6_addr32[1usize] == 0u32
                            && (*__a).__in6_u.__u6_addr32[2usize] == htonl(0xffffu32))
                            as libc::c_int
                    }) != 0
                    {
                        in6_sin6_2_sin(&mut sin, &mut sin6);
                        addr = &mut sin as *mut sockaddr_in as *mut sockaddr
                    } else {
                        addr = &mut sin6 as *mut sockaddr_in6 as *mut sockaddr
                    }
                }
                _ => addr = 0 as *mut sockaddr,
            }
            if !addr.is_null() {
                let mut stcb = 0 as *mut sctp_tcb;
                stcb = sctp_findassociation_ep_addr(
                    inp_p,
                    addr,
                    net_p,
                    0 as *mut sockaddr,
                    0 as *mut sctp_tcb,
                );
                if !stcb.is_null() {
                    return stcb;
                }
            }
        }
        off = (off as libc::c_ulong).wrapping_add(
            cmh.cmsg_len
                .wrapping_add(::std::mem::size_of::<size_t>() as libc::c_ulong)
                .wrapping_sub(1u64)
                & !(::std::mem::size_of::<size_t>() as libc::c_ulong).wrapping_sub(1u64),
        ) as libc::c_int
    }
    return 0 as *mut sctp_tcb;
}
unsafe extern "C" fn sctp_add_cookie(
    mut init: *mut mbuf,
    mut init_offset: libc::c_int,
    mut initack: *mut mbuf,
    mut initack_offset: libc::c_int,
    mut stc_in: *mut sctp_state_cookie,
    mut signature: *mut *mut uint8_t,
) -> *mut mbuf {
    let mut copy_init = 0 as *mut mbuf;
    let mut copy_initack = 0 as *mut mbuf;
    let mut m_at = 0 as *mut mbuf;
    let mut sig = 0 as *mut mbuf;
    let mut mret = 0 as *mut mbuf;
    let mut stc = 0 as *mut sctp_state_cookie;
    let mut ph = 0 as *mut sctp_paramhdr;
    let mut foo = 0 as *mut uint8_t;
    let mut sig_offset = 0;
    let mut cookie_sz = 0;
    mret = sctp_get_mbuf_for_msg(
        (::std::mem::size_of::<sctp_state_cookie>() as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<sctp_paramhdr>() as libc::c_ulong)
            as libc::c_uint,
        0i32,
        0x1i32,
        1i32,
        1i32,
    );
    if mret.is_null() {
        return 0 as *mut mbuf;
    }
    copy_init = m_copym(init, init_offset, 1000000000i32, 0x1i32);
    if copy_init.is_null() {
        m_freem(mret);
        return 0 as *mut mbuf;
    }
    copy_initack = m_copym(initack, initack_offset, 1000000000i32, 0x1i32);
    if copy_initack.is_null() {
        m_freem(mret);
        m_freem(copy_init);
        return 0 as *mut mbuf;
    }
    /* easy side we just drop it on the end */
    ph = (*mret).m_hdr.mh_data as *mut sctp_paramhdr; /* fill in at the end */
    (*mret).m_hdr.mh_len = (::std::mem::size_of::<sctp_state_cookie>() as libc::c_ulong)
        .wrapping_add(::std::mem::size_of::<sctp_paramhdr>() as libc::c_ulong)
        as libc::c_int;
    stc = (ph as caddr_t).offset(::std::mem::size_of::<sctp_paramhdr>() as isize)
        as *mut sctp_state_cookie;
    (*ph).param_type = htons(0x7u16);
    (*ph).param_length = 0u16;
    /* Fill in the stc cookie data */
    memcpy(
        stc as *mut libc::c_void,
        stc_in as *const libc::c_void,
        ::std::mem::size_of::<sctp_state_cookie>() as libc::c_ulong,
    );
    /* tack the INIT and then the INIT-ACK onto the chain */
    cookie_sz = 0u16;
    m_at = mret;
    while !m_at.is_null() {
        cookie_sz = (cookie_sz as libc::c_int + (*m_at).m_hdr.mh_len) as uint16_t;
        if (*m_at).m_hdr.mh_next.is_null() {
            (*m_at).m_hdr.mh_next = copy_init;
            break;
        } else {
            m_at = (*m_at).m_hdr.mh_next
        }
    }
    m_at = copy_init;
    while !m_at.is_null() {
        cookie_sz = (cookie_sz as libc::c_int + (*m_at).m_hdr.mh_len) as uint16_t;
        if (*m_at).m_hdr.mh_next.is_null() {
            (*m_at).m_hdr.mh_next = copy_initack;
            break;
        } else {
            m_at = (*m_at).m_hdr.mh_next
        }
    }
    m_at = copy_initack;
    while !m_at.is_null() {
        cookie_sz = (cookie_sz as libc::c_int + (*m_at).m_hdr.mh_len) as uint16_t;
        if (*m_at).m_hdr.mh_next.is_null() {
            break;
        }
        m_at = (*m_at).m_hdr.mh_next
    }
    sig = sctp_get_mbuf_for_msg(32u32, 0i32, 0x1i32, 1i32, 1i32);
    if sig.is_null() {
        /* no space, so free the entire chain */
        m_freem(mret);
        return 0 as *mut mbuf;
    }
    (*sig).m_hdr.mh_len = 0i32;
    (*m_at).m_hdr.mh_next = sig;
    sig_offset = 0i32;
    foo = (*sig).m_hdr.mh_data.offset(sig_offset as isize) as *mut uint8_t;
    memset(foo as *mut libc::c_void, 0i32, 20u64);
    *signature = foo;
    (*sig).m_hdr.mh_len += 20i32;
    cookie_sz = (cookie_sz as libc::c_int + 20i32) as uint16_t;
    (*ph).param_length = htons(cookie_sz);
    return mret;
}
unsafe extern "C" fn sctp_get_ect(mut stcb: *mut sctp_tcb) -> uint8_t {
    if !stcb.is_null() && (*stcb).asoc.ecn_supported as libc::c_int == 1i32 {
        return 0x2u8;
    } else {
        return 0u8;
    };
}
unsafe extern "C" fn sctp_handle_no_route(
    mut stcb: *mut sctp_tcb,
    mut net: *mut sctp_nets,
    mut so_locked: libc::c_int,
) {
    if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"dropped packet - no valid source addr\n\x00" as *const u8 as *const libc::c_char,
            );
        }
    }
    if !net.is_null() {
        if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"Destination was \x00" as *const u8 as *const libc::c_char,
                );
            }
        }
        if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
            sctp_print_address(&mut (*net).ro._l_addr.sa);
        }
        if (*net).dest_state as libc::c_int & 0x6i32 != 0 {
            if (*net).dest_state as libc::c_int & 0x1i32 != 0 && !stcb.is_null() {
                if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
                    if system_base_info.debug_printf.is_some() {
                        system_base_info
                            .debug_printf
                            .expect("non-null function pointer")(
                            b"no route takes interface %p down\n\x00" as *const u8
                                as *const libc::c_char,
                            net as *mut libc::c_void,
                        );
                    }
                }
                sctp_ulp_notify(3u32, stcb, 0u32, net as *mut libc::c_void, so_locked);
                (*net).dest_state = ((*net).dest_state as libc::c_int & !(0x1i32)) as uint16_t;
                (*net).dest_state = ((*net).dest_state as libc::c_int & !(0x800i32)) as uint16_t
            }
        }
        if !stcb.is_null() {
            if net == (*stcb).asoc.primary_destination {
                let mut alt = 0 as *mut sctp_nets;
                alt = sctp_find_alternate_net(stcb, net, 0i32);
                if alt != net {
                    if !(*stcb).asoc.alternate.is_null() {
                        if !(*stcb).asoc.alternate.is_null() {
                            if ::std::intrinsics::atomic_xadd(
                                &mut (*(*stcb).asoc.alternate).ref_count as *mut libc::c_int,
                                -(1i32),
                            ) == 1i32
                            {
                                sctp_os_timer_stop(&mut (*(*stcb).asoc.alternate).rxt_timer.timer);
                                sctp_os_timer_stop(&mut (*(*stcb).asoc.alternate).pmtu_timer.timer);
                                sctp_os_timer_stop(&mut (*(*stcb).asoc.alternate).hb_timer.timer);
                                if !(*(*stcb).asoc.alternate).ro.ro_rt.is_null() {
                                    if (*(*(*stcb).asoc.alternate).ro.ro_rt).rt_refcnt <= 1i64 {
                                        sctp_userspace_rtfree((*(*stcb).asoc.alternate).ro.ro_rt);
                                    } else {
                                        (*(*(*stcb).asoc.alternate).ro.ro_rt).rt_refcnt -= 1
                                    }
                                    (*(*stcb).asoc.alternate).ro.ro_rt = 0 as *mut sctp_rtentry_t;
                                    (*(*stcb).asoc.alternate).ro.ro_rt = 0 as *mut sctp_rtentry_t
                                }
                                if (*(*stcb).asoc.alternate).src_addr_selected != 0 {
                                    sctp_free_ifa((*(*stcb).asoc.alternate).ro._s_addr);
                                    (*(*stcb).asoc.alternate).ro._s_addr = 0 as *mut sctp_ifa
                                }
                                (*(*stcb).asoc.alternate).src_addr_selected = 0u8;
                                (*(*stcb).asoc.alternate).dest_state =
                                    ((*(*stcb).asoc.alternate).dest_state as libc::c_int
                                        & !(0x1i32))
                                        as uint16_t;
                                free((*stcb).asoc.alternate as *mut libc::c_void);
                                ::std::intrinsics::atomic_xsub(
                                    &mut system_base_info.sctppcbinfo.ipi_count_raddr,
                                    1u32,
                                );
                            }
                        }
                    }
                    (*stcb).asoc.alternate = alt;
                    ::std::intrinsics::atomic_xadd(&mut (*(*stcb).asoc.alternate).ref_count, 1i32);
                    if !(*net).ro._s_addr.is_null() {
                        sctp_free_ifa((*net).ro._s_addr);
                        (*net).ro._s_addr = 0 as *mut sctp_ifa
                    }
                    (*net).src_addr_selected = 0u8
                }
            }
        }
    };
}
unsafe extern "C" fn sctp_lowlevel_chunk_output(
    mut inp: *mut sctp_inpcb,
    mut stcb: *mut sctp_tcb,
    mut net: *mut sctp_nets,
    mut to: *mut sockaddr,
    mut m: *mut mbuf,
    mut auth_offset: uint32_t,
    mut auth: *mut sctp_auth_chunk,
    mut auth_keyid: uint16_t,
    mut nofragment_flag: libc::c_int,
    mut ecn_ok: libc::c_int,
    mut out_of_asoc_ok: libc::c_int,
    mut src_port: uint16_t,
    mut dest_port: uint16_t,
    mut v_tag: uint32_t,
    mut port: uint16_t,
    mut over_addr: *mut sctp_sockstore,
    mut so_locked: libc::c_int,
) -> libc::c_int
/* nofragment_flag to tell if IP_DF should be set (IPv4 only) */ {
    let mut newm = 0 as *mut mbuf;
    let mut sctphdr = 0 as *mut sctphdr;
    let mut packet_length = 0;
    let mut ret = 0;
    let mut vrf_id = 0;
    let mut o_pak = 0 as *mut mbuf;
    let mut ro = 0 as *mut sctp_route_t;
    let mut udp = 0 as *mut udphdr;
    let mut tos_value = 0;
    if !net.is_null() && (*net).dest_state as libc::c_int & 0x80i32 != 0 {
        m_freem(m);
        return 14i32;
    }
    if !stcb.is_null() {
        vrf_id = (*stcb).asoc.vrf_id
    } else {
        vrf_id = (*inp).def_vrf_id
    }
    /* fill in the HMAC digest for any AUTH chunk in the packet */
    if !auth.is_null() && !stcb.is_null() {
        sctp_fill_hmac_digest_m(m, auth_offset, auth, stcb, auth_keyid);
    }
    if !net.is_null() {
        tos_value = (*net).dscp
    } else if !stcb.is_null() {
        tos_value = (*stcb).asoc.default_dscp
    } else {
        tos_value = (*inp).sctp_ep.default_dscp
    }
    match (*to).sa_family as libc::c_int {
        2 => {
            let mut ip = 0 as *mut ip;
            let mut iproute = sctp_route_t {
                ro_rt: 0 as *mut sctp_rtentry,
                ro_dst: sockaddr {
                    sa_family: 0,
                    sa_data: [0; 14],
                },
            };
            let mut len = 0;
            len = (::std::mem::size_of::<ip>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong)
                as libc::c_int;
            if port != 0 {
                len = (len as libc::c_ulong)
                    .wrapping_add(::std::mem::size_of::<udphdr>() as libc::c_ulong)
                    as libc::c_int
            }
            newm = sctp_get_mbuf_for_msg(len as libc::c_uint, 1i32, 0x1i32, 1i32, 1i32);
            if newm.is_null() {
                m_freem(m);
                return 12i32;
            }
            if (*newm).m_hdr.mh_flags & 0x2i32 != 0 {
                (*newm).m_hdr.mh_data = (*newm).m_hdr.mh_data.offset(
                    ((((256u64).wrapping_sub(::std::mem::size_of::<m_hdr>() as libc::c_ulong)
                        as libc::c_int as libc::c_ulong)
                        .wrapping_sub(::std::mem::size_of::<pkthdr>() as libc::c_ulong)
                        as libc::c_int
                        - len) as libc::c_ulong
                        & !(::std::mem::size_of::<libc::c_long>() as libc::c_ulong)
                            .wrapping_sub(1u64)) as isize,
                )
            } else if (*newm).m_hdr.mh_flags & 0x1i32 == 0i32 {
                (*newm).m_hdr.mh_data = (*newm).m_hdr.mh_data.offset(
                    (((256u64).wrapping_sub(::std::mem::size_of::<m_hdr>() as libc::c_ulong)
                        as libc::c_int
                        - len) as libc::c_ulong
                        & !(::std::mem::size_of::<libc::c_long>() as libc::c_ulong)
                            .wrapping_sub(1u64)) as isize,
                )
            }
            (*newm).m_hdr.mh_len = len;
            (*newm).m_hdr.mh_next = m;
            m = newm;
            packet_length = sctp_calculate_len(m) as libc::c_int;
            ip = (*m).m_hdr.mh_data as *mut ip;
            (*ip).set_ip_v(4u32);
            (*ip).set_ip_hl((::std::mem::size_of::<ip>() as libc::c_ulong >> 2i32) as libc::c_uint);
            if tos_value as libc::c_int == 0i32 {
                /*
                 * This means especially, that it is not set at the
                 * SCTP layer. So use the value from the IP layer.
                 */
                tos_value = (*inp).ip_inp.inp.inp_depend4.inp4_ip_tos
            }
            tos_value = (tos_value as libc::c_int & 0xfci32) as uint8_t;
            if ecn_ok != 0 {
                tos_value =
                    (tos_value as libc::c_int | sctp_get_ect(stcb) as libc::c_int) as uint8_t
            }
            if nofragment_flag != 0 && port as libc::c_int == 0i32 {
                (*ip).ip_off = htons(0x4000u16)
            } else {
                (*ip).ip_off = 0u16
            }
            let fresh2 = ip_id;
            ip_id = ip_id.wrapping_add(1);
            (*ip).ip_id = htons(fresh2);
            (*ip).ip_ttl = (*inp).ip_inp.inp.inp_ip_ttl;
            (*ip).ip_len = packet_length as libc::c_ushort;
            (*ip).ip_tos = tos_value;
            if port != 0 {
                (*ip).ip_p = IPPROTO_UDP as uint8_t
            } else {
                (*ip).ip_p = IPPROTO_SCTP as uint8_t
            }
            (*ip).ip_sum = 0u16;
            if net.is_null() {
                ro = &mut iproute;
                memset(
                    &mut iproute as *mut sctp_route_t as *mut libc::c_void,
                    0i32,
                    ::std::mem::size_of::<sctp_route_t>() as libc::c_ulong,
                );
                memcpy(
                    &mut (*ro).ro_dst as *mut sockaddr as *mut libc::c_void,
                    to as *const libc::c_void,
                    ::std::mem::size_of::<sockaddr_in>() as libc::c_ulong,
                );
            } else {
                ro = &mut (*net).ro as *mut sctp_net_route as *mut sctp_route_t
            }
            /* Now the address selection part */
            (*ip).ip_dst.s_addr = (*(to as *mut sockaddr_in)).sin_addr.s_addr;
            /* call the routine to select the src address */
            if !net.is_null() && out_of_asoc_ok == 0i32 {
                if !(*net).ro._s_addr.is_null()
                    && (*(*net).ro._s_addr).localifa_flags & (0x2i32 | 0x8i32) as libc::c_uint != 0
                {
                    sctp_free_ifa((*net).ro._s_addr);
                    (*net).ro._s_addr = 0 as *mut sctp_ifa;
                    (*net).src_addr_selected = 0u8;
                    if !(*ro).ro_rt.is_null() {
                        if (*(*ro).ro_rt).rt_refcnt <= 1i64 {
                            sctp_userspace_rtfree((*ro).ro_rt);
                        } else {
                            (*(*ro).ro_rt).rt_refcnt -= 1
                        }
                        (*ro).ro_rt = 0 as *mut sctp_rtentry;
                        (*ro).ro_rt = 0 as *mut sctp_rtentry
                    }
                }
                if (*net).src_addr_selected as libc::c_int == 0i32 {
                    /* Cache the source address */
                    (*net).ro._s_addr =
                        sctp_source_address_selection(inp, stcb, ro, net, 0i32, vrf_id);
                    (*net).src_addr_selected = 1u8
                }
                if (*net).ro._s_addr.is_null() {
                    /* No route to host */
                    (*net).src_addr_selected = 0u8;
                    sctp_handle_no_route(stcb, net, so_locked);
                    m_freem(m);
                    return 113i32;
                }
                (*ip).ip_src = (*(*net).ro._s_addr).address.sin.sin_addr
            } else if over_addr.is_null() {
                let mut _lsrc = 0 as *mut sctp_ifa;
                _lsrc = sctp_source_address_selection(inp, stcb, ro, net, out_of_asoc_ok, vrf_id);
                if _lsrc.is_null() {
                    sctp_handle_no_route(stcb, net, so_locked);
                    m_freem(m);
                    return 113i32;
                }
                (*ip).ip_src = (*_lsrc).address.sin.sin_addr;
                sctp_free_ifa(_lsrc);
            } else {
                (*ip).ip_src = (*over_addr).sin.sin_addr;
                sctp_userspace_rtalloc(ro);
            }
            if port != 0 {
                if htons(system_base_info.sctpsysctl.sctp_udp_tunneling_port as uint16_t)
                    as libc::c_int
                    == 0i32
                {
                    sctp_handle_no_route(stcb, net, so_locked);
                    m_freem(m);
                    return 113i32;
                }
                udp = (ip as caddr_t).offset(::std::mem::size_of::<ip>() as isize) as *mut udphdr;
                (*udp).c2rust_unnamed.c2rust_unnamed.uh_sport =
                    htons(system_base_info.sctpsysctl.sctp_udp_tunneling_port as uint16_t);
                (*udp).c2rust_unnamed.c2rust_unnamed.uh_dport = port;
                (*udp).c2rust_unnamed.c2rust_unnamed.uh_ulen = htons(
                    (packet_length as libc::c_ulong)
                        .wrapping_sub(::std::mem::size_of::<ip>() as libc::c_ulong)
                        as uint16_t,
                );
                (*udp).c2rust_unnamed.c2rust_unnamed.uh_sum = 0u16;
                sctphdr = (udp as caddr_t).offset(::std::mem::size_of::<udphdr>() as isize)
                    as *mut sctphdr
            } else {
                sctphdr =
                    (ip as caddr_t).offset(::std::mem::size_of::<ip>() as isize) as *mut sctphdr
            }
            (*sctphdr).src_port = src_port;
            (*sctphdr).dest_port = dest_port;
            (*sctphdr).v_tag = v_tag;
            (*sctphdr).checksum = 0u32;
            /*
             * If source address selection fails and we find no route
             * then the ip_output should fail as well with a
             * NO_ROUTE_TO_HOST type error. We probably should catch
             * that somewhere and abort the association right away
             * (assuming this is an INIT being sent).
             */
            if (*ro).ro_rt.is_null() {
                /*
                 * src addr selection failed to find a route (or
                 * valid source addr), so we can't get there from
                 * here (yet)!
                 */
                sctp_handle_no_route(stcb, net, so_locked);
                m_freem(m);
                return 113i32;
            }
            if ro != &mut iproute as *mut sctp_route_t {
                memcpy(
                    &mut iproute as *mut sctp_route_t as *mut libc::c_void,
                    ro as *const libc::c_void,
                    ::std::mem::size_of::<sctp_route_t>() as libc::c_ulong,
                );
            }
            if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"Calling ipv4 output routine from low level src addr:%x\n\x00" as *const u8
                            as *const libc::c_char,
                        ntohl((*ip).ip_src.s_addr),
                    );
                }
            }
            if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"Destination is %x\n\x00" as *const u8 as *const libc::c_char,
                        ntohl((*ip).ip_dst.s_addr),
                    );
                }
            }
            if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"RTP route is %p through\n\x00" as *const u8 as *const libc::c_char,
                        (*ro).ro_rt as *mut libc::c_void,
                    );
                }
            }
            o_pak = m;
            (*o_pak).M_dat.MH.MH_pkthdr.len = packet_length;
            if port != 0 {
                (*sctphdr).checksum = sctp_calculate_cksum(
                    m,
                    (::std::mem::size_of::<ip>() as libc::c_ulong)
                        .wrapping_add(::std::mem::size_of::<udphdr>() as libc::c_ulong)
                        as uint32_t,
                );
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctpstat.sctps_sendswcrc,
                    1u32,
                );
            } else if !(system_base_info.sctpsysctl.sctp_no_csum_on_loopback != 0
                && !stcb.is_null()
                && (*stcb).asoc.scope.loopback_scope as libc::c_int != 0)
            {
                (*sctphdr).checksum =
                    sctp_calculate_cksum(m, ::std::mem::size_of::<ip>() as uint32_t);
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctpstat.sctps_sendswcrc,
                    1u32,
                );
            } else {
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctpstat.sctps_sendhwcrc,
                    1u32,
                );
            }
            /* send it out.  table id is taken from stcb */
            sctp_userspace_ip_output(&mut ret, o_pak, ro, stcb as *mut libc::c_void, vrf_id);
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_sendpackets, 1u32);
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_outpackets, 1u32);
            if ret != 0 {
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctpstat.sctps_senderrors,
                    1u32,
                );
            }
            if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"IP output returns %d\n\x00" as *const u8 as *const libc::c_char,
                        ret,
                    );
                }
            }
            if net.is_null() {
                /* free tempy routes */
                if !(*ro).ro_rt.is_null() {
                    if (*(*ro).ro_rt).rt_refcnt <= 1i64 {
                        sctp_userspace_rtfree((*ro).ro_rt);
                    } else {
                        (*(*ro).ro_rt).rt_refcnt -= 1
                    }
                    (*ro).ro_rt = 0 as *mut sctp_rtentry;
                    (*ro).ro_rt = 0 as *mut sctp_rtentry
                }
            } else if !(*ro).ro_rt.is_null()
                && !(*net).ro._s_addr.is_null()
                && (*net).dest_state as libc::c_int & 0x2i32 == 0i32
            {
                let mut mtu = 0;
                mtu = if !(*ro).ro_rt.is_null() {
                    (*(*ro).ro_rt).rt_rmx.rmx_mtu
                } else {
                    0u32
                };
                if mtu > 0u32 {
                    if (*net).port != 0 {
                        mtu = (mtu as libc::c_ulong)
                            .wrapping_sub(::std::mem::size_of::<udphdr>() as libc::c_ulong)
                            as uint32_t
                    }
                    if mtu < (*net).mtu {
                        if !stcb.is_null() && (*stcb).asoc.smallest_mtu > mtu {
                            sctp_mtu_size_reset(inp, &mut (*stcb).asoc, mtu);
                        }
                        (*net).mtu = mtu
                    }
                }
            } else if (*ro).ro_rt.is_null() {
                /* route was freed */
                if !(*net).ro._s_addr.is_null() && (*net).src_addr_selected as libc::c_int != 0 {
                    sctp_free_ifa((*net).ro._s_addr);
                    (*net).ro._s_addr = 0 as *mut sctp_ifa
                }
                (*net).src_addr_selected = 0u8
            }
            return ret;
        }
        10 => {
            let mut flowlabel = 0;
            let mut flowinfo = 0;
            let mut ip6h = 0 as *mut ip6_hdr;
            let mut sin6 = 0 as *mut sockaddr_in6;
            let mut tmp = sockaddr_in6 {
                sin6_family: 0,
                sin6_port: 0,
                sin6_flowinfo: 0,
                sin6_addr: in6_addr {
                    __in6_u: C2RustUnnamed_387 {
                        __u6_addr8: [0; 16],
                    },
                },
                sin6_scope_id: 0,
            };
            let mut lsa6 = 0 as *mut sockaddr_in6;
            let mut lsa6_tmp = sockaddr_in6 {
                sin6_family: 0,
                sin6_port: 0,
                sin6_flowinfo: 0,
                sin6_addr: in6_addr {
                    __in6_u: C2RustUnnamed_387 {
                        __u6_addr8: [0; 16],
                    },
                },
                sin6_scope_id: 0,
            };
            let mut prev_scope = 0i32;
            let mut prev_port = 0u16;
            let mut len_0 = 0;
            if !net.is_null() {
                flowlabel = (*net).flowlabel
            } else if !stcb.is_null() {
                flowlabel = (*stcb).asoc.default_flowlabel
            } else {
                flowlabel = (*inp).sctp_ep.default_flowlabel
            }
            if flowlabel == 0u32 {
                /*
                 * This means especially, that it is not set at the
                 * SCTP layer. So use the value from the IP layer.
                 */
                flowlabel = ntohl((*(inp as *mut inpcb)).inp_flow)
            }
            flowlabel &= 0xfffffu32;
            len_0 = (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong)
                as libc::c_int;
            if port != 0 {
                len_0 = (len_0 as libc::c_ulong)
                    .wrapping_add(::std::mem::size_of::<udphdr>() as libc::c_ulong)
                    as libc::c_int
            }
            newm = sctp_get_mbuf_for_msg(len_0 as libc::c_uint, 1i32, 0x1i32, 1i32, 1i32);
            if newm.is_null() {
                m_freem(m);
                return 12i32;
            }
            if (*newm).m_hdr.mh_flags & 0x2i32 != 0 {
                (*newm).m_hdr.mh_data = (*newm).m_hdr.mh_data.offset(
                    ((((256u64).wrapping_sub(::std::mem::size_of::<m_hdr>() as libc::c_ulong)
                        as libc::c_int as libc::c_ulong)
                        .wrapping_sub(::std::mem::size_of::<pkthdr>() as libc::c_ulong)
                        as libc::c_int
                        - len_0) as libc::c_ulong
                        & !(::std::mem::size_of::<libc::c_long>() as libc::c_ulong)
                            .wrapping_sub(1u64)) as isize,
                )
            } else if (*newm).m_hdr.mh_flags & 0x1i32 == 0i32 {
                (*newm).m_hdr.mh_data = (*newm).m_hdr.mh_data.offset(
                    (((256u64).wrapping_sub(::std::mem::size_of::<m_hdr>() as libc::c_ulong)
                        as libc::c_int
                        - len_0) as libc::c_ulong
                        & !(::std::mem::size_of::<libc::c_long>() as libc::c_ulong)
                            .wrapping_sub(1u64)) as isize,
                )
            }
            (*newm).m_hdr.mh_len = len_0;
            (*newm).m_hdr.mh_next = m;
            m = newm;
            packet_length = sctp_calculate_len(m) as libc::c_int;
            ip6h = (*m).m_hdr.mh_data as *mut ip6_hdr;
            /* protect *sin6 from overwrite */
            sin6 = to as *mut sockaddr_in6;
            tmp = *sin6;
            sin6 = &mut tmp;
            /* SCTP_EMBEDDED_V6_SCOPE */
            if net.is_null() {
                let mut ip6route = route_in6 {
                    ro_rt: 0 as *mut rtentry,
                    ro_lle: 0 as *mut llentry,
                    ro_ia6: 0 as *mut in6_addr,
                    ro_flags: 0,
                    ro_dst: sockaddr_in6 {
                        sin6_family: 0,
                        sin6_port: 0,
                        sin6_flowinfo: 0,
                        sin6_addr: in6_addr {
                            __in6_u: C2RustUnnamed_387 {
                                __u6_addr8: [0; 16],
                            },
                        },
                        sin6_scope_id: 0,
                    },
                };
                memset(
                    &mut ip6route as *mut route_in6 as *mut libc::c_void,
                    0i32,
                    ::std::mem::size_of::<route_in6>() as libc::c_ulong,
                );
                ro = &mut ip6route as *mut route_in6 as *mut sctp_route_t;
                memcpy(
                    &mut (*ro).ro_dst as *mut sockaddr as *mut libc::c_void,
                    sin6 as *const libc::c_void,
                    ::std::mem::size_of::<sockaddr_in6>() as libc::c_ulong,
                );
            } else {
                ro = &mut (*net).ro as *mut sctp_net_route as *mut sctp_route_t
            }
            /*
             * We assume here that inp_flow is in host byte order within
             * the TCB!
             */
            if tos_value as libc::c_int == 0i32 {
                /*
                 * This means especially, that it is not set at the
                 * SCTP layer. So use the value from the IP layer.
                 */
                tos_value = (ntohl((*(inp as *mut inpcb)).inp_flow) >> 20i32 & 0xffu32) as uint8_t
            }
            tos_value = (tos_value as libc::c_int & 0xfci32) as uint8_t;
            if ecn_ok != 0 {
                tos_value =
                    (tos_value as libc::c_int | sctp_get_ect(stcb) as libc::c_int) as uint8_t
            }
            flowinfo = 0x6u32;
            flowinfo <<= 8i32;
            flowinfo |= tos_value as libc::c_uint;
            flowinfo <<= 20i32;
            flowinfo |= flowlabel;
            (*ip6h).ip6_ctlun.ip6_un1.ip6_un1_flow = htonl(flowinfo);
            if port != 0 {
                (*ip6h).ip6_ctlun.ip6_un1.ip6_un1_nxt = IPPROTO_UDP as uint8_t
            } else {
                (*ip6h).ip6_ctlun.ip6_un1.ip6_un1_nxt = IPPROTO_SCTP as uint8_t
            }
            (*ip6h).ip6_ctlun.ip6_un1.ip6_un1_plen = htons(
                (packet_length as libc::c_ulong)
                    .wrapping_sub(::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
                    as uint16_t,
            );
            (*ip6h).ip6_dst = (*sin6).sin6_addr;
            /*
             * Add SRC address selection here: we can only reuse to a
             * limited degree the kame src-addr-sel, since we can try
             * their selection but it may not be bound.
             */
            memset(
                &mut lsa6_tmp as *mut sockaddr_in6 as *mut libc::c_void,
                0i32,
                ::std::mem::size_of::<sockaddr_in6>() as libc::c_ulong,
            );
            lsa6_tmp.sin6_family = 10u16;
            lsa6 = &mut lsa6_tmp;
            if !net.is_null() && out_of_asoc_ok == 0i32 {
                if !(*net).ro._s_addr.is_null()
                    && (*(*net).ro._s_addr).localifa_flags & (0x2i32 | 0x8i32) as libc::c_uint != 0
                {
                    sctp_free_ifa((*net).ro._s_addr);
                    (*net).ro._s_addr = 0 as *mut sctp_ifa;
                    (*net).src_addr_selected = 0u8;
                    if !(*ro).ro_rt.is_null() {
                        if (*(*ro).ro_rt).rt_refcnt <= 1i64 {
                            sctp_userspace_rtfree((*ro).ro_rt);
                        } else {
                            (*(*ro).ro_rt).rt_refcnt -= 1
                        }
                        (*ro).ro_rt = 0 as *mut sctp_rtentry;
                        (*ro).ro_rt = 0 as *mut sctp_rtentry
                    }
                }
                if (*net).src_addr_selected as libc::c_int == 0i32 {
                    /* SCTP_EMBEDDED_V6_SCOPE */
                    /* Cache the source address */
                    (*net).ro._s_addr =
                        sctp_source_address_selection(inp, stcb, ro, net, 0i32, vrf_id);
                    /* SCTP_EMBEDDED_V6_SCOPE */
                    (*net).src_addr_selected = 1u8
                }
                if (*net).ro._s_addr.is_null() {
                    if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
                        if system_base_info.debug_printf.is_some() {
                            system_base_info
                                .debug_printf
                                .expect("non-null function pointer")(
                                b"V6:No route to host\n\x00" as *const u8 as *const libc::c_char,
                            );
                        }
                    }
                    (*net).src_addr_selected = 0u8;
                    sctp_handle_no_route(stcb, net, so_locked);
                    m_freem(m);
                    return 113i32;
                }
                (*lsa6).sin6_addr = (*(*net).ro._s_addr).address.sin6.sin6_addr
            } else if over_addr.is_null() {
                let mut _lsrc_0 = 0 as *mut sctp_ifa;
                _lsrc_0 = sctp_source_address_selection(inp, stcb, ro, net, out_of_asoc_ok, vrf_id);
                if _lsrc_0.is_null() {
                    sctp_handle_no_route(stcb, net, so_locked);
                    m_freem(m);
                    return 113i32;
                }
                (*lsa6).sin6_addr = (*_lsrc_0).address.sin6.sin6_addr;
                sctp_free_ifa(_lsrc_0);
            } else {
                (*lsa6).sin6_addr = (*over_addr).sin6.sin6_addr;
                sctp_userspace_rtalloc(ro);
            }
            (*lsa6).sin6_port = (*inp).ip_inp.inp.inp_inc.inc_ie.ie_lport;
            if (*ro).ro_rt.is_null() {
                /* SCTP_EMBEDDED_V6_SCOPE */
                /* SCTP_EMBEDDED_V6_SCOPE */
                /*
                 * src addr selection failed to find a route (or
                 * valid source addr), so we can't get there from
                 * here!
                 */
                sctp_handle_no_route(stcb, net, so_locked);
                m_freem(m);
                return 113i32;
            }
            /* SCTP_EMBEDDED_V6_SCOPE */
            /* SCOPEDROUTING */
            (*ip6h).ip6_src = (*lsa6).sin6_addr;
            if port != 0 {
                if htons(system_base_info.sctpsysctl.sctp_udp_tunneling_port as uint16_t)
                    as libc::c_int
                    == 0i32
                {
                    sctp_handle_no_route(stcb, net, so_locked);
                    m_freem(m);
                    return 113i32;
                }
                udp = (ip6h as caddr_t).offset(::std::mem::size_of::<ip6_hdr>() as isize)
                    as *mut udphdr;
                (*udp).c2rust_unnamed.c2rust_unnamed.uh_sport =
                    htons(system_base_info.sctpsysctl.sctp_udp_tunneling_port as uint16_t);
                (*udp).c2rust_unnamed.c2rust_unnamed.uh_dport = port;
                (*udp).c2rust_unnamed.c2rust_unnamed.uh_ulen = htons(
                    (packet_length as libc::c_ulong)
                        .wrapping_sub(::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
                        as uint16_t,
                );
                (*udp).c2rust_unnamed.c2rust_unnamed.uh_sum = 0u16;
                sctphdr = (udp as caddr_t).offset(::std::mem::size_of::<udphdr>() as isize)
                    as *mut sctphdr
            } else {
                sctphdr = (ip6h as caddr_t).offset(::std::mem::size_of::<ip6_hdr>() as isize)
                    as *mut sctphdr
            }
            (*sctphdr).src_port = src_port;
            (*sctphdr).dest_port = dest_port;
            (*sctphdr).v_tag = v_tag;
            (*sctphdr).checksum = 0u32;
            /*
             * We set the hop limit now since there is a good chance
             * that our ro pointer is now filled
             */
            (*ip6h).ip6_ctlun.ip6_un1.ip6_un1_hlim = 128u8;
            /* Copy to be sure something bad is not happening */
            (*sin6).sin6_addr = (*ip6h).ip6_dst;
            (*lsa6).sin6_addr = (*ip6h).ip6_src;
            if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"Calling ipv6 output routine from low level\n\x00" as *const u8
                            as *const libc::c_char,
                    );
                }
            }
            if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"src: \x00" as *const u8 as *const libc::c_char,
                    );
                }
            }
            if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
                sctp_print_address(lsa6 as *mut sockaddr);
            }
            if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"dst: \x00" as *const u8 as *const libc::c_char,
                    );
                }
            }
            if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
                sctp_print_address(sin6 as *mut sockaddr);
            }
            if !net.is_null() {
                sin6 = &mut (*net).ro._l_addr as *mut sctp_sockstore as *mut sockaddr_in6;
                /* preserve the port and scope for link local send */
                prev_scope = (*sin6).sin6_scope_id as libc::c_int;
                prev_port = (*sin6).sin6_port
            }
            o_pak = m;
            (*o_pak).M_dat.MH.MH_pkthdr.len = packet_length;
            if port != 0 {
                (*sctphdr).checksum = sctp_calculate_cksum(
                    m,
                    (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
                        .wrapping_add(::std::mem::size_of::<udphdr>() as libc::c_ulong)
                        as uint32_t,
                );
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctpstat.sctps_sendswcrc,
                    1u32,
                );
            } else if !(system_base_info.sctpsysctl.sctp_no_csum_on_loopback != 0
                && !stcb.is_null()
                && (*stcb).asoc.scope.loopback_scope as libc::c_int != 0)
            {
                (*sctphdr).checksum =
                    sctp_calculate_cksum(m, ::std::mem::size_of::<ip6_hdr>() as uint32_t);
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctpstat.sctps_sendswcrc,
                    1u32,
                );
            } else {
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctpstat.sctps_sendhwcrc,
                    1u32,
                );
            }
            /* send it out. table id is taken from stcb */
            sctp_userspace_ip6_output(
                &mut ret,
                o_pak,
                ro as *mut route_in6,
                stcb as *mut libc::c_void,
                vrf_id,
            );
            if !net.is_null() {
                /* for link local this must be done */
                (*sin6).sin6_scope_id = prev_scope as uint32_t;
                (*sin6).sin6_port = prev_port
            }
            if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"return from send is %d\n\x00" as *const u8 as *const libc::c_char,
                        ret,
                    );
                }
            }
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_sendpackets, 1u32);
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_outpackets, 1u32);
            if ret != 0 {
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctpstat.sctps_senderrors,
                    1u32,
                );
            }
            if net.is_null() {
                /* Now if we had a temp route free it */
                if !(*ro).ro_rt.is_null() {
                    if (*(*ro).ro_rt).rt_refcnt <= 1i64 {
                        sctp_userspace_rtfree((*ro).ro_rt);
                    } else {
                        (*(*ro).ro_rt).rt_refcnt -= 1
                    }
                    (*ro).ro_rt = 0 as *mut sctp_rtentry;
                    (*ro).ro_rt = 0 as *mut sctp_rtentry
                }
            } else {
                /* PMTU check versus smallest asoc MTU goes here */
                if (*ro).ro_rt.is_null() {
                    /* Route was freed */
                    if !(*net).ro._s_addr.is_null() && (*net).src_addr_selected as libc::c_int != 0
                    {
                        sctp_free_ifa((*net).ro._s_addr);
                        (*net).ro._s_addr = 0 as *mut sctp_ifa
                    }
                    (*net).src_addr_selected = 0u8
                }
                if !(*ro).ro_rt.is_null()
                    && !(*net).ro._s_addr.is_null()
                    && (*net).dest_state as libc::c_int & 0x2i32 == 0i32
                {
                    let mut mtu_0 = 0;
                    mtu_0 = if !(*ro).ro_rt.is_null() {
                        (*(*ro).ro_rt).rt_rmx.rmx_mtu
                    } else {
                        0u32
                    };
                    if mtu_0 > 0u32 {
                        if (*net).port != 0 {
                            mtu_0 =
                                (mtu_0 as libc::c_ulong)
                                    .wrapping_sub(::std::mem::size_of::<udphdr>() as libc::c_ulong)
                                    as uint32_t
                        }
                        if mtu_0 < (*net).mtu {
                            if !stcb.is_null() && (*stcb).asoc.smallest_mtu > mtu_0 {
                                sctp_mtu_size_reset(inp, &mut (*stcb).asoc, mtu_0);
                            }
                            (*net).mtu = mtu_0
                        }
                    }
                }
            }
            return ret;
        }
        123 => {
            let mut buffer = 0 as *mut libc::c_char;
            let mut sconn = 0 as *mut sockaddr_conn;
            let mut len_1 = 0;
            sconn = to as *mut sockaddr_conn;
            len_1 = ::std::mem::size_of::<sctphdr>() as libc::c_int;
            newm = sctp_get_mbuf_for_msg(len_1 as libc::c_uint, 1i32, 0x1i32, 1i32, 1i32);
            if newm.is_null() {
                m_freem(m);
                return 12i32;
            }
            if (*newm).m_hdr.mh_flags & 0x2i32 != 0 {
                (*newm).m_hdr.mh_data = (*newm).m_hdr.mh_data.offset(
                    ((((256u64).wrapping_sub(::std::mem::size_of::<m_hdr>() as libc::c_ulong)
                        as libc::c_int as libc::c_ulong)
                        .wrapping_sub(::std::mem::size_of::<pkthdr>() as libc::c_ulong)
                        as libc::c_int
                        - len_1) as libc::c_ulong
                        & !(::std::mem::size_of::<libc::c_long>() as libc::c_ulong)
                            .wrapping_sub(1u64)) as isize,
                )
            } else if (*newm).m_hdr.mh_flags & 0x1i32 == 0i32 {
                (*newm).m_hdr.mh_data = (*newm).m_hdr.mh_data.offset(
                    (((256u64).wrapping_sub(::std::mem::size_of::<m_hdr>() as libc::c_ulong)
                        as libc::c_int
                        - len_1) as libc::c_ulong
                        & !(::std::mem::size_of::<libc::c_long>() as libc::c_ulong)
                            .wrapping_sub(1u64)) as isize,
                )
            }
            (*newm).m_hdr.mh_len = len_1;
            (*newm).m_hdr.mh_next = m;
            m = newm;
            packet_length = sctp_calculate_len(m) as libc::c_int;
            sctphdr = (*m).m_hdr.mh_data as *mut sctphdr;
            (*sctphdr).src_port = src_port;
            (*sctphdr).dest_port = dest_port;
            (*sctphdr).v_tag = v_tag;
            (*sctphdr).checksum = 0u32;
            if system_base_info.crc32c_offloaded == 0i32 {
                (*sctphdr).checksum = sctp_calculate_cksum(m, 0u32);
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctpstat.sctps_sendswcrc,
                    1u32,
                );
            } else {
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctpstat.sctps_sendhwcrc,
                    1u32,
                );
            }
            if tos_value as libc::c_int == 0i32 {
                tos_value = (*inp).ip_inp.inp.inp_depend4.inp4_ip_tos
            }
            tos_value = (tos_value as libc::c_int & 0xfci32) as uint8_t;
            if ecn_ok != 0 {
                tos_value =
                    (tos_value as libc::c_int | sctp_get_ect(stcb) as libc::c_int) as uint8_t
            }
            /* Don't alloc/free for each packet */
            buffer = malloc(packet_length as libc::c_ulong) as *mut libc::c_char;
            if !buffer.is_null() {
                m_copydata(m, 0i32, packet_length, buffer);
                ret = system_base_info
                    .conn_output
                    .expect("non-null function pointer")(
                    (*sconn).sconn_addr,
                    buffer as *mut libc::c_void,
                    packet_length as size_t,
                    tos_value,
                    nofragment_flag as uint8_t,
                );
                free(buffer as *mut libc::c_void);
            } else {
                ret = 12i32
            }
            m_freem(m);
            return ret;
        }
        _ => {
            if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"Unknown protocol (TSNH) type %d\n\x00" as *const u8
                            as *const libc::c_char,
                        (*to).sa_family as libc::c_int,
                    );
                }
            }
            m_freem(m);
            return 14i32;
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn sctp_send_initiate(
    mut inp: *mut sctp_inpcb,
    mut stcb: *mut sctp_tcb,
    mut so_locked: libc::c_int,
) {
    let mut m = 0 as *mut mbuf;
    let mut m_last_0 = 0 as *mut mbuf;
    let mut net = 0 as *mut sctp_nets;
    let mut init = 0 as *mut sctp_init_chunk;
    let mut pr_supported = 0 as *mut sctp_supported_chunk_types_param;
    let mut ph = 0 as *mut sctp_paramhdr;
    let mut cnt_inits_to = 0i32;
    let mut error = 0;
    let mut num_ext = 0;
    let mut chunk_len = 0;
    let mut padding_len = 0;
    let mut parameter_len = 0;
    /* INIT's always go to the primary (and usually ONLY address) */
    net = (*stcb).asoc.primary_destination;
    if net.is_null() {
        net = (*stcb).asoc.nets.tqh_first;
        if net.is_null() {
            /* TSNH */
            return;
        }
        /* we confirm any address we send an INIT to */
        (*net).dest_state = ((*net).dest_state as libc::c_int & !(0x200i32)) as uint16_t;
        sctp_set_primary_addr(stcb, 0 as *mut sockaddr, net);
    } else {
        /* we confirm any address we send an INIT to */
        (*net).dest_state = ((*net).dest_state as libc::c_int & !(0x200i32)) as uint16_t
    }
    if system_base_info.sctpsysctl.sctp_debug_on & 0x80u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"Sending INIT\n\x00" as *const u8 as *const libc::c_char,
            );
        }
    }
    if (*net).ro._l_addr.sa.sa_family as libc::c_int == 10i32 {
        /*
         * special hook, if we are sending to link local it will not
         * show up in our private address count.
         */
        if ({
            let mut __a = &mut (*net).ro._l_addr.sin6.sin6_addr as *mut in6_addr as *const in6_addr;
            ((*__a).__in6_u.__u6_addr32[0usize] & htonl(0xffc00000u32) == htonl(0xfe800000u32))
                as libc::c_int
        }) != 0
        {
            cnt_inits_to = 1i32
        }
    }
    if (*net).rxt_timer.timer.c_flags & 0x4i32 != 0 {
        /* This case should not happen */
        if system_base_info.sctpsysctl.sctp_debug_on & 0x80u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"Sending INIT - failed timer?\n\x00" as *const u8 as *const libc::c_char,
                );
            }
        }
        return;
    }
    /* start the INIT timer */
    sctp_timer_start(2i32, inp, stcb, net);
    m = sctp_get_mbuf_for_msg(2048u32, 1i32, 0x1i32, 1i32, 1i32);
    if m.is_null() {
        /* No memory, INIT timer will re-attempt. */
        if system_base_info.sctpsysctl.sctp_debug_on & 0x80u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"Sending INIT - mbuf?\n\x00" as *const u8 as *const libc::c_char,
                );
            }
        }
        return;
    }
    chunk_len = ::std::mem::size_of::<sctp_init_chunk>() as uint16_t;
    padding_len = 0u16;
    /* Now lets put the chunk header in place */
    init = (*m).m_hdr.mh_data as *mut sctp_init_chunk;
    /* now the chunk header */
    (*init).ch.chunk_type = 0x1u8;
    (*init).ch.chunk_flags = 0u8;
    /* fill in later from mbuf we build */
    (*init).ch.chunk_length = 0u16;
    /* place in my tag */
    (*init).init.initiate_tag = htonl((*stcb).asoc.my_vtag);
    /* set up some of the credits. */
    (*init).init.a_rwnd = htonl(
        if (if !(*inp).sctp_socket.is_null() {
            (*(*inp).sctp_socket).so_rcv.sb_hiwat
        } else {
            0u32
        }) > 4096u32
        {
            if !(*inp).sctp_socket.is_null() {
                (*(*inp).sctp_socket).so_rcv.sb_hiwat
            } else {
                0u32
            }
        } else {
            4096u32
        },
    );
    (*init).init.num_outbound_streams = htons((*stcb).asoc.pre_open_streams as uint16_t);
    (*init).init.num_inbound_streams = htons((*stcb).asoc.max_inbound_streams as uint16_t);
    (*init).init.initial_tsn = htonl((*stcb).asoc.init_seq_number);
    /* Adaptation layer indication parameter */
    if (*inp).sctp_ep.adaptation_layer_indicator_provided != 0 {
        let mut ali = 0 as *mut sctp_adaptation_layer_indication;
        parameter_len = ::std::mem::size_of::<sctp_adaptation_layer_indication>() as uint16_t;
        ali = (*m).m_hdr.mh_data.offset(chunk_len as libc::c_int as isize)
            as *mut sctp_adaptation_layer_indication;
        (*ali).ph.param_type = htons(0xc006u16);
        (*ali).ph.param_length = htons(parameter_len);
        (*ali).indication = htonl((*inp).sctp_ep.adaptation_layer_indicator);
        chunk_len = (chunk_len as libc::c_int + parameter_len as libc::c_int) as uint16_t
    }
    /* ECN parameter */
    if (*stcb).asoc.ecn_supported as libc::c_int == 1i32 {
        parameter_len = ::std::mem::size_of::<sctp_paramhdr>() as uint16_t;
        ph = (*m).m_hdr.mh_data.offset(chunk_len as libc::c_int as isize) as *mut sctp_paramhdr;
        (*ph).param_type = htons(0x8000u16);
        (*ph).param_length = htons(parameter_len);
        chunk_len = (chunk_len as libc::c_int + parameter_len as libc::c_int) as uint16_t
    }
    /* PR-SCTP supported parameter */
    if (*stcb).asoc.prsctp_supported as libc::c_int == 1i32 {
        parameter_len = ::std::mem::size_of::<sctp_paramhdr>() as uint16_t;
        ph = (*m).m_hdr.mh_data.offset(chunk_len as libc::c_int as isize) as *mut sctp_paramhdr;
        (*ph).param_type = htons(0xc000u16);
        (*ph).param_length = htons(parameter_len);
        chunk_len = (chunk_len as libc::c_int + parameter_len as libc::c_int) as uint16_t
    }
    /* Add NAT friendly parameter. */
    if system_base_info.sctpsysctl.sctp_inits_include_nat_friendly != 0 {
        parameter_len = ::std::mem::size_of::<sctp_paramhdr>() as uint16_t;
        ph = (*m).m_hdr.mh_data.offset(chunk_len as libc::c_int as isize) as *mut sctp_paramhdr;
        (*ph).param_type = htons(0xc007u16);
        (*ph).param_length = htons(parameter_len);
        chunk_len = (chunk_len as libc::c_int + parameter_len as libc::c_int) as uint16_t
    }
    /* And now tell the peer which extensions we support */
    num_ext = 0u16;
    pr_supported = (*m).m_hdr.mh_data.offset(chunk_len as libc::c_int as isize)
        as *mut sctp_supported_chunk_types_param;
    if (*stcb).asoc.prsctp_supported as libc::c_int == 1i32 {
        let fresh3 = num_ext;
        num_ext = num_ext.wrapping_add(1);
        *(*pr_supported)
            .chunk_types
            .as_mut_ptr()
            .offset(fresh3 as isize) = 0xc0u8;
        if (*stcb).asoc.idata_supported != 0 {
            let fresh4 = num_ext;
            num_ext = num_ext.wrapping_add(1);
            *(*pr_supported)
                .chunk_types
                .as_mut_ptr()
                .offset(fresh4 as isize) = 0xc2u8
        }
    }
    if (*stcb).asoc.auth_supported as libc::c_int == 1i32 {
        let fresh5 = num_ext;
        num_ext = num_ext.wrapping_add(1);
        *(*pr_supported)
            .chunk_types
            .as_mut_ptr()
            .offset(fresh5 as isize) = 0xfu8
    }
    if (*stcb).asoc.asconf_supported as libc::c_int == 1i32 {
        let fresh6 = num_ext;
        num_ext = num_ext.wrapping_add(1);
        *(*pr_supported)
            .chunk_types
            .as_mut_ptr()
            .offset(fresh6 as isize) = 0xc1u8;
        let fresh7 = num_ext;
        num_ext = num_ext.wrapping_add(1);
        *(*pr_supported)
            .chunk_types
            .as_mut_ptr()
            .offset(fresh7 as isize) = 0x80u8
    }
    if (*stcb).asoc.reconfig_supported as libc::c_int == 1i32 {
        let fresh8 = num_ext;
        num_ext = num_ext.wrapping_add(1);
        *(*pr_supported)
            .chunk_types
            .as_mut_ptr()
            .offset(fresh8 as isize) = 0x82u8
    }
    if (*stcb).asoc.idata_supported != 0 {
        let fresh9 = num_ext;
        num_ext = num_ext.wrapping_add(1);
        *(*pr_supported)
            .chunk_types
            .as_mut_ptr()
            .offset(fresh9 as isize) = 0x40u8
    }
    if (*stcb).asoc.nrsack_supported as libc::c_int == 1i32 {
        let fresh10 = num_ext;
        num_ext = num_ext.wrapping_add(1);
        *(*pr_supported)
            .chunk_types
            .as_mut_ptr()
            .offset(fresh10 as isize) = 0x10u8
    }
    if (*stcb).asoc.pktdrop_supported as libc::c_int == 1i32 {
        let fresh11 = num_ext;
        num_ext = num_ext.wrapping_add(1);
        *(*pr_supported)
            .chunk_types
            .as_mut_ptr()
            .offset(fresh11 as isize) = 0x81u8
    }
    if num_ext as libc::c_int > 0i32 {
        parameter_len = (::std::mem::size_of::<sctp_supported_chunk_types_param>() as uint16_t
            as libc::c_int
            + num_ext as libc::c_int) as uint16_t;
        (*pr_supported).ph.param_type = htons(0x8008u16);
        (*pr_supported).ph.param_length = htons(parameter_len);
        padding_len = (((parameter_len as libc::c_int + 3i32 >> 2i32) << 2i32)
            - parameter_len as libc::c_int) as uint16_t;
        chunk_len = (chunk_len as libc::c_int + parameter_len as libc::c_int) as uint16_t
    }
    /* add authentication parameters */
    if (*stcb).asoc.auth_supported != 0 {
        /* attach RANDOM parameter, if available */
        if !(*stcb).asoc.authinfo.random.is_null() {
            let mut randp = 0 as *mut sctp_auth_random;
            if padding_len as libc::c_int > 0i32 {
                memset(
                    (*m).m_hdr.mh_data.offset(chunk_len as libc::c_int as isize)
                        as *mut libc::c_void,
                    0i32,
                    padding_len as libc::c_ulong,
                );
                chunk_len = (chunk_len as libc::c_int + padding_len as libc::c_int) as uint16_t;
                padding_len = 0u16
            }
            randp = (*m).m_hdr.mh_data.offset(chunk_len as libc::c_int as isize)
                as *mut sctp_auth_random;
            parameter_len = (::std::mem::size_of::<sctp_auth_random>() as uint16_t as libc::c_uint)
                .wrapping_add((*stcb).asoc.authinfo.random_len)
                as uint16_t;
            /* random key already contains the header */
            memcpy(
                randp as *mut libc::c_void,
                (*(*stcb).asoc.authinfo.random).key.as_mut_ptr() as *const libc::c_void,
                parameter_len as libc::c_ulong,
            );
            padding_len = (((parameter_len as libc::c_int + 3i32 >> 2i32) << 2i32)
                - parameter_len as libc::c_int) as uint16_t;
            chunk_len = (chunk_len as libc::c_int + parameter_len as libc::c_int) as uint16_t
        }
        /* add HMAC_ALGO parameter */
        if !(*stcb).asoc.local_hmacs.is_null() {
            let mut hmacs = 0 as *mut sctp_auth_hmac_algo;
            if padding_len as libc::c_int > 0i32 {
                memset(
                    (*m).m_hdr.mh_data.offset(chunk_len as libc::c_int as isize)
                        as *mut libc::c_void,
                    0i32,
                    padding_len as libc::c_ulong,
                );
                chunk_len = (chunk_len as libc::c_int + padding_len as libc::c_int) as uint16_t;
                padding_len = 0u16
            }
            hmacs = (*m).m_hdr.mh_data.offset(chunk_len as libc::c_int as isize)
                as *mut sctp_auth_hmac_algo;
            parameter_len = (::std::mem::size_of::<sctp_auth_hmac_algo>() as libc::c_ulong)
                .wrapping_add(
                    ((*(*stcb).asoc.local_hmacs).num_algo as libc::c_ulong)
                        .wrapping_mul(::std::mem::size_of::<uint16_t>() as libc::c_ulong),
                ) as uint16_t;
            (*hmacs).ph.param_type = htons(0x8004u16);
            (*hmacs).ph.param_length = htons(parameter_len);
            sctp_serialize_hmaclist(
                (*stcb).asoc.local_hmacs,
                (*hmacs).hmac_ids.as_mut_ptr() as *mut uint8_t,
            );
            padding_len = (((parameter_len as libc::c_int + 3i32 >> 2i32) << 2i32)
                - parameter_len as libc::c_int) as uint16_t;
            chunk_len = (chunk_len as libc::c_int + parameter_len as libc::c_int) as uint16_t
        }
        /* add CHUNKS parameter */
        if !(*stcb).asoc.local_auth_chunks.is_null() {
            let mut chunks = 0 as *mut sctp_auth_chunk_list;
            if padding_len as libc::c_int > 0i32 {
                memset(
                    (*m).m_hdr.mh_data.offset(chunk_len as libc::c_int as isize)
                        as *mut libc::c_void,
                    0i32,
                    padding_len as libc::c_ulong,
                );
                chunk_len = (chunk_len as libc::c_int + padding_len as libc::c_int) as uint16_t;
                padding_len = 0u16
            }
            chunks = (*m).m_hdr.mh_data.offset(chunk_len as libc::c_int as isize)
                as *mut sctp_auth_chunk_list;
            parameter_len = (::std::mem::size_of::<sctp_auth_chunk_list>() as libc::c_ulong)
                .wrapping_add(sctp_auth_get_chklist_size((*stcb).asoc.local_auth_chunks))
                as uint16_t;
            (*chunks).ph.param_type = htons(0x8003u16);
            (*chunks).ph.param_length = htons(parameter_len);
            sctp_serialize_auth_chunks(
                (*stcb).asoc.local_auth_chunks,
                (*chunks).chunk_types.as_mut_ptr(),
            );
            padding_len = (((parameter_len as libc::c_int + 3i32 >> 2i32) << 2i32)
                - parameter_len as libc::c_int) as uint16_t;
            chunk_len = (chunk_len as libc::c_int + parameter_len as libc::c_int) as uint16_t
        }
    }
    /* now any cookie time extensions */
    if (*stcb).asoc.cookie_preserve_req != 0 {
        let mut cookie_preserve = 0 as *mut sctp_cookie_perserve_param;
        if padding_len as libc::c_int > 0i32 {
            memset(
                (*m).m_hdr.mh_data.offset(chunk_len as libc::c_int as isize) as *mut libc::c_void,
                0i32,
                padding_len as libc::c_ulong,
            );
            chunk_len = (chunk_len as libc::c_int + padding_len as libc::c_int) as uint16_t;
            padding_len = 0u16
        }
        parameter_len = ::std::mem::size_of::<sctp_cookie_perserve_param>() as uint16_t;
        cookie_preserve = (*m).m_hdr.mh_data.offset(chunk_len as libc::c_int as isize)
            as *mut sctp_cookie_perserve_param;
        (*cookie_preserve).ph.param_type = htons(0x9u16);
        (*cookie_preserve).ph.param_length = htons(parameter_len);
        (*cookie_preserve).time = htonl((*stcb).asoc.cookie_preserve_req);
        (*stcb).asoc.cookie_preserve_req = 0u32;
        chunk_len = (chunk_len as libc::c_int + parameter_len as libc::c_int) as uint16_t
    }
    if (*stcb).asoc.scope.ipv4_addr_legal as libc::c_int != 0
        || (*stcb).asoc.scope.ipv6_addr_legal as libc::c_int != 0
    {
        let mut sup_addr = 0 as *mut sctp_supported_addr_param;
        let mut i = 0;
        if padding_len as libc::c_int > 0i32 {
            memset(
                (*m).m_hdr.mh_data.offset(chunk_len as libc::c_int as isize) as *mut libc::c_void,
                0i32,
                padding_len as libc::c_ulong,
            );
            chunk_len = (chunk_len as libc::c_int + padding_len as libc::c_int) as uint16_t;
            padding_len = 0u16
        }
        parameter_len = ::std::mem::size_of::<sctp_paramhdr>() as uint16_t;
        if (*stcb).asoc.scope.ipv4_addr_legal != 0 {
            parameter_len = (parameter_len as libc::c_int
                + ::std::mem::size_of::<uint16_t>() as uint16_t as libc::c_int)
                as uint16_t
        }
        if (*stcb).asoc.scope.ipv6_addr_legal != 0 {
            parameter_len = (parameter_len as libc::c_int
                + ::std::mem::size_of::<uint16_t>() as uint16_t as libc::c_int)
                as uint16_t
        }
        sup_addr = (*m).m_hdr.mh_data.offset(chunk_len as libc::c_int as isize)
            as *mut sctp_supported_addr_param;
        (*sup_addr).ph.param_type = htons(0xcu16);
        (*sup_addr).ph.param_length = htons(parameter_len);
        i = 0u8;
        if (*stcb).asoc.scope.ipv4_addr_legal != 0 {
            let fresh12 = i;
            i = i.wrapping_add(1);
            (*sup_addr).addr_type[fresh12 as usize] = htons(0x5u16)
        }
        if (*stcb).asoc.scope.ipv6_addr_legal != 0 {
            let fresh13 = i;
            i = i.wrapping_add(1);
            (*sup_addr).addr_type[fresh13 as usize] = htons(0x6u16)
        }
        padding_len = (4i32 - 2i32 * i as libc::c_int) as uint16_t;
        chunk_len = (chunk_len as libc::c_int + parameter_len as libc::c_int) as uint16_t
    }
    (*m).m_hdr.mh_len = chunk_len as libc::c_int;
    /* now the addresses */
    /* To optimize this we could put the scoping stuff
     * into a structure and remove the individual uint8's from
     * the assoc structure. Then we could just sifa in the
     * address within the stcb. But for now this is a quick
     * hack to get the address stuff teased apart.
     */
    m_last_0 = sctp_add_addresses_to_i_ia(
        inp,
        stcb,
        &mut (*stcb).asoc.scope,
        m,
        cnt_inits_to,
        &mut padding_len,
        &mut chunk_len,
    );
    (*init).ch.chunk_length = htons(chunk_len);
    if padding_len as libc::c_int > 0i32 {
        if sctp_add_pad_tombuf(m_last_0, padding_len as libc::c_int).is_null() {
            m_freem(m);
            return;
        }
    }
    if system_base_info.sctpsysctl.sctp_debug_on & 0x80u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"Sending INIT - calls lowlevel_output\n\x00" as *const u8 as *const libc::c_char,
            );
        }
    }
    error = sctp_lowlevel_chunk_output(
        inp,
        stcb,
        net,
        &mut (*net).ro._l_addr as *mut sctp_sockstore as *mut sockaddr,
        m,
        0u32,
        0 as *mut sctp_auth_chunk,
        0u16,
        0i32,
        0i32,
        0i32,
        (*inp).ip_inp.inp.inp_inc.inc_ie.ie_lport,
        (*stcb).rport,
        htonl(0u32),
        (*net).port,
        0 as *mut sctp_sockstore,
        so_locked,
    );
    if error != 0 {
        if system_base_info.sctpsysctl.sctp_debug_on & 0x80u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"Gak send error %d\n\x00" as *const u8 as *const libc::c_char,
                    error,
                );
            }
        }
        if error == 105i32 {
            (*stcb).asoc.ifp_had_enobuf = 1u8;
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_lowlevelerr, 1u32);
        }
    } else {
        (*stcb).asoc.ifp_had_enobuf = 0u8
    }
    ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_outcontrolchunks, 1u32);
    gettimeofday(&mut (*net).last_sent_time, 0 as *mut timezone);
}
#[no_mangle]
pub unsafe extern "C" fn sctp_arethere_unrecognized_parameters(
    mut in_initpkt: *mut mbuf,
    mut param_offset: libc::c_int,
    mut abort_processing: *mut libc::c_int,
    mut cp: *mut sctp_chunkhdr,
    mut nat_friendly: *mut libc::c_int,
    mut cookie_found: *mut libc::c_int,
) -> *mut mbuf {
    let mut current_block: u64;
    let mut phdr = 0 as *mut sctp_paramhdr;
    let mut params = sctp_paramhdr {
        param_type: 0,
        param_length: 0,
    };
    let mut mat = 0 as *mut mbuf;
    let mut op_err = 0 as *mut mbuf;
    let mut op_err_last = 0 as *mut mbuf;
    let mut at = 0;
    let mut limit = 0;
    let mut pad_needed = 0;
    let mut ptype = 0;
    let mut plen = 0;
    *abort_processing = 0i32;
    if !cookie_found.is_null() {
        *cookie_found = 0i32
    }
    mat = in_initpkt;
    limit = (ntohs((*cp).chunk_length) as libc::c_ulong)
        .wrapping_sub(::std::mem::size_of::<sctp_init_chunk>() as libc::c_ulong)
        as libc::c_int;
    at = param_offset;
    op_err = 0 as *mut mbuf;
    op_err_last = 0 as *mut mbuf;
    pad_needed = 0i32;
    if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"Check for unrecognized param\'s\n\x00" as *const u8 as *const libc::c_char,
            );
        }
    }
    phdr = sctp_get_next_param(
        mat,
        at,
        &mut params,
        ::std::mem::size_of::<sctp_paramhdr>() as libc::c_int,
    );
    loop {
        if !(!phdr.is_null()
            && limit as size_t >= ::std::mem::size_of::<sctp_paramhdr>() as libc::c_ulong)
        {
            current_block = 15726232576006602401;
            break;
        }
        ptype = ntohs((*phdr).param_type);
        plen = ntohs((*phdr).param_length);
        if plen as libc::c_int > limit
            || (plen as libc::c_ulong) < ::std::mem::size_of::<sctp_paramhdr>() as libc::c_ulong
        {
            /* wacked parameter */
            if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"Invalid size - error %d\n\x00" as *const u8 as *const libc::c_char,
                        plen as libc::c_int,
                    );
                }
            }
            current_block = 12176675997236991492;
            break;
        } else {
            let mut padded_size = 0;
            limit -= (plen as libc::c_int + 3i32 >> 2i32) << 2i32;
            /*-
             * All parameters for all chunks that we know/understand are
             * listed here. We process them other places and make
             * appropriate stop actions per the upper bits. However this
             * is the generic routine processor's can call to get back
             * an operr.. to either incorporate (init-ack) or send.
             */
            padded_size = ((plen as libc::c_int + 3i32 >> 2i32) << 2i32) as uint16_t;
            match ptype as libc::c_int {
                1 | 8 | 49155 => {
                    /* Param's with variable size */
                    /* ok skip fwd */
                    at += padded_size as libc::c_int;
                    current_block = 2443473429557993763;
                }
                7 => {
                    if !cookie_found.is_null() {
                        *cookie_found = 1i32
                    }
                    at += padded_size as libc::c_int;
                    current_block = 2443473429557993763;
                }
                32771 | 32776 => {
                    /* Param's with variable size within a range */
                    if padded_size as libc::c_ulong
                        > (::std::mem::size_of::<sctp_supported_chunk_types_param>()
                            as libc::c_ulong)
                            .wrapping_add(
                                (::std::mem::size_of::<uint8_t>() as libc::c_ulong)
                                    .wrapping_mul(256u64),
                            )
                    {
                        if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
                            if system_base_info.debug_printf.is_some() {
                                system_base_info
                                    .debug_printf
                                    .expect("non-null function pointer")(
                                    b"Invalid size - error chklist %d\n\x00" as *const u8
                                        as *const libc::c_char,
                                    plen as libc::c_int,
                                );
                            }
                        }
                        current_block = 12176675997236991492;
                        break;
                    } else {
                        at += padded_size as libc::c_int
                    }
                    current_block = 2443473429557993763;
                }
                12 => {
                    if padded_size as libc::c_int > 12i32 {
                        if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
                            if system_base_info.debug_printf.is_some() {
                                system_base_info
                                    .debug_printf
                                    .expect("non-null function pointer")(
                                    b"Invalid size - error supaddrtype %d\n\x00" as *const u8
                                        as *const libc::c_char,
                                    plen as libc::c_int,
                                );
                            }
                        }
                        current_block = 12176675997236991492;
                        break;
                    } else {
                        at += padded_size as libc::c_int
                    }
                    current_block = 2443473429557993763;
                }
                32770 => {
                    if padded_size as libc::c_ulong
                        > (::std::mem::size_of::<sctp_auth_random>() as libc::c_ulong)
                            .wrapping_add(256u64)
                    {
                        if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
                            if system_base_info.debug_printf.is_some() {
                                system_base_info
                                    .debug_printf
                                    .expect("non-null function pointer")(
                                    b"Invalid size - error random %d\n\x00" as *const u8
                                        as *const libc::c_char,
                                    plen as libc::c_int,
                                );
                            }
                        }
                        current_block = 12176675997236991492;
                        break;
                    } else {
                        at += padded_size as libc::c_int
                    }
                    current_block = 2443473429557993763;
                }
                49156 | 49154 | 49153 => {
                    if padded_size as libc::c_ulong
                        != ::std::mem::size_of::<sctp_asconf_addrv4_param>() as libc::c_ulong
                        && padded_size as libc::c_ulong
                            != ::std::mem::size_of::<sctp_asconf_addr_param>() as libc::c_ulong
                    {
                        if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
                            if system_base_info.debug_printf.is_some() {
                                system_base_info
                                    .debug_printf
                                    .expect("non-null function pointer")(
                                    b"Invalid size - error setprim %d\n\x00" as *const u8
                                        as *const libc::c_char,
                                    plen as libc::c_int,
                                );
                            }
                        }
                        current_block = 12176675997236991492;
                        break;
                    } else {
                        at += padded_size as libc::c_int
                    }
                    current_block = 2443473429557993763;
                }
                5 => {
                    /* Param's with a fixed size */
                    if padded_size as libc::c_ulong
                        != ::std::mem::size_of::<sctp_ipv4addr_param>() as libc::c_ulong
                    {
                        if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
                            if system_base_info.debug_printf.is_some() {
                                system_base_info
                                    .debug_printf
                                    .expect("non-null function pointer")(
                                    b"Invalid size - error ipv4 addr %d\n\x00" as *const u8
                                        as *const libc::c_char,
                                    plen as libc::c_int,
                                );
                            }
                        }
                        current_block = 12176675997236991492;
                        break;
                    } else {
                        at += padded_size as libc::c_int
                    }
                    current_block = 2443473429557993763;
                }
                6 => {
                    if padded_size as libc::c_ulong
                        != ::std::mem::size_of::<sctp_ipv6addr_param>() as libc::c_ulong
                    {
                        if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
                            if system_base_info.debug_printf.is_some() {
                                system_base_info
                                    .debug_printf
                                    .expect("non-null function pointer")(
                                    b"Invalid size - error ipv6 addr %d\n\x00" as *const u8
                                        as *const libc::c_char,
                                    plen as libc::c_int,
                                );
                            }
                        }
                        current_block = 12176675997236991492;
                        break;
                    } else {
                        at += padded_size as libc::c_int
                    }
                    current_block = 2443473429557993763;
                }
                9 => {
                    if padded_size as libc::c_ulong
                        != ::std::mem::size_of::<sctp_cookie_perserve_param>() as libc::c_ulong
                    {
                        if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
                            if system_base_info.debug_printf.is_some() {
                                system_base_info
                                    .debug_printf
                                    .expect("non-null function pointer")(
                                    b"Invalid size - error cookie-preserve %d\n\x00" as *const u8
                                        as *const libc::c_char,
                                    plen as libc::c_int,
                                );
                            }
                        }
                        current_block = 12176675997236991492;
                        break;
                    } else {
                        at += padded_size as libc::c_int
                    }
                    current_block = 2443473429557993763;
                }
                49159 => {
                    *nat_friendly = 1i32;
                    current_block = 3440004290206690702;
                }
                49152 => {
                    current_block = 3440004290206690702;
                }
                32768 => {
                    if padded_size as libc::c_ulong
                        != ::std::mem::size_of::<sctp_paramhdr>() as libc::c_ulong
                    {
                        if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
                            if system_base_info.debug_printf.is_some() {
                                system_base_info
                                    .debug_printf
                                    .expect("non-null function pointer")(
                                    b"Invalid size - error ecn %d\n\x00" as *const u8
                                        as *const libc::c_char,
                                    plen as libc::c_int,
                                );
                            }
                        }
                        current_block = 12176675997236991492;
                        break;
                    } else {
                        at += padded_size as libc::c_int
                    }
                    current_block = 2443473429557993763;
                }
                49158 => {
                    if padded_size as libc::c_ulong
                        != ::std::mem::size_of::<sctp_adaptation_layer_indication>()
                            as libc::c_ulong
                    {
                        if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
                            if system_base_info.debug_printf.is_some() {
                                system_base_info
                                    .debug_printf
                                    .expect("non-null function pointer")(
                                    b"Invalid size - error adapatation %d\n\x00" as *const u8
                                        as *const libc::c_char,
                                    plen as libc::c_int,
                                );
                            }
                        }
                        current_block = 12176675997236991492;
                        break;
                    } else {
                        at += padded_size as libc::c_int
                    }
                    current_block = 2443473429557993763;
                }
                49157 => {
                    if padded_size as libc::c_ulong
                        != ::std::mem::size_of::<sctp_asconf_paramhdr>() as libc::c_ulong
                    {
                        if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
                            if system_base_info.debug_printf.is_some() {
                                system_base_info
                                    .debug_printf
                                    .expect("non-null function pointer")(
                                    b"Invalid size - error success %d\n\x00" as *const u8
                                        as *const libc::c_char,
                                    plen as libc::c_int,
                                );
                            }
                        }
                        current_block = 12176675997236991492;
                        break;
                    } else {
                        at += padded_size as libc::c_int
                    }
                    current_block = 2443473429557993763;
                }
                11 => {
                    let mut l_len = 0;
                    if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
                        if system_base_info.debug_printf.is_some() {
                            system_base_info
                                .debug_printf
                                .expect("non-null function pointer")(
                                b"Can\'t handle hostname addresses.. abort processing\n\x00"
                                    as *const u8
                                    as *const libc::c_char,
                            );
                        }
                    }
                    *abort_processing = 1i32;
                    m_freem(op_err);
                    op_err = 0 as *mut mbuf;
                    op_err_last = 0 as *mut mbuf;
                    l_len = (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
                        .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong)
                        as libc::c_int;
                    l_len = (l_len as libc::c_ulong)
                        .wrapping_add(::std::mem::size_of::<sctp_chunkhdr>() as libc::c_ulong)
                        as libc::c_int;
                    l_len =
                        (l_len as libc::c_ulong)
                            .wrapping_add(
                                ::std::mem::size_of::<sctp_gen_error_cause>() as libc::c_ulong
                            ) as libc::c_int;
                    op_err = sctp_get_mbuf_for_msg(l_len as libc::c_uint, 0i32, 0x1i32, 1i32, 1i32);
                    if !op_err.is_null() {
                        let mut cause = 0 as *mut sctp_gen_error_cause;
                        (*op_err).m_hdr.mh_data = (*op_err)
                            .m_hdr
                            .mh_data
                            .offset(::std::mem::size_of::<ip6_hdr>() as isize);
                        (*op_err).m_hdr.mh_data = (*op_err)
                            .m_hdr
                            .mh_data
                            .offset(::std::mem::size_of::<sctphdr>() as isize);
                        (*op_err).m_hdr.mh_data = (*op_err)
                            .m_hdr
                            .mh_data
                            .offset(::std::mem::size_of::<sctp_chunkhdr>() as isize);
                        (*op_err).m_hdr.mh_len =
                            ::std::mem::size_of::<sctp_gen_error_cause>() as libc::c_int;
                        cause = (*op_err).m_hdr.mh_data as *mut sctp_gen_error_cause;
                        (*cause).code = htons(0x5u16);
                        (*cause).length = htons(
                            (::std::mem::size_of::<sctp_gen_error_cause>() as libc::c_ulong)
                                .wrapping_add(plen as libc::c_ulong)
                                as uint16_t,
                        );
                        (*op_err).m_hdr.mh_next = m_copym(mat, at, plen as libc::c_int, 0x1i32);
                        if (*op_err).m_hdr.mh_next.is_null() {
                            m_freem(op_err);
                            op_err = 0 as *mut mbuf;
                            op_err_last = 0 as *mut mbuf
                        }
                    }
                    return op_err;
                }
                _ => {
                    /*
                     * we do not recognize the parameter figure out what
                     * we do.
                     */
                    if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
                        if system_base_info.debug_printf.is_some() {
                            system_base_info
                                .debug_printf
                                .expect("non-null function pointer")(
                                b"Hit default param %x\n\x00" as *const u8 as *const libc::c_char,
                                ptype as libc::c_int,
                            );
                        }
                    }
                    if ptype as libc::c_int & 0x4000i32 == 0x4000i32 {
                        /* Report bit is set?? */
                        if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
                            if system_base_info.debug_printf.is_some() {
                                system_base_info
                                    .debug_printf
                                    .expect("non-null function pointer")(
                                    b"report op err\n\x00" as *const u8 as *const libc::c_char,
                                );
                            }
                        }
                        if op_err.is_null() {
                            let mut l_len_0 = 0;
                            /* Ok need to try to get an mbuf */
                            l_len_0 = (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
                                .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong)
                                as libc::c_int;
                            l_len_0 =
                                (l_len_0 as libc::c_ulong).wrapping_add(::std::mem::size_of::<
                                    sctp_chunkhdr,
                                >(
                                )
                                    as libc::c_ulong)
                                    as libc::c_int;
                            l_len_0 =
                                (l_len_0 as libc::c_ulong).wrapping_add(::std::mem::size_of::<
                                    sctp_paramhdr,
                                >(
                                )
                                    as libc::c_ulong)
                                    as libc::c_int;
                            op_err = sctp_get_mbuf_for_msg(
                                l_len_0 as libc::c_uint,
                                0i32,
                                0x1i32,
                                1i32,
                                1i32,
                            );
                            if !op_err.is_null() {
                                (*op_err).m_hdr.mh_len = 0i32;
                                (*op_err).m_hdr.mh_data = (*op_err)
                                    .m_hdr
                                    .mh_data
                                    .offset(::std::mem::size_of::<ip6_hdr>() as isize);
                                (*op_err).m_hdr.mh_data = (*op_err)
                                    .m_hdr
                                    .mh_data
                                    .offset(::std::mem::size_of::<sctphdr>() as isize);
                                (*op_err).m_hdr.mh_data = (*op_err)
                                    .m_hdr
                                    .mh_data
                                    .offset(::std::mem::size_of::<sctp_chunkhdr>() as isize);
                                op_err_last = op_err
                            }
                        }
                        if !op_err.is_null() {
                            if pad_needed > 0i32 {
                                op_err_last = sctp_add_pad_tombuf(op_err_last, pad_needed)
                            }
                            if op_err_last.is_null() {
                                m_freem(op_err);
                                op_err = 0 as *mut mbuf;
                                op_err_last = 0 as *mut mbuf
                            } else {
                                if (if (*op_err_last).m_hdr.mh_flags & 0x1i32 != 0 {
                                    (if (*op_err_last).m_hdr.mh_flags & 0x8i32 == 0
                                        && ((*op_err_last).m_hdr.mh_flags & 0x1i32 == 0
                                            || *(*op_err_last).M_dat.MH.MH_dat.MH_ext.ref_cnt
                                                == 1u32)
                                    {
                                        (*op_err_last)
                                            .M_dat
                                            .MH
                                            .MH_dat
                                            .MH_ext
                                            .ext_buf
                                            .offset(
                                                (*op_err_last).M_dat.MH.MH_dat.MH_ext.ext_size
                                                    as isize,
                                            )
                                            .wrapping_offset_from(
                                                (*op_err_last)
                                                    .m_hdr
                                                    .mh_data
                                                    .offset((*op_err_last).m_hdr.mh_len as isize),
                                            )
                                            as libc::c_long
                                    } else {
                                        0i64
                                    })
                                } else {
                                    (&mut *(*op_err_last).M_dat.M_databuf.as_mut_ptr().offset(
                                        (256u64).wrapping_sub(
                                            ::std::mem::size_of::<m_hdr>() as libc::c_ulong
                                        ) as libc::c_int
                                            as isize,
                                    ) as *mut libc::c_char)
                                        .wrapping_offset_from(
                                            (*op_err_last)
                                                .m_hdr
                                                .mh_data
                                                .offset((*op_err_last).m_hdr.mh_len as isize),
                                        ) as libc::c_long
                                }) < ::std::mem::size_of::<sctp_paramhdr>() as libc::c_int
                                    as libc::c_long
                                {
                                    let mut m_tmp = 0 as *mut mbuf;
                                    m_tmp = sctp_get_mbuf_for_msg(
                                        ::std::mem::size_of::<sctp_paramhdr>() as libc::c_uint,
                                        0i32,
                                        0x1i32,
                                        1i32,
                                        1i32,
                                    );
                                    if m_tmp.is_null() {
                                        m_freem(op_err);
                                        op_err = 0 as *mut mbuf;
                                        op_err_last = 0 as *mut mbuf;
                                        current_block = 12970284654173519821;
                                    } else {
                                        (*m_tmp).m_hdr.mh_len = 0i32;
                                        (*m_tmp).m_hdr.mh_next = 0 as *mut mbuf;
                                        (*op_err_last).m_hdr.mh_next = m_tmp;
                                        op_err_last = m_tmp;
                                        current_block = 6852123435203331032;
                                    }
                                } else {
                                    current_block = 6852123435203331032;
                                }
                                match current_block {
                                    12970284654173519821 => {}
                                    _ => {
                                        let mut param = 0 as *mut sctp_paramhdr;
                                        param = (*op_err_last)
                                            .m_hdr
                                            .mh_data
                                            .offset((*op_err_last).m_hdr.mh_len as isize)
                                            as *mut sctp_paramhdr;
                                        (*param).param_type = htons(0x8u16);
                                        (*param).param_length = htons(
                                            (::std::mem::size_of::<sctp_paramhdr>() as uint16_t
                                                as libc::c_int
                                                + plen as libc::c_int)
                                                as uint16_t,
                                        );
                                        (*op_err_last).m_hdr.mh_len = ((*op_err_last).m_hdr.mh_len
                                            as libc::c_ulong)
                                            .wrapping_add(::std::mem::size_of::<sctp_paramhdr>()
                                                as libc::c_ulong)
                                            as libc::c_int;
                                        (*op_err_last).m_hdr.mh_next =
                                            m_copym(mat, at, plen as libc::c_int, 0x1i32);
                                        if (*op_err_last).m_hdr.mh_next.is_null() {
                                            m_freem(op_err);
                                            op_err = 0 as *mut mbuf;
                                            op_err_last = 0 as *mut mbuf
                                        } else {
                                            while !(*op_err_last).m_hdr.mh_next.is_null() {
                                                op_err_last = (*op_err_last).m_hdr.mh_next
                                            }
                                            if plen as libc::c_int % 4i32 != 0i32 {
                                                pad_needed = 4i32 - plen as libc::c_int % 4i32
                                            } else {
                                                pad_needed = 0i32
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if ptype as libc::c_int & 0x8000i32 == 0i32 {
                        if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
                            if system_base_info.debug_printf.is_some() {
                                system_base_info
                                    .debug_printf
                                    .expect("non-null function pointer")(
                                    b"stop proc\n\x00" as *const u8 as *const libc::c_char,
                                );
                            }
                        }
                        return op_err;
                    } else {
                        /* skip this chunk and continue processing */
                        if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
                            if system_base_info.debug_printf.is_some() {
                                system_base_info
                                    .debug_printf
                                    .expect("non-null function pointer")(
                                    b"move on\n\x00" as *const u8 as *const libc::c_char,
                                );
                            }
                        }
                        at += (plen as libc::c_int + 3i32 >> 2i32) << 2i32
                    }
                    current_block = 2443473429557993763;
                }
            }
            match current_block {
                3440004290206690702 =>
                /* fall through */
                {
                    if padded_size as libc::c_ulong
                        != ::std::mem::size_of::<sctp_paramhdr>() as libc::c_ulong
                    {
                        if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
                            if system_base_info.debug_printf.is_some() {
                                system_base_info
                                    .debug_printf
                                    .expect("non-null function pointer")(
                                    b"Invalid size - error prsctp/nat support %d\n\x00" as *const u8
                                        as *const libc::c_char,
                                    plen as libc::c_int,
                                );
                            }
                        }
                        current_block = 12176675997236991492;
                        break;
                    } else {
                        at += padded_size as libc::c_int
                    }
                }
                _ => {}
            }
            phdr = sctp_get_next_param(
                mat,
                at,
                &mut params,
                ::std::mem::size_of::<sctp_paramhdr>() as libc::c_int,
            )
        }
    }
    match current_block {
        15726232576006602401 => return op_err,
        _ => {
            if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"abort flag set\n\x00" as *const u8 as *const libc::c_char,
                    );
                }
            }
            *abort_processing = 1i32;
            m_freem(op_err);
            op_err = 0 as *mut mbuf;
            op_err_last = 0 as *mut mbuf;
            if !phdr.is_null() {
                let mut l_len_1 = 0;
                l_len_1 = (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
                    .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong)
                    as libc::c_int;
                l_len_1 = (l_len_1 as libc::c_ulong)
                    .wrapping_add(::std::mem::size_of::<sctp_chunkhdr>() as libc::c_ulong)
                    as libc::c_int;
                l_len_1 = (l_len_1 as libc::c_ulong).wrapping_add(
                    (2u64).wrapping_mul(::std::mem::size_of::<sctp_paramhdr>() as libc::c_ulong),
                ) as libc::c_int;
                op_err = sctp_get_mbuf_for_msg(l_len_1 as libc::c_uint, 0i32, 0x1i32, 1i32, 1i32);
                if !op_err.is_null() {
                    let mut param_0 = 0 as *mut sctp_paramhdr;
                    (*op_err).m_hdr.mh_len = 0i32;
                    (*op_err).m_hdr.mh_data = (*op_err)
                        .m_hdr
                        .mh_data
                        .offset(::std::mem::size_of::<ip6_hdr>() as isize);
                    (*op_err).m_hdr.mh_data = (*op_err)
                        .m_hdr
                        .mh_data
                        .offset(::std::mem::size_of::<sctphdr>() as isize);
                    (*op_err).m_hdr.mh_data = (*op_err)
                        .m_hdr
                        .mh_data
                        .offset(::std::mem::size_of::<sctp_chunkhdr>() as isize);
                    (*op_err).m_hdr.mh_len = (2u64)
                        .wrapping_mul(::std::mem::size_of::<sctp_paramhdr>() as libc::c_ulong)
                        as libc::c_int;
                    param_0 = (*op_err).m_hdr.mh_data as *mut sctp_paramhdr;
                    (*param_0).param_type = htons(0xdu16);
                    (*param_0).param_length = htons(
                        (2u64).wrapping_mul(::std::mem::size_of::<sctp_paramhdr>() as libc::c_ulong)
                            as uint16_t,
                    );
                    param_0 = param_0.offset(1);
                    (*param_0).param_type = htons(ptype);
                    (*param_0).param_length = htons(plen)
                }
            }
            return op_err;
        }
    };
}
unsafe extern "C" fn sctp_are_there_new_addresses(
    mut asoc: *mut sctp_association,
    mut in_initpkt: *mut mbuf,
    mut offset: libc::c_int,
    mut src: *mut sockaddr,
) -> libc::c_int {
    let mut sa = 0 as *mut sockaddr;
    let mut phdr = 0 as *mut sctp_paramhdr;
    let mut params = sctp_paramhdr {
        param_type: 0,
        param_length: 0,
    };
    let mut fnd = 0;
    let mut net = 0 as *mut sctp_nets;
    let mut check_src = 0;
    let mut sin4 = sockaddr_in {
        sin_family: 0,
        sin_port: 0,
        sin_addr: in_addr { s_addr: 0 },
        sin_zero: [0; 8],
    };
    let mut sa4 = 0 as *mut sockaddr_in;
    let mut sin6 = sockaddr_in6 {
        sin6_family: 0,
        sin6_port: 0,
        sin6_flowinfo: 0,
        sin6_addr: in6_addr {
            __in6_u: C2RustUnnamed_387 {
                __u6_addr8: [0; 16],
            },
        },
        sin6_scope_id: 0,
    };
    let mut sa6 = 0 as *mut sockaddr_in6;
    memset(
        &mut sin4 as *mut sockaddr_in as *mut libc::c_void,
        0i32,
        ::std::mem::size_of::<sockaddr_in>() as libc::c_ulong,
    );
    sin4.sin_family = 2u16;
    memset(
        &mut sin6 as *mut sockaddr_in6 as *mut libc::c_void,
        0i32,
        ::std::mem::size_of::<sockaddr_in6>() as libc::c_ulong,
    );
    sin6.sin6_family = 10u16;
    /* First what about the src address of the pkt ? */
    check_src = 0i32;
    match (*src).sa_family as libc::c_int {
        2 => {
            if (*asoc).scope.ipv4_addr_legal != 0 {
                check_src = 1i32
            }
        }
        10 => {
            if (*asoc).scope.ipv6_addr_legal != 0 {
                check_src = 1i32
            }
        }
        123 => {
            if (*asoc).scope.conn_addr_legal != 0 {
                check_src = 1i32
            }
        }
        _ => {}
    }
    if check_src != 0 {
        fnd = 0u8;
        net = (*asoc).nets.tqh_first;
        while !net.is_null() {
            sa = &mut (*net).ro._l_addr as *mut sctp_sockstore as *mut sockaddr;
            if (*sa).sa_family as libc::c_int == (*src).sa_family as libc::c_int {
                if (*sa).sa_family as libc::c_int == 2i32 {
                    let mut src4 = 0 as *mut sockaddr_in;
                    sa4 = sa as *mut sockaddr_in;
                    src4 = src as *mut sockaddr_in;
                    if (*sa4).sin_addr.s_addr == (*src4).sin_addr.s_addr {
                        fnd = 1u8;
                        break;
                    }
                }
                if (*sa).sa_family as libc::c_int == 10i32 {
                    let mut src6 = 0 as *mut sockaddr_in6;
                    sa6 = sa as *mut sockaddr_in6;
                    src6 = src as *mut sockaddr_in6;
                    if SCTP6_ARE_ADDR_EQUAL(sa6, src6) != 0 {
                        fnd = 1u8;
                        break;
                    }
                }
                if (*sa).sa_family as libc::c_int == 123i32 {
                    let mut sac = 0 as *mut sockaddr_conn;
                    let mut srcc = 0 as *mut sockaddr_conn;
                    sac = sa as *mut sockaddr_conn;
                    srcc = src as *mut sockaddr_conn;
                    if (*sac).sconn_addr == (*srcc).sconn_addr {
                        fnd = 1u8;
                        break;
                    }
                }
            }
            net = (*net).sctp_next.tqe_next
        }
        if fnd as libc::c_int == 0i32 {
            /* New address added! no need to look further. */
            return 1i32;
        }
    }
    /* Ok so far lets munge through the rest of the packet */
    offset = (offset as libc::c_ulong)
        .wrapping_add(::std::mem::size_of::<sctp_init_chunk>() as libc::c_ulong)
        as libc::c_int;
    phdr = sctp_get_next_param(
        in_initpkt,
        offset,
        &mut params,
        ::std::mem::size_of::<sctp_paramhdr>() as libc::c_int,
    );
    while !phdr.is_null() {
        let mut sa_touse = 0 as *mut sockaddr;
        let mut ptype = 0;
        let mut plen = 0;
        sa_touse = 0 as *mut sockaddr;
        ptype = ntohs((*phdr).param_type);
        plen = ntohs((*phdr).param_length);
        match ptype as libc::c_int {
            5 => {
                let mut p4_buf = sctp_ipv4addr_param {
                    ph: sctp_paramhdr {
                        param_type: 0,
                        param_length: 0,
                    },
                    addr: 0,
                };
                if plen as libc::c_ulong
                    != ::std::mem::size_of::<sctp_ipv4addr_param>() as libc::c_ulong
                {
                    return 1i32;
                }
                phdr = sctp_get_next_param(
                    in_initpkt,
                    offset,
                    &mut p4_buf as *mut sctp_ipv4addr_param as *mut sctp_paramhdr,
                    ::std::mem::size_of::<sctp_ipv4addr_param>() as libc::c_int,
                );
                if phdr.is_null() {
                    return 1i32;
                }
                if (*asoc).scope.ipv4_addr_legal != 0 {
                    let mut p4 = 0 as *mut sctp_ipv4addr_param;
                    p4 = phdr as *mut sctp_ipv4addr_param;
                    sin4.sin_addr.s_addr = (*p4).addr;
                    sa_touse = &mut sin4 as *mut sockaddr_in as *mut sockaddr
                }
            }
            6 => {
                let mut p6_buf = sctp_ipv6addr_param {
                    ph: sctp_paramhdr {
                        param_type: 0,
                        param_length: 0,
                    },
                    addr: [0; 16],
                };
                if plen as libc::c_ulong
                    != ::std::mem::size_of::<sctp_ipv6addr_param>() as libc::c_ulong
                {
                    return 1i32;
                }
                phdr = sctp_get_next_param(
                    in_initpkt,
                    offset,
                    &mut p6_buf as *mut sctp_ipv6addr_param as *mut sctp_paramhdr,
                    ::std::mem::size_of::<sctp_ipv6addr_param>() as libc::c_int,
                );
                if phdr.is_null() {
                    return 1i32;
                }
                if (*asoc).scope.ipv6_addr_legal != 0 {
                    let mut p6 = 0 as *mut sctp_ipv6addr_param;
                    p6 = phdr as *mut sctp_ipv6addr_param;
                    memcpy(
                        &mut sin6.sin6_addr as *mut in6_addr as *mut libc::c_void,
                        (*p6).addr.as_mut_ptr() as *const libc::c_void,
                        ::std::mem::size_of::<[uint8_t; 16]>() as libc::c_ulong,
                    );
                    sa_touse = &mut sin6 as *mut sockaddr_in6 as *mut sockaddr
                }
            }
            _ => sa_touse = 0 as *mut sockaddr,
        }
        if !sa_touse.is_null() {
            /* ok, sa_touse points to one to check */
            fnd = 0u8;
            net = (*asoc).nets.tqh_first;
            while !net.is_null() {
                sa = &mut (*net).ro._l_addr as *mut sctp_sockstore as *mut sockaddr;
                if !((*sa).sa_family as libc::c_int != (*sa_touse).sa_family as libc::c_int) {
                    if (*sa).sa_family as libc::c_int == 2i32 {
                        sa4 = sa as *mut sockaddr_in;
                        if (*sa4).sin_addr.s_addr == sin4.sin_addr.s_addr {
                            fnd = 1u8;
                            break;
                        }
                    }
                    if (*sa).sa_family as libc::c_int == 10i32 {
                        sa6 = sa as *mut sockaddr_in6;
                        if SCTP6_ARE_ADDR_EQUAL(sa6, &mut sin6) != 0 {
                            fnd = 1u8;
                            break;
                        }
                    }
                }
                net = (*net).sctp_next.tqe_next
            }
            if fnd == 0 {
                /* New addr added! no need to look further */
                return 1i32;
            }
        }
        offset += (plen as libc::c_int + 3i32 >> 2i32) << 2i32;
        phdr = sctp_get_next_param(
            in_initpkt,
            offset,
            &mut params,
            ::std::mem::size_of::<sctp_paramhdr>() as libc::c_int,
        )
    }
    return 0i32;
}
/*
 * Given a MBUF chain that was sent into us containing an INIT. Build a
 * INIT-ACK with COOKIE and send back. We assume that the in_initpkt has done
 * a pullup to include IPv6/4header, SCTP header and initial part of INIT
 * message (i.e. the struct sctp_init_msg).
 */
#[no_mangle]
pub unsafe extern "C" fn sctp_send_initiate_ack(
    mut inp: *mut sctp_inpcb,
    mut stcb: *mut sctp_tcb,
    mut src_net: *mut sctp_nets,
    mut init_pkt: *mut mbuf,
    mut iphlen: libc::c_int,
    mut offset: libc::c_int,
    mut src: *mut sockaddr,
    mut dst: *mut sockaddr,
    mut sh: *mut sctphdr,
    mut init_chk: *mut sctp_init_chunk,
    mut vrf_id: uint32_t,
    mut port: uint16_t,
) {
    let mut asoc = 0 as *mut sctp_association;
    let mut op_err = 0 as *mut mbuf;
    let mut abort_flag = 0;
    let mut nat_friendly = 0i32;
    let mut dst4 = dst as *mut sockaddr_in;
    let mut src4 = src as *mut sockaddr_in;
    let mut dst6 = dst as *mut sockaddr_in6;
    let mut src6 = src as *mut sockaddr_in6;
    let mut dstconn = dst as *mut sockaddr_conn;
    let mut srcconn = src as *mut sockaddr_conn;

    if !stcb.is_null() {
        asoc = &mut (*stcb).asoc
    } else {
        asoc = 0 as *mut sctp_association
    }
    if !asoc.is_null() && (*stcb).asoc.state & 0x7fi32 != 0x2i32 {
        if sctp_are_there_new_addresses(asoc, init_pkt, offset, src) != 0 {
            /*
             * new addresses, out of here in non-cookie-wait states
             *
             * Send an ABORT, without the new address error cause.
             * This looks no different than if no listener
             * was present.
             */
            op_err = sctp_generate_cause(
                system_base_info.sctpsysctl.sctp_diag_info_code as uint16_t,
                b"Address added\x00" as *const u8 as *mut libc::c_char,
            );
            sctp_send_abort(init_pkt, iphlen, src, dst, sh, 0u32, op_err, vrf_id, port);
            return;
        }
        if !src_net.is_null() && (*src_net).port as libc::c_int != port as libc::c_int {
            /*
             * change of remote encapsulation port, out of here in
             * non-cookie-wait states
             *
             * Send an ABORT, without an specific error cause.
             * This looks no different than if no listener
             * was present.
             */
            op_err = sctp_generate_cause(
                system_base_info.sctpsysctl.sctp_diag_info_code as uint16_t,
                b"Remote encapsulation port changed\x00" as *const u8 as *mut libc::c_char,
            );
            sctp_send_abort(init_pkt, iphlen, src, dst, sh, 0u32, op_err, vrf_id, port);
            return;
        }
    }
    abort_flag = 0i32;
    op_err = sctp_arethere_unrecognized_parameters(
        init_pkt,
        (offset as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<sctp_init_chunk>() as libc::c_ulong)
            as libc::c_int,
        &mut abort_flag,
        init_chk as *mut sctp_chunkhdr,
        &mut nat_friendly,
        0 as *mut libc::c_int,
    );
    if !(abort_flag != 0) {
        let mut current_block: u64;
        let mut m = 0 as *mut mbuf;
        let mut now = timeval {
            tv_sec: 0,
            tv_usec: 0,
        };
        let mut to = 0 as *mut sockaddr;
        let mut stc = sctp_state_cookie {
            identification: [0; 16],
            time_entered: timeval {
                tv_sec: 0,
                tv_usec: 0,
            },
            cookie_life: 0,
            tie_tag_my_vtag: 0,
            tie_tag_peer_vtag: 0,
            peers_vtag: 0,
            my_vtag: 0,
            address: [0; 4],
            addr_type: 0,
            laddress: [0; 4],
            laddr_type: 0,
            scope_id: 0,
            peerport: 0,
            myport: 0,
            ipv4_addr_legal: 0,
            ipv6_addr_legal: 0,
            conn_addr_legal: 0,
            local_scope: 0,
            site_scope: 0,
            ipv4_scope: 0,
            loopback_scope: 0,
            reserved: [0; 5],
        };
        let mut net = 0 as *mut sctp_nets;
        let mut cnt_inits_to = 0i32;
        let mut chunk_len = 0;
        let mut padding_len = 0;
        m = sctp_get_mbuf_for_msg(2048u32, 0i32, 0x1i32, 1i32, 1i32);
        if m.is_null() {
            /* No memory, INIT timer will re-attempt. */
            m_freem(op_err);
            return;
        }
        chunk_len = ::std::mem::size_of::<sctp_init_chunk>() as uint16_t;
        padding_len = 0u16;
        /*
         * We might not overwrite the identification[] completely and on
         * some platforms time_entered will contain some padding.
         * Therefore zero out the cookie to avoid putting
         * uninitialized memory on the wire.
         */
        memset(
            &mut stc as *mut sctp_state_cookie as *mut libc::c_void,
            0i32,
            ::std::mem::size_of::<sctp_state_cookie>() as libc::c_ulong,
        );
        /* the time I built cookie */
        gettimeofday(&mut now, 0 as *mut timezone);
        stc.time_entered.tv_sec = now.tv_sec;
        stc.time_entered.tv_usec = now.tv_usec;
        /* populate any tie tags */
        if !asoc.is_null() {
            /* unlock before tag selections */
            stc.tie_tag_my_vtag = (*asoc).my_vtag_nonce;
            stc.tie_tag_peer_vtag = (*asoc).peer_vtag_nonce;
            stc.cookie_life = (*asoc).cookie_life;
            net = (*asoc).primary_destination
        } else {
            stc.tie_tag_my_vtag = 0u32;
            stc.tie_tag_peer_vtag = 0u32;
            /* life I will award this cookie */
            stc.cookie_life = (*inp).sctp_ep.def_cookie_life
        }
        /* copy in the ports for later check */
        stc.myport = (*sh).dest_port;
        stc.peerport = (*sh).src_port;
        /*
         * If we wanted to honor cookie life extensions, we would add to
         * stc.cookie_life. For now we should NOT honor any extension
         */
        stc.loopback_scope = 0u8;
        stc.local_scope = stc.loopback_scope;
        stc.site_scope = stc.local_scope;
        if (*inp).sctp_flags & 0x4000000u32 != 0 {
            stc.ipv6_addr_legal = 1u8;
            if (*inp).ip_inp.inp.inp_flags & 0x8000i32 != 0 {
                stc.ipv4_addr_legal = 0u8
            } else {
                stc.ipv4_addr_legal = 1u8
            }
            stc.conn_addr_legal = 0u8
        } else {
            stc.ipv6_addr_legal = 0u8;
            if (*inp).sctp_flags & 0x80000000u32 != 0 {
                stc.conn_addr_legal = 1u8;
                stc.ipv4_addr_legal = 0u8
            } else {
                stc.conn_addr_legal = 0u8;
                stc.ipv4_addr_legal = 1u8
            }
        }
        stc.ipv4_scope = 0u8;
        if net.is_null() {
            to = src;
            match (*dst).sa_family as libc::c_int {
                2 => {
                    current_block = 993425571616822999;
                    match current_block {
                        993425571616822999 => {
                            /* lookup address */
                            stc.address[0usize] = (*src4).sin_addr.s_addr;
                            stc.address[1usize] = 0u32;
                            stc.address[2usize] = 0u32;
                            stc.address[3usize] = 0u32;
                            stc.addr_type = 0x5u32;
                            /* local from address */
                            stc.laddress[0usize] = (*dst4).sin_addr.s_addr;
                            stc.laddress[1usize] = 0u32;
                            stc.laddress[2usize] = 0u32;
                            stc.laddress[3usize] = 0u32;
                            stc.laddr_type = 0x5u32;
                            /* scope_id is only for v6 */
                            stc.scope_id = 0u32;
                            if *(&mut (*src4).sin_addr.s_addr as *mut in_addr_t as *mut uint8_t)
                                .offset(0isize) as libc::c_int
                                == 10i32
                                || *(&mut (*src4).sin_addr.s_addr as *mut in_addr_t as *mut uint8_t)
                                    .offset(0isize)
                                    as libc::c_int
                                    == 172i32
                                    && *(&mut (*src4).sin_addr.s_addr as *mut in_addr_t
                                        as *mut uint8_t)
                                        .offset(1isize)
                                        as libc::c_int
                                        >= 16i32
                                    && *(&mut (*src4).sin_addr.s_addr as *mut in_addr_t
                                        as *mut uint8_t)
                                        .offset(1isize)
                                        as libc::c_int
                                        <= 32i32
                                || *(&mut (*src4).sin_addr.s_addr as *mut in_addr_t as *mut uint8_t)
                                    .offset(0isize)
                                    as libc::c_int
                                    == 192i32
                                    && *(&mut (*src4).sin_addr.s_addr as *mut in_addr_t
                                        as *mut uint8_t)
                                        .offset(1isize)
                                        as libc::c_int
                                        == 168i32
                                || (*(&mut (*dst4).sin_addr.s_addr as *mut in_addr_t
                                    as *mut uint8_t)
                                    .offset(0isize)
                                    as libc::c_int
                                    == 10i32
                                    || *(&mut (*dst4).sin_addr.s_addr as *mut in_addr_t
                                        as *mut uint8_t)
                                        .offset(0isize)
                                        as libc::c_int
                                        == 172i32
                                        && *(&mut (*dst4).sin_addr.s_addr as *mut in_addr_t
                                            as *mut uint8_t)
                                            .offset(1isize)
                                            as libc::c_int
                                            >= 16i32
                                        && *(&mut (*dst4).sin_addr.s_addr as *mut in_addr_t
                                            as *mut uint8_t)
                                            .offset(1isize)
                                            as libc::c_int
                                            <= 32i32
                                    || *(&mut (*dst4).sin_addr.s_addr as *mut in_addr_t
                                        as *mut uint8_t)
                                        .offset(0isize)
                                        as libc::c_int
                                        == 192i32
                                        && *(&mut (*dst4).sin_addr.s_addr as *mut in_addr_t
                                            as *mut uint8_t)
                                            .offset(1isize)
                                            as libc::c_int
                                            == 168i32)
                            {
                                stc.ipv4_scope = 1u8
                            }
                            /* Must use the address in this case */
                            if sctp_is_address_on_local_host(src, vrf_id) != 0 {
                                stc.loopback_scope = 1u8;
                                stc.ipv4_scope = 1u8;
                                stc.site_scope = 1u8;
                                stc.local_scope = 0u8
                            }
                        }
                        6040267449472925966 => {
                            stc.addr_type = 0x6u32;
                            memcpy(
                                &mut stc.address as *mut [uint32_t; 4] as *mut libc::c_void,
                                &mut (*src6).sin6_addr as *mut in6_addr as *const libc::c_void,
                                ::std::mem::size_of::<in6_addr>() as libc::c_ulong,
                            );
                            stc.scope_id = 0u32;
                            if sctp_is_address_on_local_host(src, vrf_id) != 0 {
                                stc.loopback_scope = 1u8;
                                stc.local_scope = 0u8;
                                stc.site_scope = 1u8;
                                stc.ipv4_scope = 1u8
                            } else if ({
                                let mut __a =
                                    &mut (*src6).sin6_addr as *mut in6_addr as *const in6_addr;
                                ((*__a).__in6_u.__u6_addr32[0usize] & htonl(0xffc00000u32)
                                    == htonl(0xfe800000u32))
                                    as libc::c_int
                            }) != 0
                                || ({
                                    let mut __a =
                                        &mut (*dst6).sin6_addr as *mut in6_addr as *const in6_addr;
                                    ((*__a).__in6_u.__u6_addr32[0usize] & htonl(0xffc00000u32)
                                        == htonl(0xfe800000u32))
                                        as libc::c_int
                                }) != 0
                            {
                                /*
                                 * If the new destination or source is a
                                 * LINK_LOCAL we must have common both site and
                                 * local scope. Don't set local scope though
                                 * since we must depend on the source to be
                                 * added implicitly. We cannot assure just
                                 * because we share one link that all links are
                                 * common.
                                 */
                                stc.local_scope = 0u8;
                                stc.site_scope = 1u8;
                                stc.ipv4_scope = 1u8;
                                /* pull out the scope_id from incoming pkt */
                                cnt_inits_to = 1i32
                            } else if ({
                                let mut __a =
                                    &mut (*src6).sin6_addr as *mut in6_addr as *const in6_addr;
                                ((*__a).__in6_u.__u6_addr32[0usize] & htonl(0xffc00000u32)
                                    == htonl(0xfec00000u32))
                                    as libc::c_int
                            }) != 0
                                || ({
                                    let mut __a =
                                        &mut (*dst6).sin6_addr as *mut in6_addr as *const in6_addr;
                                    ((*__a).__in6_u.__u6_addr32[0usize] & htonl(0xffc00000u32)
                                        == htonl(0xfec00000u32))
                                        as libc::c_int
                                }) != 0
                            {
                                /*
                                 * we start counting for the private address
                                 * stuff at 1. since the link local we
                                 * source from won't show up in our scoped
                                 * count.
                                 */
                                /*
                                 * If the new destination or source is
                                 * SITE_LOCAL then we must have site scope in
                                 * common.
                                 */
                                stc.site_scope = 1u8
                            }
                            memcpy(
                                &mut stc.laddress as *mut [uint32_t; 4] as *mut libc::c_void,
                                &mut (*dst6).sin6_addr as *mut in6_addr as *const libc::c_void,
                                ::std::mem::size_of::<in6_addr>() as libc::c_ulong,
                            );
                            stc.laddr_type = 0x6u32
                        }
                        _ => {
                            /* lookup address */
                            stc.address[0usize] = 0u32;
                            stc.address[1usize] = 0u32;
                            stc.address[2usize] = 0u32;
                            stc.address[3usize] = 0u32;
                            memcpy(
                                &mut stc.address as *mut [uint32_t; 4] as *mut libc::c_void,
                                &mut (*srcconn).sconn_addr as *mut *mut libc::c_void
                                    as *const libc::c_void,
                                ::std::mem::size_of::<*mut libc::c_void>() as libc::c_ulong,
                            );
                            stc.addr_type = 0x4u32;
                            /* local from address */
                            stc.laddress[0usize] = 0u32;
                            stc.laddress[1usize] = 0u32;
                            stc.laddress[2usize] = 0u32;
                            stc.laddress[3usize] = 0u32;
                            memcpy(
                                &mut stc.laddress as *mut [uint32_t; 4] as *mut libc::c_void,
                                &mut (*dstconn).sconn_addr as *mut *mut libc::c_void
                                    as *const libc::c_void,
                                ::std::mem::size_of::<*mut libc::c_void>() as libc::c_ulong,
                            );
                            stc.laddr_type = 0x4u32;
                            /* scope_id is only for v6 */
                            stc.scope_id = 0u32
                        }
                    }
                    current_block = 13391418783698890455;
                }
                10 => {
                    current_block = 6040267449472925966;
                    match current_block {
                        993425571616822999 => {
                            stc.address[0usize] = (*src4).sin_addr.s_addr;
                            stc.address[1usize] = 0u32;
                            stc.address[2usize] = 0u32;
                            stc.address[3usize] = 0u32;
                            stc.addr_type = 0x5u32;
                            stc.laddress[0usize] = (*dst4).sin_addr.s_addr;
                            stc.laddress[1usize] = 0u32;
                            stc.laddress[2usize] = 0u32;
                            stc.laddress[3usize] = 0u32;
                            stc.laddr_type = 0x5u32;
                            stc.scope_id = 0u32;
                            if *(&mut (*src4).sin_addr.s_addr as *mut in_addr_t as *mut uint8_t)
                                .offset(0isize) as libc::c_int
                                == 10i32
                                || *(&mut (*src4).sin_addr.s_addr as *mut in_addr_t as *mut uint8_t)
                                    .offset(0isize)
                                    as libc::c_int
                                    == 172i32
                                    && *(&mut (*src4).sin_addr.s_addr as *mut in_addr_t
                                        as *mut uint8_t)
                                        .offset(1isize)
                                        as libc::c_int
                                        >= 16i32
                                    && *(&mut (*src4).sin_addr.s_addr as *mut in_addr_t
                                        as *mut uint8_t)
                                        .offset(1isize)
                                        as libc::c_int
                                        <= 32i32
                                || *(&mut (*src4).sin_addr.s_addr as *mut in_addr_t as *mut uint8_t)
                                    .offset(0isize)
                                    as libc::c_int
                                    == 192i32
                                    && *(&mut (*src4).sin_addr.s_addr as *mut in_addr_t
                                        as *mut uint8_t)
                                        .offset(1isize)
                                        as libc::c_int
                                        == 168i32
                                || (*(&mut (*dst4).sin_addr.s_addr as *mut in_addr_t
                                    as *mut uint8_t)
                                    .offset(0isize)
                                    as libc::c_int
                                    == 10i32
                                    || *(&mut (*dst4).sin_addr.s_addr as *mut in_addr_t
                                        as *mut uint8_t)
                                        .offset(0isize)
                                        as libc::c_int
                                        == 172i32
                                        && *(&mut (*dst4).sin_addr.s_addr as *mut in_addr_t
                                            as *mut uint8_t)
                                            .offset(1isize)
                                            as libc::c_int
                                            >= 16i32
                                        && *(&mut (*dst4).sin_addr.s_addr as *mut in_addr_t
                                            as *mut uint8_t)
                                            .offset(1isize)
                                            as libc::c_int
                                            <= 32i32
                                    || *(&mut (*dst4).sin_addr.s_addr as *mut in_addr_t
                                        as *mut uint8_t)
                                        .offset(0isize)
                                        as libc::c_int
                                        == 192i32
                                        && *(&mut (*dst4).sin_addr.s_addr as *mut in_addr_t
                                            as *mut uint8_t)
                                            .offset(1isize)
                                            as libc::c_int
                                            == 168i32)
                            {
                                stc.ipv4_scope = 1u8
                            }
                            if sctp_is_address_on_local_host(src, vrf_id) != 0 {
                                stc.loopback_scope = 1u8;
                                stc.ipv4_scope = 1u8;
                                stc.site_scope = 1u8;
                                stc.local_scope = 0u8
                            }
                        }
                        6040267449472925966 => {
                            stc.addr_type = 0x6u32;
                            memcpy(
                                &mut stc.address as *mut [uint32_t; 4] as *mut libc::c_void,
                                &mut (*src6).sin6_addr as *mut in6_addr as *const libc::c_void,
                                ::std::mem::size_of::<in6_addr>() as libc::c_ulong,
                            );
                            stc.scope_id = 0u32;
                            if sctp_is_address_on_local_host(src, vrf_id) != 0 {
                                stc.loopback_scope = 1u8;
                                stc.local_scope = 0u8;
                                stc.site_scope = 1u8;
                                stc.ipv4_scope = 1u8
                            } else if ({
                                let mut __a =
                                    &mut (*src6).sin6_addr as *mut in6_addr as *const in6_addr;
                                ((*__a).__in6_u.__u6_addr32[0usize] & htonl(0xffc00000u32)
                                    == htonl(0xfe800000u32))
                                    as libc::c_int
                            }) != 0
                                || ({
                                    let mut __a =
                                        &mut (*dst6).sin6_addr as *mut in6_addr as *const in6_addr;
                                    ((*__a).__in6_u.__u6_addr32[0usize] & htonl(0xffc00000u32)
                                        == htonl(0xfe800000u32))
                                        as libc::c_int
                                }) != 0
                            {
                                stc.local_scope = 0u8;
                                stc.site_scope = 1u8;
                                stc.ipv4_scope = 1u8;
                                cnt_inits_to = 1i32
                            } else if ({
                                let mut __a =
                                    &mut (*src6).sin6_addr as *mut in6_addr as *const in6_addr;
                                ((*__a).__in6_u.__u6_addr32[0usize] & htonl(0xffc00000u32)
                                    == htonl(0xfec00000u32))
                                    as libc::c_int
                            }) != 0
                                || ({
                                    let mut __a =
                                        &mut (*dst6).sin6_addr as *mut in6_addr as *const in6_addr;
                                    ((*__a).__in6_u.__u6_addr32[0usize] & htonl(0xffc00000u32)
                                        == htonl(0xfec00000u32))
                                        as libc::c_int
                                }) != 0
                            {
                                stc.site_scope = 1u8
                            }
                            memcpy(
                                &mut stc.laddress as *mut [uint32_t; 4] as *mut libc::c_void,
                                &mut (*dst6).sin6_addr as *mut in6_addr as *const libc::c_void,
                                ::std::mem::size_of::<in6_addr>() as libc::c_ulong,
                            );
                            stc.laddr_type = 0x6u32
                        }
                        _ => {
                            stc.address[0usize] = 0u32;
                            stc.address[1usize] = 0u32;
                            stc.address[2usize] = 0u32;
                            stc.address[3usize] = 0u32;
                            memcpy(
                                &mut stc.address as *mut [uint32_t; 4] as *mut libc::c_void,
                                &mut (*srcconn).sconn_addr as *mut *mut libc::c_void
                                    as *const libc::c_void,
                                ::std::mem::size_of::<*mut libc::c_void>() as libc::c_ulong,
                            );
                            stc.addr_type = 0x4u32;
                            stc.laddress[0usize] = 0u32;
                            stc.laddress[1usize] = 0u32;
                            stc.laddress[2usize] = 0u32;
                            stc.laddress[3usize] = 0u32;
                            memcpy(
                                &mut stc.laddress as *mut [uint32_t; 4] as *mut libc::c_void,
                                &mut (*dstconn).sconn_addr as *mut *mut libc::c_void
                                    as *const libc::c_void,
                                ::std::mem::size_of::<*mut libc::c_void>() as libc::c_ulong,
                            );
                            stc.laddr_type = 0x4u32;
                            stc.scope_id = 0u32
                        }
                    }
                    current_block = 13391418783698890455;
                }
                123 => {
                    current_block = 11718254377427810743;
                    match current_block {
                        993425571616822999 => {
                            stc.address[0usize] = (*src4).sin_addr.s_addr;
                            stc.address[1usize] = 0u32;
                            stc.address[2usize] = 0u32;
                            stc.address[3usize] = 0u32;
                            stc.addr_type = 0x5u32;
                            stc.laddress[0usize] = (*dst4).sin_addr.s_addr;
                            stc.laddress[1usize] = 0u32;
                            stc.laddress[2usize] = 0u32;
                            stc.laddress[3usize] = 0u32;
                            stc.laddr_type = 0x5u32;
                            stc.scope_id = 0u32;
                            if *(&mut (*src4).sin_addr.s_addr as *mut in_addr_t as *mut uint8_t)
                                .offset(0isize) as libc::c_int
                                == 10i32
                                || *(&mut (*src4).sin_addr.s_addr as *mut in_addr_t as *mut uint8_t)
                                    .offset(0isize)
                                    as libc::c_int
                                    == 172i32
                                    && *(&mut (*src4).sin_addr.s_addr as *mut in_addr_t
                                        as *mut uint8_t)
                                        .offset(1isize)
                                        as libc::c_int
                                        >= 16i32
                                    && *(&mut (*src4).sin_addr.s_addr as *mut in_addr_t
                                        as *mut uint8_t)
                                        .offset(1isize)
                                        as libc::c_int
                                        <= 32i32
                                || *(&mut (*src4).sin_addr.s_addr as *mut in_addr_t as *mut uint8_t)
                                    .offset(0isize)
                                    as libc::c_int
                                    == 192i32
                                    && *(&mut (*src4).sin_addr.s_addr as *mut in_addr_t
                                        as *mut uint8_t)
                                        .offset(1isize)
                                        as libc::c_int
                                        == 168i32
                                || (*(&mut (*dst4).sin_addr.s_addr as *mut in_addr_t
                                    as *mut uint8_t)
                                    .offset(0isize)
                                    as libc::c_int
                                    == 10i32
                                    || *(&mut (*dst4).sin_addr.s_addr as *mut in_addr_t
                                        as *mut uint8_t)
                                        .offset(0isize)
                                        as libc::c_int
                                        == 172i32
                                        && *(&mut (*dst4).sin_addr.s_addr as *mut in_addr_t
                                            as *mut uint8_t)
                                            .offset(1isize)
                                            as libc::c_int
                                            >= 16i32
                                        && *(&mut (*dst4).sin_addr.s_addr as *mut in_addr_t
                                            as *mut uint8_t)
                                            .offset(1isize)
                                            as libc::c_int
                                            <= 32i32
                                    || *(&mut (*dst4).sin_addr.s_addr as *mut in_addr_t
                                        as *mut uint8_t)
                                        .offset(0isize)
                                        as libc::c_int
                                        == 192i32
                                        && *(&mut (*dst4).sin_addr.s_addr as *mut in_addr_t
                                            as *mut uint8_t)
                                            .offset(1isize)
                                            as libc::c_int
                                            == 168i32)
                            {
                                stc.ipv4_scope = 1u8
                            }
                            if sctp_is_address_on_local_host(src, vrf_id) != 0 {
                                stc.loopback_scope = 1u8;
                                stc.ipv4_scope = 1u8;
                                stc.site_scope = 1u8;
                                stc.local_scope = 0u8
                            }
                        }
                        6040267449472925966 => {
                            stc.addr_type = 0x6u32;
                            memcpy(
                                &mut stc.address as *mut [uint32_t; 4] as *mut libc::c_void,
                                &mut (*src6).sin6_addr as *mut in6_addr as *const libc::c_void,
                                ::std::mem::size_of::<in6_addr>() as libc::c_ulong,
                            );
                            stc.scope_id = 0u32;
                            if sctp_is_address_on_local_host(src, vrf_id) != 0 {
                                stc.loopback_scope = 1u8;
                                stc.local_scope = 0u8;
                                stc.site_scope = 1u8;
                                stc.ipv4_scope = 1u8
                            } else if ({
                                let mut __a =
                                    &mut (*src6).sin6_addr as *mut in6_addr as *const in6_addr;
                                ((*__a).__in6_u.__u6_addr32[0usize] & htonl(0xffc00000u32)
                                    == htonl(0xfe800000u32))
                                    as libc::c_int
                            }) != 0
                                || ({
                                    let mut __a =
                                        &mut (*dst6).sin6_addr as *mut in6_addr as *const in6_addr;
                                    ((*__a).__in6_u.__u6_addr32[0usize] & htonl(0xffc00000u32)
                                        == htonl(0xfe800000u32))
                                        as libc::c_int
                                }) != 0
                            {
                                stc.local_scope = 0u8;
                                stc.site_scope = 1u8;
                                stc.ipv4_scope = 1u8;
                                cnt_inits_to = 1i32
                            } else if ({
                                let mut __a =
                                    &mut (*src6).sin6_addr as *mut in6_addr as *const in6_addr;
                                ((*__a).__in6_u.__u6_addr32[0usize] & htonl(0xffc00000u32)
                                    == htonl(0xfec00000u32))
                                    as libc::c_int
                            }) != 0
                                || ({
                                    let mut __a =
                                        &mut (*dst6).sin6_addr as *mut in6_addr as *const in6_addr;
                                    ((*__a).__in6_u.__u6_addr32[0usize] & htonl(0xffc00000u32)
                                        == htonl(0xfec00000u32))
                                        as libc::c_int
                                }) != 0
                            {
                                stc.site_scope = 1u8
                            }
                            memcpy(
                                &mut stc.laddress as *mut [uint32_t; 4] as *mut libc::c_void,
                                &mut (*dst6).sin6_addr as *mut in6_addr as *const libc::c_void,
                                ::std::mem::size_of::<in6_addr>() as libc::c_ulong,
                            );
                            stc.laddr_type = 0x6u32
                        }
                        _ => {
                            stc.address[0usize] = 0u32;
                            stc.address[1usize] = 0u32;
                            stc.address[2usize] = 0u32;
                            stc.address[3usize] = 0u32;
                            memcpy(
                                &mut stc.address as *mut [uint32_t; 4] as *mut libc::c_void,
                                &mut (*srcconn).sconn_addr as *mut *mut libc::c_void
                                    as *const libc::c_void,
                                ::std::mem::size_of::<*mut libc::c_void>() as libc::c_ulong,
                            );
                            stc.addr_type = 0x4u32;
                            stc.laddress[0usize] = 0u32;
                            stc.laddress[1usize] = 0u32;
                            stc.laddress[2usize] = 0u32;
                            stc.laddress[3usize] = 0u32;
                            memcpy(
                                &mut stc.laddress as *mut [uint32_t; 4] as *mut libc::c_void,
                                &mut (*dstconn).sconn_addr as *mut *mut libc::c_void
                                    as *const libc::c_void,
                                ::std::mem::size_of::<*mut libc::c_void>() as libc::c_ulong,
                            );
                            stc.laddr_type = 0x4u32;
                            stc.scope_id = 0u32
                        }
                    }
                    current_block = 13391418783698890455;
                }
                _ => {
                    current_block = 12175967925781855312;
                }
            }
        } else {
            let mut lnet = 0 as *mut sctp_nets;
            stc.loopback_scope = (*asoc).scope.loopback_scope;
            stc.ipv4_scope = (*asoc).scope.ipv4_local_scope;
            stc.site_scope = (*asoc).scope.site_scope;
            stc.local_scope = (*asoc).scope.local_scope;
            /* Why do we not consider IPv4 LL addresses? */
            lnet = (*asoc).nets.tqh_first;
            while !lnet.is_null() {
                if (*lnet).ro._l_addr.sin6.sin6_family as libc::c_int == 10i32 {
                    if ({
                        let mut __a = &mut (*lnet).ro._l_addr.sin6.sin6_addr as *mut in6_addr
                            as *const in6_addr;
                        ((*__a).__in6_u.__u6_addr32[0usize] & htonl(0xffc00000u32)
                            == htonl(0xfe800000u32)) as libc::c_int
                    }) != 0
                    {
                        /*
                         * if we have a LL address, start
                         * counting at 1.
                         */
                        cnt_inits_to = 1i32
                    }
                }
                lnet = (*lnet).sctp_next.tqe_next
            }
            /* use the net pointer */
            to = &mut (*net).ro._l_addr as *mut sctp_sockstore as *mut sockaddr;
            match (*to).sa_family as libc::c_int {
                2 => {
                    let mut sin = 0 as *mut sockaddr_in;
                    sin = to as *mut sockaddr_in;
                    stc.address[0usize] = (*sin).sin_addr.s_addr;
                    stc.address[1usize] = 0u32;
                    stc.address[2usize] = 0u32;
                    stc.address[3usize] = 0u32;
                    stc.addr_type = 0x5u32;
                    if (*net).src_addr_selected as libc::c_int == 0i32 {
                        /*
                         * strange case here, the INIT should have
                         * did the selection.
                         */
                        (*net).ro._s_addr = sctp_source_address_selection(
                            inp,
                            stcb,
                            &mut (*net).ro as *mut sctp_net_route as *mut sctp_route_t,
                            net,
                            0i32,
                            vrf_id,
                        );
                        if (*net).ro._s_addr.is_null() {
                            m_freem(op_err);
                            m_freem(m);
                            return;
                        }
                        (*net).src_addr_selected = 1u8
                    }
                    stc.laddress[0usize] = (*(*net).ro._s_addr).address.sin.sin_addr.s_addr;
                    stc.laddress[1usize] = 0u32;
                    stc.laddress[2usize] = 0u32;
                    stc.laddress[3usize] = 0u32;
                    stc.laddr_type = 0x5u32;
                    /* scope_id is only for v6 */
                    stc.scope_id = 0u32
                }
                10 => {
                    let mut sin6 = 0 as *mut sockaddr_in6;
                    sin6 = to as *mut sockaddr_in6;
                    memcpy(
                        &mut stc.address as *mut [uint32_t; 4] as *mut libc::c_void,
                        &mut (*sin6).sin6_addr as *mut in6_addr as *const libc::c_void,
                        ::std::mem::size_of::<in6_addr>() as libc::c_ulong,
                    );
                    stc.addr_type = 0x6u32;
                    stc.scope_id = (*sin6).sin6_scope_id;
                    if (*net).src_addr_selected as libc::c_int == 0i32 {
                        /*
                         * strange case here, the INIT should have
                         * done the selection.
                         */
                        (*net).ro._s_addr = sctp_source_address_selection(
                            inp,
                            stcb,
                            &mut (*net).ro as *mut sctp_net_route as *mut sctp_route_t,
                            net,
                            0i32,
                            vrf_id,
                        );
                        if (*net).ro._s_addr.is_null() {
                            m_freem(op_err);
                            m_freem(m);
                            return;
                        }
                        (*net).src_addr_selected = 1u8
                    }
                    memcpy(
                        &mut stc.laddress as *mut [uint32_t; 4] as *mut libc::c_void,
                        &mut (*(*net).ro._s_addr).address.sin6.sin6_addr as *mut in6_addr
                            as *const libc::c_void,
                        ::std::mem::size_of::<in6_addr>() as libc::c_ulong,
                    );
                    stc.laddr_type = 0x6u32
                }
                123 => {
                    let mut sconn = 0 as *mut sockaddr_conn;
                    sconn = to as *mut sockaddr_conn;
                    stc.address[0usize] = 0u32;
                    stc.address[1usize] = 0u32;
                    stc.address[2usize] = 0u32;
                    stc.address[3usize] = 0u32;
                    memcpy(
                        &mut stc.address as *mut [uint32_t; 4] as *mut libc::c_void,
                        &mut (*sconn).sconn_addr as *mut *mut libc::c_void as *const libc::c_void,
                        ::std::mem::size_of::<*mut libc::c_void>() as libc::c_ulong,
                    );
                    stc.addr_type = 0x4u32;
                    stc.laddress[0usize] = 0u32;
                    stc.laddress[1usize] = 0u32;
                    stc.laddress[2usize] = 0u32;
                    stc.laddress[3usize] = 0u32;
                    memcpy(
                        &mut stc.laddress as *mut [uint32_t; 4] as *mut libc::c_void,
                        &mut (*sconn).sconn_addr as *mut *mut libc::c_void as *const libc::c_void,
                        ::std::mem::size_of::<*mut libc::c_void>() as libc::c_ulong,
                    );
                    stc.laddr_type = 0x4u32;
                    stc.scope_id = 0u32
                }
                _ => {}
            }
            current_block = 13391418783698890455;
        }
        match current_block {
            12175967925781855312 => {}
            _ => {
                let mut m_tmp = 0 as *mut mbuf;
                let mut m_last_0 = 0 as *mut mbuf;
                let mut m_cookie = 0 as *mut mbuf;
                let mut initack = 0 as *mut sctp_init_chunk;
                let mut pr_supported = 0 as *mut sctp_supported_chunk_types_param;
                let mut ph = 0 as *mut sctp_paramhdr;
                let mut over_addr = 0 as *mut sctp_sockstore;
                let mut scp = sctp_scoping {
                    ipv4_addr_legal: 0,
                    ipv6_addr_legal: 0,
                    conn_addr_legal: 0,
                    loopback_scope: 0,
                    ipv4_local_scope: 0,
                    local_scope: 0,
                    site_scope: 0,
                };
                let mut signature = 0 as *mut uint8_t;
                let mut his_limit = 0;
                let mut i_want = 0;
                let mut error = 0;
                let mut so = 0 as *mut socket;
                let mut num_ext = 0;
                let mut parameter_len = 0;
                initack = (*m).m_hdr.mh_data as *mut sctp_init_chunk;
                /* Save it off for quick ref */
                stc.peers_vtag = ntohl((*init_chk).init.initiate_tag);
                /* who are we */
                memcpy(
                    stc.identification.as_mut_ptr() as *mut libc::c_void,
                    b"KAME-BSD 1.1\x00" as *const u8 as *const libc::c_void,
                    if strlen(b"KAME-BSD 1.1\x00" as *const u8 as *const libc::c_char)
                        > ::std::mem::size_of::<[uint8_t; 16]>() as libc::c_ulong
                    {
                        ::std::mem::size_of::<[uint8_t; 16]>() as libc::c_ulong
                    } else {
                        strlen(b"KAME-BSD 1.1\x00" as *const u8 as *const libc::c_char)
                    },
                );
                memset(stc.reserved.as_mut_ptr() as *mut libc::c_void, 0i32, 5u64);
                /* now the chunk header */
                (*initack).ch.chunk_type = 0x2u8;
                (*initack).ch.chunk_flags = 0u8;
                /* fill in later from mbuf we build */
                (*initack).ch.chunk_length = 0u16;
                /* place in my tag */
                if !asoc.is_null()
                    && ((*stcb).asoc.state & 0x7fi32 == 0x2i32
                        || (*stcb).asoc.state & 0x7fi32 == 0x1i32
                        || (*stcb).asoc.state & 0x7fi32 == 0x4i32)
                {
                    /* re-use the v-tags and init-seq here */
                    (*initack).init.initiate_tag = htonl((*asoc).my_vtag);
                    (*initack).init.initial_tsn = htonl((*asoc).init_seq_number)
                } else {
                    let mut vtag = 0;
                    if !asoc.is_null() {
                        let mut itsn = 0;
                        ::std::intrinsics::atomic_xadd(&mut (*asoc).refcnt, 1u32);
                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                        loop
                        /* Got a duplicate vtag on some guy behind a nat
                         * make sure we don't use it.
                         */
                        {
                            vtag = sctp_select_a_tag(
                                inp,
                                (*inp).ip_inp.inp.inp_inc.inc_ie.ie_lport,
                                (*sh).src_port,
                                1i32,
                            );
                            if !((*asoc).peer_supports_nat as libc::c_int != 0
                                && vtag == (*asoc).my_vtag)
                            {
                                break;
                            }
                        }
                        (*initack).init.initiate_tag = htonl(vtag);
                        /* get a TSN to use too */
                        itsn = sctp_select_initial_TSN(&mut (*inp).sctp_ep);
                        (*initack).init.initial_tsn = htonl(itsn);
                        pthread_mutex_lock(&mut (*stcb).tcb_mtx);
                        ::std::intrinsics::atomic_xadd(&mut (*asoc).refcnt, -(1i32) as uint32_t);
                    } else {
                        ::std::intrinsics::atomic_xadd(&mut (*inp).refcount, 1i32);
                        pthread_mutex_unlock(&mut (*inp).inp_mtx);
                        vtag = sctp_select_a_tag(
                            inp,
                            (*inp).ip_inp.inp.inp_inc.inc_ie.ie_lport,
                            (*sh).src_port,
                            1i32,
                        );
                        (*initack).init.initiate_tag = htonl(vtag);
                        /* get a TSN to use too */
                        (*initack).init.initial_tsn =
                            htonl(sctp_select_initial_TSN(&mut (*inp).sctp_ep));
                        pthread_mutex_lock(&mut (*inp).inp_mtx);
                        ::std::intrinsics::atomic_xadd(&mut (*inp).refcount, -(1i32));
                    }
                }
                /* save away my tag to */
                stc.my_vtag = (*initack).init.initiate_tag;
                /* set up some of the credits. */
                so = (*inp).sctp_socket;
                if so.is_null() {
                    /* memory problem */
                    m_freem(op_err);
                    m_freem(m);
                    return;
                } else {
                    (*initack).init.a_rwnd = htonl(if (*so).so_rcv.sb_hiwat > 4096u32 {
                        (*so).so_rcv.sb_hiwat
                    } else {
                        4096u32
                    })
                }
                /* set what I want */
                his_limit = ntohs((*init_chk).init.num_inbound_streams);
                /* choose what I want */
                if !asoc.is_null() {
                    if (*asoc).streamoutcnt as libc::c_uint > (*asoc).pre_open_streams {
                        i_want = (*asoc).streamoutcnt
                    } else {
                        i_want = (*asoc).pre_open_streams as uint16_t
                    }
                } else {
                    i_want = (*inp).sctp_ep.pre_open_stream_count
                }
                if (his_limit as libc::c_int) < i_want as libc::c_int {
                    /* I Want more :< */
                    (*initack).init.num_outbound_streams = (*init_chk).init.num_inbound_streams
                } else {
                    /* I can have what I want :> */
                    (*initack).init.num_outbound_streams = htons(i_want)
                }
                /* tell him his limit. */
                (*initack).init.num_inbound_streams = htons((*inp).sctp_ep.max_open_streams_intome);
                /* adaptation layer indication parameter */
                if (*inp).sctp_ep.adaptation_layer_indicator_provided != 0 {
                    let mut ali = 0 as *mut sctp_adaptation_layer_indication;
                    parameter_len =
                        ::std::mem::size_of::<sctp_adaptation_layer_indication>() as uint16_t;
                    ali = (*m).m_hdr.mh_data.offset(chunk_len as libc::c_int as isize)
                        as *mut sctp_adaptation_layer_indication;
                    (*ali).ph.param_type = htons(0xc006u16);
                    (*ali).ph.param_length = htons(parameter_len);
                    (*ali).indication = htonl((*inp).sctp_ep.adaptation_layer_indicator);
                    chunk_len =
                        (chunk_len as libc::c_int + parameter_len as libc::c_int) as uint16_t
                }
                /* ECN parameter */
                if !asoc.is_null() && (*asoc).ecn_supported as libc::c_int == 1i32
                    || asoc.is_null() && (*inp).ecn_supported as libc::c_int == 1i32
                {
                    parameter_len = ::std::mem::size_of::<sctp_paramhdr>() as uint16_t;
                    ph = (*m).m_hdr.mh_data.offset(chunk_len as libc::c_int as isize)
                        as *mut sctp_paramhdr;
                    (*ph).param_type = htons(0x8000u16);
                    (*ph).param_length = htons(parameter_len);
                    chunk_len =
                        (chunk_len as libc::c_int + parameter_len as libc::c_int) as uint16_t
                }
                /* PR-SCTP supported parameter */
                if !asoc.is_null() && (*asoc).prsctp_supported as libc::c_int == 1i32
                    || asoc.is_null() && (*inp).prsctp_supported as libc::c_int == 1i32
                {
                    parameter_len = ::std::mem::size_of::<sctp_paramhdr>() as uint16_t;
                    ph = (*m).m_hdr.mh_data.offset(chunk_len as libc::c_int as isize)
                        as *mut sctp_paramhdr;
                    (*ph).param_type = htons(0xc000u16);
                    (*ph).param_length = htons(parameter_len);
                    chunk_len =
                        (chunk_len as libc::c_int + parameter_len as libc::c_int) as uint16_t
                }
                /* Add NAT friendly parameter */
                if nat_friendly != 0 {
                    parameter_len = ::std::mem::size_of::<sctp_paramhdr>() as uint16_t;
                    ph = (*m).m_hdr.mh_data.offset(chunk_len as libc::c_int as isize)
                        as *mut sctp_paramhdr;
                    (*ph).param_type = htons(0xc007u16);
                    (*ph).param_length = htons(parameter_len);
                    chunk_len =
                        (chunk_len as libc::c_int + parameter_len as libc::c_int) as uint16_t
                }
                /* And now tell the peer which extensions we support */
                num_ext = 0u16;
                pr_supported = (*m).m_hdr.mh_data.offset(chunk_len as libc::c_int as isize)
                    as *mut sctp_supported_chunk_types_param;
                if !asoc.is_null() && (*asoc).prsctp_supported as libc::c_int == 1i32
                    || asoc.is_null() && (*inp).prsctp_supported as libc::c_int == 1i32
                {
                    let fresh14 = num_ext;
                    num_ext = num_ext.wrapping_add(1);
                    *(*pr_supported)
                        .chunk_types
                        .as_mut_ptr()
                        .offset(fresh14 as isize) = 0xc0u8;
                    if !asoc.is_null() && (*asoc).idata_supported as libc::c_int == 1i32
                        || asoc.is_null() && (*inp).idata_supported as libc::c_int == 1i32
                    {
                        let fresh15 = num_ext;
                        num_ext = num_ext.wrapping_add(1);
                        *(*pr_supported)
                            .chunk_types
                            .as_mut_ptr()
                            .offset(fresh15 as isize) = 0xc2u8
                    }
                }
                if !asoc.is_null() && (*asoc).auth_supported as libc::c_int == 1i32
                    || asoc.is_null() && (*inp).auth_supported as libc::c_int == 1i32
                {
                    let fresh16 = num_ext;
                    num_ext = num_ext.wrapping_add(1);
                    *(*pr_supported)
                        .chunk_types
                        .as_mut_ptr()
                        .offset(fresh16 as isize) = 0xfu8
                }
                if !asoc.is_null() && (*asoc).asconf_supported as libc::c_int == 1i32
                    || asoc.is_null() && (*inp).asconf_supported as libc::c_int == 1i32
                {
                    let fresh17 = num_ext;
                    num_ext = num_ext.wrapping_add(1);
                    *(*pr_supported)
                        .chunk_types
                        .as_mut_ptr()
                        .offset(fresh17 as isize) = 0xc1u8;
                    let fresh18 = num_ext;
                    num_ext = num_ext.wrapping_add(1);
                    *(*pr_supported)
                        .chunk_types
                        .as_mut_ptr()
                        .offset(fresh18 as isize) = 0x80u8
                }
                if !asoc.is_null() && (*asoc).reconfig_supported as libc::c_int == 1i32
                    || asoc.is_null() && (*inp).reconfig_supported as libc::c_int == 1i32
                {
                    let fresh19 = num_ext;
                    num_ext = num_ext.wrapping_add(1);
                    *(*pr_supported)
                        .chunk_types
                        .as_mut_ptr()
                        .offset(fresh19 as isize) = 0x82u8
                }
                if !asoc.is_null() && (*asoc).idata_supported as libc::c_int == 1i32
                    || asoc.is_null() && (*inp).idata_supported as libc::c_int == 1i32
                {
                    let fresh20 = num_ext;
                    num_ext = num_ext.wrapping_add(1);
                    *(*pr_supported)
                        .chunk_types
                        .as_mut_ptr()
                        .offset(fresh20 as isize) = 0x40u8
                }
                if !asoc.is_null() && (*asoc).nrsack_supported as libc::c_int == 1i32
                    || asoc.is_null() && (*inp).nrsack_supported as libc::c_int == 1i32
                {
                    let fresh21 = num_ext;
                    num_ext = num_ext.wrapping_add(1);
                    *(*pr_supported)
                        .chunk_types
                        .as_mut_ptr()
                        .offset(fresh21 as isize) = 0x10u8
                }
                if !asoc.is_null() && (*asoc).pktdrop_supported as libc::c_int == 1i32
                    || asoc.is_null() && (*inp).pktdrop_supported as libc::c_int == 1i32
                {
                    let fresh22 = num_ext;
                    num_ext = num_ext.wrapping_add(1);
                    *(*pr_supported)
                        .chunk_types
                        .as_mut_ptr()
                        .offset(fresh22 as isize) = 0x81u8
                }
                if num_ext as libc::c_int > 0i32 {
                    parameter_len = (::std::mem::size_of::<sctp_supported_chunk_types_param>()
                        as uint16_t as libc::c_int
                        + num_ext as libc::c_int) as uint16_t;
                    (*pr_supported).ph.param_type = htons(0x8008u16);
                    (*pr_supported).ph.param_length = htons(parameter_len);
                    padding_len = (((parameter_len as libc::c_int + 3i32 >> 2i32) << 2i32)
                        - parameter_len as libc::c_int)
                        as uint16_t;
                    chunk_len =
                        (chunk_len as libc::c_int + parameter_len as libc::c_int) as uint16_t
                }
                /* add authentication parameters */
                if !asoc.is_null() && (*asoc).auth_supported as libc::c_int == 1i32
                    || asoc.is_null() && (*inp).auth_supported as libc::c_int == 1i32
                {
                    let mut randp = 0 as *mut sctp_auth_random;
                    let mut hmacs = 0 as *mut sctp_auth_hmac_algo;
                    let mut chunks = 0 as *mut sctp_auth_chunk_list;
                    if padding_len as libc::c_int > 0i32 {
                        memset(
                            (*m).m_hdr.mh_data.offset(chunk_len as libc::c_int as isize)
                                as *mut libc::c_void,
                            0i32,
                            padding_len as libc::c_ulong,
                        );
                        chunk_len =
                            (chunk_len as libc::c_int + padding_len as libc::c_int) as uint16_t;
                        padding_len = 0u16
                    }
                    /* generate and add RANDOM parameter */
                    randp = (*m).m_hdr.mh_data.offset(chunk_len as libc::c_int as isize)
                        as *mut sctp_auth_random;
                    parameter_len = (::std::mem::size_of::<sctp_auth_random>() as uint16_t
                        as libc::c_int
                        + 32i32) as uint16_t;
                    (*randp).ph.param_type = htons(0x8002u16);
                    (*randp).ph.param_length = htons(parameter_len);
                    read_random(
                        (*randp).random_data.as_mut_ptr() as *mut libc::c_void,
                        32i32,
                    );
                    padding_len = (((parameter_len as libc::c_int + 3i32 >> 2i32) << 2i32)
                        - parameter_len as libc::c_int)
                        as uint16_t;
                    chunk_len =
                        (chunk_len as libc::c_int + parameter_len as libc::c_int) as uint16_t;
                    if padding_len as libc::c_int > 0i32 {
                        memset(
                            (*m).m_hdr.mh_data.offset(chunk_len as libc::c_int as isize)
                                as *mut libc::c_void,
                            0i32,
                            padding_len as libc::c_ulong,
                        );
                        chunk_len =
                            (chunk_len as libc::c_int + padding_len as libc::c_int) as uint16_t;
                        padding_len = 0u16
                    }
                    /* add HMAC_ALGO parameter */
                    hmacs = (*m).m_hdr.mh_data.offset(chunk_len as libc::c_int as isize)
                        as *mut sctp_auth_hmac_algo;
                    parameter_len = (::std::mem::size_of::<sctp_auth_hmac_algo>() as uint16_t
                        as libc::c_int
                        + sctp_serialize_hmaclist(
                            (*inp).sctp_ep.local_hmacs,
                            (*hmacs).hmac_ids.as_mut_ptr() as *mut uint8_t,
                        )) as uint16_t;
                    (*hmacs).ph.param_type = htons(0x8004u16);
                    (*hmacs).ph.param_length = htons(parameter_len);
                    padding_len = (((parameter_len as libc::c_int + 3i32 >> 2i32) << 2i32)
                        - parameter_len as libc::c_int)
                        as uint16_t;
                    chunk_len =
                        (chunk_len as libc::c_int + parameter_len as libc::c_int) as uint16_t;
                    if padding_len as libc::c_int > 0i32 {
                        memset(
                            (*m).m_hdr.mh_data.offset(chunk_len as libc::c_int as isize)
                                as *mut libc::c_void,
                            0i32,
                            padding_len as libc::c_ulong,
                        );
                        chunk_len =
                            (chunk_len as libc::c_int + padding_len as libc::c_int) as uint16_t;
                        padding_len = 0u16
                    }
                    /* add CHUNKS parameter */
                    chunks = (*m).m_hdr.mh_data.offset(chunk_len as libc::c_int as isize)
                        as *mut sctp_auth_chunk_list;
                    parameter_len = (::std::mem::size_of::<sctp_auth_chunk_list>() as uint16_t
                        as libc::c_int
                        + sctp_serialize_auth_chunks(
                            (*inp).sctp_ep.local_auth_chunks,
                            (*chunks).chunk_types.as_mut_ptr(),
                        )) as uint16_t;
                    (*chunks).ph.param_type = htons(0x8003u16);
                    (*chunks).ph.param_length = htons(parameter_len);
                    padding_len = (((parameter_len as libc::c_int + 3i32 >> 2i32) << 2i32)
                        - parameter_len as libc::c_int)
                        as uint16_t;
                    chunk_len =
                        (chunk_len as libc::c_int + parameter_len as libc::c_int) as uint16_t
                }
                (*m).m_hdr.mh_len = chunk_len as libc::c_int;
                m_last_0 = m;
                /* now the addresses */
                /* To optimize this we could put the scoping stuff
                 * into a structure and remove the individual uint8's from
                 * the stc structure. Then we could just sifa in the
                 * address within the stc.. but for now this is a quick
                 * hack to get the address stuff teased apart.
                 */
                scp.ipv4_addr_legal = stc.ipv4_addr_legal;
                scp.ipv6_addr_legal = stc.ipv6_addr_legal;
                scp.conn_addr_legal = stc.conn_addr_legal;
                scp.loopback_scope = stc.loopback_scope;
                scp.ipv4_local_scope = stc.ipv4_scope;
                scp.local_scope = stc.local_scope;
                scp.site_scope = stc.site_scope;
                m_last_0 = sctp_add_addresses_to_i_ia(
                    inp,
                    stcb,
                    &mut scp,
                    m_last_0,
                    cnt_inits_to,
                    &mut padding_len,
                    &mut chunk_len,
                );
                /* padding_len can only be positive, if no addresses have been added */
                if padding_len as libc::c_int > 0i32 {
                    memset(
                        (*m).m_hdr.mh_data.offset(chunk_len as libc::c_int as isize)
                            as *mut libc::c_void,
                        0i32,
                        padding_len as libc::c_ulong,
                    );
                    chunk_len = (chunk_len as libc::c_int + padding_len as libc::c_int) as uint16_t;
                    (*m).m_hdr.mh_len += padding_len as libc::c_int;
                    padding_len = 0u16
                }
                /* tack on the operational error if present */
                if !op_err.is_null() {
                    parameter_len = 0u16;
                    m_tmp = op_err;
                    while !m_tmp.is_null() {
                        parameter_len =
                            (parameter_len as libc::c_int + (*m_tmp).m_hdr.mh_len) as uint16_t;
                        m_tmp = (*m_tmp).m_hdr.mh_next
                    }
                    padding_len = (((parameter_len as libc::c_int + 3i32 >> 2i32) << 2i32)
                        - parameter_len as libc::c_int)
                        as uint16_t;
                    (*m_last_0).m_hdr.mh_next = op_err;
                    while !(*m_last_0).m_hdr.mh_next.is_null() {
                        m_last_0 = (*m_last_0).m_hdr.mh_next
                    }
                    chunk_len =
                        (chunk_len as libc::c_int + parameter_len as libc::c_int) as uint16_t
                }
                if padding_len as libc::c_int > 0i32 {
                    m_last_0 = sctp_add_pad_tombuf(m_last_0, padding_len as libc::c_int);
                    if m_last_0.is_null() {
                        /* Houston we have a problem, no space */
                        m_freem(m);
                        return;
                    }
                    chunk_len = (chunk_len as libc::c_int + padding_len as libc::c_int) as uint16_t;
                    padding_len = 0u16
                }
                /* Now we must build a cookie */
                m_cookie = sctp_add_cookie(init_pkt, offset, m, 0i32, &mut stc, &mut signature);
                if m_cookie.is_null() {
                    /* memory problem */
                    m_freem(m);
                    return;
                }
                /* Now append the cookie to the end and update the space/size */
                (*m_last_0).m_hdr.mh_next = m_cookie;
                parameter_len = 0u16;
                m_tmp = m_cookie;
                while !m_tmp.is_null() {
                    parameter_len =
                        (parameter_len as libc::c_int + (*m_tmp).m_hdr.mh_len) as uint16_t;
                    if (*m_tmp).m_hdr.mh_next.is_null() {
                        m_last_0 = m_tmp
                    }
                    m_tmp = (*m_tmp).m_hdr.mh_next
                }
                padding_len = (((parameter_len as libc::c_int + 3i32 >> 2i32) << 2i32)
                    - parameter_len as libc::c_int) as uint16_t;
                chunk_len = (chunk_len as libc::c_int + parameter_len as libc::c_int) as uint16_t;
                /* Place in the size, but we don't include
                 * the last pad (if any) in the INIT-ACK.
                 */
                (*initack).ch.chunk_length = htons(chunk_len);
                /* Time to sign the cookie, we don't sign over the cookie
                 * signature though thus we set trailer.
                 */
                sctp_hmac_m(
                    0x1u16,
                    (*inp).sctp_ep.secret_key
                        [(*inp).sctp_ep.current_secret_number as libc::c_int as usize]
                        .as_mut_ptr() as *mut uint8_t,
                    32u32,
                    m_cookie,
                    ::std::mem::size_of::<sctp_paramhdr>() as uint32_t,
                    signature,
                    20u32,
                );
                /*
                 * We sifa 0 here to NOT set IP_DF if its IPv4, we ignore the return
                 * here since the timer will drive a retranmission.
                 */
                if padding_len as libc::c_int > 0i32 {
                    if sctp_add_pad_tombuf(m_last_0, padding_len as libc::c_int).is_null() {
                        m_freem(m);
                        return;
                    }
                }
                if stc.loopback_scope != 0 {
                    over_addr = dst as *mut sctp_sockstore
                } else {
                    over_addr = 0 as *mut sctp_sockstore
                }
                error = sctp_lowlevel_chunk_output(
                    inp,
                    0 as *mut sctp_tcb,
                    0 as *mut sctp_nets,
                    to,
                    m,
                    0u32,
                    0 as *mut sctp_auth_chunk,
                    0u16,
                    0i32,
                    0i32,
                    0i32,
                    (*inp).ip_inp.inp.inp_inc.inc_ie.ie_lport,
                    (*sh).src_port,
                    (*init_chk).init.initiate_tag,
                    port,
                    over_addr,
                    0i32,
                );
                if error != 0 {
                    if system_base_info.sctpsysctl.sctp_debug_on & 0x80u32 != 0 {
                        if system_base_info.debug_printf.is_some() {
                            system_base_info
                                .debug_printf
                                .expect("non-null function pointer")(
                                b"Gak send error %d\n\x00" as *const u8 as *const libc::c_char,
                                error,
                            );
                        }
                    }
                    if error == 105i32 {
                        if !asoc.is_null() {
                            (*asoc).ifp_had_enobuf = 1u8
                        }
                        ::std::intrinsics::atomic_xadd(
                            &mut system_base_info.sctpstat.sctps_lowlevelerr,
                            1u32,
                        );
                    }
                } else if !asoc.is_null() {
                    (*asoc).ifp_had_enobuf = 0u8
                }
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctpstat.sctps_outcontrolchunks,
                    1u32,
                );
                return;
            }
        }
    }
    /* TSNH */
    if op_err.is_null() {
        let mut msg = [0; 128]; /* tailqforeach */
        snprintf(msg.as_mut_ptr(),
                 ::std::mem::size_of::<[libc::c_char; 128]>() as
                     libc::c_ulong,
                 b"%s:%d at %s\x00" as *const u8 as *const libc::c_char,
                 b"/usr/local/google/home/winniexiao/chromium/src/third_party/usrsctp/usrsctplib/usrsctplib/netinet/sctp_output.c\x00"
                     as *const u8 as *const libc::c_char, 6015i32,
                 (*::std::mem::transmute::<&[u8; 23],
                                           &[libc::c_char; 23]>(b"sctp_send_initiate_ack\x00")).as_ptr());
        op_err = sctp_generate_cause(
            system_base_info.sctpsysctl.sctp_diag_info_code as uint16_t,
            msg.as_mut_ptr(),
        )
    }
    sctp_send_abort(
        init_pkt,
        iphlen,
        src,
        dst,
        sh,
        (*init_chk).init.initiate_tag,
        op_err,
        vrf_id,
        port,
    );
}
unsafe extern "C" fn sctp_prune_prsctp(
    mut stcb: *mut sctp_tcb,
    mut asoc: *mut sctp_association,
    mut srcv: *mut sctp_sndrcvinfo,
    mut dataout: libc::c_int,
) {
    if (*asoc).prsctp_supported as libc::c_int != 0 && (*asoc).sent_queue_cnt_removeable > 0u32 {
        let mut freed_spc = 0i32;
        let mut chk = 0 as *mut sctp_tmit_chunk;
        let mut nchk = 0 as *mut sctp_tmit_chunk;
        chk = (*asoc).sent_queue.tqh_first;
        while !chk.is_null() {
            /*
             * Look for chunks marked with the PR_SCTP flag AND
             * the buffer space flag. If the one being sent is
             * equal or greater priority then purge the old one
             * and free some space.
             */
            if (*chk).flags as libc::c_int & 0xfi32 == 0x2i32 {
                /*
                 * This one is PR-SCTP AND buffer space
                 * limited type
                 */
                if (*chk).rec.data.timetodrop.tv_sec >= (*srcv).sinfo_timetolive as libc::c_long {
                    /*
                     * Lower numbers equates to higher
                     * priority so if the one we are
                     * looking at has a larger or equal
                     * priority we want to drop the data
                     * and NOT retransmit it.
                     */
                    if !(*chk).data.is_null() {
                        let mut ret_spc = 0;
                        let mut sent = 0;
                        if (*chk).sent > 0i32 {
                            sent = 1u8
                        } else {
                            sent = 0u8
                        }
                        ret_spc = sctp_release_pr_sctp_chunk(stcb, chk, sent, 1i32);
                        freed_spc += ret_spc;
                        if freed_spc >= dataout {
                            return;
                        }
                    }
                    /* if chunk was present */
                }
                /* if of sufficient priority */
            }
            chk = (*chk).sctp_next.tqe_next
            /* if chunk has enabled */
        }
        chk = (*asoc).send_queue.tqh_first;
        while !chk.is_null() && {
            nchk = (*chk).sctp_next.tqe_next;
            (1i32) != 0
        } {
            /* tailqforeachsafe (chk) */
            /* Here we must move to the sent queue and mark */
            if (*chk).flags as libc::c_int & 0xfi32 == 0x2i32 {
                if (*chk).rec.data.timetodrop.tv_sec >= (*srcv).sinfo_timetolive as libc::c_long {
                    if !(*chk).data.is_null() {
                        let mut ret_spc_0 = 0;
                        ret_spc_0 = sctp_release_pr_sctp_chunk(stcb, chk, 0u8, 1i32);
                        freed_spc += ret_spc_0;
                        if freed_spc >= dataout {
                            return;
                        }
                    }
                    /* end if chk->data */
                }
                /* end if right class */
            }
            chk = nchk
            /* end if chk pr-sctp */
        }
    };
    /* if enabled in asoc */
}
#[no_mangle]
pub unsafe extern "C" fn sctp_get_frag_point(
    mut stcb: *mut sctp_tcb,
    mut asoc: *mut sctp_association,
) -> libc::c_int {
    let mut siz = 0;
    let mut ovh = 0;
    /*
     * For endpoints that have both v6 and v4 addresses we must reserve
     * room for the ipv6 header, for those that are only dealing with V4
     * we use a larger frag point.
     */
    if (*(*stcb).sctp_ep).sctp_flags & 0x4000000u32 != 0 {
        ovh = (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong)
            as libc::c_int
    } else if (*(*stcb).sctp_ep).sctp_flags & 0x80000000u32 != 0 {
        ovh = ::std::mem::size_of::<sctphdr>() as libc::c_int
    } else {
        ovh = (::std::mem::size_of::<ip>() as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong)
            as libc::c_int
    }
    ovh = (ovh as libc::c_ulong).wrapping_add(if (*stcb).asoc.idata_supported as libc::c_int != 0 {
        ::std::mem::size_of::<sctp_idata_chunk>() as libc::c_ulong
    } else {
        ::std::mem::size_of::<sctp_data_chunk>() as libc::c_ulong
    }) as libc::c_int;
    if (*stcb).asoc.sctp_frag_point > (*asoc).smallest_mtu {
        siz = (*asoc).smallest_mtu.wrapping_sub(ovh as libc::c_uint) as libc::c_int
    } else {
        siz = (*stcb)
            .asoc
            .sctp_frag_point
            .wrapping_sub(ovh as libc::c_uint) as libc::c_int
    }
    /*
     * if (siz > (MCLBYTES-sizeof(struct sctp_data_chunk))) {
     */
    /* A data chunk MUST fit in a cluster */
    /* siz = (MCLBYTES - sizeof(struct sctp_data_chunk)); */
    /* } */
    /* adjust for an AUTH chunk if DATA requires auth */
    if if (*stcb).asoc.peer_auth_chunks.is_null() {
        0i32
    } else {
        ((*(*stcb).asoc.peer_auth_chunks).chunks[0usize] as libc::c_int != 0i32) as libc::c_int
    } != 0
    {
        siz = (siz as libc::c_uint).wrapping_sub(sctp_get_auth_chunk_len((*stcb).asoc.peer_hmac_id))
            as libc::c_int
    }
    if siz % 4i32 != 0 {
        /* make it an even word boundary please */
        siz -= siz % 4i32
    }
    return siz;
}
unsafe extern "C" fn sctp_set_prsctp_policy(mut sp: *mut sctp_stream_queue_pending) {
    /*
     * We assume that the user wants PR_SCTP_TTL if the user
     * provides a positive lifetime but does not specify any
     * PR_SCTP policy.
     */
    if (*sp).sinfo_flags as libc::c_int & 0xfi32 != 0i32
        && (*sp).sinfo_flags as libc::c_int & 0xfi32 != 0xfi32
    {
        (*sp).act_flags =
            ((*sp).act_flags as libc::c_int | (*sp).sinfo_flags as libc::c_int & 0xfi32) as uint16_t
    } else if (*sp).timetolive > 0u32 {
        (*sp).sinfo_flags = ((*sp).sinfo_flags as libc::c_int | 0x1i32) as uint16_t;
        (*sp).act_flags =
            ((*sp).act_flags as libc::c_int | (*sp).sinfo_flags as libc::c_int & 0xfi32) as uint16_t
    } else {
        return;
    }
    match (*sp).sinfo_flags as libc::c_int & 0xfi32 {
        2 => {
            /*
             * Time to live is a priority stored in tv_sec when
             * doing the buffer drop thing.
             */
            (*sp).ts.tv_sec = (*sp).timetolive as __time_t;
            (*sp).ts.tv_usec = 0i64
        }
        1 => {
            let mut tv = timeval {
                tv_sec: 0,
                tv_usec: 0,
            };
            gettimeofday(&mut (*sp).ts, 0 as *mut timezone);
            tv.tv_sec = (*sp).timetolive.wrapping_div(1000u32) as __time_t;
            tv.tv_usec = (*sp)
                .timetolive
                .wrapping_mul(1000u32)
                .wrapping_rem(1000000u32) as __suseconds_t;
            /* TODO sctp_constants.h needs alternative time macros when
             *  _KERNEL is undefined.
             */
            (*sp).ts.tv_sec = (*sp).ts.tv_sec + tv.tv_sec;
            (*sp).ts.tv_usec = (*sp).ts.tv_usec + tv.tv_usec;
            if (*sp).ts.tv_usec >= 1000000i64 {
                (*sp).ts.tv_sec += 1;
                (*sp).ts.tv_usec -= 1000000i64
            }
        }
        3 => {
            /*
             * Time to live is a the number or retransmissions
             * stored in tv_sec.
             */
            (*sp).ts.tv_sec = (*sp).timetolive as __time_t;
            (*sp).ts.tv_usec = 0i64
        }
        _ => {
            if system_base_info.sctpsysctl.sctp_debug_on & 0x10000000u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"Unknown PR_SCTP policy %u.\n\x00" as *const u8 as *const libc::c_char,
                        (*sp).sinfo_flags as libc::c_int & 0xfi32,
                    );
                }
            }
        }
    };
}
unsafe extern "C" fn sctp_msg_append(
    mut stcb: *mut sctp_tcb,
    mut net: *mut sctp_nets,
    mut m: *mut mbuf,
    mut srcv: *mut sctp_sndrcvinfo,
    mut hold_stcb_lock: libc::c_int,
) -> libc::c_int {
    let mut error = 0i32;
    /* Given an mbuf chain, put it
     * into the association send queue and
     * place it on the wheel
     */
    if (*srcv).sinfo_stream as libc::c_int >= (*stcb).asoc.streamoutcnt as libc::c_int {
        /* Invalid stream number */
        error = 22i32
    } else if (*stcb).asoc.stream_locked as libc::c_int != 0
        && (*stcb).asoc.stream_locked_on as libc::c_int != (*srcv).sinfo_stream as libc::c_int
    {
        error = 22i32
    } else {
        let mut strm = 0 as *mut sctp_stream_out;
        strm = &mut *(*stcb).asoc.strmout.offset((*srcv).sinfo_stream as isize)
            as *mut sctp_stream_out;
        /* Now can we send this? */
        if (*stcb).asoc.state & 0x7fi32 == 0x10i32
            || (*stcb).asoc.state & 0x7fi32 == 0x40i32
            || (*stcb).asoc.state & 0x7fi32 == 0x20i32
            || (*stcb).asoc.state & 0x80i32 != 0
        {
            /* got data while shutting down */
            error = 104i32
        } else {
            let mut sp = 0 as *mut sctp_stream_queue_pending;
            sp = malloc(system_base_info.sctppcbinfo.ipi_zone_strmoq)
                as *mut sctp_stream_queue_pending;
            if !sp.is_null() {
                memset(
                    sp as *mut libc::c_void,
                    0i32,
                    ::std::mem::size_of::<sctp_stream_queue_pending>() as libc::c_ulong,
                );
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctppcbinfo.ipi_count_strmoq,
                    1u32,
                );
                (*sp).holds_key_ref = 0u8
            }
            if sp.is_null() {
                error = 12i32
            } else {
                let mut at = 0 as *mut mbuf;
                (*sp).sinfo_flags = (*srcv).sinfo_flags;
                (*sp).timetolive = (*srcv).sinfo_timetolive;
                (*sp).ppid = (*srcv).sinfo_ppid;
                (*sp).context = (*srcv).sinfo_context;
                (*sp).fsn = 0u32;
                if (*sp).sinfo_flags as libc::c_int & 0x800i32 != 0 {
                    (*sp).net = net;
                    ::std::intrinsics::atomic_xadd(&mut (*(*sp).net).ref_count, 1i32);
                } else {
                    (*sp).net = 0 as *mut sctp_nets
                }
                gettimeofday(&mut (*sp).ts, 0 as *mut timezone);
                (*sp).sid = (*srcv).sinfo_stream;
                (*sp).msg_is_complete = 1u8;
                (*sp).sender_all_done = 1u8;
                (*sp).some_taken = 0u8;
                (*sp).data = m;
                (*sp).tail_mbuf = 0 as *mut mbuf;
                sctp_set_prsctp_policy(sp);
                /* We could in theory (for sendall) sifa the length
                 * in, but we would still have to hunt through the
                 * chain since we need to setup the tail_mbuf
                 */
                (*sp).length = 0u32;
                at = m;
                while !at.is_null() {
                    if (*at).m_hdr.mh_next.is_null() {
                        (*sp).tail_mbuf = at
                    }
                    (*sp).length = ((*sp).length).wrapping_add((*at).m_hdr.mh_len as libc::c_uint);
                    at = (*at).m_hdr.mh_next
                }
                if (*srcv).sinfo_keynumber_valid != 0 {
                    (*sp).auth_keyid = (*srcv).sinfo_keynumber
                } else {
                    (*sp).auth_keyid = (*stcb).asoc.authinfo.active_keyid
                }
                if if (*stcb).asoc.peer_auth_chunks.is_null() {
                    0i32
                } else {
                    ((*(*stcb).asoc.peer_auth_chunks).chunks[0usize] as libc::c_int != 0i32)
                        as libc::c_int
                } != 0
                {
                    sctp_auth_key_acquire(stcb, (*sp).auth_keyid);
                    (*sp).holds_key_ref = 1u8
                }
                if hold_stcb_lock == 0i32 {
                    pthread_mutex_lock(&mut (*stcb).tcb_send_mtx);
                }
                ::std::intrinsics::atomic_xadd(
                    &mut (*stcb).asoc.total_output_queue_size,
                    (*sp).length,
                );
                if !(*stcb).sctp_socket.is_null()
                    && ((*(*stcb).sctp_ep).sctp_flags & 0x2u32 != 0
                        || (*(*stcb).sctp_ep).sctp_flags & 0x400000u32 != 0)
                {
                    ::std::intrinsics::atomic_xadd(
                        &mut (*(*stcb).sctp_socket).so_snd.sb_cc,
                        (*sp).length,
                    );
                }
                ::std::intrinsics::atomic_xadd(&mut (*stcb).asoc.stream_queue_cnt, 1u32);
                (*sp).next.tqe_next = 0 as *mut sctp_stream_queue_pending;
                (*sp).next.tqe_prev = (*strm).outqueue.tqh_last;
                *(*strm).outqueue.tqh_last = sp;
                (*strm).outqueue.tqh_last = &mut (*sp).next.tqe_next;
                (*stcb)
                    .asoc
                    .ss_functions
                    .sctp_ss_add_to_stream
                    .expect("non-null function pointer")(
                    stcb, &mut (*stcb).asoc, strm, sp, 1i32
                );
                m = 0 as *mut mbuf;
                if hold_stcb_lock == 0i32 {
                    pthread_mutex_unlock(&mut (*stcb).tcb_send_mtx);
                }
            }
        }
    }
    if !m.is_null() {
        m_freem(m);
    }
    return error;
}
unsafe extern "C" fn sctp_copy_mbufchain(
    mut clonechain: *mut mbuf,
    mut outchain: *mut mbuf,
    mut endofchain: *mut *mut mbuf,
    mut can_take_mbuf: libc::c_int,
    mut sizeofcpy: libc::c_int,
    mut copy_by_ref: uint8_t,
) -> *mut mbuf {
    if !endofchain.is_null() {
        let mut current_block: u64;
        let mut m = 0 as *mut mbuf;
        let mut appendchain = 0 as *mut mbuf;
        if can_take_mbuf != 0 {
            appendchain = clonechain;
            current_block = 14945149239039849694;
        } else if copy_by_ref == 0
            && sizeofcpy
                <= system_base_info
                    .sctpsysctl
                    .sctp_mbuf_threshold_count
                    .wrapping_sub(1u32)
                    .wrapping_mul(
                        (256u64).wrapping_sub(::std::mem::size_of::<m_hdr>() as libc::c_ulong)
                            as libc::c_uint,
                    )
                    .wrapping_add(
                        ((256u64).wrapping_sub(::std::mem::size_of::<m_hdr>() as libc::c_ulong)
                            as libc::c_int as libc::c_ulong)
                            .wrapping_sub(::std::mem::size_of::<pkthdr>() as libc::c_ulong)
                            as libc::c_uint,
                    ) as libc::c_int
        {
            let mut len = 0;
            if (*endofchain).is_null() {
                /* lets get a mbuf cluster */
                if outchain.is_null() {
                    current_block = 17083085471943351580;
                } else {
                    /* We really should not get a NULL in endofchain */
                    /* find end */
                    m = outchain;
                    while !m.is_null() {
                        if (*m).m_hdr.mh_next.is_null() {
                            *endofchain = m;
                            break;
                        } else {
                            m = (*m).m_hdr.mh_next
                        }
                    }
                    /* sanity */
                    if (*endofchain).is_null() {
                        /* huh, TSNH XXX maybe we should panic */
                        m_freem(outchain);
                        current_block = 17083085471943351580;
                    } else {
                        current_block = 15925075030174552612;
                    }
                }
                match current_block {
                    17083085471943351580 =>
                    /* This is the general case */
                    {
                        outchain = sctp_get_mbuf_for_msg(2048u32, 0i32, 0x1i32, 1i32, 1i32);
                        if outchain.is_null() {
                            current_block = 3768355041895918160;
                        } else {
                            (*outchain).m_hdr.mh_len = 0i32;
                            *endofchain = outchain;
                            /* get the prepend space */
                            (*outchain).m_hdr.mh_data =
                                (*outchain).m_hdr.mh_data.offset((68i32 + 4i32) as isize);
                            current_block = 15925075030174552612;
                        }
                    }
                    _ => {}
                }
                match current_block {
                    3768355041895918160 => {}
                    _ => {
                        /* get the new end of length */
                        len = if (**endofchain).m_hdr.mh_flags & 0x1i32 != 0 {
                            if (**endofchain).m_hdr.mh_flags & 0x8i32 == 0
                                && ((**endofchain).m_hdr.mh_flags & 0x1i32 == 0
                                    || *(**endofchain).M_dat.MH.MH_dat.MH_ext.ref_cnt == 1u32)
                            {
                                (**endofchain)
                                    .M_dat
                                    .MH
                                    .MH_dat
                                    .MH_ext
                                    .ext_buf
                                    .offset((**endofchain).M_dat.MH.MH_dat.MH_ext.ext_size as isize)
                                    .wrapping_offset_from(
                                        (**endofchain)
                                            .m_hdr
                                            .mh_data
                                            .offset((**endofchain).m_hdr.mh_len as isize),
                                    ) as libc::c_long
                            } else {
                                0i64
                            }
                        } else {
                            (&mut *(**endofchain).M_dat.M_databuf.as_mut_ptr().offset(
                                (256u64)
                                    .wrapping_sub(::std::mem::size_of::<m_hdr>() as libc::c_ulong)
                                    as libc::c_int as isize,
                            ) as *mut libc::c_char)
                                .wrapping_offset_from(
                                    (**endofchain)
                                        .m_hdr
                                        .mh_data
                                        .offset((**endofchain).m_hdr.mh_len as isize),
                                ) as libc::c_long
                        } as libc::c_int;
                        current_block = 11459959175219260272;
                    }
                }
            } else {
                /* how much is left at the end? */
                len = if (**endofchain).m_hdr.mh_flags & 0x1i32 != 0 {
                    if (**endofchain).m_hdr.mh_flags & 0x8i32 == 0
                        && ((**endofchain).m_hdr.mh_flags & 0x1i32 == 0
                            || *(**endofchain).M_dat.MH.MH_dat.MH_ext.ref_cnt == 1u32)
                    {
                        (**endofchain)
                            .M_dat
                            .MH
                            .MH_dat
                            .MH_ext
                            .ext_buf
                            .offset((**endofchain).M_dat.MH.MH_dat.MH_ext.ext_size as isize)
                            .wrapping_offset_from(
                                (**endofchain)
                                    .m_hdr
                                    .mh_data
                                    .offset((**endofchain).m_hdr.mh_len as isize),
                            ) as libc::c_long
                    } else {
                        0i64
                    }
                } else {
                    (&mut *(**endofchain).M_dat.M_databuf.as_mut_ptr().offset(
                        (256u64).wrapping_sub(::std::mem::size_of::<m_hdr>() as libc::c_ulong)
                            as libc::c_int as isize,
                    ) as *mut libc::c_char)
                        .wrapping_offset_from(
                            (**endofchain)
                                .m_hdr
                                .mh_data
                                .offset((**endofchain).m_hdr.mh_len as isize),
                        ) as libc::c_long
                } as libc::c_int;
                current_block = 11459959175219260272;
            }
            match current_block {
                3768355041895918160 => {}
                _ => {
                    let mut cp = 0 as *mut libc::c_char;
                    cp = (**endofchain)
                        .m_hdr
                        .mh_data
                        .offset((**endofchain).m_hdr.mh_len as isize);
                    /* Now lets copy it out */
                    if len >= sizeofcpy {
                        /* It all fits, copy it in */
                        m_copydata(clonechain, 0i32, sizeofcpy, cp);
                        (**endofchain).m_hdr.mh_len += sizeofcpy;
                        current_block = 3160140712158701372;
                    } else {
                        /* fill up the end of the chain */
                        if len > 0i32 {
                            m_copydata(clonechain, 0i32, len, cp);
                            (**endofchain).m_hdr.mh_len += len;
                            /* now we need another one */
                            sizeofcpy -= len
                        }
                        m = sctp_get_mbuf_for_msg(2048u32, 0i32, 0x1i32, 1i32, 1i32);
                        if m.is_null() {
                            current_block = 3768355041895918160;
                        } else {
                            (**endofchain).m_hdr.mh_next = m;
                            *endofchain = m;
                            cp = (**endofchain).m_hdr.mh_data;
                            m_copydata(clonechain, len, sizeofcpy, cp);
                            (**endofchain).m_hdr.mh_len += sizeofcpy;
                            current_block = 3160140712158701372;
                        }
                    }
                    match current_block {
                        3768355041895918160 => {}
                        _ => return outchain,
                    }
                }
            }
        } else {
            /* copy the old fashion way */
            appendchain = m_copym(clonechain, 0i32, 1000000000i32, 0x1i32);
            current_block = 14945149239039849694;
        }
        match current_block {
            3768355041895918160 => {}
            _ => {
                if appendchain.is_null() {
                    /* error */
                    if !outchain.is_null() {
                        m_freem(outchain);
                    }
                    return 0 as *mut mbuf;
                }
                if !outchain.is_null() {
                    /* tack on to the end */
                    if !(*endofchain).is_null() {
                        (**endofchain).m_hdr.mh_next = appendchain
                    } else {
                        m = outchain;
                        while !m.is_null() {
                            if (*m).m_hdr.mh_next.is_null() {
                                (*m).m_hdr.mh_next = appendchain;
                                break;
                            } else {
                                m = (*m).m_hdr.mh_next
                            }
                        }
                    }
                    /*
                     * save off the end and update the end-chain
                     * position
                     */
                    m = appendchain;
                    while !m.is_null() {
                        if (*m).m_hdr.mh_next.is_null() {
                            *endofchain = m;
                            break;
                        } else {
                            m = (*m).m_hdr.mh_next
                        }
                    }
                    return outchain;
                } else {
                    /* save off the end and update the end-chain position */
                    m = appendchain;
                    while !m.is_null() {
                        if (*m).m_hdr.mh_next.is_null() {
                            *endofchain = m;
                            break;
                        } else {
                            m = (*m).m_hdr.mh_next
                        }
                    }
                    return appendchain;
                }
            }
        }
    }
    /* We failed */
    if !outchain.is_null() {
        m_freem(outchain);
    }
    return 0 as *mut mbuf;
}
unsafe extern "C" fn sctp_sendall_iterator(
    mut inp: *mut sctp_inpcb,
    mut stcb: *mut sctp_tcb,
    mut ptr: *mut libc::c_void,
    mut val: uint32_t,
) {
    let mut ca = 0 as *mut sctp_copy_all;
    let mut m = 0 as *mut mbuf;
    let mut ret = 0i32;
    let mut net = 0 as *mut sctp_nets;
    ca = ptr as *mut sctp_copy_all;
    if (*ca).m.is_null() {
        return;
    }
    if (*ca).inp != inp {
        /* TSNH */
        return;
    }
    if (*ca).sndlen > 0i64 {
        m = m_copym((*ca).m, 0i32, 1000000000i32, 0x1i32);
        if m.is_null() {
            /* can't copy so we are done */
            (*ca).cnt_failed += 1;
            return;
        }
    } else {
        m = 0 as *mut mbuf
    }
    if !(*stcb).asoc.alternate.is_null() {
        net = (*stcb).asoc.alternate
    } else {
        net = (*stcb).asoc.primary_destination
    }
    if (*ca).sndrcv.sinfo_flags as libc::c_int & 0x200i32 != 0 {
        /* Abort this assoc with m as the user defined reason */
        if !m.is_null() {
            let mut _mplen = ::std::mem::size_of::<sctp_paramhdr>() as libc::c_int;
            let mut _mmp = &mut m;
            let mut _mm = *_mmp;

            if (if (*_mm).m_hdr.mh_flags & 0x1i32 != 0 {
                (if (*_mm).m_hdr.mh_flags & 0x8i32 == 0
                    && ((*_mm).m_hdr.mh_flags & 0x1i32 == 0
                        || *(*_mm).M_dat.MH.MH_dat.MH_ext.ref_cnt == 1u32)
                {
                    (*_mm)
                        .m_hdr
                        .mh_data
                        .wrapping_offset_from((*_mm).M_dat.MH.MH_dat.MH_ext.ext_buf)
                        as libc::c_long
                } else {
                    0i64
                })
            } else {
                (if (*_mm).m_hdr.mh_flags & 0x2i32 != 0 {
                    (*_mm)
                        .m_hdr
                        .mh_data
                        .wrapping_offset_from((*_mm).M_dat.MH.MH_dat.MH_databuf.as_mut_ptr())
                        as libc::c_long
                } else {
                    (*_mm)
                        .m_hdr
                        .mh_data
                        .wrapping_offset_from((*_mm).M_dat.M_databuf.as_mut_ptr())
                        as libc::c_long
                })
            }) >= _mplen as libc::c_long
            {
                (*_mm).m_hdr.mh_data = (*_mm).m_hdr.mh_data.offset(-(_mplen as isize));
                (*_mm).m_hdr.mh_len += _mplen
            } else {
                let mut __mhow = 0x1i32;
                _mm = m_prepend(_mm, _mplen, __mhow)
            }
            if !_mm.is_null() && (*_mm).m_hdr.mh_flags & 0x2i32 != 0 {
                (*_mm).M_dat.MH.MH_pkthdr.len += _mplen
            }
            *_mmp = _mm
        } else {
            m = sctp_get_mbuf_for_msg(
                ::std::mem::size_of::<sctp_paramhdr>() as libc::c_uint,
                0i32,
                0x1i32,
                1i32,
                1i32,
            );
            (*m).m_hdr.mh_len = ::std::mem::size_of::<sctp_paramhdr>() as libc::c_int
        }
        if !m.is_null() {
            let mut ph = 0 as *mut sctp_paramhdr;
            ph = (*m).m_hdr.mh_data as *mut sctp_paramhdr;
            (*ph).param_type = htons(0xcu16);
            (*ph).param_length = htons(
                (::std::mem::size_of::<sctp_paramhdr>() as libc::c_ulong)
                    .wrapping_add((*ca).sndlen as libc::c_ulong) as uint16_t,
            )
        }
        /* We add one here to keep the assoc from
         * dis-appearing on us.
         */
        ::std::intrinsics::atomic_xadd(&mut (*stcb).asoc.refcnt, 1u32);
        sctp_abort_an_association(inp, stcb, m, 0i32);
        /* sctp_abort_an_association calls sctp_free_asoc()
         * free association will NOT free it since we
         * incremented the refcnt .. we do this to prevent
         * it being freed and things getting tricky since
         * we could end up (from free_asoc) calling inpcb_free
         * which would get a recursive lock call to the
         * iterator lock.. But as a consequence of that the
         * stcb will return to us un-locked.. since free_asoc
         * returns with either no TCB or the TCB unlocked, we
         * must relock.. to unlock in the iterator timer :-0
         */
        pthread_mutex_lock(&mut (*stcb).tcb_mtx);
        ::std::intrinsics::atomic_xadd(&mut (*stcb).asoc.refcnt, -(1i32) as uint32_t);
    } else {
        let mut current_block: u64;
        let mut added_control = 0i32;
        let mut do_chunk_output = 1i32;
        let mut asoc = 0 as *mut sctp_association;
        if !m.is_null() {
            ret = sctp_msg_append(stcb, net, m, &mut (*ca).sndrcv, 1i32)
        }
        asoc = &mut (*stcb).asoc;
        if (*ca).sndrcv.sinfo_flags as libc::c_int & 0x100i32 != 0 {
            let mut op_err = 0 as *mut mbuf;
            let mut msg = [0; 128];
            if (*asoc).send_queue.tqh_first.is_null()
                && (*asoc).sent_queue.tqh_first.is_null()
                && sctp_is_there_unsent_data(stcb, 0i32) == 0i32
            {
                if Some(
                    (*asoc)
                        .ss_functions
                        .sctp_ss_is_user_msgs_incomplete
                        .expect("non-null function pointer"),
                )
                .expect("non-null function pointer")(stcb, asoc)
                    != 0
                {
                    current_block = 18238719995905865279;
                } else {
                    /* there is nothing queued to send, so I'm done... */
                    if (*stcb).asoc.state & 0x7fi32 != 0x10i32
                        && (*stcb).asoc.state & 0x7fi32 != 0x20i32
                        && (*stcb).asoc.state & 0x7fi32 != 0x40i32
                    {
                        /* only send SHUTDOWN the first time through */
                        if (*stcb).asoc.state & 0x7fi32 == 0x8i32 {
                            ::std::intrinsics::atomic_xsub(
                                &mut system_base_info.sctpstat.sctps_currestab,
                                1u32,
                            );
                        }
                        sctp_set_state(stcb, 0x10i32);
                        sctp_stop_timers_for_shutdown(stcb);
                        sctp_send_shutdown(stcb, net);
                        sctp_timer_start(4i32, (*stcb).sctp_ep, stcb, net);
                        sctp_timer_start(11i32, (*stcb).sctp_ep, stcb, (*asoc).primary_destination);
                        added_control = 1i32;
                        do_chunk_output = 0i32
                    }
                    current_block = 3879520548144599102;
                }
            } else if (*stcb).asoc.state & 0x7fi32 != 0x10i32
                && (*stcb).asoc.state & 0x7fi32 != 0x20i32
                && (*stcb).asoc.state & 0x7fi32 != 0x40i32
            {
                if Some(
                    (*asoc)
                        .ss_functions
                        .sctp_ss_is_user_msgs_incomplete
                        .expect("non-null function pointer"),
                )
                .expect("non-null function pointer")(stcb, asoc)
                    != 0
                {
                    sctp_add_substate(stcb, 0x400i32);
                }
                sctp_add_substate(stcb, 0x80i32);
                if (*asoc).send_queue.tqh_first.is_null()
                    && (*asoc).sent_queue.tqh_first.is_null()
                    && (*asoc).state & 0x400i32 != 0
                {
                    op_err = 0 as *mut mbuf;
                    msg = [0; 128];
                    current_block = 18238719995905865279;
                } else {
                    sctp_timer_start(11i32, (*stcb).sctp_ep, stcb, (*asoc).primary_destination);
                    current_block = 3879520548144599102;
                }
            } else {
                current_block = 3879520548144599102;
            }
            match current_block {
                3879520548144599102 => {}
                _ => {
                    snprintf(msg.as_mut_ptr(),
                             ::std::mem::size_of::<[libc::c_char; 128]>() as
                                 libc::c_ulong,
                             b"%s:%d at %s\x00" as *const u8 as
                                 *const libc::c_char,
                             b"/usr/local/google/home/winniexiao/chromium/src/third_party/usrsctp/usrsctplib/usrsctplib/netinet/sctp_output.c\x00"
                                 as *const u8 as *const libc::c_char,
                             7255i32,
                             (*::std::mem::transmute::<&[u8; 22],
                                                       &[libc::c_char; 22]>(b"sctp_sendall_iterator\x00")).as_ptr());
                    op_err = sctp_generate_cause(
                        system_base_info.sctpsysctl.sctp_diag_info_code as uint16_t,
                        msg.as_mut_ptr(),
                    );
                    ::std::intrinsics::atomic_xadd(&mut (*stcb).asoc.refcnt, 1u32);
                    sctp_abort_an_association((*stcb).sctp_ep, stcb, op_err, 0i32);
                    ::std::intrinsics::atomic_xadd(&mut (*stcb).asoc.refcnt, -(1i32) as uint32_t);
                    current_block = 14082154601095379914;
                }
            }
        } else {
            current_block = 3879520548144599102;
        }
        match current_block {
            14082154601095379914 => {}
            _ => {
                let mut un_sent = 0;
                un_sent = ((*stcb)
                    .asoc
                    .total_output_queue_size
                    .wrapping_sub((*stcb).asoc.total_flight)
                    as libc::c_ulong)
                    .wrapping_add(
                        ((*stcb).asoc.stream_queue_cnt as libc::c_ulong).wrapping_mul(
                            (if (*stcb).asoc.idata_supported as libc::c_int != 0 {
                                ::std::mem::size_of::<sctp_idata_chunk>() as libc::c_ulong
                            } else {
                                ::std::mem::size_of::<sctp_data_chunk>() as libc::c_ulong
                            }),
                        ),
                    ) as libc::c_int;
                if (*inp).sctp_features & 0x100u64 == 0u64
                    && (*stcb).asoc.total_flight > 0u32
                    && un_sent
                        < ((*stcb).asoc.smallest_mtu as libc::c_ulong).wrapping_sub(
                            (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
                                .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong),
                        ) as libc::c_int
                {
                    do_chunk_output = 0i32
                }
                if do_chunk_output != 0 {
                    sctp_chunk_output(inp, stcb, 0i32, 0i32);
                } else if added_control != 0 {
                    let mut num_out = 0;
                    let mut reason = 0;
                    let mut now_filled = 0i32;
                    let mut now = timeval {
                        tv_sec: 0,
                        tv_usec: 0,
                    };
                    let mut frag_point = 0;
                    frag_point = sctp_get_frag_point(stcb, &mut (*stcb).asoc);
                    sctp_med_chunk_output(
                        inp,
                        stcb,
                        &mut (*stcb).asoc,
                        &mut num_out,
                        &mut reason,
                        1i32,
                        1i32,
                        &mut now,
                        &mut now_filled,
                        frag_point,
                        0i32,
                    );
                }
            }
        }
    }
    if ret != 0 {
        (*ca).cnt_failed += 1
    } else {
        (*ca).cnt_sent += 1
    };
}
unsafe extern "C" fn sctp_sendall_completes(mut ptr: *mut libc::c_void, mut val: uint32_t) {
    let mut ca = 0 as *mut sctp_copy_all;
    ca = ptr as *mut sctp_copy_all;
    /*
     * we still got (or just got) data to send, so set
     * SHUTDOWN_PENDING
     */
    /*
     * XXX sockets draft says that SCTP_EOF should be
     * sent with no data.  currently, we will allow user
     * data to be sent first and move to
     * SHUTDOWN-PENDING
     */
    /*
     * Do a notify here? Kacheong suggests that the notify be done at
     * the send time.. so you would push up a notification if any send
     * failed. Don't know if this is feasible since the only failures we
     * have is "memory" related and if you cannot get an mbuf to send
     * the data you surely can't get an mbuf to send up to notify the
     * user you can't send the data :->
     */
    /* now free everything */
    if !(*ca).inp.is_null() {
        /* Lets clear the flag to allow others to run. */
        (*(*ca).inp).sctp_flags &= !(0x20i32) as libc::c_uint
    }
    m_freem((*ca).m);
    free(ca as *mut libc::c_void);
}
unsafe extern "C" fn sctp_copy_out_all(mut uio: *mut uio, mut len: ssize_t) -> *mut mbuf {
    let mut ret = 0 as *mut mbuf;
    let mut at = 0 as *mut mbuf;
    let mut left = 0;
    let mut willcpy = 0;
    let mut cancpy = 0;
    ret = sctp_get_mbuf_for_msg(2048u32, 0i32, 0x2i32, 1i32, 1i32);
    if ret.is_null() {
        /* TSNH */
        return 0 as *mut mbuf;
    }
    left = len;
    (*ret).m_hdr.mh_len = 0i32;
    /* save space for the data chunk header */
    cancpy = if (*ret).m_hdr.mh_flags & 0x1i32 != 0 {
        if (*ret).m_hdr.mh_flags & 0x8i32 == 0
            && ((*ret).m_hdr.mh_flags & 0x1i32 == 0
                || *(*ret).M_dat.MH.MH_dat.MH_ext.ref_cnt == 1u32)
        {
            (*ret)
                .M_dat
                .MH
                .MH_dat
                .MH_ext
                .ext_buf
                .offset((*ret).M_dat.MH.MH_dat.MH_ext.ext_size as isize)
                .wrapping_offset_from((*ret).m_hdr.mh_data.offset((*ret).m_hdr.mh_len as isize))
                as libc::c_long
        } else {
            0i64
        }
    } else {
        (&mut *(*ret).M_dat.M_databuf.as_mut_ptr().offset(
            (256u64).wrapping_sub(::std::mem::size_of::<m_hdr>() as libc::c_ulong) as libc::c_int
                as isize,
        ) as *mut libc::c_char)
            .wrapping_offset_from((*ret).m_hdr.mh_data.offset((*ret).m_hdr.mh_len as isize))
            as libc::c_long
    } as libc::c_int as ssize_t;
    willcpy = if cancpy > left { left } else { cancpy };
    at = ret;
    while left > 0i64 {
        's_118: {
            let mut error = 0;
            /* Align data to the end */
            error = uiomove(
                (*at).m_hdr.mh_data as *mut libc::c_void,
                willcpy as libc::c_int,
                uio,
            ) as ssize_t;
            if !(error != 0) {
                let mut current_block_19: u64;
                (*at).m_hdr.mh_len = willcpy as libc::c_int;
                (*at).m_hdr.mh_next = 0 as *mut mbuf;
                (*at).m_hdr.mh_nextpkt = (*at).m_hdr.mh_next;
                left -= willcpy;
                if left > 0i64 {
                    (*at).m_hdr.mh_next =
                        sctp_get_mbuf_for_msg(left as libc::c_uint, 0i32, 0x2i32, 1i32, 1i32);
                    if (*at).m_hdr.mh_next.is_null() {
                        current_block_19 = 1640775038293379178;
                    } else {
                        at = (*at).m_hdr.mh_next;
                        (*at).m_hdr.mh_len = 0i32;
                        cancpy = if (*at).m_hdr.mh_flags & 0x1i32 != 0 {
                            if (*at).m_hdr.mh_flags & 0x8i32 == 0
                                && ((*at).m_hdr.mh_flags & 0x1i32 == 0
                                    || *(*at).M_dat.MH.MH_dat.MH_ext.ref_cnt == 1u32)
                            {
                                (*at)
                                    .M_dat
                                    .MH
                                    .MH_dat
                                    .MH_ext
                                    .ext_buf
                                    .offset((*at).M_dat.MH.MH_dat.MH_ext.ext_size as isize)
                                    .wrapping_offset_from(
                                        (*at).m_hdr.mh_data.offset((*at).m_hdr.mh_len as isize),
                                    ) as libc::c_long
                            } else {
                                0i64
                            }
                        } else {
                            (&mut *(*at).M_dat.M_databuf.as_mut_ptr().offset(
                                (256u64)
                                    .wrapping_sub(::std::mem::size_of::<m_hdr>() as libc::c_ulong)
                                    as libc::c_int as isize,
                            ) as *mut libc::c_char)
                                .wrapping_offset_from(
                                    (*at).m_hdr.mh_data.offset((*at).m_hdr.mh_len as isize),
                                ) as libc::c_long
                        } as libc::c_int as ssize_t;
                        willcpy = if cancpy > left { left } else { cancpy };
                        current_block_19 = 5634871135123216486;
                    }
                } else {
                    current_block_19 = 5634871135123216486;
                }
                match current_block_19 {
                    1640775038293379178 => {}
                    _ => {
                        break 's_118;
                    }
                }
            }
            m_freem(at);
            return 0 as *mut mbuf;
        }
    }
    return ret;
}
unsafe extern "C" fn sctp_sendall(
    mut inp: *mut sctp_inpcb,
    mut uio: *mut uio,
    mut m: *mut mbuf,
    mut srcv: *mut sctp_sndrcvinfo,
) -> libc::c_int {
    let mut ret = 0;
    let mut ca = 0 as *mut sctp_copy_all;
    if (*inp).sctp_flags & 0x20u32 != 0 {
        /* There is another. */
        return 16i32;
    }
    if (*uio).uio_resid > system_base_info.sctpsysctl.sctp_sendall_limit as ssize_t {
        /* You must not be larger than the limit! */
        return 90i32;
    }
    ca = malloc(::std::mem::size_of::<sctp_copy_all>() as libc::c_ulong) as *mut sctp_copy_all;
    if 0x1i32 & 0x100i32 != 0 {
        memset(
            ca as *mut libc::c_void,
            0i32,
            ::std::mem::size_of::<sctp_copy_all>() as libc::c_ulong,
        );
    }
    if ca.is_null() {
        m_freem(m);
        return 12i32;
    }
    memset(
        ca as *mut libc::c_void,
        0i32,
        ::std::mem::size_of::<sctp_copy_all>() as libc::c_ulong,
    );
    (*ca).inp = inp;
    if !srcv.is_null() {
        memcpy(
            &mut (*ca).sndrcv as *mut sctp_sndrcvinfo as *mut libc::c_void,
            srcv as *const libc::c_void,
            ::std::mem::size_of::<sctp_nonpad_sndrcvinfo>() as libc::c_ulong,
        );
    }
    /*
     * take off the sendall flag, it would be bad if we failed to do
     * this :-0
     */
    (*ca).sndrcv.sinfo_flags = ((*ca).sndrcv.sinfo_flags as libc::c_int & !(0x1000i32)) as uint16_t;
    /* get length and mbuf chain */
    if !uio.is_null() {
        (*ca).sndlen = (*uio).uio_resid;
        (*ca).m = sctp_copy_out_all(uio, (*ca).sndlen);
        if (*ca).m.is_null() {
            free(ca as *mut libc::c_void);
            return 12i32;
        }
    } else {
        let mut mat = 0 as *mut mbuf;
        (*ca).sndlen = 0i64;
        mat = m;
        while !mat.is_null() {
            (*ca).sndlen += (*mat).m_hdr.mh_len as libc::c_long;
            mat = (*mat).m_hdr.mh_next
        }
    }
    (*inp).sctp_flags |= 0x20u32;
    ret = sctp_initiate_iterator(
        None,
        Some(
            sctp_sendall_iterator
                as unsafe extern "C" fn(
                    _: *mut sctp_inpcb,
                    _: *mut sctp_tcb,
                    _: *mut libc::c_void,
                    _: uint32_t,
                ) -> (),
        ),
        None,
        0u32,
        0u32,
        0u32,
        ca as *mut libc::c_void,
        0u32,
        Some(
            sctp_sendall_completes as unsafe extern "C" fn(_: *mut libc::c_void, _: uint32_t) -> (),
        ),
        inp,
        1u8,
    );
    if ret != 0 {
        (*inp).sctp_flags &= !(0x20i32) as libc::c_uint;
        free(ca as *mut libc::c_void);
        return 14i32;
    }
    return 0i32;
}
#[no_mangle]
pub unsafe extern "C" fn sctp_toss_old_cookies(
    mut stcb: *mut sctp_tcb,
    mut asoc: *mut sctp_association,
) {
    let mut chk = 0 as *mut sctp_tmit_chunk;
    let mut nchk = 0 as *mut sctp_tmit_chunk;
    chk = (*asoc).control_send_queue.tqh_first;
    while !chk.is_null() && {
        nchk = (*chk).sctp_next.tqe_next;
        (1i32) != 0
    } {
        if (*chk).rec.chunk_id.id as libc::c_int == 0xai32 {
            if !(*chk).sctp_next.tqe_next.is_null() {
                (*(*chk).sctp_next.tqe_next).sctp_next.tqe_prev = (*chk).sctp_next.tqe_prev
            } else {
                (*asoc).control_send_queue.tqh_last = (*chk).sctp_next.tqe_prev
            }
            *(*chk).sctp_next.tqe_prev = (*chk).sctp_next.tqe_next;
            (*asoc).ctrl_queue_cnt -= 1;
            if !(*chk).data.is_null() {
                m_freem((*chk).data);
                (*chk).data = 0 as *mut mbuf
            }
            if (*chk).holds_key_ref != 0 {
                sctp_auth_key_release(stcb, (*chk).auth_keyid, 0i32);
                (*chk).holds_key_ref = 0u8
            }
            if !stcb.is_null() {
                if !(*chk).whoTo.is_null() {
                    if !(*chk).whoTo.is_null() {
                        if ::std::intrinsics::atomic_xadd(
                            &mut (*(*chk).whoTo).ref_count as *mut libc::c_int,
                            -(1i32),
                        ) == 1i32
                        {
                            sctp_os_timer_stop(&mut (*(*chk).whoTo).rxt_timer.timer);
                            sctp_os_timer_stop(&mut (*(*chk).whoTo).pmtu_timer.timer);
                            sctp_os_timer_stop(&mut (*(*chk).whoTo).hb_timer.timer);
                            if !(*(*chk).whoTo).ro.ro_rt.is_null() {
                                if (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt <= 1i64 {
                                    sctp_userspace_rtfree((*(*chk).whoTo).ro.ro_rt);
                                } else {
                                    (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt -= 1
                                }
                                (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t;
                                (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t
                            }
                            if (*(*chk).whoTo).src_addr_selected != 0 {
                                sctp_free_ifa((*(*chk).whoTo).ro._s_addr);
                                (*(*chk).whoTo).ro._s_addr = 0 as *mut sctp_ifa
                            }
                            (*(*chk).whoTo).src_addr_selected = 0u8;
                            (*(*chk).whoTo).dest_state =
                                ((*(*chk).whoTo).dest_state as libc::c_int & !(0x1i32)) as uint16_t;
                            free((*chk).whoTo as *mut libc::c_void);
                            ::std::intrinsics::atomic_xsub(
                                &mut system_base_info.sctppcbinfo.ipi_count_raddr,
                                1u32,
                            );
                        }
                    }
                    (*chk).whoTo = 0 as *mut sctp_nets
                }
                if (*stcb).asoc.free_chunk_cnt as libc::c_uint
                    > system_base_info.sctpsysctl.sctp_asoc_free_resc_limit
                    || system_base_info.sctppcbinfo.ipi_free_chunks
                        > system_base_info.sctpsysctl.sctp_system_free_resc_limit
                {
                    free(chk as *mut libc::c_void);
                    ::std::intrinsics::atomic_xsub(
                        &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                        1u32,
                    );
                } else {
                    (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
                    (*chk).sctp_next.tqe_prev = (*stcb).asoc.free_chunks.tqh_last;
                    *(*stcb).asoc.free_chunks.tqh_last = chk;
                    (*stcb).asoc.free_chunks.tqh_last = &mut (*chk).sctp_next.tqe_next;
                    (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_add(1);
                    ::std::intrinsics::atomic_xadd(
                        &mut system_base_info.sctppcbinfo.ipi_free_chunks,
                        1u32,
                    );
                }
            } else {
                free(chk as *mut libc::c_void);
                ::std::intrinsics::atomic_xsub(
                    &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                    1u32,
                );
            }
        }
        chk = nchk
    }
}
#[no_mangle]
pub unsafe extern "C" fn sctp_toss_old_asconf(mut stcb: *mut sctp_tcb) {
    let mut asoc = 0 as *mut sctp_association;
    let mut chk = 0 as *mut sctp_tmit_chunk;
    let mut nchk = 0 as *mut sctp_tmit_chunk;
    asoc = &mut (*stcb).asoc;
    chk = (*asoc).asconf_send_queue.tqh_first;
    while !chk.is_null() && {
        nchk = (*chk).sctp_next.tqe_next;
        (1i32) != 0
    } {
        /* find SCTP_ASCONF chunk in queue */
        if (*chk).rec.chunk_id.id as libc::c_int == 0xc1i32 {
            if !(*chk).data.is_null() {
                let mut acp = 0 as *mut sctp_asconf_chunk;
                acp = (*(*chk).data).m_hdr.mh_data as *mut sctp_asconf_chunk;
                if ntohl((*acp).serial_number) < (*asoc).asconf_seq_out_acked
                    && (*asoc)
                        .asconf_seq_out_acked
                        .wrapping_sub(ntohl((*acp).serial_number))
                        > (1u32) << 31i32
                    || ntohl((*acp).serial_number) > (*asoc).asconf_seq_out_acked
                        && ntohl((*acp).serial_number).wrapping_sub((*asoc).asconf_seq_out_acked)
                            < (1u32) << 31i32
                {
                    break;
                }
            }
            if !(*chk).sctp_next.tqe_next.is_null() {
                (*(*chk).sctp_next.tqe_next).sctp_next.tqe_prev = (*chk).sctp_next.tqe_prev
            } else {
                (*asoc).asconf_send_queue.tqh_last = (*chk).sctp_next.tqe_prev
            }
            *(*chk).sctp_next.tqe_prev = (*chk).sctp_next.tqe_next;
            (*asoc).ctrl_queue_cnt -= 1;
            if !(*chk).data.is_null() {
                m_freem((*chk).data);
                (*chk).data = 0 as *mut mbuf
            }
            if (*chk).holds_key_ref != 0 {
                sctp_auth_key_release(stcb, (*chk).auth_keyid, 0i32);
                (*chk).holds_key_ref = 0u8
            }
            if !stcb.is_null() {
                if !(*chk).whoTo.is_null() {
                    if !(*chk).whoTo.is_null() {
                        if ::std::intrinsics::atomic_xadd(
                            &mut (*(*chk).whoTo).ref_count as *mut libc::c_int,
                            -(1i32),
                        ) == 1i32
                        {
                            sctp_os_timer_stop(&mut (*(*chk).whoTo).rxt_timer.timer);
                            sctp_os_timer_stop(&mut (*(*chk).whoTo).pmtu_timer.timer);
                            sctp_os_timer_stop(&mut (*(*chk).whoTo).hb_timer.timer);
                            if !(*(*chk).whoTo).ro.ro_rt.is_null() {
                                if (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt <= 1i64 {
                                    sctp_userspace_rtfree((*(*chk).whoTo).ro.ro_rt);
                                } else {
                                    (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt -= 1
                                }
                                (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t;
                                (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t
                            }
                            if (*(*chk).whoTo).src_addr_selected != 0 {
                                sctp_free_ifa((*(*chk).whoTo).ro._s_addr);
                                (*(*chk).whoTo).ro._s_addr = 0 as *mut sctp_ifa
                            }
                            (*(*chk).whoTo).src_addr_selected = 0u8;
                            (*(*chk).whoTo).dest_state =
                                ((*(*chk).whoTo).dest_state as libc::c_int & !(0x1i32)) as uint16_t;
                            free((*chk).whoTo as *mut libc::c_void);
                            ::std::intrinsics::atomic_xsub(
                                &mut system_base_info.sctppcbinfo.ipi_count_raddr,
                                1u32,
                            );
                        }
                    }
                    (*chk).whoTo = 0 as *mut sctp_nets
                }
                if (*stcb).asoc.free_chunk_cnt as libc::c_uint
                    > system_base_info.sctpsysctl.sctp_asoc_free_resc_limit
                    || system_base_info.sctppcbinfo.ipi_free_chunks
                        > system_base_info.sctpsysctl.sctp_system_free_resc_limit
                {
                    free(chk as *mut libc::c_void);
                    ::std::intrinsics::atomic_xsub(
                        &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                        1u32,
                    );
                } else {
                    (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
                    (*chk).sctp_next.tqe_prev = (*stcb).asoc.free_chunks.tqh_last;
                    *(*stcb).asoc.free_chunks.tqh_last = chk;
                    (*stcb).asoc.free_chunks.tqh_last = &mut (*chk).sctp_next.tqe_next;
                    (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_add(1);
                    ::std::intrinsics::atomic_xadd(
                        &mut system_base_info.sctppcbinfo.ipi_free_chunks,
                        1u32,
                    );
                }
            } else {
                free(chk as *mut libc::c_void);
                ::std::intrinsics::atomic_xsub(
                    &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                    1u32,
                );
            }
        }
        chk = nchk
    }
}
unsafe extern "C" fn sctp_clean_up_datalist(
    mut stcb: *mut sctp_tcb,
    mut asoc: *mut sctp_association,
    mut data_list: *mut *mut sctp_tmit_chunk,
    mut bundle_at: libc::c_int,
    mut net: *mut sctp_nets,
) {
    for i in 0i32..bundle_at {
        let mut tp1 = 0 as *mut sctp_tmit_chunk;
        if !(**data_list.offset(i as isize))
            .sctp_next
            .tqe_next
            .is_null()
        {
            let ref mut fresh23 = (*(**data_list.offset(i as isize)).sctp_next.tqe_next)
                .sctp_next
                .tqe_prev;
            *fresh23 = (**data_list.offset(i as isize)).sctp_next.tqe_prev
        } else {
            (*asoc).send_queue.tqh_last = (**data_list.offset(i as isize)).sctp_next.tqe_prev
        }

        let ref mut fresh24 = *(**data_list.offset(i as isize)).sctp_next.tqe_prev;

        *fresh24 = (**data_list.offset(i as isize)).sctp_next.tqe_next;

        (*asoc).send_queue_cnt = (*asoc).send_queue_cnt.wrapping_sub(1);

        if i > 0i32 {
            /*
             * Any chunk NOT 0 you zap the time chunk 0 gets
             * zapped or set based on if a RTO measurment is
             * needed.
             */
            (**data_list.offset(i as isize)).do_rtt = 0u8
        }
        /* record time */
        (**data_list.offset(i as isize)).sent_rcv_time = (*net).last_sent_time;

        (**data_list.offset(i as isize)).rec.data.cwnd_at_send = (*net).cwnd;

        (**data_list.offset(i as isize)).rec.data.fast_retran_tsn =
            (**data_list.offset(i as isize)).rec.data.tsn;

        if (**data_list.offset(i as isize)).whoTo.is_null() {
            let ref mut fresh25 = (**data_list.offset(i as isize)).whoTo;
            *fresh25 = net;
            ::std::intrinsics::atomic_xadd(&mut (*net).ref_count, 1i32);
        }
        /* on to the sent queue */
        tp1 = *(*((*asoc).sent_queue.tqh_last as *mut sctpchunk_listhead)).tqh_last;

        if !tp1.is_null()
            && ((*tp1).rec.data.tsn < (**data_list.offset(i as isize)).rec.data.tsn
                && (**data_list.offset(i as isize))
                    .rec
                    .data
                    .tsn
                    .wrapping_sub((*tp1).rec.data.tsn)
                    > (1u32) << 31i32
                || (*tp1).rec.data.tsn > (**data_list.offset(i as isize)).rec.data.tsn
                    && (*tp1)
                        .rec
                        .data
                        .tsn
                        .wrapping_sub((**data_list.offset(i as isize)).rec.data.tsn)
                        < (1u32) << 31i32)
        {
            loop
            /* need to move back */
            {
                let mut tpp = 0 as *mut sctp_tmit_chunk;
                tpp = *(*((*tp1).sctp_next.tqe_prev as *mut sctpchunk_listhead)).tqh_last;
                if tpp.is_null() {
                    let ref mut fresh26 = (**data_list.offset(i as isize)).sctp_next.tqe_prev;
                    *fresh26 = (*tp1).sctp_next.tqe_prev;
                    let ref mut fresh27 = (**data_list.offset(i as isize)).sctp_next.tqe_next;
                    *fresh27 = tp1;
                    *(*tp1).sctp_next.tqe_prev = *data_list.offset(i as isize);
                    (*tp1).sctp_next.tqe_prev =
                        &mut (**data_list.offset(i as isize)).sctp_next.tqe_next;
                    break;
                } else {
                    tp1 = tpp;
                    if (*tp1).rec.data.tsn < (**data_list.offset(i as isize)).rec.data.tsn
                        && (**data_list.offset(i as isize))
                            .rec
                            .data
                            .tsn
                            .wrapping_sub((*tp1).rec.data.tsn)
                            > (1u32) << 31i32
                        || (*tp1).rec.data.tsn > (**data_list.offset(i as isize)).rec.data.tsn
                            && (*tp1)
                                .rec
                                .data
                                .tsn
                                .wrapping_sub((**data_list.offset(i as isize)).rec.data.tsn)
                                < (1u32) << 31i32
                    {
                        continue;
                    }
                    let ref mut fresh28 = (**data_list.offset(i as isize)).sctp_next.tqe_next;
                    *fresh28 = (*tp1).sctp_next.tqe_next;
                    if !(*fresh28).is_null() {
                        let ref mut fresh29 =
                            (*(**data_list.offset(i as isize)).sctp_next.tqe_next)
                                .sctp_next
                                .tqe_prev;
                        *fresh29 = &mut (**data_list.offset(i as isize)).sctp_next.tqe_next
                    } else {
                        (*asoc).sent_queue.tqh_last =
                            &mut (**data_list.offset(i as isize)).sctp_next.tqe_next
                    }
                    (*tp1).sctp_next.tqe_next = *data_list.offset(i as isize);
                    let ref mut fresh30 = (**data_list.offset(i as isize)).sctp_next.tqe_prev;
                    *fresh30 = &mut (*tp1).sctp_next.tqe_next;
                    break;
                }
            }
        } else {
            let ref mut fresh31 = (**data_list.offset(i as isize)).sctp_next.tqe_next;
            *fresh31 = 0 as *mut sctp_tmit_chunk;
            let ref mut fresh32 = (**data_list.offset(i as isize)).sctp_next.tqe_prev;
            *fresh32 = (*asoc).sent_queue.tqh_last;
            *(*asoc).sent_queue.tqh_last = *data_list.offset(i as isize);
            (*asoc).sent_queue.tqh_last = &mut (**data_list.offset(i as isize)).sctp_next.tqe_next
        }
        /* This does not lower until the cum-ack passes it */
        (*asoc).sent_queue_cnt = (*asoc).sent_queue_cnt.wrapping_add(1);

        if (*asoc).peers_rwnd <= 0u32 && (*asoc).total_flight == 0u32 && bundle_at == 1i32 {
            /* Mark the chunk as being a window probe */
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_windowprobed, 1u32);
        }

        (**data_list.offset(i as isize)).sent = 1i32;

        (**data_list.offset(i as isize)).snd_count = 1u16;

        (**data_list.offset(i as isize)).rec.data.chunk_was_revoked = 0u8;

        if system_base_info.sctpsysctl.sctp_logging_level & 0x20u32 != 0 {
            sctp_misc_ints(
                108u8,
                (*(**data_list.offset(i as isize)).whoTo).flight_size,
                (**data_list.offset(i as isize)).book_size as uint32_t,
                (**data_list.offset(i as isize)).whoTo as uint32_t,
                (**data_list.offset(i as isize)).rec.data.tsn,
            );
        }

        let ref mut fresh33 = (*(**data_list.offset(i as isize)).whoTo).flight_size;

        *fresh33 =
            (*fresh33).wrapping_add((**data_list.offset(i as isize)).book_size as libc::c_uint);

        (*stcb).asoc.total_flight_count = (*stcb).asoc.total_flight_count.wrapping_add(1);

        (*stcb).asoc.total_flight = (*stcb)
            .asoc
            .total_flight
            .wrapping_add((**data_list.offset(i as isize)).book_size as libc::c_uint);

        if system_base_info.sctpsysctl.sctp_logging_level & 0x100000u32 != 0 {
            sctp_log_rwnd(
                37u8,
                (*asoc).peers_rwnd,
                (**data_list.offset(i as isize)).send_size as uint32_t,
                system_base_info.sctpsysctl.sctp_peer_chunk_oh,
            );
        }

        (*asoc).peers_rwnd = if (*asoc).peers_rwnd
            > ((**data_list.offset(i as isize)).send_size as libc::c_uint)
                .wrapping_add(system_base_info.sctpsysctl.sctp_peer_chunk_oh)
        {
            (*asoc).peers_rwnd.wrapping_sub(
                ((**data_list.offset(i as isize)).send_size as libc::c_uint)
                    .wrapping_add(system_base_info.sctpsysctl.sctp_peer_chunk_oh),
            )
        } else {
            0u32
        };

        if (*asoc).peers_rwnd < (*(*stcb).sctp_ep).sctp_ep.sctp_sws_sender {
            /* SWS sender side engages */
            (*asoc).peers_rwnd = 0u32
        }
    }
    if (*asoc)
        .cc_functions
        .sctp_cwnd_update_packet_transmitted
        .is_some()
    {
        Some(
            (*asoc)
                .cc_functions
                .sctp_cwnd_update_packet_transmitted
                .expect("non-null function pointer"),
        )
        .expect("non-null function pointer")(stcb, net);
    };
}
unsafe extern "C" fn sctp_clean_up_ctl(
    mut stcb: *mut sctp_tcb,
    mut asoc: *mut sctp_association,
    mut so_locked: libc::c_int,
) {
    let mut chk = 0 as *mut sctp_tmit_chunk;
    let mut nchk = 0 as *mut sctp_tmit_chunk;
    chk = (*asoc).control_send_queue.tqh_first;
    while !chk.is_null() && {
        nchk = (*chk).sctp_next.tqe_next;
        (1i32) != 0
    } {
        let mut current_block_84: u64;
        if (*chk).rec.chunk_id.id as libc::c_int == 0x3i32
            || (*chk).rec.chunk_id.id as libc::c_int == 0x10i32
            || (*chk).rec.chunk_id.id as libc::c_int == 0x4i32
            || (*chk).rec.chunk_id.id as libc::c_int == 0x5i32
            || (*chk).rec.chunk_id.id as libc::c_int == 0xc0i32
            || (*chk).rec.chunk_id.id as libc::c_int == 0x7i32
            || (*chk).rec.chunk_id.id as libc::c_int == 0x8i32
            || (*chk).rec.chunk_id.id as libc::c_int == 0x9i32
            || (*chk).rec.chunk_id.id as libc::c_int == 0x81i32
            || (*chk).rec.chunk_id.id as libc::c_int == 0xbi32
            || (*chk).rec.chunk_id.id as libc::c_int == 0xdi32
            || (*chk).rec.chunk_id.id as libc::c_int == 0x80i32
        {
            current_block_84 = 6426278056554751537;
        } else if (*chk).rec.chunk_id.id as libc::c_int == 0x82i32 {
            /* special handling, we must look into the param */
            if chk != (*asoc).str_reset {
                current_block_84 = 6426278056554751537;
            } else {
                current_block_84 = 9879896046554623444;
            }
        } else {
            current_block_84 = 9879896046554623444;
        }
        match current_block_84 {
            6426278056554751537 =>
            /* Stray chunks must be cleaned up */
            {
                if !(*chk).sctp_next.tqe_next.is_null() {
                    (*(*chk).sctp_next.tqe_next).sctp_next.tqe_prev = (*chk).sctp_next.tqe_prev
                } else {
                    (*asoc).control_send_queue.tqh_last = (*chk).sctp_next.tqe_prev
                }
                *(*chk).sctp_next.tqe_prev = (*chk).sctp_next.tqe_next;
                (*asoc).ctrl_queue_cnt -= 1;
                if !(*chk).data.is_null() {
                    m_freem((*chk).data);
                    (*chk).data = 0 as *mut mbuf
                }
                if (*chk).rec.chunk_id.id as libc::c_int == 0xc0i32 {
                    (*asoc).fwd_tsn_cnt = (*asoc).fwd_tsn_cnt.wrapping_sub(1)
                }
                if (*chk).holds_key_ref != 0 {
                    sctp_auth_key_release(stcb, (*chk).auth_keyid, so_locked);
                    (*chk).holds_key_ref = 0u8
                }
                if !stcb.is_null() {
                    if !(*chk).whoTo.is_null() {
                        if !(*chk).whoTo.is_null() {
                            if ::std::intrinsics::atomic_xadd(
                                &mut (*(*chk).whoTo).ref_count as *mut libc::c_int,
                                -(1i32),
                            ) == 1i32
                            {
                                sctp_os_timer_stop(&mut (*(*chk).whoTo).rxt_timer.timer);
                                sctp_os_timer_stop(&mut (*(*chk).whoTo).pmtu_timer.timer);
                                sctp_os_timer_stop(&mut (*(*chk).whoTo).hb_timer.timer);
                                if !(*(*chk).whoTo).ro.ro_rt.is_null() {
                                    if (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt <= 1i64 {
                                        sctp_userspace_rtfree((*(*chk).whoTo).ro.ro_rt);
                                    } else {
                                        (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt -= 1
                                    }
                                    (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t;
                                    (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t
                                }
                                if (*(*chk).whoTo).src_addr_selected != 0 {
                                    sctp_free_ifa((*(*chk).whoTo).ro._s_addr);
                                    (*(*chk).whoTo).ro._s_addr = 0 as *mut sctp_ifa
                                }
                                (*(*chk).whoTo).src_addr_selected = 0u8;
                                (*(*chk).whoTo).dest_state =
                                    ((*(*chk).whoTo).dest_state as libc::c_int & !(0x1i32))
                                        as uint16_t;
                                free((*chk).whoTo as *mut libc::c_void);
                                ::std::intrinsics::atomic_xsub(
                                    &mut system_base_info.sctppcbinfo.ipi_count_raddr,
                                    1u32,
                                );
                            }
                        }
                        (*chk).whoTo = 0 as *mut sctp_nets
                    }
                    if (*stcb).asoc.free_chunk_cnt as libc::c_uint
                        > system_base_info.sctpsysctl.sctp_asoc_free_resc_limit
                        || system_base_info.sctppcbinfo.ipi_free_chunks
                            > system_base_info.sctpsysctl.sctp_system_free_resc_limit
                    {
                        free(chk as *mut libc::c_void);
                        ::std::intrinsics::atomic_xsub(
                            &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                            1u32,
                        );
                    } else {
                        (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
                        (*chk).sctp_next.tqe_prev = (*stcb).asoc.free_chunks.tqh_last;
                        *(*stcb).asoc.free_chunks.tqh_last = chk;
                        (*stcb).asoc.free_chunks.tqh_last = &mut (*chk).sctp_next.tqe_next;
                        (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_add(1);
                        ::std::intrinsics::atomic_xadd(
                            &mut system_base_info.sctppcbinfo.ipi_free_chunks,
                            1u32,
                        );
                    }
                } else {
                    free(chk as *mut libc::c_void);
                    ::std::intrinsics::atomic_xsub(
                        &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                        1u32,
                    );
                }
            }
            _ => {}
        }
        chk = nchk
    }
}
unsafe extern "C" fn sctp_can_we_split_this(
    mut stcb: *mut sctp_tcb,
    mut length: uint32_t,
    mut space_left: uint32_t,
    mut frag_point: uint32_t,
    mut eeor_on: libc::c_int,
) -> uint32_t {
    /* Make a decision on if I should split a
     * msg into multiple parts. This is only asked of
     * incomplete messages.
     */
    if eeor_on != 0 {
        /* If we are doing EEOR we need to always send
         * it if its the entire thing, since it might
         * be all the guy is putting in the hopper.
         */
        if space_left >= length {
            /*-
             * If we have data outstanding,
             * we get another chance when the sack
             * arrives to transmit - wait for more data
             */
            if (*stcb).asoc.total_flight == 0u32 {
                /* If nothing is in flight, we zero
                 * the packet counter.
                 */
                return length;
            }
            return 0u32;
        } else {
            /* You can fill the rest */
            return space_left;
        }
    }
    /*-
     * For those strange folk that make the send buffer
     * smaller than our fragmentation point, we can't
     * get a full msg in so we have to allow splitting.
     */
    if (*(*stcb).sctp_socket).so_snd.sb_hiwat < frag_point {
        return length;
    }
    if length <= space_left
        || length.wrapping_sub(space_left) < system_base_info.sctpsysctl.sctp_min_residual
    {
        /* Sub-optimial residual don't split in non-eeor mode. */
        return 0u32;
    }
    /* If we reach here length is larger
     * than the space_left. Do we wish to split
     * it for the sake of packet putting together?
     */
    if space_left
        >= (if system_base_info.sctpsysctl.sctp_min_split_point > frag_point {
            frag_point
        } else {
            system_base_info.sctpsysctl.sctp_min_split_point
        })
    {
        /* Its ok to split it */
        return if space_left > frag_point {
            frag_point
        } else {
            space_left
        };
    }
    /* Nope, can't split */
    return 0u32;
}
unsafe extern "C" fn sctp_move_to_outqueue(
    mut stcb: *mut sctp_tcb,
    mut strq: *mut sctp_stream_out,
    mut space_left: uint32_t,
    mut frag_point: uint32_t,
    mut giveup: *mut libc::c_int,
    mut eeor_mode: libc::c_int,
    mut bail: *mut libc::c_int,
    mut so_locked: libc::c_int,
) -> uint32_t {
    let mut current_block: u64;
    let mut asoc = 0 as *mut sctp_association;
    let mut sp = 0 as *mut sctp_stream_queue_pending;
    let mut to_move = 0;
    let mut send_lock_up = 0u8;
    asoc = &mut (*stcb).asoc;
    loop
    /* back to get the next msg */
    /*sa_ignore FREED_MEMORY*/
    {
        sp = (*strq).outqueue.tqh_first;
        if sp.is_null() {
            if send_lock_up as libc::c_int == 0i32 {
                pthread_mutex_lock(&mut (*stcb).tcb_send_mtx);
                send_lock_up = 1u8
            }
            sp = (*strq).outqueue.tqh_first;
            if !sp.is_null() {
                continue;
            }
            if ((*(*stcb).sctp_ep).sctp_features & 0x400000u64 == 0x400000u64) as libc::c_int
                == 0i32
                && (*stcb).asoc.idata_supported as libc::c_int == 0i32
                && (*strq).last_msg_incomplete as libc::c_int != 0
            {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"Huh? Stream:%d lm_in_c=%d but queue is NULL\n\x00" as *const u8
                            as *const libc::c_char,
                        (*strq).sid as libc::c_int,
                        (*strq).last_msg_incomplete as libc::c_int,
                    );
                }
                (*strq).last_msg_incomplete = 0u8
            }
            to_move = 0u32;
            if send_lock_up != 0 {
                pthread_mutex_unlock(&mut (*stcb).tcb_send_mtx);
                send_lock_up = 0u8
            }
            current_block = 83758123177234263;
            break;
        } else if (*sp).msg_is_complete as libc::c_int != 0 && (*sp).length == 0u32 {
            if (*sp).sender_all_done != 0 {
                /* We are doing deferred cleanup. Last
                 * time through when we took all the data
                 * the sender_all_done was not set.
                 */
                if (*sp).put_last_out as libc::c_int == 0i32
                    && (*sp).discard_rest as libc::c_int == 0i32
                {
                    if system_base_info.debug_printf.is_some() {
                        system_base_info
                            .debug_printf
                            .expect("non-null function pointer")(
                            b"Gak, put out entire msg with NO end!-1\n\x00" as *const u8
                                as *const libc::c_char,
                        );
                    }
                    if system_base_info.debug_printf.is_some() {
                        system_base_info
                            .debug_printf
                            .expect("non-null function pointer")(
                            b"sender_done:%d len:%d msg_comp:%d put_last_out:%d send_lock:%d\n\x00"
                                as *const u8 as *const libc::c_char,
                            (*sp).sender_all_done as libc::c_int,
                            (*sp).length,
                            (*sp).msg_is_complete as libc::c_int,
                            (*sp).put_last_out as libc::c_int,
                            send_lock_up as libc::c_int,
                        );
                    }
                }
                if (*sp).next.tqe_next.is_null() && send_lock_up as libc::c_int == 0i32 {
                    pthread_mutex_lock(&mut (*stcb).tcb_send_mtx);
                    send_lock_up = 1u8
                }
                ::std::intrinsics::atomic_xsub(&mut (*asoc).stream_queue_cnt, 1u32);
                if !(*sp).next.tqe_next.is_null() {
                    (*(*sp).next.tqe_next).next.tqe_prev = (*sp).next.tqe_prev
                } else {
                    (*strq).outqueue.tqh_last = (*sp).next.tqe_prev
                }
                *(*sp).next.tqe_prev = (*sp).next.tqe_next;
                (*stcb)
                    .asoc
                    .ss_functions
                    .sctp_ss_remove_from_stream
                    .expect("non-null function pointer")(
                    stcb,
                    asoc,
                    strq,
                    sp,
                    send_lock_up as libc::c_int,
                );
                if (*strq).state as libc::c_int == 0x3i32
                    && (*strq).chunks_on_queues == 0u32
                    && (*strq).outqueue.tqh_first.is_null()
                {
                    (*stcb).asoc.trigger_reset = 1u8
                }
                if !(*sp).net.is_null() {
                    if !(*sp).net.is_null() {
                        if ::std::intrinsics::atomic_xadd(
                            &mut (*(*sp).net).ref_count as *mut libc::c_int,
                            -(1i32),
                        ) == 1i32
                        {
                            sctp_os_timer_stop(&mut (*(*sp).net).rxt_timer.timer);
                            sctp_os_timer_stop(&mut (*(*sp).net).pmtu_timer.timer);
                            sctp_os_timer_stop(&mut (*(*sp).net).hb_timer.timer);
                            if !(*(*sp).net).ro.ro_rt.is_null() {
                                if (*(*(*sp).net).ro.ro_rt).rt_refcnt <= 1i64 {
                                    sctp_userspace_rtfree((*(*sp).net).ro.ro_rt);
                                } else {
                                    (*(*(*sp).net).ro.ro_rt).rt_refcnt -= 1
                                }
                                (*(*sp).net).ro.ro_rt = 0 as *mut sctp_rtentry_t;
                                (*(*sp).net).ro.ro_rt = 0 as *mut sctp_rtentry_t
                            }
                            if (*(*sp).net).src_addr_selected != 0 {
                                sctp_free_ifa((*(*sp).net).ro._s_addr);
                                (*(*sp).net).ro._s_addr = 0 as *mut sctp_ifa
                            }
                            (*(*sp).net).src_addr_selected = 0u8;
                            (*(*sp).net).dest_state =
                                ((*(*sp).net).dest_state as libc::c_int & !(0x1i32)) as uint16_t;
                            free((*sp).net as *mut libc::c_void);
                            ::std::intrinsics::atomic_xsub(
                                &mut system_base_info.sctppcbinfo.ipi_count_raddr,
                                1u32,
                            );
                        }
                    }
                    (*sp).net = 0 as *mut sctp_nets
                }
                if !(*sp).data.is_null() {
                    m_freem((*sp).data);
                    (*sp).data = 0 as *mut mbuf
                }
                if (*sp).holds_key_ref != 0 {
                    sctp_auth_key_release(stcb, (*sp).auth_keyid, so_locked);
                    (*sp).holds_key_ref = 0u8
                }
                free(sp as *mut libc::c_void);
                ::std::intrinsics::atomic_xsub(
                    &mut system_base_info.sctppcbinfo.ipi_count_strmoq,
                    1u32,
                );
                /* we can't be locked to it */
                if send_lock_up != 0 {
                    pthread_mutex_unlock(&mut (*stcb).tcb_send_mtx);
                    send_lock_up = 0u8
                }
            } else {
                /* sender just finished this but
                 * still holds a reference
                 */
                *giveup = 1i32;
                to_move = 0u32;
                current_block = 83758123177234263;
                break;
            }
        } else if (*sp).length == 0u32
        /* is there some to get */
        {
            current_block = 10863493864285401582;
            break;
        } else {
            current_block = 9775647934248138666;
            break;
        }
    }
    match current_block {
        9775647934248138666 => {
            if (*sp).discard_rest != 0 {
                if send_lock_up as libc::c_int == 0i32 {
                    pthread_mutex_lock(&mut (*stcb).tcb_send_mtx);
                    send_lock_up = 1u8
                }
                /* Whack down the size */
                ::std::intrinsics::atomic_xsub(
                    &mut (*stcb).asoc.total_output_queue_size,
                    (*sp).length,
                );
                if !(*stcb).sctp_socket.is_null()
                    && ((*(*stcb).sctp_ep).sctp_flags & 0x2u32 != 0
                        || (*(*stcb).sctp_ep).sctp_flags & 0x400000u32 != 0)
                {
                    ::std::intrinsics::atomic_xsub(
                        &mut (*(*stcb).sctp_socket).so_snd.sb_cc,
                        (*sp).length,
                    );
                }
                if !(*sp).data.is_null() {
                    m_freem((*sp).data);
                    (*sp).data = 0 as *mut mbuf;
                    (*sp).tail_mbuf = 0 as *mut mbuf
                }
                (*sp).length = 0u32;
                (*sp).some_taken = 1u8;
                *giveup = 1i32;
                to_move = 0u32
            } else {
                let mut length = 0;
                let mut rcv_flags = 0u8;
                let mut some_taken = 0;
                some_taken = (*sp).some_taken;
                loop
                /* the sender finished the msg */
                {
                    length = (*sp).length;
                    if (*sp).msg_is_complete != 0 {
                        /* The message is complete */
                        to_move = if length > frag_point {
                            frag_point
                        } else {
                            length
                        };
                        if to_move == length {
                            /* All of it fits in the MTU */
                            if (*sp).some_taken != 0 {
                                rcv_flags = (rcv_flags as libc::c_int | 0x1i32) as uint8_t
                            } else {
                                rcv_flags = (rcv_flags as libc::c_int | 0x3i32) as uint8_t
                            }
                            (*sp).put_last_out = 1u8;
                            if (*sp).sinfo_flags as libc::c_int & 0x4000i32 != 0 {
                                rcv_flags = (rcv_flags as libc::c_int | 0x8i32) as uint8_t
                            }
                        } else {
                            /* Not all of it fits, we fragment */
                            if (*sp).some_taken as libc::c_int == 0i32 {
                                rcv_flags = (rcv_flags as libc::c_int | 0x2i32) as uint8_t
                            }
                            (*sp).some_taken = 1u8
                        }
                        current_block = 10282596542094995802;
                        break;
                    } else {
                        to_move =
                            sctp_can_we_split_this(stcb, length, space_left, frag_point, eeor_mode);
                        if to_move != 0 {
                            let mut llen = 0;
                            llen = 0;
                            llen = length;
                            if !(to_move >= llen) {
                                current_block = 8968043056769084000;
                                break;
                            }
                            to_move = llen;
                            if !(send_lock_up as libc::c_int == 0i32) {
                                current_block = 8968043056769084000;
                                break;
                            }
                            /*-
                             * We are taking all of an incomplete msg
                             * thus we need a send lock.
                             */
                            pthread_mutex_lock(&mut (*stcb).tcb_send_mtx);
                            send_lock_up = 1u8;
                            if !((*sp).msg_is_complete != 0) {
                                current_block = 8968043056769084000;
                                break;
                            }
                        } else {
                            /* Nothing to take. */
                            *giveup = 1i32;
                            to_move = 0u32;
                            current_block = 83758123177234263;
                            break;
                        }
                    }
                }
                match current_block {
                    83758123177234263 => {}
                    _ => {
                        let mut chk = 0 as *mut sctp_tmit_chunk;
                        match current_block {
                            8968043056769084000 => {
                                if (*sp).some_taken as libc::c_int == 0i32 {
                                    rcv_flags = (rcv_flags as libc::c_int | 0x2i32) as uint8_t;
                                    (*sp).some_taken = 1u8
                                }
                            }
                            _ => {}
                        }
                        /* If we reach here, we can copy out a chunk */
                        if (*stcb).asoc.free_chunks.tqh_first.is_null() {
                            chk = malloc(system_base_info.sctppcbinfo.ipi_zone_chunk)
                                as *mut sctp_tmit_chunk;
                            if !chk.is_null() {
                                ::std::intrinsics::atomic_xadd(
                                    &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                                    1u32,
                                );
                                (*chk).whoTo = 0 as *mut sctp_nets;
                                (*chk).holds_key_ref = 0u8
                            }
                        } else {
                            chk = (*stcb).asoc.free_chunks.tqh_first;
                            if !(*chk).sctp_next.tqe_next.is_null() {
                                (*(*chk).sctp_next.tqe_next).sctp_next.tqe_prev =
                                    (*chk).sctp_next.tqe_prev
                            } else {
                                (*stcb).asoc.free_chunks.tqh_last = (*chk).sctp_next.tqe_prev
                            }
                            *(*chk).sctp_next.tqe_prev = (*chk).sctp_next.tqe_next;
                            ::std::intrinsics::atomic_xsub(
                                &mut system_base_info.sctppcbinfo.ipi_free_chunks,
                                1u32,
                            );
                            (*chk).holds_key_ref = 0u8;
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_cached_chk,
                                1u32,
                            );
                            (*stcb).asoc.free_chunk_cnt =
                                (*stcb).asoc.free_chunk_cnt.wrapping_sub(1)
                        }
                        if chk.is_null() {
                            /* No chunk memory */
                            *giveup = 1i32;
                            to_move = 0u32
                        } else {
                            let mut m = 0 as *mut mbuf;
                            if (*sp).sinfo_flags as libc::c_int & 0x400i32 != 0 {
                                rcv_flags = (rcv_flags as libc::c_int | 0x4i32) as uint8_t
                            }
                            if system_base_info.sctpsysctl.sctp_enable_sack_immediately != 0
                                && (*sp).sinfo_flags as libc::c_int & 0x100i32 == 0x100i32
                            {
                                rcv_flags = (rcv_flags as libc::c_int | 0x8i32) as uint8_t
                            }
                            /* clear out the chunk before setting up */
                            memset(
                                chk as *mut libc::c_void,
                                0i32,
                                ::std::mem::size_of::<sctp_tmit_chunk>() as libc::c_ulong,
                            );
                            (*chk).rec.data.rcv_flags = rcv_flags;
                            if to_move >= length {
                                /* we think we can steal the whole thing */
                                if (*sp).sender_all_done as libc::c_int == 0i32
                                    && send_lock_up as libc::c_int == 0i32
                                {
                                    pthread_mutex_lock(&mut (*stcb).tcb_send_mtx);
                                    send_lock_up = 1u8
                                }
                                if to_move < (*sp).length {
                                    current_block = 6283195712876485389;
                                } else {
                                    (*chk).data = (*sp).data;
                                    (*chk).last_mbuf = (*sp).tail_mbuf;
                                    /* register the stealing */
                                    (*sp).tail_mbuf = 0 as *mut mbuf;
                                    (*sp).data = (*sp).tail_mbuf;
                                    current_block = 10779579613334775377;
                                }
                            } else {
                                m = 0 as *mut mbuf;
                                current_block = 6283195712876485389;
                            }
                            match current_block {
                                6283195712876485389 =>
                                /* bail, it changed */
                                {
                                    (*chk).data =
                                        m_copym((*sp).data, 0i32, to_move as libc::c_int, 0x1i32);
                                    (*chk).last_mbuf = 0 as *mut mbuf;
                                    if (*chk).data.is_null() {
                                        (*sp).some_taken = some_taken;
                                        if (*chk).holds_key_ref != 0 {
                                            sctp_auth_key_release(
                                                stcb,
                                                (*chk).auth_keyid,
                                                so_locked,
                                            );
                                            (*chk).holds_key_ref = 0u8
                                        }
                                        if !stcb.is_null() {
                                            if !(*chk).whoTo.is_null() {
                                                if !(*chk).whoTo.is_null() {
                                                    if ::std::intrinsics::atomic_xadd(
                                                        &mut (*(*chk).whoTo).ref_count
                                                            as *mut libc::c_int,
                                                        -(1i32),
                                                    ) == 1i32
                                                    {
                                                        sctp_os_timer_stop(
                                                            &mut (*(*chk).whoTo).rxt_timer.timer,
                                                        );
                                                        sctp_os_timer_stop(
                                                            &mut (*(*chk).whoTo).pmtu_timer.timer,
                                                        );
                                                        sctp_os_timer_stop(
                                                            &mut (*(*chk).whoTo).hb_timer.timer,
                                                        );
                                                        if !(*(*chk).whoTo).ro.ro_rt.is_null() {
                                                            if (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt
                                                                <= 1i64
                                                            {
                                                                sctp_userspace_rtfree(
                                                                    (*(*chk).whoTo).ro.ro_rt,
                                                                );
                                                            } else {
                                                                (*(*(*chk).whoTo).ro.ro_rt)
                                                                    .rt_refcnt -= 1
                                                            }
                                                            (*(*chk).whoTo).ro.ro_rt =
                                                                0 as *mut sctp_rtentry_t;
                                                            (*(*chk).whoTo).ro.ro_rt =
                                                                0 as *mut sctp_rtentry_t
                                                        }
                                                        if (*(*chk).whoTo).src_addr_selected != 0 {
                                                            sctp_free_ifa(
                                                                (*(*chk).whoTo).ro._s_addr,
                                                            );
                                                            (*(*chk).whoTo).ro._s_addr =
                                                                0 as *mut sctp_ifa
                                                        }
                                                        (*(*chk).whoTo).src_addr_selected = 0u8;
                                                        (*(*chk).whoTo).dest_state =
                                                            ((*(*chk).whoTo).dest_state
                                                                as libc::c_int
                                                                & !(0x1i32))
                                                                as uint16_t;
                                                        free((*chk).whoTo as *mut libc::c_void);
                                                        ::std::intrinsics::atomic_xsub(
                                                            &mut system_base_info
                                                                .sctppcbinfo
                                                                .ipi_count_raddr,
                                                            1u32,
                                                        );
                                                    }
                                                }
                                                (*chk).whoTo = 0 as *mut sctp_nets
                                            }
                                            if (*stcb).asoc.free_chunk_cnt as libc::c_uint
                                                > system_base_info
                                                    .sctpsysctl
                                                    .sctp_asoc_free_resc_limit
                                                || system_base_info.sctppcbinfo.ipi_free_chunks
                                                    > system_base_info
                                                        .sctpsysctl
                                                        .sctp_system_free_resc_limit
                                            {
                                                free(chk as *mut libc::c_void);
                                                ::std::intrinsics::atomic_xsub(
                                                    &mut system_base_info
                                                        .sctppcbinfo
                                                        .ipi_count_chunk,
                                                    1u32,
                                                );
                                            } else {
                                                (*chk).sctp_next.tqe_next =
                                                    0 as *mut sctp_tmit_chunk;
                                                (*chk).sctp_next.tqe_prev =
                                                    (*stcb).asoc.free_chunks.tqh_last;
                                                *(*stcb).asoc.free_chunks.tqh_last = chk;
                                                (*stcb).asoc.free_chunks.tqh_last =
                                                    &mut (*chk).sctp_next.tqe_next;
                                                (*stcb).asoc.free_chunk_cnt =
                                                    (*stcb).asoc.free_chunk_cnt.wrapping_add(1);
                                                ::std::intrinsics::atomic_xadd(
                                                    &mut system_base_info
                                                        .sctppcbinfo
                                                        .ipi_free_chunks,
                                                    1u32,
                                                );
                                            }
                                        } else {
                                            free(chk as *mut libc::c_void);
                                            ::std::intrinsics::atomic_xsub(
                                                &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                                                1u32,
                                            );
                                        }
                                        *bail = 1i32;
                                        to_move = 0u32;
                                        current_block = 83758123177234263;
                                    } else {
                                        /* Pull off the data */
                                        m_adj((*sp).data, to_move as libc::c_int);
                                        /* Now lets work our way down and compact it */
                                        m = (*sp).data;
                                        while !m.is_null() && (*m).m_hdr.mh_len == 0i32 {
                                            (*sp).data = (*m).m_hdr.mh_next;
                                            (*m).m_hdr.mh_next = 0 as *mut mbuf;
                                            if (*sp).tail_mbuf == m {
                                                /*-
                                                 * Freeing tail? TSNH since
                                                 * we supposedly were taking less
                                                 * than the sp->length.
                                                 */
                                                if system_base_info.debug_printf.is_some() {
                                                    system_base_info
                                                        .debug_printf
                                                        .expect("non-null function pointer")(
                                                        b"Huh, freeing tail? - TSNH\n\x00"
                                                            as *const u8
                                                            as *const libc::c_char,
                                                    );
                                                }
                                                (*sp).data = 0 as *mut mbuf;
                                                (*sp).tail_mbuf = (*sp).data;
                                                (*sp).length = 0u32
                                            }
                                            m_free(m);
                                            m = (*sp).data
                                        }
                                        current_block = 10779579613334775377;
                                    }
                                }
                                _ => {}
                            }
                            match current_block {
                                83758123177234263 => {}
                                _ => {
                                    let mut leading = 0;
                                    if (*(*chk).data).m_hdr.mh_flags & 0x1i32 != 0 {
                                        (*chk).copy_by_ref = 1u8
                                    } else {
                                        (*chk).copy_by_ref = 0u8
                                    }
                                    /* get last_mbuf and counts of mb usage
                                     * This is ugly but hopefully its only one mbuf.
                                     */
                                    if (*chk).last_mbuf.is_null() {
                                        (*chk).last_mbuf = (*chk).data;
                                        while !(*(*chk).last_mbuf).m_hdr.mh_next.is_null() {
                                            (*chk).last_mbuf = (*(*chk).last_mbuf).m_hdr.mh_next
                                        }
                                    }
                                    if to_move > length {
                                        /*- This should not happen either
                                         * since we always lower to_move to the size
                                         * of sp->length if its larger.
                                         */
                                        if system_base_info.debug_printf.is_some() {
                                            system_base_info
                                                .debug_printf
                                                .expect("non-null function pointer")(
                                                b"Huh, how can to_move be larger?\n\x00"
                                                    as *const u8
                                                    as *const libc::c_char,
                                            );
                                        }
                                        (*sp).length = 0u32
                                    } else {
                                        ::std::intrinsics::atomic_xsub(&mut (*sp).length, to_move);
                                    }
                                    leading = if (*stcb).asoc.idata_supported as libc::c_int != 0 {
                                        ::std::mem::size_of::<sctp_idata_chunk>() as libc::c_ulong
                                    } else {
                                        ::std::mem::size_of::<sctp_data_chunk>() as libc::c_ulong
                                    } as libc::c_int;
                                    if (if (*(*chk).data).m_hdr.mh_flags & 0x1i32 != 0 {
                                        (if (*(*chk).data).m_hdr.mh_flags & 0x8i32 == 0
                                            && ((*(*chk).data).m_hdr.mh_flags & 0x1i32 == 0
                                                || *(*(*chk).data).M_dat.MH.MH_dat.MH_ext.ref_cnt
                                                    == 1u32)
                                        {
                                            (*(*chk).data).m_hdr.mh_data.wrapping_offset_from(
                                                (*(*chk).data).M_dat.MH.MH_dat.MH_ext.ext_buf,
                                            )
                                                as libc::c_long
                                        } else {
                                            0i64
                                        })
                                    } else {
                                        (if (*(*chk).data).m_hdr.mh_flags & 0x2i32 != 0 {
                                            (*(*chk).data).m_hdr.mh_data.wrapping_offset_from(
                                                (*(*chk).data)
                                                    .M_dat
                                                    .MH
                                                    .MH_dat
                                                    .MH_databuf
                                                    .as_mut_ptr(),
                                            )
                                                as libc::c_long
                                        } else {
                                            (*(*chk).data).m_hdr.mh_data.wrapping_offset_from(
                                                (*(*chk).data).M_dat.M_databuf.as_mut_ptr(),
                                            )
                                                as libc::c_long
                                        })
                                    }) < leading as libc::c_long
                                    {
                                        let mut m_0 = 0 as *mut mbuf;
                                        m_0 = sctp_get_mbuf_for_msg(1u32, 0i32, 0x1i32, 1i32, 1i32);
                                        if m_0.is_null() {
                                            /*
                                             * we're in trouble here. _PREPEND below will free
                                             * all the data if there is no leading space, so we
                                             * must put the data back and restore.
                                             */
                                            if send_lock_up as libc::c_int == 0i32 {
                                                pthread_mutex_lock(&mut (*stcb).tcb_send_mtx);
                                                send_lock_up = 1u8
                                            }
                                            if (*sp).data.is_null() {
                                                /* unsteal the data */
                                                (*sp).data = (*chk).data;
                                                (*sp).tail_mbuf = (*chk).last_mbuf
                                            } else {
                                                let mut m_tmp = 0 as *mut mbuf;
                                                /* reassemble the data */
                                                m_tmp = (*sp).data;
                                                (*sp).data = (*chk).data;
                                                (*(*chk).last_mbuf).m_hdr.mh_next = m_tmp
                                            }
                                            (*sp).some_taken = some_taken;
                                            ::std::intrinsics::atomic_xadd(
                                                &mut (*sp).length,
                                                to_move,
                                            );
                                            (*chk).data = 0 as *mut mbuf;
                                            *bail = 1i32;
                                            if (*chk).holds_key_ref != 0 {
                                                sctp_auth_key_release(
                                                    stcb,
                                                    (*chk).auth_keyid,
                                                    so_locked,
                                                );
                                                (*chk).holds_key_ref = 0u8
                                            }
                                            if !stcb.is_null() {
                                                if !(*chk).whoTo.is_null() {
                                                    if !(*chk).whoTo.is_null() {
                                                        if ::std::intrinsics::atomic_xadd(
                                                            &mut (*(*chk).whoTo).ref_count
                                                                as *mut libc::c_int,
                                                            -(1i32),
                                                        ) == 1i32
                                                        {
                                                            sctp_os_timer_stop(
                                                                &mut (*(*chk).whoTo)
                                                                    .rxt_timer
                                                                    .timer,
                                                            );
                                                            sctp_os_timer_stop(
                                                                &mut (*(*chk).whoTo)
                                                                    .pmtu_timer
                                                                    .timer,
                                                            );
                                                            sctp_os_timer_stop(
                                                                &mut (*(*chk).whoTo).hb_timer.timer,
                                                            );
                                                            if !(*(*chk).whoTo).ro.ro_rt.is_null() {
                                                                if (*(*(*chk).whoTo).ro.ro_rt)
                                                                    .rt_refcnt
                                                                    <= 1i64
                                                                {
                                                                    sctp_userspace_rtfree(
                                                                        (*(*chk).whoTo).ro.ro_rt,
                                                                    );
                                                                } else {
                                                                    (*(*(*chk).whoTo).ro.ro_rt)
                                                                        .rt_refcnt -= 1
                                                                }
                                                                (*(*chk).whoTo).ro.ro_rt =
                                                                    0 as *mut sctp_rtentry_t;
                                                                (*(*chk).whoTo).ro.ro_rt =
                                                                    0 as *mut sctp_rtentry_t
                                                            }
                                                            if (*(*chk).whoTo).src_addr_selected
                                                                != 0
                                                            {
                                                                sctp_free_ifa(
                                                                    (*(*chk).whoTo).ro._s_addr,
                                                                );
                                                                (*(*chk).whoTo).ro._s_addr =
                                                                    0 as *mut sctp_ifa
                                                            }
                                                            (*(*chk).whoTo).src_addr_selected = 0u8;
                                                            (*(*chk).whoTo).dest_state =
                                                                ((*(*chk).whoTo).dest_state
                                                                    as libc::c_int
                                                                    & !(0x1i32))
                                                                    as uint16_t;
                                                            free((*chk).whoTo as *mut libc::c_void);
                                                            ::std::intrinsics::atomic_xsub(
                                                                &mut system_base_info
                                                                    .sctppcbinfo
                                                                    .ipi_count_raddr,
                                                                1u32,
                                                            );
                                                        }
                                                    }
                                                    (*chk).whoTo = 0 as *mut sctp_nets
                                                }
                                                if (*stcb).asoc.free_chunk_cnt as libc::c_uint
                                                    > system_base_info
                                                        .sctpsysctl
                                                        .sctp_asoc_free_resc_limit
                                                    || system_base_info.sctppcbinfo.ipi_free_chunks
                                                        > system_base_info
                                                            .sctpsysctl
                                                            .sctp_system_free_resc_limit
                                                {
                                                    free(chk as *mut libc::c_void);
                                                    ::std::intrinsics::atomic_xsub(
                                                        &mut system_base_info
                                                            .sctppcbinfo
                                                            .ipi_count_chunk,
                                                        1u32,
                                                    );
                                                } else {
                                                    (*chk).sctp_next.tqe_next =
                                                        0 as *mut sctp_tmit_chunk;
                                                    (*chk).sctp_next.tqe_prev =
                                                        (*stcb).asoc.free_chunks.tqh_last;
                                                    *(*stcb).asoc.free_chunks.tqh_last = chk;
                                                    (*stcb).asoc.free_chunks.tqh_last =
                                                        &mut (*chk).sctp_next.tqe_next;
                                                    (*stcb).asoc.free_chunk_cnt =
                                                        (*stcb).asoc.free_chunk_cnt.wrapping_add(1);
                                                    ::std::intrinsics::atomic_xadd(
                                                        &mut system_base_info
                                                            .sctppcbinfo
                                                            .ipi_free_chunks,
                                                        1u32,
                                                    );
                                                }
                                            } else {
                                                free(chk as *mut libc::c_void);
                                                ::std::intrinsics::atomic_xsub(
                                                    &mut system_base_info
                                                        .sctppcbinfo
                                                        .ipi_count_chunk,
                                                    1u32,
                                                );
                                            }
                                            to_move = 0u32;
                                            current_block = 83758123177234263;
                                        } else {
                                            (*m_0).m_hdr.mh_len = 0i32;
                                            (*m_0).m_hdr.mh_next = (*chk).data;
                                            (*chk).data = m_0;
                                            (*(*chk).data).m_hdr.mh_data =
                                                (*(*chk).data).m_hdr.mh_data.offset(
                                                    (((256u64).wrapping_sub(::std::mem::size_of::<
                                                        m_hdr,
                                                    >(
                                                    )
                                                        as libc::c_ulong)
                                                        as libc::c_int
                                                        - 4i32)
                                                        as libc::c_ulong
                                                        & !(::std::mem::size_of::<libc::c_long>()
                                                            as libc::c_ulong)
                                                            .wrapping_sub(1u64))
                                                        as isize,
                                                );
                                            current_block = 9828016697359808143;
                                        }
                                    } else {
                                        current_block = 9828016697359808143;
                                    }
                                    match current_block {
                                        83758123177234263 => {}
                                        _ => {
                                            let mut _mmp = &mut (*chk).data;
                                            let mut _mm = *_mmp;
                                            let mut _mplen =
                                                if (*stcb).asoc.idata_supported as libc::c_int != 0
                                                {
                                                    ::std::mem::size_of::<sctp_idata_chunk>()
                                                        as libc::c_ulong
                                                } else {
                                                    ::std::mem::size_of::<sctp_data_chunk>()
                                                        as libc::c_ulong
                                                }
                                                    as libc::c_int;

                                            if (if (*_mm).m_hdr.mh_flags & 0x1i32 != 0 {
                                                (if (*_mm).m_hdr.mh_flags & 0x8i32 == 0
                                                    && ((*_mm).m_hdr.mh_flags & 0x1i32 == 0
                                                        || *(*_mm).M_dat.MH.MH_dat.MH_ext.ref_cnt
                                                            == 1u32)
                                                {
                                                    (*_mm).m_hdr.mh_data.wrapping_offset_from(
                                                        (*_mm).M_dat.MH.MH_dat.MH_ext.ext_buf,
                                                    )
                                                        as libc::c_long
                                                } else {
                                                    0i64
                                                })
                                            } else {
                                                (if (*_mm).m_hdr.mh_flags & 0x2i32 != 0 {
                                                    (*_mm).m_hdr.mh_data.wrapping_offset_from(
                                                        (*_mm)
                                                            .M_dat
                                                            .MH
                                                            .MH_dat
                                                            .MH_databuf
                                                            .as_mut_ptr(),
                                                    )
                                                        as libc::c_long
                                                } else {
                                                    (*_mm).m_hdr.mh_data.wrapping_offset_from(
                                                        (*_mm).M_dat.M_databuf.as_mut_ptr(),
                                                    )
                                                        as libc::c_long
                                                })
                                            }) >= _mplen as libc::c_long
                                            {
                                                (*_mm).m_hdr.mh_data =
                                                    (*_mm).m_hdr.mh_data.offset(-(_mplen as isize));
                                                (*_mm).m_hdr.mh_len += _mplen
                                            } else {
                                                let mut __mhow = 0x1i32;
                                                _mm = m_prepend(_mm, _mplen, __mhow)
                                            }
                                            if !_mm.is_null() && (*_mm).m_hdr.mh_flags & 0x2i32 != 0
                                            {
                                                (*_mm).M_dat.MH.MH_pkthdr.len += _mplen
                                            }
                                            *_mmp = _mm;
                                            if (*chk).data.is_null() {
                                                /* HELP, TSNH since we assured it would not above? */
                                                if system_base_info.debug_printf.is_some() {
                                                    system_base_info
                                                        .debug_printf
                                                        .expect("non-null function pointer")(
                                                        b"prepend fails HELP?\n\x00" as *const u8
                                                            as *const libc::c_char,
                                                    );
                                                }
                                                if (*chk).holds_key_ref != 0 {
                                                    sctp_auth_key_release(
                                                        stcb,
                                                        (*chk).auth_keyid,
                                                        so_locked,
                                                    );
                                                    (*chk).holds_key_ref = 0u8
                                                }
                                                if !stcb.is_null() {
                                                    if !(*chk).whoTo.is_null() {
                                                        if !(*chk).whoTo.is_null() {
                                                            if ::std::intrinsics::atomic_xadd(
                                                                &mut (*(*chk).whoTo).ref_count
                                                                    as *mut libc::c_int,
                                                                -(1i32),
                                                            ) == 1i32
                                                            {
                                                                sctp_os_timer_stop(
                                                                    &mut (*(*chk).whoTo)
                                                                        .rxt_timer
                                                                        .timer,
                                                                );
                                                                sctp_os_timer_stop(
                                                                    &mut (*(*chk).whoTo)
                                                                        .pmtu_timer
                                                                        .timer,
                                                                );
                                                                sctp_os_timer_stop(
                                                                    &mut (*(*chk).whoTo)
                                                                        .hb_timer
                                                                        .timer,
                                                                );
                                                                if !(*(*chk).whoTo)
                                                                    .ro
                                                                    .ro_rt
                                                                    .is_null()
                                                                {
                                                                    if (*(*(*chk).whoTo).ro.ro_rt)
                                                                        .rt_refcnt
                                                                        <= 1i64
                                                                    {
                                                                        sctp_userspace_rtfree(
                                                                            (*(*chk).whoTo)
                                                                                .ro
                                                                                .ro_rt,
                                                                        );
                                                                    } else {
                                                                        (*(*(*chk).whoTo)
                                                                            .ro
                                                                            .ro_rt)
                                                                            .rt_refcnt -= 1
                                                                    }
                                                                    (*(*chk).whoTo).ro.ro_rt =
                                                                        0 as *mut sctp_rtentry_t;
                                                                    (*(*chk).whoTo).ro.ro_rt =
                                                                        0 as *mut sctp_rtentry_t
                                                                }
                                                                if (*(*chk).whoTo).src_addr_selected
                                                                    != 0
                                                                {
                                                                    sctp_free_ifa(
                                                                        (*(*chk).whoTo).ro._s_addr,
                                                                    );
                                                                    (*(*chk).whoTo).ro._s_addr =
                                                                        0 as *mut sctp_ifa
                                                                }
                                                                (*(*chk).whoTo).src_addr_selected =
                                                                    0u8;
                                                                (*(*chk).whoTo).dest_state =
                                                                    ((*(*chk).whoTo).dest_state
                                                                        as libc::c_int
                                                                        & !(0x1i32))
                                                                        as uint16_t;
                                                                free(
                                                                    (*chk).whoTo
                                                                        as *mut libc::c_void,
                                                                );
                                                                ::std::intrinsics::atomic_xsub(
                                                                    &mut system_base_info
                                                                        .sctppcbinfo
                                                                        .ipi_count_raddr,
                                                                    1u32,
                                                                );
                                                            }
                                                        }
                                                        (*chk).whoTo = 0 as *mut sctp_nets
                                                    }
                                                    if (*stcb).asoc.free_chunk_cnt as libc::c_uint
                                                        > system_base_info
                                                            .sctpsysctl
                                                            .sctp_asoc_free_resc_limit
                                                        || system_base_info
                                                            .sctppcbinfo
                                                            .ipi_free_chunks
                                                            > system_base_info
                                                                .sctpsysctl
                                                                .sctp_system_free_resc_limit
                                                    {
                                                        free(chk as *mut libc::c_void);
                                                        ::std::intrinsics::atomic_xsub(
                                                            &mut system_base_info
                                                                .sctppcbinfo
                                                                .ipi_count_chunk,
                                                            1u32,
                                                        );
                                                    } else {
                                                        (*chk).sctp_next.tqe_next =
                                                            0 as *mut sctp_tmit_chunk;
                                                        (*chk).sctp_next.tqe_prev =
                                                            (*stcb).asoc.free_chunks.tqh_last;
                                                        *(*stcb).asoc.free_chunks.tqh_last = chk;
                                                        (*stcb).asoc.free_chunks.tqh_last =
                                                            &mut (*chk).sctp_next.tqe_next;
                                                        (*stcb).asoc.free_chunk_cnt = (*stcb)
                                                            .asoc
                                                            .free_chunk_cnt
                                                            .wrapping_add(1);
                                                        ::std::intrinsics::atomic_xadd(
                                                            &mut system_base_info
                                                                .sctppcbinfo
                                                                .ipi_free_chunks,
                                                            1u32,
                                                        );
                                                    }
                                                } else {
                                                    free(chk as *mut libc::c_void);
                                                    ::std::intrinsics::atomic_xsub(
                                                        &mut system_base_info
                                                            .sctppcbinfo
                                                            .ipi_count_chunk,
                                                        1u32,
                                                    );
                                                }
                                                *bail = 1i32;
                                                to_move = 0u32
                                            } else {
                                                let mut dchkh = 0 as *mut sctp_data_chunk;
                                                let mut ndchkh = 0 as *mut sctp_idata_chunk;
                                                ::std::intrinsics::atomic_xadd(
                                                    &mut (*stcb).asoc.total_output_queue_size,
                                                    if (*stcb).asoc.idata_supported as libc::c_int
                                                        != 0
                                                    {
                                                        ::std::mem::size_of::<sctp_idata_chunk>()
                                                            as libc::c_ulong
                                                    } else {
                                                        ::std::mem::size_of::<sctp_data_chunk>()
                                                            as libc::c_ulong
                                                    }
                                                        as uint32_t,
                                                );
                                                if !(*stcb).sctp_socket.is_null()
                                                    && ((*(*stcb).sctp_ep).sctp_flags & 0x2u32 != 0
                                                        || (*(*stcb).sctp_ep).sctp_flags
                                                            & 0x400000u32
                                                            != 0)
                                                {
                                                    ::std::intrinsics::atomic_xadd(
                                                        &mut (*(*stcb).sctp_socket).so_snd.sb_cc,
                                                        if (*stcb).asoc.idata_supported
                                                            as libc::c_int
                                                            != 0
                                                        {
                                                            ::std::mem::size_of::<sctp_idata_chunk>(
                                                            )
                                                                as libc::c_ulong
                                                        } else {
                                                            ::std::mem::size_of::<sctp_data_chunk>()
                                                                as libc::c_ulong
                                                        }
                                                            as u_int,
                                                    );
                                                }
                                                (*chk).send_size = (to_move as libc::c_ulong)
                                                    .wrapping_add(
                                                        (if (*stcb).asoc.idata_supported
                                                            as libc::c_int
                                                            != 0
                                                        {
                                                            ::std::mem::size_of::<sctp_idata_chunk>(
                                                            )
                                                                as libc::c_ulong
                                                        } else {
                                                            ::std::mem::size_of::<sctp_data_chunk>()
                                                                as libc::c_ulong
                                                        }),
                                                    )
                                                    as uint16_t;
                                                (*chk).book_size = (*chk).send_size;
                                                (*chk).book_size_scale = 0u8;
                                                (*chk).sent = 0i32;
                                                (*chk).flags = 0u16;
                                                (*chk).asoc = &mut (*stcb).asoc;
                                                (*chk).pad_inplace = 0u8;
                                                (*chk).no_fr_allowed = 0u8;
                                                if (*stcb).asoc.idata_supported as libc::c_int
                                                    == 0i32
                                                {
                                                    if rcv_flags as libc::c_int & 0x4i32 != 0 {
                                                        /* Just use 0. The receiver ignores the values. */
                                                        (*chk).rec.data.mid = 0u32
                                                    } else {
                                                        (*chk).rec.data.mid =
                                                            (*strq).next_mid_ordered;
                                                        if rcv_flags as libc::c_int & 0x1i32 != 0 {
                                                            (*strq).next_mid_ordered = (*strq)
                                                                .next_mid_ordered
                                                                .wrapping_add(1)
                                                        }
                                                    }
                                                } else if rcv_flags as libc::c_int & 0x4i32 != 0 {
                                                    (*chk).rec.data.mid =
                                                        (*strq).next_mid_unordered;
                                                    if rcv_flags as libc::c_int & 0x1i32 != 0 {
                                                        (*strq).next_mid_unordered = (*strq)
                                                            .next_mid_unordered
                                                            .wrapping_add(1)
                                                    }
                                                } else {
                                                    (*chk).rec.data.mid = (*strq).next_mid_ordered;
                                                    if rcv_flags as libc::c_int & 0x1i32 != 0 {
                                                        (*strq).next_mid_ordered =
                                                            (*strq).next_mid_ordered.wrapping_add(1)
                                                    }
                                                }
                                                (*chk).rec.data.sid = (*sp).sid;
                                                (*chk).rec.data.ppid = (*sp).ppid;
                                                (*chk).rec.data.context = (*sp).context;
                                                (*chk).rec.data.doing_fast_retransmit = 0u8;
                                                (*chk).rec.data.timetodrop = (*sp).ts;
                                                (*chk).flags = (*sp).act_flags;
                                                if !(*sp).net.is_null() {
                                                    (*chk).whoTo = (*sp).net;
                                                    ::std::intrinsics::atomic_xadd(
                                                        &mut (*(*chk).whoTo).ref_count,
                                                        1i32,
                                                    );
                                                } else {
                                                    (*chk).whoTo = 0 as *mut sctp_nets
                                                }
                                                if (*sp).holds_key_ref != 0 {
                                                    (*chk).auth_keyid = (*sp).auth_keyid;
                                                    sctp_auth_key_acquire(stcb, (*chk).auth_keyid);
                                                    (*chk).holds_key_ref = 1u8
                                                }
                                                let fresh34 = (*asoc).sending_seq;
                                                (*asoc).sending_seq =
                                                    (*asoc).sending_seq.wrapping_add(1);
                                                (*chk).rec.data.tsn = fresh34;
                                                if system_base_info.sctpsysctl.sctp_logging_level
                                                    & 0x8000000u32
                                                    != 0
                                                {
                                                    sctp_misc_ints(
                                                        106u8,
                                                        stcb as uint32_t,
                                                        (*sp).length,
                                                        (((*chk).rec.data.sid as libc::c_int)
                                                            << 16i32)
                                                            as libc::c_uint
                                                            | 0xffffu32 & (*chk).rec.data.mid,
                                                        (*chk).rec.data.tsn,
                                                    );
                                                }
                                                if (*stcb).asoc.idata_supported as libc::c_int
                                                    == 0i32
                                                {
                                                    dchkh = (*(*chk).data).m_hdr.mh_data
                                                        as *mut sctp_data_chunk
                                                } else {
                                                    ndchkh = (*(*chk).data).m_hdr.mh_data
                                                        as *mut sctp_idata_chunk
                                                }
                                                /*
                                                 * Put the rest of the things in place now. Size was done
                                                 * earlier in previous loop prior to padding.
                                                 */
                                                if (*stcb).asoc.idata_supported as libc::c_int
                                                    == 0i32
                                                {
                                                    (*dchkh).ch.chunk_type = 0u8;
                                                    (*dchkh).ch.chunk_flags =
                                                        (*chk).rec.data.rcv_flags;
                                                    (*dchkh).dp.tsn = htonl((*chk).rec.data.tsn);
                                                    (*dchkh).dp.sid = htons((*strq).sid);
                                                    (*dchkh).dp.ssn =
                                                        htons((*chk).rec.data.mid as uint16_t);
                                                    (*dchkh).dp.ppid = (*chk).rec.data.ppid;
                                                    (*dchkh).ch.chunk_length =
                                                        htons((*chk).send_size)
                                                } else {
                                                    (*ndchkh).ch.chunk_type = 0x40u8;
                                                    (*ndchkh).ch.chunk_flags =
                                                        (*chk).rec.data.rcv_flags;
                                                    (*ndchkh).dp.tsn = htonl((*chk).rec.data.tsn);
                                                    (*ndchkh).dp.sid = htons((*strq).sid);
                                                    (*ndchkh).dp.reserved = htons(0u16);
                                                    (*ndchkh).dp.mid = htonl((*chk).rec.data.mid);
                                                    if (*sp).fsn == 0u32 {
                                                        (*ndchkh).dp.ppid_fsn.ppid =
                                                            (*chk).rec.data.ppid
                                                    } else {
                                                        (*ndchkh).dp.ppid_fsn.fsn = htonl((*sp).fsn)
                                                    }
                                                    (*sp).fsn = (*sp).fsn.wrapping_add(1);
                                                    (*ndchkh).ch.chunk_length =
                                                        htons((*chk).send_size)
                                                }
                                                /* Now advance the chk->send_size by the actual pad needed. */
                                                if ((*chk).send_size as libc::c_int)
                                                    < ((*chk).book_size as libc::c_int + 3i32
                                                        >> 2i32)
                                                        << 2i32
                                                {
                                                    let mut lm = 0 as *mut mbuf;
                                                    let mut pads = 0;
                                                    pads = (((*chk).book_size as libc::c_int
                                                        + 3i32
                                                        >> 2i32)
                                                        << 2i32)
                                                        - (*chk).send_size as libc::c_int;
                                                    lm = sctp_pad_lastmbuf(
                                                        (*chk).data,
                                                        pads,
                                                        (*chk).last_mbuf,
                                                    );
                                                    if !lm.is_null() {
                                                        (*chk).last_mbuf = lm;
                                                        (*chk).pad_inplace = 1u8
                                                    }
                                                    (*chk).send_size =
                                                        ((*chk).send_size as libc::c_int + pads)
                                                            as uint16_t
                                                }
                                                if (*chk).flags as libc::c_int & 0xfi32 != 0i32
                                                    && (*chk).flags as libc::c_int & 0xfi32
                                                        != 0xfi32
                                                {
                                                    (*asoc).pr_sctp_cnt =
                                                        (*asoc).pr_sctp_cnt.wrapping_add(1)
                                                }
                                                if (*sp).msg_is_complete as libc::c_int != 0
                                                    && (*sp).length == 0u32
                                                    && (*sp).sender_all_done as libc::c_int != 0
                                                {
                                                    /* All done pull and kill the message */
                                                    if (*sp).put_last_out as libc::c_int == 0i32 {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"Gak, put out entire msg with NO end!-2\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char);
                                                        }
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"sender_done:%d len:%d msg_comp:%d put_last_out:%d send_lock:%d\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char,
                                                                                                                              (*sp).sender_all_done
                                                                                                                                  as
                                                                                                                                  libc::c_int,
                                                                                                                              (*sp).length,
                                                                                                                              (*sp).msg_is_complete
                                                                                                                                  as
                                                                                                                                  libc::c_int,
                                                                                                                              (*sp).put_last_out
                                                                                                                                  as
                                                                                                                                  libc::c_int,
                                                                                                                              send_lock_up
                                                                                                                                  as
                                                                                                                                  libc::c_int);
                                                        }
                                                    }
                                                    if send_lock_up as libc::c_int == 0i32
                                                        && (*sp).next.tqe_next.is_null()
                                                    {
                                                        pthread_mutex_lock(
                                                            &mut (*stcb).tcb_send_mtx,
                                                        );
                                                        send_lock_up = 1u8
                                                    }
                                                    ::std::intrinsics::atomic_xsub(
                                                        &mut (*asoc).stream_queue_cnt,
                                                        1u32,
                                                    );
                                                    if !(*sp).next.tqe_next.is_null() {
                                                        (*(*sp).next.tqe_next).next.tqe_prev =
                                                            (*sp).next.tqe_prev
                                                    } else {
                                                        (*strq).outqueue.tqh_last =
                                                            (*sp).next.tqe_prev
                                                    }
                                                    *(*sp).next.tqe_prev = (*sp).next.tqe_next;
                                                    (*stcb)
                                                        .asoc
                                                        .ss_functions
                                                        .sctp_ss_remove_from_stream
                                                        .expect("non-null function pointer")(
                                                        stcb,
                                                        asoc,
                                                        strq,
                                                        sp,
                                                        send_lock_up as libc::c_int,
                                                    );
                                                    if (*strq).state as libc::c_int == 0x3i32
                                                        && (*strq).chunks_on_queues == 0u32
                                                        && (*strq).outqueue.tqh_first.is_null()
                                                    {
                                                        (*stcb).asoc.trigger_reset = 1u8
                                                    }
                                                    if !(*sp).net.is_null() {
                                                        if !(*sp).net.is_null() {
                                                            if ::std::intrinsics::atomic_xadd(
                                                                &mut (*(*sp).net).ref_count
                                                                    as *mut libc::c_int,
                                                                -(1i32),
                                                            ) == 1i32
                                                            {
                                                                sctp_os_timer_stop(
                                                                    &mut (*(*sp).net)
                                                                        .rxt_timer
                                                                        .timer,
                                                                );
                                                                sctp_os_timer_stop(
                                                                    &mut (*(*sp).net)
                                                                        .pmtu_timer
                                                                        .timer,
                                                                );
                                                                sctp_os_timer_stop(
                                                                    &mut (*(*sp).net)
                                                                        .hb_timer
                                                                        .timer,
                                                                );
                                                                if !(*(*sp).net).ro.ro_rt.is_null()
                                                                {
                                                                    if (*(*(*sp).net).ro.ro_rt)
                                                                        .rt_refcnt
                                                                        <= 1i64
                                                                    {
                                                                        sctp_userspace_rtfree(
                                                                            (*(*sp).net).ro.ro_rt,
                                                                        );
                                                                    } else {
                                                                        (*(*(*sp).net).ro.ro_rt)
                                                                            .rt_refcnt -= 1
                                                                    }
                                                                    (*(*sp).net).ro.ro_rt =
                                                                        0 as *mut sctp_rtentry_t;
                                                                    (*(*sp).net).ro.ro_rt =
                                                                        0 as *mut sctp_rtentry_t
                                                                }
                                                                if (*(*sp).net).src_addr_selected
                                                                    != 0
                                                                {
                                                                    sctp_free_ifa(
                                                                        (*(*sp).net).ro._s_addr,
                                                                    );
                                                                    (*(*sp).net).ro._s_addr =
                                                                        0 as *mut sctp_ifa
                                                                }
                                                                (*(*sp).net).src_addr_selected =
                                                                    0u8;
                                                                (*(*sp).net).dest_state =
                                                                    ((*(*sp).net).dest_state
                                                                        as libc::c_int
                                                                        & !(0x1i32))
                                                                        as uint16_t;
                                                                free(
                                                                    (*sp).net as *mut libc::c_void,
                                                                );
                                                                ::std::intrinsics::atomic_xsub(
                                                                    &mut system_base_info
                                                                        .sctppcbinfo
                                                                        .ipi_count_raddr,
                                                                    1u32,
                                                                );
                                                            }
                                                        }
                                                        (*sp).net = 0 as *mut sctp_nets
                                                    }
                                                    if !(*sp).data.is_null() {
                                                        m_freem((*sp).data);
                                                        (*sp).data = 0 as *mut mbuf
                                                    }
                                                    if (*sp).holds_key_ref != 0 {
                                                        sctp_auth_key_release(
                                                            stcb,
                                                            (*sp).auth_keyid,
                                                            so_locked,
                                                        );
                                                        (*sp).holds_key_ref = 0u8
                                                    }
                                                    free(sp as *mut libc::c_void);
                                                    ::std::intrinsics::atomic_xsub(
                                                        &mut system_base_info
                                                            .sctppcbinfo
                                                            .ipi_count_strmoq,
                                                        1u32,
                                                    );
                                                }
                                                (*asoc).chunks_on_out_queue =
                                                    (*asoc).chunks_on_out_queue.wrapping_add(1);
                                                (*strq).chunks_on_queues =
                                                    (*strq).chunks_on_queues.wrapping_add(1);
                                                (*chk).sctp_next.tqe_next =
                                                    0 as *mut sctp_tmit_chunk;
                                                (*chk).sctp_next.tqe_prev =
                                                    (*asoc).send_queue.tqh_last;
                                                *(*asoc).send_queue.tqh_last = chk;
                                                (*asoc).send_queue.tqh_last =
                                                    &mut (*chk).sctp_next.tqe_next;
                                                (*asoc).send_queue_cnt =
                                                    (*asoc).send_queue_cnt.wrapping_add(1)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        10863493864285401582 => {
            /* no */
            *giveup = 1i32;
            to_move = 0u32
        }
        _ => {}
    }
    if send_lock_up != 0 {
        pthread_mutex_unlock(&mut (*stcb).tcb_send_mtx);
    }
    return to_move;
}
unsafe extern "C" fn sctp_fill_outqueue(
    mut stcb: *mut sctp_tcb,
    mut net: *mut sctp_nets,
    mut frag_point: libc::c_int,
    mut eeor_mode: libc::c_int,
    mut quit_now: *mut libc::c_int,
    mut so_locked: libc::c_int,
) {
    let mut asoc = 0 as *mut sctp_association;
    let mut strq = 0 as *mut sctp_stream_out;
    let mut space_left = 0;
    let mut total_moved = 0;
    let mut bail = 0;
    let mut giveup = 0;
    asoc = &mut (*stcb).asoc;
    total_moved = 0u32;
    match (*net).ro._l_addr.sa.sa_family as libc::c_int {
        2 => {
            space_left = ((*net).mtu as libc::c_ulong).wrapping_sub(
                (::std::mem::size_of::<ip>() as libc::c_ulong)
                    .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong),
            ) as uint32_t
        }
        10 => {
            space_left = ((*net).mtu as libc::c_ulong).wrapping_sub(
                (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
                    .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong),
            ) as uint32_t
        }
        123 => {
            space_left = ((*net).mtu as libc::c_ulong)
                .wrapping_sub(::std::mem::size_of::<sctphdr>() as libc::c_ulong)
                as uint32_t
        }
        _ => {
            /* TSNH */
            space_left = (*net).mtu
        }
    }
    /* Need an allowance for the data chunk header too */
    space_left = (space_left as libc::c_ulong).wrapping_sub(
        if (*stcb).asoc.idata_supported as libc::c_int != 0 {
            ::std::mem::size_of::<sctp_idata_chunk>() as libc::c_ulong
        } else {
            ::std::mem::size_of::<sctp_data_chunk>() as libc::c_ulong
        },
    ) as uint32_t;
    /* must make even word boundary */
    space_left &= 0xfffffffcu32;
    strq = (*stcb)
        .asoc
        .ss_functions
        .sctp_ss_select_stream
        .expect("non-null function pointer")(stcb, net, asoc);
    giveup = 0i32;
    bail = 0i32;
    while space_left > 0u32 && !strq.is_null() {
        let mut moved = 0;
        moved = sctp_move_to_outqueue(
            stcb,
            strq,
            space_left,
            frag_point as uint32_t,
            &mut giveup,
            eeor_mode,
            &mut bail,
            so_locked,
        );
        (*stcb)
            .asoc
            .ss_functions
            .sctp_ss_scheduled
            .expect("non-null function pointer")(
            stcb, net, asoc, strq, moved as libc::c_int
        );
        if giveup != 0i32 || bail != 0i32 {
            break;
        }
        strq = (*stcb)
            .asoc
            .ss_functions
            .sctp_ss_select_stream
            .expect("non-null function pointer")(stcb, net, asoc);
        total_moved = (total_moved).wrapping_add(moved);
        space_left = (space_left).wrapping_sub(moved);
        if space_left as libc::c_ulong
            >= (if (*stcb).asoc.idata_supported as libc::c_int != 0 {
                ::std::mem::size_of::<sctp_idata_chunk>() as libc::c_ulong
            } else {
                ::std::mem::size_of::<sctp_data_chunk>() as libc::c_ulong
            })
        {
            space_left = (space_left as libc::c_ulong).wrapping_sub(
                if (*stcb).asoc.idata_supported as libc::c_int != 0 {
                    ::std::mem::size_of::<sctp_idata_chunk>() as libc::c_ulong
                } else {
                    ::std::mem::size_of::<sctp_data_chunk>() as libc::c_ulong
                },
            ) as uint32_t
        } else {
            space_left = 0u32
        }
        space_left &= 0xfffffffcu32
    }
    if bail != 0i32 {
        *quit_now = 1i32
    }
    (*stcb)
        .asoc
        .ss_functions
        .sctp_ss_packet_done
        .expect("non-null function pointer")(stcb, net, asoc);
    if total_moved == 0u32 {
        if (*stcb).asoc.sctp_cmt_on_off as libc::c_int == 0i32
            && net == (*stcb).asoc.primary_destination
        {
            /* ran dry for primary network net */
            ::std::intrinsics::atomic_xadd(
                &mut system_base_info.sctpstat.sctps_primary_randry,
                1u32,
            );
        } else if (*stcb).asoc.sctp_cmt_on_off as libc::c_int > 0i32 {
            /* ran dry with CMT on */
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_cmt_randry, 1u32);
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn sctp_fix_ecn_echo(mut asoc: *mut sctp_association) {
    let mut chk = 0 as *mut sctp_tmit_chunk;
    chk = (*asoc).control_send_queue.tqh_first;
    while !chk.is_null() {
        if (*chk).rec.chunk_id.id as libc::c_int == 0xci32 {
            (*chk).sent = 0i32
        }
        chk = (*chk).sctp_next.tqe_next
    }
}
#[no_mangle]
pub unsafe extern "C" fn sctp_move_chunks_from_net(
    mut stcb: *mut sctp_tcb,
    mut net: *mut sctp_nets,
) {
    let mut asoc = 0 as *mut sctp_association;
    let mut chk = 0 as *mut sctp_tmit_chunk;
    let mut i = 0;
    if net.is_null() {
        return;
    }
    asoc = &mut (*stcb).asoc;
    i = 0u32;
    while i < (*stcb).asoc.streamoutcnt as libc::c_uint {
        let mut sp = 0 as *mut sctp_stream_queue_pending;
        sp = (*(*stcb).asoc.strmout.offset(i as isize))
            .outqueue
            .tqh_first;
        while !sp.is_null() {
            if (*sp).net == net {
                if !(*sp).net.is_null() {
                    if ::std::intrinsics::atomic_xadd(
                        &mut (*(*sp).net).ref_count as *mut libc::c_int,
                        -(1i32),
                    ) == 1i32
                    {
                        sctp_os_timer_stop(&mut (*(*sp).net).rxt_timer.timer);
                        sctp_os_timer_stop(&mut (*(*sp).net).pmtu_timer.timer);
                        sctp_os_timer_stop(&mut (*(*sp).net).hb_timer.timer);
                        if !(*(*sp).net).ro.ro_rt.is_null() {
                            if (*(*(*sp).net).ro.ro_rt).rt_refcnt <= 1i64 {
                                sctp_userspace_rtfree((*(*sp).net).ro.ro_rt);
                            } else {
                                (*(*(*sp).net).ro.ro_rt).rt_refcnt -= 1
                            }
                            (*(*sp).net).ro.ro_rt = 0 as *mut sctp_rtentry_t;
                            (*(*sp).net).ro.ro_rt = 0 as *mut sctp_rtentry_t
                        }
                        if (*(*sp).net).src_addr_selected != 0 {
                            sctp_free_ifa((*(*sp).net).ro._s_addr);
                            (*(*sp).net).ro._s_addr = 0 as *mut sctp_ifa
                        }
                        (*(*sp).net).src_addr_selected = 0u8;
                        (*(*sp).net).dest_state =
                            ((*(*sp).net).dest_state as libc::c_int & !(0x1i32)) as uint16_t;
                        free((*sp).net as *mut libc::c_void);
                        ::std::intrinsics::atomic_xsub(
                            &mut system_base_info.sctppcbinfo.ipi_count_raddr,
                            1u32,
                        );
                    }
                }
                (*sp).net = 0 as *mut sctp_nets
            }
            sp = (*sp).next.tqe_next
        }
        i = i.wrapping_add(1)
    }
    chk = (*asoc).send_queue.tqh_first;
    while !chk.is_null() {
        if (*chk).whoTo == net {
            if !(*chk).whoTo.is_null() {
                if ::std::intrinsics::atomic_xadd(
                    &mut (*(*chk).whoTo).ref_count as *mut libc::c_int,
                    -(1i32),
                ) == 1i32
                {
                    sctp_os_timer_stop(&mut (*(*chk).whoTo).rxt_timer.timer);
                    sctp_os_timer_stop(&mut (*(*chk).whoTo).pmtu_timer.timer);
                    sctp_os_timer_stop(&mut (*(*chk).whoTo).hb_timer.timer);
                    if !(*(*chk).whoTo).ro.ro_rt.is_null() {
                        if (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt <= 1i64 {
                            sctp_userspace_rtfree((*(*chk).whoTo).ro.ro_rt);
                        } else {
                            (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt -= 1
                        }
                        (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t;
                        (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t
                    }
                    if (*(*chk).whoTo).src_addr_selected != 0 {
                        sctp_free_ifa((*(*chk).whoTo).ro._s_addr);
                        (*(*chk).whoTo).ro._s_addr = 0 as *mut sctp_ifa
                    }
                    (*(*chk).whoTo).src_addr_selected = 0u8;
                    (*(*chk).whoTo).dest_state =
                        ((*(*chk).whoTo).dest_state as libc::c_int & !(0x1i32)) as uint16_t;
                    free((*chk).whoTo as *mut libc::c_void);
                    ::std::intrinsics::atomic_xsub(
                        &mut system_base_info.sctppcbinfo.ipi_count_raddr,
                        1u32,
                    );
                }
            }
            (*chk).whoTo = 0 as *mut sctp_nets
        }
        chk = (*chk).sctp_next.tqe_next
    }
}
unsafe extern "C" fn sctp_med_chunk_output(
    mut inp: *mut sctp_inpcb,
    mut stcb: *mut sctp_tcb,
    mut asoc: *mut sctp_association,
    mut num_out: *mut libc::c_int,
    mut reason_code: *mut libc::c_int,
    mut control_only: libc::c_int,
    mut from_where: libc::c_int,
    mut now: *mut timeval,
    mut now_filled: *mut libc::c_int,
    mut frag_point: libc::c_int,
    mut so_locked: libc::c_int,
) -> libc::c_int {
    /* JRS 5/14/07 - Add flag for whether a heartbeat is sent to
    the destination. */
    let mut hbflag = 0;
    let mut asconf = 0;
    let mut cookie = 0;
    let mut no_out_cnt = 0;
    let mut ctl_cnt = 0;
    let mut no_data_chunks = 0;
    let mut eeor_mode = 0;
    let mut auth_keyid = 0;
    *num_out = 0i32;
    *reason_code = 0i32;
    auth_keyid = (*stcb).asoc.authinfo.active_keyid;
    if (*asoc).state & 0x80i32 != 0
        || (*stcb).asoc.state & 0x7fi32 == 0x20i32
        || (*inp).sctp_features & 0x400000u64 == 0x400000u64
    {
        eeor_mode = 1i32
    } else {
        eeor_mode = 0i32
    }
    cookie = 0i32;
    asconf = cookie;
    no_out_cnt = asconf;
    ctl_cnt = no_out_cnt;
    /*
     * First lets prime the pump. For each destination, if there is room
     * in the flight size, attempt to pull an MTU's worth out of the
     * stream queues into the general send_queue
     */
    hbflag = 0i32;
    if control_only != 0 {
        no_data_chunks = 1i32
    } else {
        no_data_chunks = 0i32
    }
    /* Nothing to possible to send? */
    if !(((*asoc).control_send_queue.tqh_first.is_null()
        || (*asoc).ctrl_queue_cnt == (*stcb).asoc.ecn_echo_cnt_onq as libc::c_int)
        && (*asoc).asconf_send_queue.tqh_first.is_null()
        && (*asoc).send_queue.tqh_first.is_null()
        && sctp_is_there_unsent_data(stcb, so_locked) == 0i32)
    {
        let mut current_block: u64;
        let mut sack_goes_to = 0 as *mut sctp_nets;
        let mut chk = 0 as *mut sctp_tmit_chunk;
        if (*asoc).peers_rwnd == 0u32 {
            /* No room in peers rwnd */
            *reason_code = 1i32;
            if (*asoc).total_flight > 0u32 {
                /* we are allowed one chunk in flight */
                no_data_chunks = 1i32
            }
        }
        if (*stcb).asoc.ecn_echo_cnt_onq != 0 {
            /* Record where a sack goes, if any */
            if no_data_chunks != 0
                && (*asoc).ctrl_queue_cnt == (*stcb).asoc.ecn_echo_cnt_onq as libc::c_int
            {
                current_block = 2637080092179448240;
            } else {
                chk = (*asoc).control_send_queue.tqh_first;
                while !chk.is_null() {
                    if (*chk).rec.chunk_id.id as libc::c_int == 0x3i32
                        || (*chk).rec.chunk_id.id as libc::c_int == 0x10i32
                    {
                        sack_goes_to = (*chk).whoTo;
                        break;
                    } else {
                        chk = (*chk).sctp_next.tqe_next
                    }
                }
                current_block = 7226443171521532240;
            }
        } else {
            current_block = 7226443171521532240;
        }
        match current_block {
            2637080092179448240 => {}
            _ => {
                let mut net = 0 as *mut sctp_nets;
                let mut start_at = 0 as *mut sctp_nets;
                let mut old_start_at = 0 as *mut sctp_nets;
                let mut max_rwnd_per_dest = 0;
                let mut max_send_per_dest = 0;
                let mut skip_fill_up = 0i32;
                max_rwnd_per_dest = (*asoc)
                    .peers_rwnd
                    .wrapping_add((*asoc).total_flight)
                    .wrapping_div((*asoc).numnets);
                if !(*stcb).sctp_socket.is_null() {
                    max_send_per_dest = (*(*stcb).sctp_socket)
                        .so_snd
                        .sb_hiwat
                        .wrapping_div((*asoc).numnets)
                } else {
                    max_send_per_dest = 0u32
                }
                if no_data_chunks == 0i32 {
                    /* How many non-directed chunks are there? */
                    chk = (*asoc).send_queue.tqh_first;
                    while !chk.is_null() {
                        if (*chk).whoTo.is_null() {
                            /* We already have non-directed
                             * chunks on the queue, no need
                             * to do a fill-up.
                             */
                            skip_fill_up = 1i32;
                            break;
                        } else {
                            chk = (*chk).sctp_next.tqe_next
                        }
                    }
                }
                if no_data_chunks == 0i32
                    && skip_fill_up == 0i32
                    && (*stcb)
                        .asoc
                        .ss_functions
                        .sctp_ss_is_empty
                        .expect("non-null function pointer")(stcb, asoc)
                        == 0
                {
                    net = (*asoc).nets.tqh_first;
                    while !net.is_null() {
                        /*
                         * This for loop we are in takes in
                         * each net, if its's got space in cwnd and
                         * has data sent to it (when CMT is off) then it
                         * calls sctp_fill_outqueue for the net. This gets
                         * data on the send queue for that network.
                         *
                         * In sctp_fill_outqueue TSN's are assigned and
                         * data is copied out of the stream buffers. Note
                         * mostly copy by reference (we hope).
                         */
                        (*net).window_probe = 0u8;
                        if net != (*stcb).asoc.alternate
                            && ((*net).dest_state as libc::c_int & 0x800i32 != 0
                                || (*net).dest_state as libc::c_int & 0x1i32 == 0
                                || (*net).dest_state as libc::c_int & 0x200i32 != 0)
                        {
                            if system_base_info.sctpsysctl.sctp_logging_level & 0x4u32 != 0 {
                                sctp_log_cwnd(stcb, net, 1i32, 69u8);
                            }
                        } else {
                            if (*stcb)
                                .asoc
                                .cc_functions
                                .sctp_cwnd_new_transmission_begins
                                .is_some()
                                && (*net).flight_size == 0u32
                            {
                                Some(
                                    (*stcb)
                                        .asoc
                                        .cc_functions
                                        .sctp_cwnd_new_transmission_begins
                                        .expect("non-null function pointer"),
                                )
                                .expect("non-null function pointer")(
                                    stcb, net
                                );
                            }
                            if (*net).flight_size >= (*net).cwnd {
                                /* skip this network, no room - can't fill */
                                if system_base_info.sctpsysctl.sctp_logging_level & 0x4u32 != 0 {
                                    sctp_log_cwnd(stcb, net, 3i32, 69u8);
                                }
                            } else {
                                let mut quit_now = 0i32;
                                if system_base_info.sctpsysctl.sctp_logging_level & 0x4u32 != 0 {
                                    sctp_log_cwnd(stcb, net, 4i32, 69u8);
                                }
                                sctp_fill_outqueue(
                                    stcb,
                                    net,
                                    frag_point,
                                    eeor_mode,
                                    &mut quit_now,
                                    so_locked,
                                );
                                if quit_now != 0 {
                                    /* memory alloc failure */
                                    no_data_chunks = 1i32;
                                    break;
                                }
                            }
                        }
                        net = (*net).sctp_next.tqe_next
                    }
                }
                /* now service each destination and send out what we can for it */
                /* Nothing to send? */
                if (*asoc).control_send_queue.tqh_first.is_null()
                    && (*asoc).asconf_send_queue.tqh_first.is_null()
                    && (*asoc).send_queue.tqh_first.is_null()
                {
                    *reason_code = 8i32;
                    return 0i32;
                }
                if (*asoc).sctp_cmt_on_off as libc::c_int > 0i32 {
                    /* get the last start point */
                    start_at = (*asoc).last_net_cmt_send_started;
                    if start_at.is_null() {
                        /* null so to beginning */
                        start_at = (*asoc).nets.tqh_first
                    } else {
                        start_at = (*(*asoc).last_net_cmt_send_started).sctp_next.tqe_next;
                        if start_at.is_null() {
                            start_at = (*asoc).nets.tqh_first
                        }
                    }
                    (*asoc).last_net_cmt_send_started = start_at
                } else {
                    start_at = (*asoc).nets.tqh_first
                }
                chk = (*asoc).control_send_queue.tqh_first;
                while !chk.is_null() {
                    if (*chk).whoTo.is_null() {
                        if !(*asoc).alternate.is_null() {
                            (*chk).whoTo = (*asoc).alternate
                        } else {
                            (*chk).whoTo = (*asoc).primary_destination
                        }
                        ::std::intrinsics::atomic_xadd(&mut (*(*chk).whoTo).ref_count, 1i32);
                    }
                    chk = (*chk).sctp_next.tqe_next
                }
                old_start_at = 0 as *mut sctp_nets;
                loop {
                    net = start_at;
                    while !net.is_null() {
                        let mut tsns_sent = 0i32;
                        if !old_start_at.is_null() && old_start_at == net {
                            break;
                        }
                        tsns_sent = 0xai32;
                        if !((*asoc).control_send_queue.tqh_first.is_null()
                            && (*asoc).asconf_send_queue.tqh_first.is_null()
                            && (*net).flight_size >= (*net).cwnd)
                        {
                            let mut outchain = 0 as *mut mbuf;
                            let mut endoutchain = 0 as *mut mbuf;
                            let mut nchk = 0 as *mut sctp_tmit_chunk;
                            let mut no_fragmentflg = 0;
                            let mut error = 0;
                            let mut one_chunk = 0;
                            let mut skip_data_for_this_net = 0;
                            let mut bundle_at = 0;
                            let mut mtu = 0;
                            let mut r_mtu = 0;
                            let mut omtu = 0;
                            let mut mx_mtu = 0;
                            let mut to_out = 0;
                            let mut auth_offset = 0;
                            let mut auth = 0 as *mut sctp_auth_chunk;
                            bundle_at = 0i32;
                            outchain = 0 as *mut mbuf;
                            endoutchain = outchain;
                            auth = 0 as *mut sctp_auth_chunk;
                            auth_offset = 0u32;
                            no_fragmentflg = 1i32;
                            one_chunk = 0i32;
                            if (*net).dest_state as libc::c_int & 0x200i32 != 0 {
                                skip_data_for_this_net = 1i32
                            } else {
                                skip_data_for_this_net = 0i32
                            }
                            match (*(&mut (*net).ro._l_addr as *mut sctp_sockstore
                                as *mut sockaddr))
                                .sa_family as libc::c_int
                            {
                                2 => {
                                    mtu = ((*net).mtu as libc::c_ulong).wrapping_sub(
                                        (::std::mem::size_of::<ip>() as libc::c_ulong)
                                            .wrapping_add(
                                                ::std::mem::size_of::<sctphdr>() as libc::c_ulong
                                            ),
                                    ) as libc::c_uint
                                }
                                10 => {
                                    mtu = ((*net).mtu as libc::c_ulong).wrapping_sub(
                                        (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
                                            .wrapping_add(
                                                ::std::mem::size_of::<sctphdr>() as libc::c_ulong
                                            ),
                                    ) as libc::c_uint
                                }
                                123 => {
                                    mtu = ((*net).mtu as libc::c_ulong).wrapping_sub(
                                        ::std::mem::size_of::<sctphdr>() as libc::c_ulong,
                                    ) as libc::c_uint
                                }
                                _ => {
                                    /* TSNH */
                                    mtu = (*net).mtu
                                }
                            }
                            mx_mtu = mtu;
                            to_out = 0u32;
                            if mtu > (*asoc).peers_rwnd {
                                if (*asoc).total_flight > 0u32 {
                                    /* We have a packet in flight somewhere */
                                    r_mtu = (*asoc).peers_rwnd
                                } else {
                                    /* We are always allowed to send one MTU out */
                                    one_chunk = 1i32;
                                    r_mtu = mtu
                                }
                            } else {
                                r_mtu = mtu
                            }
                            error = 0i32;
                            /* ***********************/
                            /* ASCONF transmission */
                            /* ***********************/
                            /* Now first lets go through the asconf queue */
                            chk = (*asoc).asconf_send_queue.tqh_first;
                            while !chk.is_null() && {
                                nchk = (*chk).sctp_next.tqe_next;
                                (1i32) != 0
                            } {
                                if !((*chk).rec.chunk_id.id as libc::c_int != 0xc1i32) {
                                    if (*chk).whoTo.is_null() {
                                        if (*asoc).alternate.is_null() {
                                            if (*asoc).primary_destination != net {
                                                break;
                                            }
                                        } else if (*asoc).alternate != net {
                                            break;
                                        }
                                    } else if (*chk).whoTo != net {
                                        break;
                                    }
                                    if (*chk).data.is_null() {
                                        break;
                                    }
                                    if (*chk).sent != 0i32 && (*chk).sent != 4i32 {
                                        break;
                                    }
                                    /*
                                     * if no AUTH is yet included and this chunk
                                     * requires it, make sure to account for it.  We
                                     * don't apply the size until the AUTH chunk is
                                     * actually added below in case there is no room for
                                     * this chunk. NOTE: we overload the use of "omtu"
                                     * here
                                     */
                                    if auth.is_null()
                                        && (if (*stcb).asoc.peer_auth_chunks.is_null() {
                                            0i32
                                        } else {
                                            ((*(*stcb).asoc.peer_auth_chunks).chunks
                                                [(*chk).rec.chunk_id.id as usize]
                                                as libc::c_int
                                                != 0i32)
                                                as libc::c_int
                                        }) != 0
                                    {
                                        omtu = sctp_get_auth_chunk_len((*stcb).asoc.peer_hmac_id)
                                    } else {
                                        omtu = 0u32
                                    }
                                    /* Here we do NOT factor the r_mtu */
                                    if ((*chk).send_size as libc::c_int)
                                        < mtu.wrapping_sub(omtu) as libc::c_int
                                        || (*chk).flags as libc::c_int & 0x100i32 != 0
                                    {
                                        /*
                                         * We probably should glom the mbuf chain
                                         * from the chk->data for control but the
                                         * problem is it becomes yet one more level
                                         * of tracking to do if for some reason
                                         * output fails. Then I have got to
                                         * reconstruct the merged control chain.. el
                                         * yucko.. for now we take the easy way and
                                         * do the copy
                                         */
                                        /*
                                         * Add an AUTH chunk, if chunk requires it
                                         * save the offset into the chain for AUTH
                                         */
                                        if auth.is_null()
                                            && (if (*stcb).asoc.peer_auth_chunks.is_null() {
                                                0i32
                                            } else {
                                                ((*(*stcb).asoc.peer_auth_chunks).chunks
                                                    [(*chk).rec.chunk_id.id as usize]
                                                    as libc::c_int
                                                    != 0i32)
                                                    as libc::c_int
                                            }) != 0
                                        {
                                            outchain = sctp_add_auth_chunk(
                                                outchain,
                                                &mut endoutchain,
                                                &mut auth,
                                                &mut auth_offset,
                                                stcb,
                                                (*chk).rec.chunk_id.id,
                                            );
                                            ::std::intrinsics::atomic_xadd(
                                                &mut system_base_info
                                                    .sctpstat
                                                    .sctps_outcontrolchunks,
                                                1u32,
                                            );
                                        }
                                        outchain = sctp_copy_mbufchain(
                                            (*chk).data,
                                            outchain,
                                            &mut endoutchain,
                                            (*chk).rec.chunk_id.can_take_data as libc::c_int,
                                            (*chk).send_size as libc::c_int,
                                            (*chk).copy_by_ref,
                                        );
                                        if outchain.is_null() {
                                            *reason_code = 8i32;
                                            return 12i32;
                                        }
                                        ::std::intrinsics::atomic_xadd(
                                            &mut system_base_info.sctpstat.sctps_outcontrolchunks,
                                            1u32,
                                        );
                                        /* update our MTU size */
                                        if mtu
                                            > ((*chk).send_size as libc::c_uint).wrapping_add(omtu)
                                        {
                                            mtu = mtu.wrapping_sub(
                                                ((*chk).send_size as libc::c_uint)
                                                    .wrapping_add(omtu),
                                            )
                                        } else {
                                            mtu = 0u32
                                        }
                                        to_out = to_out.wrapping_add(
                                            ((*chk).send_size as libc::c_uint).wrapping_add(omtu),
                                        );
                                        /* Do clear IP_DF ? */
                                        if (*chk).flags as libc::c_int & 0x100i32 != 0 {
                                            no_fragmentflg = 0i32
                                        }
                                        if (*chk).rec.chunk_id.can_take_data != 0 {
                                            (*chk).data = 0 as *mut mbuf
                                        }
                                        /*
                                         * set hb flag since we can
                                         * use these for RTO
                                         */
                                        hbflag = 1i32;
                                        asconf = 1i32;
                                        /*
                                         * should sysctl this: don't
                                         * bundle data with ASCONF
                                         * since it requires AUTH
                                         */
                                        no_data_chunks = 1i32;
                                        (*chk).sent = 1i32;
                                        if (*chk).whoTo.is_null() {
                                            (*chk).whoTo = net;
                                            ::std::intrinsics::atomic_xadd(
                                                &mut (*net).ref_count,
                                                1i32,
                                            );
                                        }
                                        (*chk).snd_count = (*chk).snd_count.wrapping_add(1);
                                        if mtu == 0u32 {
                                            /*
                                             * Ok we are out of room but we can
                                             * output without effecting the
                                             * flight size since this little guy
                                             * is a control only packet.
                                             */
                                            sctp_timer_start(10i32, inp, stcb, net);
                                            /*
                                             * do NOT clear the asconf
                                             * flag as it is used to do
                                             * appropriate source address
                                             * selection.
                                             */
                                            if *now_filled == 0i32 {
                                                gettimeofday(now, 0 as *mut timezone);
                                                *now_filled = 1i32
                                            }
                                            (*net).last_sent_time = *now;
                                            hbflag = 0i32;
                                            error = sctp_lowlevel_chunk_output(
                                                inp,
                                                stcb,
                                                net,
                                                &mut (*net).ro._l_addr as *mut sctp_sockstore
                                                    as *mut sockaddr,
                                                outchain,
                                                auth_offset,
                                                auth,
                                                (*stcb).asoc.authinfo.active_keyid,
                                                no_fragmentflg,
                                                0i32,
                                                asconf,
                                                (*inp).ip_inp.inp.inp_inc.inc_ie.ie_lport,
                                                (*stcb).rport,
                                                htonl((*stcb).asoc.peer_vtag),
                                                (*net).port,
                                                0 as *mut sctp_sockstore,
                                                so_locked,
                                            );
                                            if error != 0 {
                                                /* error, we could not output */
                                                if system_base_info.sctpsysctl.sctp_debug_on
                                                    & 0x40u32
                                                    != 0
                                                {
                                                    if system_base_info.debug_printf.is_some() {
                                                        system_base_info
                                                            .debug_printf
                                                            .expect("non-null function pointer")(
                                                            b"Gak send error %d\n\x00" as *const u8
                                                                as *const libc::c_char,
                                                            error,
                                                        );
                                                    }
                                                }
                                                if from_where == 0i32 {
                                                    ::std::intrinsics::atomic_xadd(
                                                        &mut system_base_info
                                                            .sctpstat
                                                            .sctps_lowlevelerrusr,
                                                        1u32,
                                                    );
                                                }
                                                if error == 105i32 {
                                                    (*asoc).ifp_had_enobuf = 1u8;
                                                    ::std::intrinsics::atomic_xadd(
                                                        &mut system_base_info
                                                            .sctpstat
                                                            .sctps_lowlevelerr,
                                                        1u32,
                                                    );
                                                }
                                                /* error, could not output */
                                                if error == 113i32 {
                                                    /*
                                                     * Destination went
                                                     * unreachable
                                                     * during this send
                                                     */
                                                    sctp_move_chunks_from_net(stcb, net);
                                                }
                                                *reason_code = 7i32;
                                                break;
                                            } else {
                                                (*asoc).ifp_had_enobuf = 0u8;
                                                /*
                                                 * increase the number we sent, if a
                                                 * cookie is sent we don't tell them
                                                 * any was sent out.
                                                 */
                                                endoutchain = 0 as *mut mbuf;
                                                outchain = endoutchain;
                                                auth = 0 as *mut sctp_auth_chunk;
                                                auth_offset = 0u32;
                                                if no_out_cnt == 0 {
                                                    *num_out += ctl_cnt
                                                }
                                                /* recalc a clean slate and setup */
                                                match (*net).ro._l_addr.sa.sa_family as libc::c_int
                                                {
                                                    2 => {
                                                        mtu = ((*net).mtu as libc::c_ulong)
                                                            .wrapping_sub(
                                                            (::std::mem::size_of::<ip>()
                                                                as libc::c_ulong)
                                                                .wrapping_add(
                                                                    ::std::mem::size_of::<sctphdr>()
                                                                        as libc::c_ulong,
                                                                ),
                                                        )
                                                            as libc::c_uint
                                                    }
                                                    10 => {
                                                        mtu = ((*net).mtu as libc::c_ulong)
                                                            .wrapping_sub(
                                                            (::std::mem::size_of::<ip6_hdr>()
                                                                as libc::c_ulong)
                                                                .wrapping_add(
                                                                    ::std::mem::size_of::<sctphdr>()
                                                                        as libc::c_ulong,
                                                                ),
                                                        )
                                                            as libc::c_uint
                                                    }
                                                    123 => {
                                                        mtu = ((*net).mtu as libc::c_ulong)
                                                            .wrapping_sub(::std::mem::size_of::<
                                                                sctphdr,
                                                            >(
                                                            )
                                                                as libc::c_ulong)
                                                            as libc::c_uint
                                                    }
                                                    _ => {
                                                        /* TSNH */
                                                        mtu = (*net).mtu
                                                    }
                                                }
                                                to_out = 0u32;
                                                no_fragmentflg = 1i32
                                            }
                                        }
                                    }
                                }
                                chk = nchk
                            }
                            if !(error != 0i32) {
                                /* ***********************/
                                /* Control transmission */
                                /* ***********************/
                                /* Now first lets go through the control queue */
                                chk = (*asoc).control_send_queue.tqh_first;
                                while !chk.is_null() && {
                                    nchk = (*chk).sctp_next.tqe_next;
                                    (1i32) != 0
                                } {
                                    let mut current_block_291: u64;
                                    if !sack_goes_to.is_null()
                                        && (*chk).rec.chunk_id.id as libc::c_int == 0xci32
                                        && (*chk).whoTo != sack_goes_to
                                    {
                                        /*
                                         * if we have a sack in queue, and we are looking at an
                                         * ecn echo that is NOT queued to where the sack is going..
                                         */
                                        if (*chk).whoTo == net {
                                            /* Don't transmit it to where its going (current net) */
                                            current_block_291 = 14723351692138084861;
                                        } else if sack_goes_to == net {
                                            current_block_291 = 9965697116123570547;
                                        } else {
                                            current_block_291 = 16225421537987648902;
                                        }
                                    } else {
                                        current_block_291 = 16225421537987648902;
                                    }
                                    match current_block_291 {
                                        16225421537987648902 => {
                                            if (*chk).whoTo.is_null() {
                                                if (*asoc).alternate.is_null() {
                                                    if (*asoc).primary_destination != net {
                                                        current_block_291 = 14723351692138084861;
                                                    } else {
                                                        current_block_291 = 9965697116123570547;
                                                    }
                                                } else if (*asoc).alternate != net {
                                                    current_block_291 = 14723351692138084861;
                                                } else {
                                                    current_block_291 = 9965697116123570547;
                                                }
                                            } else if (*chk).whoTo != net {
                                                current_block_291 = 14723351692138084861;
                                            } else {
                                                current_block_291 = 9965697116123570547;
                                            }
                                        }
                                        _ => {}
                                    }
                                    match current_block_291 {
                                        9965697116123570547 =>
                                        /* But do transmit it to this address */
                                        {
                                            if !(*chk).data.is_null() {
                                                if !((*chk).sent != 0i32) {
                                                    /*
                                                     * if no AUTH is yet included and this chunk
                                                     * requires it, make sure to account for it.  We
                                                     * don't apply the size until the AUTH chunk is
                                                     * actually added below in case there is no room for
                                                     * this chunk. NOTE: we overload the use of "omtu"
                                                     * here
                                                     */
                                                    if auth.is_null()
                                                        && (if (*stcb)
                                                            .asoc
                                                            .peer_auth_chunks
                                                            .is_null()
                                                        {
                                                            0i32
                                                        } else {
                                                            ((*(*stcb).asoc.peer_auth_chunks).chunks
                                                                [(*chk).rec.chunk_id.id as usize]
                                                                as libc::c_int
                                                                != 0i32)
                                                                as libc::c_int
                                                        }) != 0
                                                    {
                                                        omtu = sctp_get_auth_chunk_len(
                                                            (*stcb).asoc.peer_hmac_id,
                                                        )
                                                    } else {
                                                        omtu = 0u32
                                                    }
                                                    /* Here we do NOT factor the r_mtu */
                                                    if (*chk).send_size as libc::c_int
                                                        <= mtu.wrapping_sub(omtu) as libc::c_int
                                                        || (*chk).flags as libc::c_int & 0x100i32
                                                            != 0
                                                    {
                                                        /*
                                                         * We probably should glom the mbuf chain
                                                         * from the chk->data for control but the
                                                         * problem is it becomes yet one more level
                                                         * of tracking to do if for some reason
                                                         * output fails. Then I have got to
                                                         * reconstruct the merged control chain.. el
                                                         * yucko.. for now we take the easy way and
                                                         * do the copy
                                                         */
                                                        /*
                                                         * Add an AUTH chunk, if chunk requires it
                                                         * save the offset into the chain for AUTH
                                                         */
                                                        if auth.is_null()
                                                            && (if (*stcb)
                                                                .asoc
                                                                .peer_auth_chunks
                                                                .is_null()
                                                            {
                                                                0i32
                                                            } else {
                                                                ((*(*stcb).asoc.peer_auth_chunks)
                                                                    .chunks
                                                                    [(*chk).rec.chunk_id.id
                                                                        as usize]
                                                                    as libc::c_int
                                                                    != 0i32)
                                                                    as libc::c_int
                                                            }) != 0
                                                        {
                                                            outchain = sctp_add_auth_chunk(
                                                                outchain,
                                                                &mut endoutchain,
                                                                &mut auth,
                                                                &mut auth_offset,
                                                                stcb,
                                                                (*chk).rec.chunk_id.id,
                                                            );
                                                            ::std::intrinsics::atomic_xadd(
                                                                &mut system_base_info
                                                                    .sctpstat
                                                                    .sctps_outcontrolchunks,
                                                                1u32,
                                                            );
                                                        }
                                                        outchain = sctp_copy_mbufchain(
                                                            (*chk).data,
                                                            outchain,
                                                            &mut endoutchain,
                                                            (*chk).rec.chunk_id.can_take_data
                                                                as libc::c_int,
                                                            (*chk).send_size as libc::c_int,
                                                            (*chk).copy_by_ref,
                                                        );
                                                        if outchain.is_null() {
                                                            *reason_code = 8i32;
                                                            return 12i32;
                                                        }
                                                        ::std::intrinsics::atomic_xadd(
                                                            &mut system_base_info
                                                                .sctpstat
                                                                .sctps_outcontrolchunks,
                                                            1u32,
                                                        );
                                                        /* update our MTU size */
                                                        if mtu
                                                            > ((*chk).send_size as libc::c_uint)
                                                                .wrapping_add(omtu)
                                                        {
                                                            mtu = mtu.wrapping_sub(
                                                                ((*chk).send_size as libc::c_uint)
                                                                    .wrapping_add(omtu),
                                                            )
                                                        } else {
                                                            mtu = 0u32
                                                        }
                                                        to_out = to_out.wrapping_add(
                                                            ((*chk).send_size as libc::c_uint)
                                                                .wrapping_add(omtu),
                                                        );
                                                        /* Do clear IP_DF ? */
                                                        if (*chk).flags as libc::c_int & 0x100i32
                                                            != 0
                                                        {
                                                            no_fragmentflg = 0i32
                                                        }
                                                        if (*chk).rec.chunk_id.can_take_data != 0 {
                                                            (*chk).data = 0 as *mut mbuf
                                                        }
                                                        /* Mark things to be removed, if needed */
                                                        if (*chk).rec.chunk_id.id as libc::c_int
                                                            == 0x3i32
                                                            || (*chk).rec.chunk_id.id as libc::c_int
                                                                == 0x10i32
                                                            || (*chk).rec.chunk_id.id as libc::c_int
                                                                == 0x4i32
                                                            || (*chk).rec.chunk_id.id as libc::c_int
                                                                == 0x5i32
                                                            || (*chk).rec.chunk_id.id as libc::c_int
                                                                == 0x7i32
                                                            || (*chk).rec.chunk_id.id as libc::c_int
                                                                == 0x8i32
                                                            || (*chk).rec.chunk_id.id as libc::c_int
                                                                == 0x9i32
                                                            || (*chk).rec.chunk_id.id as libc::c_int
                                                                == 0xbi32
                                                            || (*chk).rec.chunk_id.id as libc::c_int
                                                                == 0xdi32
                                                            || (*chk).rec.chunk_id.id as libc::c_int
                                                                == 0x81i32
                                                            || (*chk).rec.chunk_id.id as libc::c_int
                                                                == 0x80i32
                                                        {
                                                            if (*chk).rec.chunk_id.id as libc::c_int
                                                                == 0x4i32
                                                            {
                                                                hbflag = 1i32
                                                            }
                                                            /* remove these chunks at the end */
                                                            if (*chk).rec.chunk_id.id as libc::c_int
                                                                == 0x3i32
                                                                || (*chk).rec.chunk_id.id
                                                                    as libc::c_int
                                                                    == 0x10i32
                                                            {
                                                                /* turn off the timer */
                                                                if (*stcb)
                                                                    .asoc
                                                                    .dack_timer
                                                                    .timer
                                                                    .c_flags
                                                                    & 0x4i32
                                                                    != 0
                                                                {
                                                                    sctp_timer_stop(
                                                                        3i32,
                                                                        inp,
                                                                        stcb,
                                                                        net,
                                                                        (0x90000000u32)
                                                                            .wrapping_add(0x1u32),
                                                                    );
                                                                }
                                                            }
                                                            ctl_cnt += 1
                                                        } else {
                                                            /*
                                                             * Other chunks, since they have
                                                             * timers running (i.e. COOKIE)
                                                             * we just "trust" that it
                                                             * gets sent or retransmitted.
                                                             */
                                                            ctl_cnt += 1;
                                                            if (*chk).rec.chunk_id.id as libc::c_int
                                                                == 0xai32
                                                            {
                                                                cookie = 1i32;
                                                                no_out_cnt = 1i32
                                                            } else if (*chk).rec.chunk_id.id
                                                                as libc::c_int
                                                                == 0xci32
                                                            {
                                                                /*
                                                                 * Increment ecne send count here
                                                                 * this means we may be over-zealous in
                                                                 * our counting if the send fails, but its
                                                                 * the best place to do it (we used to do
                                                                 * it in the queue of the chunk, but that did
                                                                 * not tell how many times it was sent.
                                                                 */
                                                                ::std::intrinsics::atomic_xadd(
                                                                    &mut system_base_info
                                                                        .sctpstat
                                                                        .sctps_sendecne,
                                                                    1u32,
                                                                );
                                                            }
                                                            (*chk).sent = 1i32;
                                                            if (*chk).whoTo.is_null() {
                                                                (*chk).whoTo = net;
                                                                ::std::intrinsics::atomic_xadd(
                                                                    &mut (*net).ref_count,
                                                                    1i32,
                                                                );
                                                            }
                                                            (*chk).snd_count =
                                                                (*chk).snd_count.wrapping_add(1)
                                                        }
                                                        if mtu == 0u32 {
                                                            /*
                                                             * Ok we are out of room but we can
                                                             * output without effecting the
                                                             * flight size since this little guy
                                                             * is a control only packet.
                                                             */
                                                            if asconf != 0 {
                                                                sctp_timer_start(
                                                                    10i32, inp, stcb, net,
                                                                );
                                                                /*
                                                                 * do NOT clear the asconf
                                                                 * flag as it is used to do
                                                                 * appropriate source address
                                                                 * selection.
                                                                 */
                                                            }
                                                            if cookie != 0 {
                                                                sctp_timer_start(
                                                                    6i32, inp, stcb, net,
                                                                );
                                                                cookie = 0i32
                                                            }
                                                            /* Only HB or ASCONF advances time */
                                                            if hbflag != 0 {
                                                                if *now_filled == 0i32 {
                                                                    gettimeofday(
                                                                        now,
                                                                        0 as *mut timezone,
                                                                    );
                                                                    *now_filled = 1i32
                                                                }
                                                                (*net).last_sent_time = *now;
                                                                hbflag = 0i32
                                                            }
                                                            error = sctp_lowlevel_chunk_output(
                                                                inp,
                                                                stcb,
                                                                net,
                                                                &mut (*net).ro._l_addr
                                                                    as *mut sctp_sockstore
                                                                    as *mut sockaddr,
                                                                outchain,
                                                                auth_offset,
                                                                auth,
                                                                (*stcb).asoc.authinfo.active_keyid,
                                                                no_fragmentflg,
                                                                0i32,
                                                                asconf,
                                                                (*inp)
                                                                    .ip_inp
                                                                    .inp
                                                                    .inp_inc
                                                                    .inc_ie
                                                                    .ie_lport,
                                                                (*stcb).rport,
                                                                htonl((*stcb).asoc.peer_vtag),
                                                                (*net).port,
                                                                0 as *mut sctp_sockstore,
                                                                so_locked,
                                                            );
                                                            if error != 0 {
                                                                /* error, we could not output */
                                                                if system_base_info
                                                                    .sctpsysctl
                                                                    .sctp_debug_on
                                                                    & 0x40u32
                                                                    != 0
                                                                {
                                                                    if system_base_info
                                                                        .debug_printf
                                                                        .is_some()
                                                                    {
                                                                        system_base_info.debug_printf.expect("non-null function pointer")(b"Gak send error %d\n\x00"
                                                                                                                                              as
                                                                                                                                              *const u8
                                                                                                                                              as
                                                                                                                                              *const libc::c_char,
                                                                                                                                          error);
                                                                    }
                                                                }
                                                                if from_where == 0i32 {
                                                                    ::std::intrinsics::atomic_xadd(
                                                                        &mut system_base_info
                                                                            .sctpstat
                                                                            .sctps_lowlevelerrusr,
                                                                        1u32,
                                                                    );
                                                                }
                                                                if error == 105i32 {
                                                                    (*asoc).ifp_had_enobuf = 1u8;
                                                                    ::std::intrinsics::atomic_xadd(
                                                                        &mut system_base_info
                                                                            .sctpstat
                                                                            .sctps_lowlevelerr,
                                                                        1u32,
                                                                    );
                                                                }
                                                                if error == 113i32 {
                                                                    /*
                                                                     * Destination went
                                                                     * unreachable
                                                                     * during this send
                                                                     */
                                                                    sctp_move_chunks_from_net(
                                                                        stcb, net,
                                                                    );
                                                                }
                                                                *reason_code = 7i32;
                                                                break;
                                                            } else {
                                                                (*asoc).ifp_had_enobuf = 0u8;
                                                                /*
                                                                 * increase the number we sent, if a
                                                                 * cookie is sent we don't tell them
                                                                 * any was sent out.
                                                                 */
                                                                endoutchain = 0 as *mut mbuf;
                                                                outchain = endoutchain;
                                                                auth = 0 as *mut sctp_auth_chunk;
                                                                auth_offset = 0u32;
                                                                if no_out_cnt == 0 {
                                                                    *num_out += ctl_cnt
                                                                }
                                                                /* recalc a clean slate and setup */
                                                                match (*net).ro._l_addr.sa.sa_family
                                                                          as
                                                                          libc::c_int
                                                                    {
                                                                    2 => {
                                                                        mtu =
                                                                            ((*net).mtu
                                                                                 as
                                                                                 libc::c_ulong).wrapping_sub((::std::mem::size_of::<ip>()
                                                                                                                  as
                                                                                                                  libc::c_ulong).wrapping_add(::std::mem::size_of::<sctphdr>()
                                                                                                                                                  as
                                                                                                                                                  libc::c_ulong))
                                                                                as
                                                                                libc::c_uint
                                                                    }
                                                                    10 => {
                                                                        mtu =
                                                                            ((*net).mtu
                                                                                 as
                                                                                 libc::c_ulong).wrapping_sub((::std::mem::size_of::<ip6_hdr>()
                                                                                                                  as
                                                                                                                  libc::c_ulong).wrapping_add(::std::mem::size_of::<sctphdr>()
                                                                                                                                                  as
                                                                                                                                                  libc::c_ulong))
                                                                                as
                                                                                libc::c_uint
                                                                    }
                                                                    123 => {
                                                                        mtu =
                                                                            ((*net).mtu
                                                                                 as
                                                                                 libc::c_ulong).wrapping_sub(::std::mem::size_of::<sctphdr>()
                                                                                                                 as
                                                                                                                 libc::c_ulong)
                                                                                as
                                                                                libc::c_uint
                                                                    }
                                                                    _ => {
                                                                        /* TSNH */
                                                                        mtu =
                                                                            (*net).mtu
                                                                    }
                                                                }
                                                                to_out = 0u32;
                                                                no_fragmentflg = 1i32
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                    /*
                                     * It must be unsent. Cookies and ASCONF's
                                     * hang around but there timers will force
                                     * when marked for resend.
                                     */
                                    chk = nchk
                                }
                                if !(error != 0i32) {
                                    let mut data_list = [0 as *mut sctp_tmit_chunk; 256];
                                    if !((*asoc).sctp_cmt_on_off as libc::c_int > 0i32
                                        && net != (*stcb).asoc.alternate
                                        && (*net).dest_state as libc::c_int & 0x800i32 != 0)
                                    {
                                        if !((*net).flight_size >= (*net).cwnd) {
                                            if !((*asoc).sctp_cmt_on_off as libc::c_int > 0i32
                                                && system_base_info
                                                    .sctpsysctl
                                                    .sctp_buffer_splitting
                                                    & 0x2u32
                                                    != 0
                                                && (*net).flight_size > max_rwnd_per_dest)
                                            {
                                                /*
                                                 * We need a specific accounting for the usage of the
                                                 * send buffer. We also need to check the number of messages
                                                 * per net. For now, this is better than nothing and it
                                                 * disabled by default...
                                                 */
                                                if !((*asoc).sctp_cmt_on_off as libc::c_int > 0i32
                                                    && system_base_info
                                                        .sctpsysctl
                                                        .sctp_buffer_splitting
                                                        & 0x1u32
                                                        != 0
                                                    && max_send_per_dest > 0u32
                                                    && (*net).flight_size > max_send_per_dest)
                                                {
                                                    /* ********************/
                                                    /* Data transmission */
                                                    /* ********************/
                                                    /*
                                                     * if AUTH for DATA is required and no AUTH has been added
                                                     * yet, account for this in the mtu now... if no data can be
                                                     * bundled, this adjustment won't matter anyways since the
                                                     * packet will be going out...
                                                     */
                                                    let mut data_auth_reqd = 0i32;
                                                    data_auth_reqd = if (*stcb)
                                                        .asoc
                                                        .peer_auth_chunks
                                                        .is_null()
                                                    {
                                                        0i32
                                                    } else {
                                                        ((*(*stcb).asoc.peer_auth_chunks).chunks
                                                            [0usize]
                                                            as libc::c_int
                                                            != 0i32)
                                                            as libc::c_int
                                                    };
                                                    if data_auth_reqd != 0 && auth.is_null() {
                                                        mtu = mtu.wrapping_sub(
                                                            sctp_get_auth_chunk_len(
                                                                (*stcb).asoc.peer_hmac_id,
                                                            ),
                                                        )
                                                    }
                                                    /* now lets add any data within the MTU constraints */
                                                    match (*(&mut (*net).ro._l_addr
                                                        as *mut sctp_sockstore
                                                        as *mut sockaddr))
                                                        .sa_family
                                                        as libc::c_int
                                                    {
                                                        2 => {
                                                            if (*net).mtu as
                                                                   libc::c_ulong
                                                                   >
                                                                   (::std::mem::size_of::<ip>()
                                                                        as
                                                                        libc::c_ulong).wrapping_add(::std::mem::size_of::<sctphdr>()
                                                                                                        as
                                                                                                        libc::c_ulong)
                                                               {
                                                                omtu =
                                                                    ((*net).mtu
                                                                         as
                                                                         libc::c_ulong).wrapping_sub((::std::mem::size_of::<ip>()
                                                                                                          as
                                                                                                          libc::c_ulong).wrapping_add(::std::mem::size_of::<sctphdr>()
                                                                                                                                          as
                                                                                                                                          libc::c_ulong))
                                                                        as
                                                                        libc::c_uint
                                                            } else {
                                                                omtu =
                                                                    0u32
                                                            }
                                                        }
                                                        10 => {
                                                            if (*net).mtu as
                                                                   libc::c_ulong
                                                                   >
                                                                   (::std::mem::size_of::<ip6_hdr>()
                                                                        as
                                                                        libc::c_ulong).wrapping_add(::std::mem::size_of::<sctphdr>()
                                                                                                        as
                                                                                                        libc::c_ulong)
                                                               {
                                                                omtu =
                                                                    ((*net).mtu
                                                                         as
                                                                         libc::c_ulong).wrapping_sub((::std::mem::size_of::<ip6_hdr>()
                                                                                                          as
                                                                                                          libc::c_ulong).wrapping_add(::std::mem::size_of::<sctphdr>()
                                                                                                                                          as
                                                                                                                                          libc::c_ulong))
                                                                        as
                                                                        libc::c_uint
                                                            } else {
                                                                omtu =
                                                                    0u32
                                                            }
                                                        }
                                                        123 => {
                                                            if (*net).mtu as libc::c_ulong
                                                                > ::std::mem::size_of::<sctphdr>()
                                                                    as libc::c_ulong
                                                            {
                                                                omtu =
                                                                    ((*net).mtu as libc::c_ulong)
                                                                        .wrapping_sub(
                                                                            ::std::mem::size_of::<
                                                                                sctphdr,
                                                                            >(
                                                                            )
                                                                                as libc::c_ulong,
                                                                        )
                                                                        as libc::c_uint
                                                            } else {
                                                                omtu = 0u32
                                                            }
                                                        }
                                                        _ => {
                                                            /* TSNH */
                                                            omtu = 0u32
                                                        }
                                                    } /* if asoc.state OPEN */
                                                    if ((*stcb).asoc.state & 0x7fi32 == 0x8i32
                                                        || (*stcb).asoc.state & 0x7fi32 == 0x20i32)
                                                        && skip_data_for_this_net == 0i32
                                                        || cookie != 0
                                                    {
                                                        chk = (*asoc).send_queue.tqh_first;
                                                        while !chk.is_null() && {
                                                            nchk = (*chk).sctp_next.tqe_next;
                                                            (1i32) != 0
                                                        } {
                                                            if no_data_chunks != 0 {
                                                                /* let only control go out */
                                                                *reason_code = 1i32;
                                                                break;
                                                            } else if (*net).flight_size
                                                                >= (*net).cwnd
                                                            {
                                                                /* skip this net, no room for data */
                                                                *reason_code = 2i32;
                                                                break;
                                                            } else {
                                                                if !(!(*chk).whoTo.is_null()
                                                                    && (*chk).whoTo != net)
                                                                {
                                                                    let mut current_block_381: u64;
                                                                    if (*asoc).sctp_cmt_on_off
                                                                        as libc::c_int
                                                                        == 0i32
                                                                    {
                                                                        if !(*asoc)
                                                                            .alternate
                                                                            .is_null()
                                                                            && (*asoc).alternate
                                                                                != net
                                                                            && (*chk)
                                                                                .whoTo
                                                                                .is_null()
                                                                        {
                                                                            current_block_381 =
                                                                                6186991752471315663;
                                                                        } else if net
                                                                            != (*asoc)
                                                                                .primary_destination
                                                                            && (*asoc)
                                                                                .alternate
                                                                                .is_null()
                                                                            && (*chk)
                                                                                .whoTo
                                                                                .is_null()
                                                                        {
                                                                            current_block_381 =
                                                                                6186991752471315663;
                                                                        } else {
                                                                            current_block_381 =
                                                                                9258408531781082179;
                                                                        }
                                                                    } else {
                                                                        current_block_381 =
                                                                            9258408531781082179;
                                                                    }
                                                                    match current_block_381 {
                                                                        6186991752471315663 => {}
                                                                        _ => {
                                                                            if (*chk).send_size
                                                                                as libc::c_uint
                                                                                > omtu
                                                                                && (*chk).flags
                                                                                    as libc::c_int
                                                                                    & 0x100i32
                                                                                    == 0i32
                                                                            {
                                                                                /*-
                                                                                 * strange, we have a chunk that is
                                                                                 * to big for its destination and
                                                                                 * yet no fragment ok flag.
                                                                                 * Something went wrong when the
                                                                                 * PMTU changed...we did not mark
                                                                                 * this chunk for some reason?? I
                                                                                 * will fix it here by letting IP
                                                                                 * fragment it for now and printing
                                                                                 * a warning. This really should not
                                                                                 * happen ...
                                                                                 */
                                                                                if system_base_info
                                                                                    .debug_printf
                                                                                    .is_some()
                                                                                {
                                                                                    system_base_info.debug_printf.expect("non-null function pointer")(b"Warning chunk of %d bytes > mtu:%d and yet PMTU disc missed\n\x00"
                                                                                                                                                          as
                                                                                                                                                          *const u8
                                                                                                                                                          as
                                                                                                                                                          *const libc::c_char,
                                                                                                                                                      (*chk).send_size
                                                                                                                                                          as
                                                                                                                                                          libc::c_int,
                                                                                                                                                      mtu);
                                                                                }
                                                                                (*chk).flags
                                                                                    =
                                                                                    ((*chk).flags
                                                                                         as
                                                                                         libc::c_int
                                                                                         |
                                                                                         0x100i32)
                                                                                        as
                                                                                        uint16_t
                                                                            }
                                                                            if system_base_info.sctpsysctl.sctp_enable_sack_immediately
                                                                                   !=
                                                                                   0
                                                                                   &&
                                                                                   (*asoc).state
                                                                                       &
                                                                                       0x80i32
                                                                                       !=
                                                                                       0
                                                                               {
                                                                                   let mut dchkh =
                                                                                    0
                                                                                        as
                                                                                        *mut sctp_data_chunk;
                                                                                dchkh
                                                                                    =
                                                                                    (*(*chk).data).m_hdr.mh_data
                                                                                        as
                                                                                        *mut sctp_data_chunk;
                                                                                (*dchkh).ch.chunk_flags
                                                                                    =
                                                                                    ((*dchkh).ch.chunk_flags
                                                                                         as
                                                                                         libc::c_int
                                                                                         |
                                                                                         0x8i32)
                                                                                        as
                                                                                        uint8_t
                                                                            }
                                                                            if !((*chk).send_size
                                                                                     as
                                                                                     libc::c_uint
                                                                                     <=
                                                                                     mtu
                                                                                     &&
                                                                                     (*chk).send_size
                                                                                         as
                                                                                         libc::c_uint
                                                                                         <=
                                                                                         r_mtu
                                                                                     ||
                                                                                     (*chk).flags
                                                                                         as
                                                                                         libc::c_int
                                                                                         &
                                                                                         0x100i32
                                                                                         !=
                                                                                         0
                                                                                         &&
                                                                                         (*chk).send_size
                                                                                             as
                                                                                             libc::c_uint
                                                                                             <=
                                                                                             (*asoc).peers_rwnd)
                                                                               {
                                                                                break
                                                                                    ;
                                                                            }
                                                                            /* ok we will add this one */
                                                                            /*
                                                                             * Add an AUTH chunk, if chunk
                                                                             * requires it, save the offset into
                                                                             * the chain for AUTH
                                                                             */
                                                                            if data_auth_reqd != 0 {
                                                                                let mut override_ok =
                                                                                    1i32;
                                                                                if auth.is_null()
                                                                                   {
                                                                                    outchain
                                                                                        =
                                                                                        sctp_add_auth_chunk(outchain,
                                                                                                            &mut endoutchain,
                                                                                                            &mut auth,
                                                                                                            &mut auth_offset,
                                                                                                            stcb,
                                                                                                            0u8);
                                                                                    auth_keyid
                                                                                        =
                                                                                        (*chk).auth_keyid;
                                                                                    override_ok
                                                                                        =
                                                                                        0i32;
                                                                                    ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_outcontrolchunks,
                                                                                                                   1u32);
                                                                                } else if override_ok
                                                                                              !=
                                                                                              0
                                                                                 {
                                                                                    /* use this data's keyid */
                                                                                    auth_keyid
                                                                                        =
                                                                                        (*chk).auth_keyid;
                                                                                    override_ok
                                                                                        =
                                                                                        0i32
                                                                                } else if auth_keyid
                                                                                              as
                                                                                              libc::c_int
                                                                                              !=
                                                                                              (*chk).auth_keyid
                                                                                                  as
                                                                                                  libc::c_int
                                                                                 {
                                                                                    /* different keyid, so done bundling */
                                                                                    break
                                                                                        ;
                                                                                }
                                                                            }
                                                                            outchain
                                                                                =
                                                                                sctp_copy_mbufchain((*chk).data,
                                                                                                    outchain,
                                                                                                    &mut endoutchain,
                                                                                                    0i32,
                                                                                                    (*chk).send_size
                                                                                                        as
                                                                                                        libc::c_int,
                                                                                                    (*chk).copy_by_ref);
                                                                            if outchain.is_null() {
                                                                                if system_base_info
                                                                                    .sctpsysctl
                                                                                    .sctp_debug_on
                                                                                    & 0x40u32
                                                                                    != 0
                                                                                {
                                                                                    if system_base_info.debug_printf.is_some()
                                                                                       {
                                                                                        system_base_info.debug_printf.expect("non-null function pointer")(b"No memory?\n\x00"
                                                                                                                                                              as
                                                                                                                                                              *const u8
                                                                                                                                                              as
                                                                                                                                                              *const libc::c_char);
                                                                                    }
                                                                                }
                                                                                if (*net)
                                                                                    .rxt_timer
                                                                                    .timer
                                                                                    .c_flags
                                                                                    & 0x4i32
                                                                                    == 0
                                                                                {
                                                                                    sctp_timer_start(1i32,
                                                                                                     inp,
                                                                                                     stcb,
                                                                                                     net);
                                                                                }
                                                                                *reason_code = 3i32;
                                                                                return 12i32;
                                                                            }
                                                                            /* upate our MTU size */
                                                                            /* Do clear IP_DF ? */
                                                                            if (*chk).flags
                                                                                as libc::c_int
                                                                                & 0x100i32
                                                                                != 0
                                                                            {
                                                                                no_fragmentflg =
                                                                                    0i32
                                                                            }
                                                                            /* unsigned subtraction of mtu */
                                                                            if mtu
                                                                                > (*chk).send_size
                                                                                    as libc::c_uint
                                                                            {
                                                                                mtu
                                                                                    =
                                                                                    mtu.wrapping_sub((*chk).send_size
                                                                                                         as
                                                                                                         libc::c_uint)
                                                                            } else {
                                                                                mtu = 0u32
                                                                            }
                                                                            /* unsigned subtraction of r_mtu */
                                                                            if r_mtu
                                                                                > (*chk).send_size
                                                                                    as libc::c_uint
                                                                            {
                                                                                r_mtu
                                                                                    =
                                                                                    r_mtu.wrapping_sub((*chk).send_size
                                                                                                           as
                                                                                                           libc::c_uint)
                                                                            } else {
                                                                                r_mtu = 0u32
                                                                            }
                                                                            to_out = to_out
                                                                                .wrapping_add(
                                                                                (*chk).send_size
                                                                                    as libc::c_uint,
                                                                            );
                                                                            if to_out > mx_mtu
                                                                                && no_fragmentflg
                                                                                    != 0
                                                                            {
                                                                                if system_base_info
                                                                                    .debug_printf
                                                                                    .is_some()
                                                                                {
                                                                                    system_base_info.debug_printf.expect("non-null function pointer")(b"Exceeding mtu of %d out size is %d\n\x00"
                                                                                                                                                          as
                                                                                                                                                          *const u8
                                                                                                                                                          as
                                                                                                                                                          *const libc::c_char,
                                                                                                                                                      mx_mtu,
                                                                                                                                                      to_out);
                                                                                }
                                                                            }
                                                                            (*chk).window_probe =
                                                                                0u8;
                                                                            let fresh35 = bundle_at;
                                                                            bundle_at =
                                                                                bundle_at + 1;
                                                                            data_list[fresh35
                                                                                as usize] = chk;
                                                                            if bundle_at >= 256i32 {
                                                                                break;
                                                                            }
                                                                            if (*chk).sent == 0i32 {
                                                                                if (*chk)
                                                                                    .rec
                                                                                    .data
                                                                                    .rcv_flags
                                                                                    as libc::c_int
                                                                                    & 0x4i32
                                                                                    == 0i32
                                                                                {
                                                                                    ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_outorderchunks,
                                                                                                                   1u32);
                                                                                } else {
                                                                                    ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_outunorderchunks,
                                                                                                                   1u32);
                                                                                }
                                                                                if (*chk).rec.data.rcv_flags
                                                                                       as
                                                                                       libc::c_int
                                                                                       &
                                                                                       0x1i32
                                                                                       ==
                                                                                       0x1i32
                                                                                       &&
                                                                                       (*chk).rec.data.rcv_flags
                                                                                           as
                                                                                           libc::c_int
                                                                                           &
                                                                                           0x2i32
                                                                                           ==
                                                                                           0i32
                                                                                   {
                                                                                    /* Count number of user msg's that were fragmented
							 * we do this by counting when we see a LAST fragment
							 * only.
							 */
                                                                                    ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_fragusrmsgs,
                                                                                                                   1u32);
                                                                                }
                                                                            }
                                                                            if mtu == 0u32
                                                                                || r_mtu == 0u32
                                                                                || one_chunk != 0
                                                                            {
                                                                                if one_chunk
                                                                                       !=
                                                                                       0
                                                                                       &&
                                                                                       (*stcb).asoc.total_flight
                                                                                           ==
                                                                                           0u32
                                                                                   {
                                                                                    (*data_list[0usize]).window_probe
                                                                                        =
                                                                                        1u8;
                                                                                    (*net).window_probe
                                                                                        =
                                                                                        1u8
                                                                                }
                                                                                break;
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                /* Don't send the chunk on this net */
                                                                chk = nchk
                                                            }
                                                        }
                                                        /* for (chunk gather loop for this net) */
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    /* Is there something to send for this destination? */
                                    if !outchain.is_null() {
                                        /* We may need to start a control timer or two */
                                        if asconf != 0 {
                                            sctp_timer_start(10i32, inp, stcb, net);
                                            /*
                                             * do NOT clear the asconf flag as it is used
                                             * to do appropriate source address selection.
                                             */
                                        }
                                        if cookie != 0 {
                                            sctp_timer_start(6i32, inp, stcb, net);
                                            cookie = 0i32
                                        }
                                        /* must start a send timer if data is being sent */
                                        if bundle_at != 0
                                            && (*net).rxt_timer.timer.c_flags & 0x4i32 == 0
                                        {
                                            /*
                                             * no timer running on this destination
                                             * restart it.
                                             */
                                            sctp_timer_start(1i32, inp, stcb, net);
                                        }
                                        if bundle_at != 0 || hbflag != 0 {
                                            /* For data/asconf and hb set time */
                                            if *now_filled == 0i32 {
                                                gettimeofday(now, 0 as *mut timezone);
                                                *now_filled = 1i32
                                            }
                                            (*net).last_sent_time = *now
                                        }
                                        /* Now send it, if there is anything to send :> */
                                        error = sctp_lowlevel_chunk_output(
                                            inp,
                                            stcb,
                                            net,
                                            &mut (*net).ro._l_addr as *mut sctp_sockstore
                                                as *mut sockaddr,
                                            outchain,
                                            auth_offset,
                                            auth,
                                            auth_keyid,
                                            no_fragmentflg,
                                            bundle_at,
                                            asconf,
                                            (*inp).ip_inp.inp.inp_inc.inc_ie.ie_lport,
                                            (*stcb).rport,
                                            htonl((*stcb).asoc.peer_vtag),
                                            (*net).port,
                                            0 as *mut sctp_sockstore,
                                            so_locked,
                                        );
                                        if error != 0 {
                                            /* error, we could not output */
                                            if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32
                                                != 0
                                            {
                                                if system_base_info.debug_printf.is_some() {
                                                    system_base_info
                                                        .debug_printf
                                                        .expect("non-null function pointer")(
                                                        b"Gak send error %d\n\x00" as *const u8
                                                            as *const libc::c_char,
                                                        error,
                                                    );
                                                }
                                            }
                                            if from_where == 0i32 {
                                                ::std::intrinsics::atomic_xadd(
                                                    &mut system_base_info
                                                        .sctpstat
                                                        .sctps_lowlevelerrusr,
                                                    1u32,
                                                );
                                            }
                                            if error == 105i32 {
                                                (*asoc).ifp_had_enobuf = 1u8;
                                                ::std::intrinsics::atomic_xadd(
                                                    &mut system_base_info
                                                        .sctpstat
                                                        .sctps_lowlevelerr,
                                                    1u32,
                                                );
                                            }
                                            if error == 113i32 {
                                                /* This takes us back to the for() for the nets. */
                                                /*
                                                 * Destination went unreachable
                                                 * during this send
                                                 */
                                                sctp_move_chunks_from_net(stcb, net);
                                            }
                                            *reason_code = 6i32;
                                            /*-
                                             * I add this line to be paranoid. As far as
                                             * I can tell the continue, takes us back to
                                             * the top of the for, but just to make sure
                                             * I will reset these again here.
                                             */
                                            bundle_at = 0i32;
                                            ctl_cnt = bundle_at;
                                            current_block = 17372050596571538954;
                                        } else {
                                            (*asoc).ifp_had_enobuf = 0u8;
                                            endoutchain = 0 as *mut mbuf;
                                            auth = 0 as *mut sctp_auth_chunk;
                                            auth_offset = 0u32;
                                            if no_out_cnt == 0 {
                                                *num_out += ctl_cnt + bundle_at
                                            }
                                            if bundle_at != 0 {
                                                /* setup for a RTO measurement */
                                                tsns_sent = (*data_list[0usize]).rec.data.tsn
                                                    as libc::c_int;
                                                /* fill time if not already filled */
                                                if *now_filled == 0i32 {
                                                    gettimeofday(
                                                        &mut (*asoc).time_last_sent,
                                                        0 as *mut timezone,
                                                    );
                                                    *now_filled = 1i32;
                                                    *now = (*asoc).time_last_sent
                                                } else {
                                                    (*asoc).time_last_sent = *now
                                                }
                                                if (*net).rto_needed != 0 {
                                                    (*data_list[0usize]).do_rtt = 1u8;
                                                    (*net).rto_needed = 0u8
                                                }
                                                ::std::intrinsics::atomic_xadd(
                                                    &mut system_base_info.sctpstat.sctps_senddata,
                                                    bundle_at as uint32_t,
                                                );
                                                sctp_clean_up_datalist(
                                                    stcb,
                                                    asoc,
                                                    data_list.as_mut_ptr(),
                                                    bundle_at,
                                                    net,
                                                );
                                            }
                                            if one_chunk != 0 {
                                                break;
                                            }
                                            current_block = 14149131090004556752;
                                        }
                                    } else {
                                        current_block = 14149131090004556752;
                                    }
                                    match current_block {
                                        17372050596571538954 => {}
                                        _ => {
                                            if system_base_info.sctpsysctl.sctp_logging_level
                                                & 0x4u32
                                                != 0
                                            {
                                                sctp_log_cwnd(stcb, net, tsns_sent, 61u8);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        /* try next net */
                        net = (*net).sctp_next.tqe_next
                    }
                    /* through list ocmpletely. */
                    if !old_start_at.is_null() {
                        break;
                    }
                    old_start_at = start_at;
                    start_at = (*asoc).nets.tqh_first;
                    if old_start_at.is_null() {
                        break;
                    }
                }
                /*
                 * At the end there should be no NON timed chunks hanging on this
                 * queue.
                 */
                if system_base_info.sctpsysctl.sctp_logging_level & 0x4u32 != 0 {
                    sctp_log_cwnd(stcb, net, *num_out, 61u8);
                }
                if *num_out == 0i32 && *reason_code == 0i32 {
                    *reason_code = 4i32
                } else {
                    *reason_code = 5i32
                }
                sctp_clean_up_ctl(stcb, asoc, so_locked);
                return 0i32;
            }
        }
    }
    /* Nothing but ECNe to send - we don't do that */
    *reason_code = 9i32;
    return 0i32;
}
#[no_mangle]
pub unsafe extern "C" fn sctp_queue_op_err(mut stcb: *mut sctp_tcb, mut op_err: *mut mbuf) {
    let mut hdr = 0 as *mut sctp_chunkhdr;
    let mut chk = 0 as *mut sctp_tmit_chunk;
    let mut mat = 0 as *mut mbuf;
    let mut last_mbuf = 0 as *mut mbuf;
    let mut chunk_length = 0;
    let mut padding_length = 0;
    let mut _mplen = ::std::mem::size_of::<sctp_chunkhdr>() as libc::c_int;
    let mut _mmp = &mut op_err;
    let mut _mm = *_mmp;

    if (if (*_mm).m_hdr.mh_flags & 0x1i32 != 0 {
        (if (*_mm).m_hdr.mh_flags & 0x8i32 == 0
            && ((*_mm).m_hdr.mh_flags & 0x1i32 == 0
                || *(*_mm).M_dat.MH.MH_dat.MH_ext.ref_cnt == 1u32)
        {
            (*_mm)
                .m_hdr
                .mh_data
                .wrapping_offset_from((*_mm).M_dat.MH.MH_dat.MH_ext.ext_buf)
                as libc::c_long
        } else {
            0i64
        })
    } else {
        (if (*_mm).m_hdr.mh_flags & 0x2i32 != 0 {
            (*_mm)
                .m_hdr
                .mh_data
                .wrapping_offset_from((*_mm).M_dat.MH.MH_dat.MH_databuf.as_mut_ptr())
                as libc::c_long
        } else {
            (*_mm)
                .m_hdr
                .mh_data
                .wrapping_offset_from((*_mm).M_dat.M_databuf.as_mut_ptr())
                as libc::c_long
        })
    }) >= _mplen as libc::c_long
    {
        (*_mm).m_hdr.mh_data = (*_mm).m_hdr.mh_data.offset(-(_mplen as isize));
        (*_mm).m_hdr.mh_len += _mplen
    } else {
        let mut __mhow = 0x1i32;
        _mm = m_prepend(_mm, _mplen, __mhow)
    }
    if !_mm.is_null() && (*_mm).m_hdr.mh_flags & 0x2i32 != 0 {
        (*_mm).M_dat.MH.MH_pkthdr.len += _mplen
    }
    *_mmp = _mm;
    if op_err.is_null() {
        return;
    }
    last_mbuf = 0 as *mut mbuf;
    chunk_length = 0u32;
    mat = op_err;
    while !mat.is_null() {
        chunk_length = (chunk_length).wrapping_add((*mat).m_hdr.mh_len as libc::c_uint);
        if (*mat).m_hdr.mh_next.is_null() {
            last_mbuf = mat
        }
        mat = (*mat).m_hdr.mh_next
    }
    if chunk_length > 0xffffu32 {
        m_freem(op_err);
        return;
    }
    padding_length = chunk_length.wrapping_rem(4u32) as uint16_t;
    if padding_length as libc::c_int != 0i32 {
        padding_length = (4i32 - padding_length as libc::c_int) as uint16_t
    }
    if padding_length as libc::c_int != 0i32 {
        if sctp_add_pad_tombuf(last_mbuf, padding_length as libc::c_int).is_null() {
            m_freem(op_err);
            return;
        }
    }
    if (*stcb).asoc.free_chunks.tqh_first.is_null() {
        chk = malloc(system_base_info.sctppcbinfo.ipi_zone_chunk) as *mut sctp_tmit_chunk;
        if !chk.is_null() {
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctppcbinfo.ipi_count_chunk, 1u32);
            (*chk).whoTo = 0 as *mut sctp_nets;
            (*chk).holds_key_ref = 0u8
        }
    } else {
        chk = (*stcb).asoc.free_chunks.tqh_first;
        if !(*chk).sctp_next.tqe_next.is_null() {
            (*(*chk).sctp_next.tqe_next).sctp_next.tqe_prev = (*chk).sctp_next.tqe_prev
        } else {
            (*stcb).asoc.free_chunks.tqh_last = (*chk).sctp_next.tqe_prev
        }
        *(*chk).sctp_next.tqe_prev = (*chk).sctp_next.tqe_next;
        ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_free_chunks, 1u32);
        (*chk).holds_key_ref = 0u8;
        ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_cached_chk, 1u32);
        (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_sub(1)
    }
    if chk.is_null() {
        /* no memory */
        m_freem(op_err);
        return;
    }
    (*chk).copy_by_ref = 0u8;
    (*chk).rec.chunk_id.id = 0x9u8;
    (*chk).rec.chunk_id.can_take_data = 0u8;
    (*chk).flags = 0u16;
    (*chk).send_size = chunk_length as uint16_t;
    (*chk).sent = 0i32;
    (*chk).snd_count = 0u16;
    (*chk).asoc = &mut (*stcb).asoc;
    (*chk).data = op_err;
    (*chk).whoTo = 0 as *mut sctp_nets;
    hdr = (*op_err).m_hdr.mh_data as *mut sctp_chunkhdr;
    (*hdr).chunk_type = 0x9u8;
    (*hdr).chunk_flags = 0u8;
    (*hdr).chunk_length = htons((*chk).send_size);
    (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
    (*chk).sctp_next.tqe_prev = (*(*chk).asoc).control_send_queue.tqh_last;
    *(*(*chk).asoc).control_send_queue.tqh_last = chk;
    (*(*chk).asoc).control_send_queue.tqh_last = &mut (*chk).sctp_next.tqe_next;
    (*(*chk).asoc).ctrl_queue_cnt += 1;
}
#[no_mangle]
pub unsafe extern "C" fn sctp_send_cookie_echo(
    mut m: *mut mbuf,
    mut offset: libc::c_int,
    mut limit: libc::c_int,
    mut stcb: *mut sctp_tcb,
    mut net: *mut sctp_nets,
) -> libc::c_int {
    let mut at = 0;
    let mut cookie = 0 as *mut mbuf;
    let mut hdr = 0 as *mut sctp_chunkhdr;
    let mut chk = 0 as *mut sctp_tmit_chunk;
    let mut plen = 0;
    /* First find the cookie in the param area */
    cookie = 0 as *mut mbuf;
    at = (offset as libc::c_ulong)
        .wrapping_add(::std::mem::size_of::<sctp_init_chunk>() as libc::c_ulong)
        as libc::c_int;
    loop {
        let mut param = sctp_paramhdr {
            param_type: 0,
            param_length: 0,
        };
        let mut phdr = 0 as *mut sctp_paramhdr;
        let mut ptype = 0;
        phdr = sctp_get_next_param(
            m,
            at,
            &mut param,
            ::std::mem::size_of::<sctp_paramhdr>() as libc::c_int,
        );
        if phdr.is_null() {
            return -(3i32);
        }
        ptype = ntohs((*phdr).param_type);
        plen = ntohs((*phdr).param_length);
        if (plen as libc::c_ulong) < ::std::mem::size_of::<sctp_paramhdr>() as libc::c_ulong {
            return -(6i32);
        }
        if ptype as libc::c_int == 0x7i32 {
            let mut pad = 0;
            /* found the cookie */
            if at + plen as libc::c_int > limit {
                return -(7i32);
            }
            cookie = m_copym(m, at, plen as libc::c_int, 0x1i32);
            if cookie.is_null() {
                /* No memory */
                return -(2i32);
            }
            pad = plen as libc::c_int % 4i32;
            if pad > 0i32 {
                pad = 4i32 - pad
            }
            if pad > 0i32 {
                if sctp_pad_lastmbuf(cookie, pad, 0 as *mut mbuf).is_null() {
                    return -(8i32);
                }
            }
            break;
        } else {
            at += (plen as libc::c_int + 3i32 >> 2i32) << 2i32
        }
    }
    /* ok, we got the cookie lets change it into a cookie echo chunk */
    /* first the change from param to cookie */
    hdr = (*cookie).m_hdr.mh_data as *mut sctp_chunkhdr;
    (*hdr).chunk_type = 0xau8;
    (*hdr).chunk_flags = 0u8;
    /* get the chunk stuff now and place it in the FRONT of the queue */
    if (*stcb).asoc.free_chunks.tqh_first.is_null() {
        chk = malloc(system_base_info.sctppcbinfo.ipi_zone_chunk) as *mut sctp_tmit_chunk;
        if !chk.is_null() {
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctppcbinfo.ipi_count_chunk, 1u32);
            (*chk).whoTo = 0 as *mut sctp_nets;
            (*chk).holds_key_ref = 0u8
        }
    } else {
        chk = (*stcb).asoc.free_chunks.tqh_first;
        if !(*chk).sctp_next.tqe_next.is_null() {
            (*(*chk).sctp_next.tqe_next).sctp_next.tqe_prev = (*chk).sctp_next.tqe_prev
        } else {
            (*stcb).asoc.free_chunks.tqh_last = (*chk).sctp_next.tqe_prev
        }
        *(*chk).sctp_next.tqe_prev = (*chk).sctp_next.tqe_next;
        ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_free_chunks, 1u32);
        (*chk).holds_key_ref = 0u8;
        ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_cached_chk, 1u32);
        (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_sub(1)
    }
    if chk.is_null() {
        /* no memory */
        m_freem(cookie);
        return -(5i32);
    }
    (*chk).copy_by_ref = 0u8;
    (*chk).rec.chunk_id.id = 0xau8;
    (*chk).rec.chunk_id.can_take_data = 0u8;
    (*chk).flags = 0x100u16;
    (*chk).send_size = ((plen as libc::c_int + 3i32 >> 2i32) << 2i32) as uint16_t;
    (*chk).sent = 0i32;
    (*chk).snd_count = 0u16;
    (*chk).asoc = &mut (*stcb).asoc;
    (*chk).data = cookie;
    (*chk).whoTo = net;
    ::std::intrinsics::atomic_xadd(&mut (*(*chk).whoTo).ref_count, 1i32);
    (*chk).sctp_next.tqe_next = (*(*chk).asoc).control_send_queue.tqh_first;
    if !(*chk).sctp_next.tqe_next.is_null() {
        (*(*(*chk).asoc).control_send_queue.tqh_first)
            .sctp_next
            .tqe_prev = &mut (*chk).sctp_next.tqe_next
    } else {
        (*(*chk).asoc).control_send_queue.tqh_last = &mut (*chk).sctp_next.tqe_next
    }
    (*(*chk).asoc).control_send_queue.tqh_first = chk;
    (*chk).sctp_next.tqe_prev = &mut (*(*chk).asoc).control_send_queue.tqh_first;
    (*(*chk).asoc).ctrl_queue_cnt += 1;
    return 0i32;
}
#[no_mangle]
pub unsafe extern "C" fn sctp_send_heartbeat_ack(
    mut stcb: *mut sctp_tcb,
    mut m: *mut mbuf,
    mut offset: libc::c_int,
    mut chk_length: libc::c_int,
    mut net: *mut sctp_nets,
) {
    let mut outchain = 0 as *mut mbuf;
    let mut chdr = 0 as *mut sctp_chunkhdr;
    let mut chk = 0 as *mut sctp_tmit_chunk;
    if net.is_null() {
        /* must have a net pointer */
        return;
    }
    outchain = m_copym(m, offset, chk_length, 0x1i32);
    if outchain.is_null() {
        /* gak out of memory */
        return;
    }
    chdr = (*outchain).m_hdr.mh_data as *mut sctp_chunkhdr;
    (*chdr).chunk_type = 0x5u8;
    (*chdr).chunk_flags = 0u8;
    if chk_length % 4i32 != 0i32 {
        sctp_pad_lastmbuf(outchain, 4i32 - chk_length % 4i32, 0 as *mut mbuf);
    }
    if (*stcb).asoc.free_chunks.tqh_first.is_null() {
        chk = malloc(system_base_info.sctppcbinfo.ipi_zone_chunk) as *mut sctp_tmit_chunk;
        if !chk.is_null() {
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctppcbinfo.ipi_count_chunk, 1u32);
            (*chk).whoTo = 0 as *mut sctp_nets;
            (*chk).holds_key_ref = 0u8
        }
    } else {
        chk = (*stcb).asoc.free_chunks.tqh_first;
        if !(*chk).sctp_next.tqe_next.is_null() {
            (*(*chk).sctp_next.tqe_next).sctp_next.tqe_prev = (*chk).sctp_next.tqe_prev
        } else {
            (*stcb).asoc.free_chunks.tqh_last = (*chk).sctp_next.tqe_prev
        }
        *(*chk).sctp_next.tqe_prev = (*chk).sctp_next.tqe_next;
        ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_free_chunks, 1u32);
        (*chk).holds_key_ref = 0u8;
        ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_cached_chk, 1u32);
        (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_sub(1)
    }
    if chk.is_null() {
        /* no memory */
        m_freem(outchain);
        return;
    }
    (*chk).copy_by_ref = 0u8;
    (*chk).rec.chunk_id.id = 0x5u8;
    (*chk).rec.chunk_id.can_take_data = 1u8;
    (*chk).flags = 0u16;
    (*chk).send_size = chk_length as uint16_t;
    (*chk).sent = 0i32;
    (*chk).snd_count = 0u16;
    (*chk).asoc = &mut (*stcb).asoc;
    (*chk).data = outchain;
    (*chk).whoTo = net;
    ::std::intrinsics::atomic_xadd(&mut (*(*chk).whoTo).ref_count, 1i32);
    (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
    (*chk).sctp_next.tqe_prev = (*(*chk).asoc).control_send_queue.tqh_last;
    *(*(*chk).asoc).control_send_queue.tqh_last = chk;
    (*(*chk).asoc).control_send_queue.tqh_last = &mut (*chk).sctp_next.tqe_next;
    (*(*chk).asoc).ctrl_queue_cnt += 1;
}
#[no_mangle]
pub unsafe extern "C" fn sctp_send_cookie_ack(mut stcb: *mut sctp_tcb) {
    let mut cookie_ack = 0 as *mut mbuf;
    let mut hdr = 0 as *mut sctp_chunkhdr;
    let mut chk = 0 as *mut sctp_tmit_chunk;
    cookie_ack = sctp_get_mbuf_for_msg(
        ::std::mem::size_of::<sctp_chunkhdr>() as libc::c_uint,
        0i32,
        0x1i32,
        1i32,
        1i32,
    );
    if cookie_ack.is_null() {
        /* no mbuf's */
        return;
    }
    (*cookie_ack).m_hdr.mh_data = (*cookie_ack).m_hdr.mh_data.offset(
        (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong) as isize,
    );
    if (*stcb).asoc.free_chunks.tqh_first.is_null() {
        chk = malloc(system_base_info.sctppcbinfo.ipi_zone_chunk) as *mut sctp_tmit_chunk;
        if !chk.is_null() {
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctppcbinfo.ipi_count_chunk, 1u32);
            (*chk).whoTo = 0 as *mut sctp_nets;
            (*chk).holds_key_ref = 0u8
        }
    } else {
        chk = (*stcb).asoc.free_chunks.tqh_first;
        if !(*chk).sctp_next.tqe_next.is_null() {
            (*(*chk).sctp_next.tqe_next).sctp_next.tqe_prev = (*chk).sctp_next.tqe_prev
        } else {
            (*stcb).asoc.free_chunks.tqh_last = (*chk).sctp_next.tqe_prev
        }
        *(*chk).sctp_next.tqe_prev = (*chk).sctp_next.tqe_next;
        ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_free_chunks, 1u32);
        (*chk).holds_key_ref = 0u8;
        ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_cached_chk, 1u32);
        (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_sub(1)
    }
    if chk.is_null() {
        /* no memory */
        m_freem(cookie_ack);
        return;
    }
    (*chk).copy_by_ref = 0u8;
    (*chk).rec.chunk_id.id = 0xbu8;
    (*chk).rec.chunk_id.can_take_data = 1u8;
    (*chk).flags = 0u16;
    (*chk).send_size = ::std::mem::size_of::<sctp_chunkhdr>() as uint16_t;
    (*chk).sent = 0i32;
    (*chk).snd_count = 0u16;
    (*chk).asoc = &mut (*stcb).asoc;
    (*chk).data = cookie_ack;
    if !(*(*chk).asoc).last_control_chunk_from.is_null() {
        (*chk).whoTo = (*(*chk).asoc).last_control_chunk_from;
        ::std::intrinsics::atomic_xadd(&mut (*(*chk).whoTo).ref_count, 1i32);
    } else {
        (*chk).whoTo = 0 as *mut sctp_nets
    }
    hdr = (*cookie_ack).m_hdr.mh_data as *mut sctp_chunkhdr;
    (*hdr).chunk_type = 0xbu8;
    (*hdr).chunk_flags = 0u8;
    (*hdr).chunk_length = htons((*chk).send_size);
    (*cookie_ack).m_hdr.mh_len = (*chk).send_size as libc::c_int;
    (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
    (*chk).sctp_next.tqe_prev = (*(*chk).asoc).control_send_queue.tqh_last;
    *(*(*chk).asoc).control_send_queue.tqh_last = chk;
    (*(*chk).asoc).control_send_queue.tqh_last = &mut (*chk).sctp_next.tqe_next;
    (*(*chk).asoc).ctrl_queue_cnt += 1;
}
#[no_mangle]
pub unsafe extern "C" fn sctp_send_shutdown_ack(mut stcb: *mut sctp_tcb, mut net: *mut sctp_nets) {
    let mut m_shutdown_ack = 0 as *mut mbuf;
    let mut ack_cp = 0 as *mut sctp_shutdown_ack_chunk;
    let mut chk = 0 as *mut sctp_tmit_chunk;
    m_shutdown_ack = sctp_get_mbuf_for_msg(
        ::std::mem::size_of::<sctp_shutdown_ack_chunk>() as libc::c_uint,
        0i32,
        0x1i32,
        1i32,
        1i32,
    );
    if m_shutdown_ack.is_null() {
        /* no mbuf's */
        return;
    }
    (*m_shutdown_ack).m_hdr.mh_data = (*m_shutdown_ack).m_hdr.mh_data.offset(
        (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong) as isize,
    );
    if (*stcb).asoc.free_chunks.tqh_first.is_null() {
        chk = malloc(system_base_info.sctppcbinfo.ipi_zone_chunk) as *mut sctp_tmit_chunk;
        if !chk.is_null() {
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctppcbinfo.ipi_count_chunk, 1u32);
            (*chk).whoTo = 0 as *mut sctp_nets;
            (*chk).holds_key_ref = 0u8
        }
    } else {
        chk = (*stcb).asoc.free_chunks.tqh_first;
        if !(*chk).sctp_next.tqe_next.is_null() {
            (*(*chk).sctp_next.tqe_next).sctp_next.tqe_prev = (*chk).sctp_next.tqe_prev
        } else {
            (*stcb).asoc.free_chunks.tqh_last = (*chk).sctp_next.tqe_prev
        }
        *(*chk).sctp_next.tqe_prev = (*chk).sctp_next.tqe_next;
        ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_free_chunks, 1u32);
        (*chk).holds_key_ref = 0u8;
        ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_cached_chk, 1u32);
        (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_sub(1)
    }
    if chk.is_null() {
        /* no memory */
        m_freem(m_shutdown_ack);
        return;
    }
    (*chk).copy_by_ref = 0u8;
    (*chk).rec.chunk_id.id = 0x8u8;
    (*chk).rec.chunk_id.can_take_data = 1u8;
    (*chk).flags = 0u16;
    (*chk).send_size = ::std::mem::size_of::<sctp_chunkhdr>() as uint16_t;
    (*chk).sent = 0i32;
    (*chk).snd_count = 0u16;
    (*chk).asoc = &mut (*stcb).asoc;
    (*chk).data = m_shutdown_ack;
    (*chk).whoTo = net;
    if !(*chk).whoTo.is_null() {
        ::std::intrinsics::atomic_xadd(&mut (*(*chk).whoTo).ref_count, 1i32);
    }
    ack_cp = (*m_shutdown_ack).m_hdr.mh_data as *mut sctp_shutdown_ack_chunk;
    (*ack_cp).ch.chunk_type = 0x8u8;
    (*ack_cp).ch.chunk_flags = 0u8;
    (*ack_cp).ch.chunk_length = htons((*chk).send_size);
    (*m_shutdown_ack).m_hdr.mh_len = (*chk).send_size as libc::c_int;
    (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
    (*chk).sctp_next.tqe_prev = (*(*chk).asoc).control_send_queue.tqh_last;
    *(*(*chk).asoc).control_send_queue.tqh_last = chk;
    (*(*chk).asoc).control_send_queue.tqh_last = &mut (*chk).sctp_next.tqe_next;
    (*(*chk).asoc).ctrl_queue_cnt += 1;
}
#[no_mangle]
pub unsafe extern "C" fn sctp_send_shutdown(mut stcb: *mut sctp_tcb, mut net: *mut sctp_nets) {
    let mut shutdown_cp = 0 as *mut sctp_shutdown_chunk;
    let mut chk = 0 as *mut sctp_tmit_chunk;
    chk = (*stcb).asoc.control_send_queue.tqh_first;
    while !chk.is_null() {
        if (*chk).rec.chunk_id.id as libc::c_int == 0x7i32 {
            /* We already have a SHUTDOWN queued. Reuse it. */
            if !(*chk).whoTo.is_null() {
                if !(*chk).whoTo.is_null() {
                    if ::std::intrinsics::atomic_xadd(
                        &mut (*(*chk).whoTo).ref_count as *mut libc::c_int,
                        -(1i32),
                    ) == 1i32
                    {
                        sctp_os_timer_stop(&mut (*(*chk).whoTo).rxt_timer.timer);
                        sctp_os_timer_stop(&mut (*(*chk).whoTo).pmtu_timer.timer);
                        sctp_os_timer_stop(&mut (*(*chk).whoTo).hb_timer.timer);
                        if !(*(*chk).whoTo).ro.ro_rt.is_null() {
                            if (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt <= 1i64 {
                                sctp_userspace_rtfree((*(*chk).whoTo).ro.ro_rt);
                            } else {
                                (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt -= 1
                            }
                            (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t;
                            (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t
                        }
                        if (*(*chk).whoTo).src_addr_selected != 0 {
                            sctp_free_ifa((*(*chk).whoTo).ro._s_addr);
                            (*(*chk).whoTo).ro._s_addr = 0 as *mut sctp_ifa
                        }
                        (*(*chk).whoTo).src_addr_selected = 0u8;
                        (*(*chk).whoTo).dest_state =
                            ((*(*chk).whoTo).dest_state as libc::c_int & !(0x1i32)) as uint16_t;
                        free((*chk).whoTo as *mut libc::c_void);
                        ::std::intrinsics::atomic_xsub(
                            &mut system_base_info.sctppcbinfo.ipi_count_raddr,
                            1u32,
                        );
                    }
                }
                (*chk).whoTo = 0 as *mut sctp_nets
            }
            break;
        } else {
            chk = (*chk).sctp_next.tqe_next
        }
    }
    if chk.is_null() {
        let mut m_shutdown = 0 as *mut mbuf;
        m_shutdown = sctp_get_mbuf_for_msg(
            ::std::mem::size_of::<sctp_shutdown_chunk>() as libc::c_uint,
            0i32,
            0x1i32,
            1i32,
            1i32,
        );
        if m_shutdown.is_null() {
            /* no mbuf's */
            return;
        }
        (*m_shutdown).m_hdr.mh_data = (*m_shutdown).m_hdr.mh_data.offset(
            (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong)
                as isize,
        );
        if (*stcb).asoc.free_chunks.tqh_first.is_null() {
            chk = malloc(system_base_info.sctppcbinfo.ipi_zone_chunk) as *mut sctp_tmit_chunk;
            if !chk.is_null() {
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                    1u32,
                );
                (*chk).whoTo = 0 as *mut sctp_nets;
                (*chk).holds_key_ref = 0u8
            }
        } else {
            chk = (*stcb).asoc.free_chunks.tqh_first;
            if !(*chk).sctp_next.tqe_next.is_null() {
                (*(*chk).sctp_next.tqe_next).sctp_next.tqe_prev = (*chk).sctp_next.tqe_prev
            } else {
                (*stcb).asoc.free_chunks.tqh_last = (*chk).sctp_next.tqe_prev
            }
            *(*chk).sctp_next.tqe_prev = (*chk).sctp_next.tqe_next;
            ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_free_chunks, 1u32);
            (*chk).holds_key_ref = 0u8;
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_cached_chk, 1u32);
            (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_sub(1)
        }
        if chk.is_null() {
            /* no memory */
            m_freem(m_shutdown);
            return;
        }
        (*chk).copy_by_ref = 0u8;
        (*chk).rec.chunk_id.id = 0x7u8;
        (*chk).rec.chunk_id.can_take_data = 1u8;
        (*chk).flags = 0u16;
        (*chk).send_size = ::std::mem::size_of::<sctp_shutdown_chunk>() as uint16_t;
        (*chk).sent = 0i32;
        (*chk).snd_count = 0u16;
        (*chk).asoc = &mut (*stcb).asoc;
        (*chk).data = m_shutdown;
        (*chk).whoTo = net;
        if !(*chk).whoTo.is_null() {
            ::std::intrinsics::atomic_xadd(&mut (*(*chk).whoTo).ref_count, 1i32);
        }
        shutdown_cp = (*m_shutdown).m_hdr.mh_data as *mut sctp_shutdown_chunk;
        (*shutdown_cp).ch.chunk_type = 0x7u8;
        (*shutdown_cp).ch.chunk_flags = 0u8;
        (*shutdown_cp).ch.chunk_length = htons((*chk).send_size);
        (*shutdown_cp).cumulative_tsn_ack = htonl((*stcb).asoc.cumulative_tsn);
        (*m_shutdown).m_hdr.mh_len = (*chk).send_size as libc::c_int;
        (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
        (*chk).sctp_next.tqe_prev = (*(*chk).asoc).control_send_queue.tqh_last;
        *(*(*chk).asoc).control_send_queue.tqh_last = chk;
        (*(*chk).asoc).control_send_queue.tqh_last = &mut (*chk).sctp_next.tqe_next;
        (*(*chk).asoc).ctrl_queue_cnt += 1
    } else {
        if !(*chk).sctp_next.tqe_next.is_null() {
            (*(*chk).sctp_next.tqe_next).sctp_next.tqe_prev = (*chk).sctp_next.tqe_prev
        } else {
            (*stcb).asoc.control_send_queue.tqh_last = (*chk).sctp_next.tqe_prev
        }
        *(*chk).sctp_next.tqe_prev = (*chk).sctp_next.tqe_next;
        (*chk).whoTo = net;
        if !(*chk).whoTo.is_null() {
            ::std::intrinsics::atomic_xadd(&mut (*(*chk).whoTo).ref_count, 1i32);
        }
        shutdown_cp = (*(*chk).data).m_hdr.mh_data as *mut sctp_shutdown_chunk;
        (*shutdown_cp).cumulative_tsn_ack = htonl((*stcb).asoc.cumulative_tsn);
        (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
        (*chk).sctp_next.tqe_prev = (*stcb).asoc.control_send_queue.tqh_last;
        *(*stcb).asoc.control_send_queue.tqh_last = chk;
        (*stcb).asoc.control_send_queue.tqh_last = &mut (*chk).sctp_next.tqe_next
    };
}
#[no_mangle]
pub unsafe extern "C" fn sctp_send_asconf(
    mut stcb: *mut sctp_tcb,
    mut net: *mut sctp_nets,
    mut addr_locked: libc::c_int,
) {
    let mut chk = 0 as *mut sctp_tmit_chunk;
    let mut m_asconf = 0 as *mut mbuf;
    let mut len = 0;
    if !(*stcb).asoc.asconf_send_queue.tqh_first.is_null()
        && !((*(*stcb).sctp_ep).sctp_features & 0x1000000u64 == 0x1000000u64)
    {
        /* can't send a new one if there is one in flight already */
        return;
    }
    /* compose an ASCONF chunk, maximum length is PMTU */
    m_asconf = sctp_compose_asconf(stcb, &mut len, addr_locked);
    if m_asconf.is_null() {
        return;
    }
    if (*stcb).asoc.free_chunks.tqh_first.is_null() {
        chk = malloc(system_base_info.sctppcbinfo.ipi_zone_chunk) as *mut sctp_tmit_chunk;
        if !chk.is_null() {
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctppcbinfo.ipi_count_chunk, 1u32);
            (*chk).whoTo = 0 as *mut sctp_nets;
            (*chk).holds_key_ref = 0u8
        }
    } else {
        chk = (*stcb).asoc.free_chunks.tqh_first;
        if !(*chk).sctp_next.tqe_next.is_null() {
            (*(*chk).sctp_next.tqe_next).sctp_next.tqe_prev = (*chk).sctp_next.tqe_prev
        } else {
            (*stcb).asoc.free_chunks.tqh_last = (*chk).sctp_next.tqe_prev
        }
        *(*chk).sctp_next.tqe_prev = (*chk).sctp_next.tqe_next;
        ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_free_chunks, 1u32);
        (*chk).holds_key_ref = 0u8;
        ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_cached_chk, 1u32);
        (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_sub(1)
    }
    if chk.is_null() {
        /* no memory */
        m_freem(m_asconf);
        return;
    }
    (*chk).copy_by_ref = 0u8;
    (*chk).rec.chunk_id.id = 0xc1u8;
    (*chk).rec.chunk_id.can_take_data = 0u8;
    (*chk).flags = 0x100u16;
    (*chk).data = m_asconf;
    (*chk).send_size = len as uint16_t;
    (*chk).sent = 0i32;
    (*chk).snd_count = 0u16;
    (*chk).asoc = &mut (*stcb).asoc;
    (*chk).whoTo = net;
    if !(*chk).whoTo.is_null() {
        ::std::intrinsics::atomic_xadd(&mut (*(*chk).whoTo).ref_count, 1i32);
    }
    (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
    (*chk).sctp_next.tqe_prev = (*(*chk).asoc).asconf_send_queue.tqh_last;
    *(*(*chk).asoc).asconf_send_queue.tqh_last = chk;
    (*(*chk).asoc).asconf_send_queue.tqh_last = &mut (*chk).sctp_next.tqe_next;
    (*(*chk).asoc).ctrl_queue_cnt += 1;
}
#[no_mangle]
pub unsafe extern "C" fn sctp_send_asconf_ack(mut stcb: *mut sctp_tcb) {
    let mut ack = 0 as *mut sctp_asconf_ack;
    let mut latest_ack = 0 as *mut sctp_asconf_ack;
    let mut net = 0 as *mut sctp_nets;
    /* Get the latest ASCONF-ACK */
    latest_ack = *(*((*stcb).asoc.asconf_ack_sent.tqh_last as *mut sctp_asconf_ackhead)).tqh_last;
    if latest_ack.is_null() {
        return;
    }
    if !(*latest_ack).last_sent_to.is_null()
        && (*latest_ack).last_sent_to == (*stcb).asoc.last_control_chunk_from
    {
        /* we're doing a retransmission */
        net = sctp_find_alternate_net(stcb, (*stcb).asoc.last_control_chunk_from, 0i32);
        if net.is_null() {
            /* no alternate */
            if (*stcb).asoc.last_control_chunk_from.is_null() {
                if !(*stcb).asoc.alternate.is_null() {
                    net = (*stcb).asoc.alternate
                } else {
                    net = (*stcb).asoc.primary_destination
                }
            } else {
                net = (*stcb).asoc.last_control_chunk_from
            }
        }
    } else if (*stcb).asoc.last_control_chunk_from.is_null() {
        if !(*stcb).asoc.alternate.is_null() {
            net = (*stcb).asoc.alternate
        } else {
            net = (*stcb).asoc.primary_destination
        }
    } else {
        net = (*stcb).asoc.last_control_chunk_from
    }
    (*latest_ack).last_sent_to = net;
    ack = (*stcb).asoc.asconf_ack_sent.tqh_first;
    while !ack.is_null() {
        if !(*ack).data.is_null() {
            let mut chk = 0 as *mut sctp_tmit_chunk;
            let mut m_ack = 0 as *mut mbuf;
            m_ack = m_copym((*ack).data, 0i32, 1000000000i32, 0x1i32);
            if m_ack.is_null() {
                /* couldn't copy it */
                return;
            }
            if (*stcb).asoc.free_chunks.tqh_first.is_null() {
                chk = malloc(system_base_info.sctppcbinfo.ipi_zone_chunk) as *mut sctp_tmit_chunk;
                if !chk.is_null() {
                    ::std::intrinsics::atomic_xadd(
                        &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                        1u32,
                    );
                    (*chk).whoTo = 0 as *mut sctp_nets;
                    (*chk).holds_key_ref = 0u8
                }
            } else {
                chk = (*stcb).asoc.free_chunks.tqh_first;
                if !(*chk).sctp_next.tqe_next.is_null() {
                    (*(*chk).sctp_next.tqe_next).sctp_next.tqe_prev = (*chk).sctp_next.tqe_prev
                } else {
                    (*stcb).asoc.free_chunks.tqh_last = (*chk).sctp_next.tqe_prev
                }
                *(*chk).sctp_next.tqe_prev = (*chk).sctp_next.tqe_next;
                ::std::intrinsics::atomic_xsub(
                    &mut system_base_info.sctppcbinfo.ipi_free_chunks,
                    1u32,
                );
                (*chk).holds_key_ref = 0u8;
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctpstat.sctps_cached_chk,
                    1u32,
                );
                (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_sub(1)
            }
            if chk.is_null() {
                /* no memory */
                if !m_ack.is_null() {
                    m_freem(m_ack);
                }
                return;
            }
            (*chk).copy_by_ref = 0u8;
            (*chk).rec.chunk_id.id = 0x80u8;
            (*chk).rec.chunk_id.can_take_data = 1u8;
            (*chk).flags = 0x100u16;
            (*chk).whoTo = net;
            if !(*chk).whoTo.is_null() {
                ::std::intrinsics::atomic_xadd(&mut (*(*chk).whoTo).ref_count, 1i32);
            }
            (*chk).data = m_ack;
            (*chk).send_size = (*ack).len;
            (*chk).sent = 0i32;
            (*chk).snd_count = 0u16;
            (*chk).asoc = &mut (*stcb).asoc;
            (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
            (*chk).sctp_next.tqe_prev = (*(*chk).asoc).control_send_queue.tqh_last;
            *(*(*chk).asoc).control_send_queue.tqh_last = chk;
            (*(*chk).asoc).control_send_queue.tqh_last = &mut (*chk).sctp_next.tqe_next;
            (*(*chk).asoc).ctrl_queue_cnt += 1
        }
        ack = (*ack).next.tqe_next
    }
}
unsafe extern "C" fn sctp_chunk_retransmission(
    mut inp: *mut sctp_inpcb,
    mut stcb: *mut sctp_tcb,
    mut asoc: *mut sctp_association,
    mut cnt_out: *mut libc::c_int,
    mut now: *mut timeval,
    mut now_filled: *mut libc::c_int,
    mut fr_done: *mut libc::c_int,
    mut so_locked: libc::c_int,
) -> libc::c_int {
    let mut chk = 0 as *mut sctp_tmit_chunk;
    let mut fwd = 0 as *mut sctp_tmit_chunk;
    let mut m = 0 as *mut mbuf;
    let mut endofchain = 0 as *mut mbuf;
    let mut no_fragmentflg = 0;
    let mut bundle_at = 0;
    let mut cnt_thru = 0;
    let mut error = 0;
    let mut one_chunk = 0;
    let mut fwd_tsn = 0;
    let mut ctl_cnt = 0;
    let mut tmr_started = 0;
    let mut auth = 0 as *mut sctp_auth_chunk;
    let mut auth_offset = 0u32;
    let mut auth_keyid = 0;
    let mut data_auth_reqd = 0i32;
    error = 0i32;
    bundle_at = error;
    ctl_cnt = bundle_at;
    tmr_started = ctl_cnt;
    no_fragmentflg = 1i32;
    fwd_tsn = 0i32;
    *cnt_out = 0i32;
    fwd = 0 as *mut sctp_tmit_chunk;
    m = 0 as *mut mbuf;
    endofchain = m;
    auth_keyid = (*stcb).asoc.authinfo.active_keyid;
    if (*asoc).sent_queue.tqh_first.is_null() && (*asoc).control_send_queue.tqh_first.is_null() {
        if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"SCTP hits empty queue with cnt set to %d?\n\x00" as *const u8
                        as *const libc::c_char,
                    (*asoc).sent_queue_retran_cnt,
                );
            }
        }
        (*asoc).sent_queue_cnt = 0u32;
        (*asoc).sent_queue_cnt_removeable = 0u32;
        /* send back 0/0 so we enter normal transmission */
        *cnt_out = 0i32;
        return 0i32;
    }

    chk = (*asoc).control_send_queue.tqh_first;
    while !chk.is_null() {
        if (*chk).rec.chunk_id.id as libc::c_int == 0xai32
            || (*chk).rec.chunk_id.id as libc::c_int == 0x82i32
            || (*chk).rec.chunk_id.id as libc::c_int == 0xc0i32
        {
            if !((*chk).sent != 4i32) {
                let mut current_block_33: u64;
                if (*chk).rec.chunk_id.id as libc::c_int == 0x82i32 {
                    if chk != (*asoc).str_reset {
                        current_block_33 = 7205609094909031804;
                    } else {
                        current_block_33 = 8180496224585318153;
                    }
                } else {
                    current_block_33 = 8180496224585318153;
                }
                match current_block_33 {
                    7205609094909031804 => {}
                    _ => {
                        ctl_cnt += 1;
                        if (*chk).rec.chunk_id.id as libc::c_int == 0xc0i32 {
                            fwd_tsn = 1i32
                        }
                        /*
                         * Add an AUTH chunk, if chunk requires it save the
                         * offset into the chain for AUTH
                         */
                        if auth.is_null()
                            && (if (*stcb).asoc.peer_auth_chunks.is_null() {
                                0i32
                            } else {
                                ((*(*stcb).asoc.peer_auth_chunks).chunks
                                    [(*chk).rec.chunk_id.id as usize]
                                    as libc::c_int
                                    != 0i32) as libc::c_int
                            }) != 0
                        {
                            m = sctp_add_auth_chunk(
                                m,
                                &mut endofchain,
                                &mut auth,
                                &mut auth_offset,
                                stcb,
                                (*chk).rec.chunk_id.id,
                            );
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_outcontrolchunks,
                                1u32,
                            );
                        }
                        m = sctp_copy_mbufchain(
                            (*chk).data,
                            m,
                            &mut endofchain,
                            0i32,
                            (*chk).send_size as libc::c_int,
                            (*chk).copy_by_ref,
                        );
                        break;
                    }
                }
            }
        }
        /*
         * not eligible for retran if its
         * not ours
         */
        chk = (*chk).sctp_next.tqe_next
    }
    one_chunk = 0i32;
    cnt_thru = 0i32;
    /* do we have control chunks to retransmit? */
    if !m.is_null() {
        /* Start a timer no matter if we succeed or fail */
        if (*chk).rec.chunk_id.id as libc::c_int == 0xai32 {
            sctp_timer_start(6i32, inp, stcb, (*chk).whoTo); /* update our count */
        } else if (*chk).rec.chunk_id.id as libc::c_int == 0xc1i32 {
            sctp_timer_start(10i32, inp, stcb, (*chk).whoTo);
        }
        (*chk).snd_count = (*chk).snd_count.wrapping_add(1);
        error = sctp_lowlevel_chunk_output(
            inp,
            stcb,
            (*chk).whoTo,
            &mut (*(*chk).whoTo).ro._l_addr as *mut sctp_sockstore as *mut sockaddr,
            m,
            auth_offset,
            auth,
            (*stcb).asoc.authinfo.active_keyid,
            no_fragmentflg,
            0i32,
            0i32,
            (*inp).ip_inp.inp.inp_inc.inc_ie.ie_lport,
            (*stcb).rport,
            htonl((*stcb).asoc.peer_vtag),
            (*(*chk).whoTo).port,
            0 as *mut sctp_sockstore,
            so_locked,
        );
        if error != 0 {
            if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"Gak send error %d\n\x00" as *const u8 as *const libc::c_char,
                        error,
                    );
                }
            }
            if error == 105i32 {
                (*asoc).ifp_had_enobuf = 1u8;
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctpstat.sctps_lowlevelerr,
                    1u32,
                );
            }
            return error;
        } else {
            (*asoc).ifp_had_enobuf = 0u8
        }
        endofchain = 0 as *mut mbuf;
        auth = 0 as *mut sctp_auth_chunk;
        auth_offset = 0u32;
        /*
         * We don't want to mark the net->sent time here since this
         * we use this for HB and retrans cannot measure RTT
         */
        /* (void)SCTP_GETTIME_TIMEVAL(&chk->whoTo->last_sent_time); */
        *cnt_out += 1i32;
        (*chk).sent = 1i32;
        if (*stcb).asoc.sent_queue_retran_cnt > 0u32 {
            (*stcb).asoc.sent_queue_retran_cnt = (*stcb).asoc.sent_queue_retran_cnt.wrapping_sub(1)
        } else {
            (*stcb).asoc.sent_queue_retran_cnt = 0u32
        }
        if fwd_tsn == 0i32 {
            return 0i32;
        } else {
            /* Clean up the fwd-tsn list */
            sctp_clean_up_ctl(stcb, asoc, so_locked);
            return 0i32;
        }
    }
    /*
     * Ok, it is just data retransmission we need to do or that and a
     * fwd-tsn with it all.
     */
    if (*asoc).sent_queue.tqh_first.is_null() {
        return -(1i32);
    }
    if (*stcb).asoc.state & 0x7fi32 == 0x4i32 || (*stcb).asoc.state & 0x7fi32 == 0x2i32 {
        /* not yet open, resend the cookie and that is it */
        return 1i32;
    }
    data_auth_reqd = if (*stcb).asoc.peer_auth_chunks.is_null() {
        0i32
    } else {
        ((*(*stcb).asoc.peer_auth_chunks).chunks[0usize] as libc::c_int != 0i32) as libc::c_int
    };

    chk = (*asoc).sent_queue.tqh_first;
    while !chk.is_null() {
        if !((*chk).sent != 4i32) {
            if (*chk).data.is_null() {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"TSN:%x chk->snd_count:%d chk->sent:%d can\'t retran - no data\n\x00"
                            as *const u8 as *const libc::c_char,
                        (*chk).rec.data.tsn,
                        (*chk).snd_count as libc::c_int,
                        (*chk).sent,
                    );
                }
            } else {
                let mut net = 0 as *mut sctp_nets;
                let mut mtu = 0;
                let mut current_block_275: u64;
                if system_base_info.sctpsysctl.sctp_max_retran_chunk != 0
                    && (*chk).snd_count as libc::c_uint
                        >= system_base_info.sctpsysctl.sctp_max_retran_chunk
                {
                    let mut op_err = 0 as *mut mbuf;
                    let mut msg = [0; 128];
                    snprintf(
                        msg.as_mut_ptr(),
                        ::std::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
                        b"TSN %8.8x retransmitted %d times, giving up\x00" as *const u8
                            as *const libc::c_char,
                        (*chk).rec.data.tsn,
                        (*chk).snd_count as libc::c_int,
                    );
                    op_err = sctp_generate_cause(
                        system_base_info.sctpsysctl.sctp_diag_info_code as uint16_t,
                        msg.as_mut_ptr(),
                    );
                    ::std::intrinsics::atomic_xadd(&mut (*stcb).asoc.refcnt, 1u32);
                    sctp_abort_an_association((*stcb).sctp_ep, stcb, op_err, so_locked);
                    pthread_mutex_lock(&mut (*stcb).tcb_mtx);
                    ::std::intrinsics::atomic_xsub(&mut (*stcb).asoc.refcnt, 1u32);
                    return -(2i32);
                }
                /* pick up the net */
                net = (*chk).whoTo;
                match (*net).ro._l_addr.sa.sa_family as libc::c_int {
                    2 => {
                        mtu = ((*net).mtu as libc::c_ulong).wrapping_sub(
                            (::std::mem::size_of::<ip>() as libc::c_ulong)
                                .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong),
                        ) as libc::c_uint
                    }
                    10 => {
                        mtu = ((*net).mtu as libc::c_ulong).wrapping_sub(
                            (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
                                .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong),
                        ) as libc::c_uint
                    }
                    123 => {
                        mtu = ((*net).mtu as libc::c_ulong)
                            .wrapping_sub(::std::mem::size_of::<sctphdr>() as libc::c_ulong)
                            as libc::c_uint
                    }
                    _ => {
                        /* TSNH */
                        mtu = (*net).mtu
                    }
                }
                if (*asoc).peers_rwnd < mtu && (*asoc).total_flight > 0u32 {
                    let mut tsn = 0;
                    tsn = (*asoc).last_acked_seq.wrapping_add(1u32);
                    if !(tsn == (*chk).rec.data.tsn) {
                        return 1i32;
                    }
                }
                /*
                 * we make a special exception for this
                 * case. The peer has no rwnd but is missing
                 * the lowest chunk.. which is probably what
                 * is holding up the rwnd.
                 */
                if (*asoc).peers_rwnd < mtu {
                    one_chunk = 1i32;
                    if (*asoc).peers_rwnd == 0u32 && (*asoc).total_flight == 0u32 {
                        (*chk).window_probe = 1u8;
                        (*(*chk).whoTo).window_probe = 1u8
                    }
                }
                bundle_at = 0i32;
                m = 0 as *mut mbuf;
                (*net).fast_retran_ip = 0u8;
                if (*chk).rec.data.doing_fast_retransmit as libc::c_int == 0i32 {
                    /*
                     * if no FR in progress skip destination that have
                     * flight_size > cwnd.
                     */
                    if (*net).flight_size >= (*net).cwnd {
                        current_block_275 = 18137396335907573669;
                    } else {
                        current_block_275 = 9838996637140935403;
                    }
                } else {
                    /*
                     * Mark the destination net to have FR recovery
                     * limits put on it.
                     */
                    *fr_done = 1i32;
                    (*net).fast_retran_ip = 1u8;
                    current_block_275 = 9838996637140935403;
                }
                match current_block_275 {
                    18137396335907573669 => {}
                    _ => {
                        let mut data_list = [0 as *mut sctp_tmit_chunk; 256];
                        let mut override_ok = 1i32;
                        let mut dmtu = 0u32;
                        if data_auth_reqd != 0 && auth.is_null() {
                            dmtu = sctp_get_auth_chunk_len((*stcb).asoc.peer_hmac_id)
                        } else {
                            dmtu = 0u32
                        }
                        if (*chk).send_size as libc::c_uint <= mtu.wrapping_sub(dmtu)
                            || (*chk).flags as libc::c_int & 0x100i32 != 0
                        {
                            /* ok we will add this one */
                            if data_auth_reqd != 0 {
                                if auth.is_null() {
                                    m = sctp_add_auth_chunk(
                                        m,
                                        &mut endofchain,
                                        &mut auth,
                                        &mut auth_offset,
                                        stcb,
                                        0u8,
                                    );
                                    auth_keyid = (*chk).auth_keyid;
                                    override_ok = 0i32;
                                    ::std::intrinsics::atomic_xadd(
                                        &mut system_base_info.sctpstat.sctps_outcontrolchunks,
                                        1u32,
                                    );
                                } else if override_ok != 0 {
                                    auth_keyid = (*chk).auth_keyid;
                                    override_ok = 0i32
                                } else if (*chk).auth_keyid as libc::c_int
                                    != auth_keyid as libc::c_int
                                {
                                    /* different keyid, so done bundling */
                                    break;
                                }
                            }
                            m = sctp_copy_mbufchain(
                                (*chk).data,
                                m,
                                &mut endofchain,
                                0i32,
                                (*chk).send_size as libc::c_int,
                                (*chk).copy_by_ref,
                            );
                            if m.is_null() {
                                return 12i32;
                            }
                            /* Do clear IP_DF ? */
                            if (*chk).flags as libc::c_int & 0x100i32 != 0 {
                                no_fragmentflg = 0i32
                            }
                            /* upate our MTU size */
                            if mtu > ((*chk).send_size as libc::c_uint).wrapping_add(dmtu) {
                                mtu = mtu.wrapping_sub(
                                    ((*chk).send_size as libc::c_uint).wrapping_add(dmtu),
                                )
                            } else {
                                mtu = 0u32
                            }
                            let fresh36 = bundle_at;
                            bundle_at = bundle_at + 1;
                            data_list[fresh36 as usize] = chk;
                            if one_chunk != 0 && (*asoc).total_flight <= 0u32 {
                                ::std::intrinsics::atomic_xadd(
                                    &mut system_base_info.sctpstat.sctps_windowprobed,
                                    1u32,
                                );
                            }
                        }
                        if one_chunk == 0i32 {
                            /*
                             * now are there anymore forward from chk to pick
                             * up?
                             */
                            fwd = (*chk).sctp_next.tqe_next;
                            while !fwd.is_null() {
                                if !((*fwd).sent != 4i32) {
                                    if !((*fwd).whoTo != net) {
                                        if data_auth_reqd != 0 && auth.is_null() {
                                            dmtu =
                                                sctp_get_auth_chunk_len((*stcb).asoc.peer_hmac_id)
                                        } else {
                                            dmtu = 0u32
                                        }
                                        if !((*fwd).send_size as libc::c_uint
                                            <= mtu.wrapping_sub(dmtu))
                                        {
                                            break;
                                        }
                                        if data_auth_reqd != 0 {
                                            if auth.is_null() {
                                                m = sctp_add_auth_chunk(
                                                    m,
                                                    &mut endofchain,
                                                    &mut auth,
                                                    &mut auth_offset,
                                                    stcb,
                                                    0u8,
                                                );
                                                auth_keyid = (*fwd).auth_keyid;
                                                override_ok = 0i32;
                                                ::std::intrinsics::atomic_xadd(
                                                    &mut system_base_info
                                                        .sctpstat
                                                        .sctps_outcontrolchunks,
                                                    1u32,
                                                );
                                            } else if override_ok != 0 {
                                                auth_keyid = (*fwd).auth_keyid;
                                                override_ok = 0i32
                                            } else if (*fwd).auth_keyid as libc::c_int
                                                != auth_keyid as libc::c_int
                                            {
                                                /* different keyid, so done bundling */
                                                break;
                                            }
                                        }
                                        m = sctp_copy_mbufchain(
                                            (*fwd).data,
                                            m,
                                            &mut endofchain,
                                            0i32,
                                            (*fwd).send_size as libc::c_int,
                                            (*fwd).copy_by_ref,
                                        );
                                        if m.is_null() {
                                            return 12i32;
                                        }
                                        /* Do clear IP_DF ? */
                                        if (*fwd).flags as libc::c_int & 0x100i32 != 0 {
                                            no_fragmentflg = 0i32
                                        }
                                        /* upate our MTU size */
                                        if mtu
                                            > ((*fwd).send_size as libc::c_uint).wrapping_add(dmtu)
                                        {
                                            mtu = mtu.wrapping_sub(
                                                ((*fwd).send_size as libc::c_uint)
                                                    .wrapping_add(dmtu),
                                            )
                                        } else {
                                            mtu = 0u32
                                        }
                                        let fresh37 = bundle_at;
                                        bundle_at = bundle_at + 1;
                                        data_list[fresh37 as usize] = fwd;
                                        if bundle_at >= 256i32 {
                                            break;
                                        }
                                    }
                                }
                                /* Nope, not the net in question */
                                fwd = (*fwd).sctp_next.tqe_next
                            }
                        }
                        /* Is there something to send for this destination? */
                        if !m.is_null() {
                            let mut tsns_sent = 0u32;
                            if (*net).rxt_timer.timer.c_flags & 0x4i32 == 0 {
                                /*
                                 * no timer running on this destination
                                 * restart it.
                                 */
                                sctp_timer_start(1i32, inp, stcb, net);
                                tmr_started = 1i32
                            }
                            /* Now lets send it, if there is anything to send :> */
                            error = sctp_lowlevel_chunk_output(
                                inp,
                                stcb,
                                net,
                                &mut (*net).ro._l_addr as *mut sctp_sockstore as *mut sockaddr,
                                m,
                                auth_offset,
                                auth,
                                auth_keyid,
                                no_fragmentflg,
                                0i32,
                                0i32,
                                (*inp).ip_inp.inp.inp_inc.inc_ie.ie_lport,
                                (*stcb).rport,
                                htonl((*stcb).asoc.peer_vtag),
                                (*net).port,
                                0 as *mut sctp_sockstore,
                                so_locked,
                            );
                            if error != 0 {
                                /* error, we could not output */
                                if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
                                    if system_base_info.debug_printf.is_some() {
                                        system_base_info
                                            .debug_printf
                                            .expect("non-null function pointer")(
                                            b"Gak send error %d\n\x00" as *const u8
                                                as *const libc::c_char,
                                            error,
                                        );
                                    }
                                }
                                if error == 105i32 {
                                    (*asoc).ifp_had_enobuf = 1u8;
                                    ::std::intrinsics::atomic_xadd(
                                        &mut system_base_info.sctpstat.sctps_lowlevelerr,
                                        1u32,
                                    );
                                }
                                return error;
                            } else {
                                (*asoc).ifp_had_enobuf = 0u8
                            }
                            endofchain = 0 as *mut mbuf;
                            auth = 0 as *mut sctp_auth_chunk;
                            auth_offset = 0u32;
                            /* For HB's */
                            /*
                             * We don't want to mark the net->sent time here
                             * since this we use this for HB and retrans cannot
                             * measure RTT
                             */
                            /* (void)SCTP_GETTIME_TIMEVAL(&net->last_sent_time); */
                            /* For auto-close */
                            cnt_thru += 1;
                            if *now_filled == 0i32 {
                                gettimeofday(&mut (*asoc).time_last_sent, 0 as *mut timezone);
                                *now = (*asoc).time_last_sent;
                                *now_filled = 1i32
                            } else {
                                (*asoc).time_last_sent = *now
                            }
                            *cnt_out += bundle_at;
                            if bundle_at != 0 {
                                tsns_sent = (*data_list[0usize]).rec.data.tsn
                            }

                            for i in 0i32..bundle_at {
                                ::std::intrinsics::atomic_xadd(
                                    &mut system_base_info.sctpstat.sctps_sendretransdata,
                                    1u32,
                                );

                                (*data_list[i as usize]).sent = 1i32;
                                /*
                                 * When we have a revoked data, and we
                                 * retransmit it, then we clear the revoked
                                 * flag since this flag dictates if we
                                 * subtracted from the fs
                                 */
                                if (*data_list[i as usize]).rec.data.chunk_was_revoked != 0 {
                                    /* Deflate the cwnd */
                                    (*(*data_list[i as usize]).whoTo).cwnd =
                                        ((*(*data_list[i as usize]).whoTo).cwnd).wrapping_sub(
                                            (*data_list[i as usize]).book_size as libc::c_uint,
                                        );
                                    (*data_list[i as usize]).rec.data.chunk_was_revoked = 0u8
                                }

                                (*data_list[i as usize]).snd_count =
                                    (*data_list[i as usize]).snd_count.wrapping_add(1);

                                if (*asoc).sent_queue_retran_cnt > 0u32 {
                                    (*asoc).sent_queue_retran_cnt =
                                        (*asoc).sent_queue_retran_cnt.wrapping_sub(1)
                                } else {
                                    (*asoc).sent_queue_retran_cnt = 0u32
                                }
                                /* record the time */
                                (*data_list[i as usize]).sent_rcv_time = (*asoc).time_last_sent;

                                if (*data_list[i as usize]).book_size_scale != 0 {
                                    /*
                                     * need to double the book size on
                                     * this one
                                     */
                                    (*data_list[i as usize]).book_size_scale = 0u8;
                                    /* Since we double the booksize, we must
                                     * also double the output queue size, since this
                                     * get shrunk when we free by this amount.
                                     */
                                    ::std::intrinsics::atomic_xadd(
                                        &mut (*asoc).total_output_queue_size,
                                        (*data_list[i as usize]).book_size as uint32_t,
                                    );
                                    (*data_list[i as usize]).book_size =
                                        ((*data_list[i as usize]).book_size as libc::c_int * 2i32)
                                            as uint16_t
                                } else {
                                    if system_base_info.sctpsysctl.sctp_logging_level & 0x100000u32
                                        != 0
                                    {
                                        sctp_log_rwnd(
                                            37u8,
                                            (*asoc).peers_rwnd,
                                            (*data_list[i as usize]).send_size as uint32_t,
                                            system_base_info.sctpsysctl.sctp_peer_chunk_oh,
                                        );
                                    }
                                    (*asoc).peers_rwnd = if (*asoc).peers_rwnd
                                        > ((*data_list[i as usize]).send_size as libc::c_uint)
                                            .wrapping_add(
                                                system_base_info.sctpsysctl.sctp_peer_chunk_oh,
                                            ) {
                                        (*asoc).peers_rwnd.wrapping_sub(
                                            ((*data_list[i as usize]).send_size as libc::c_uint)
                                                .wrapping_add(
                                                    system_base_info.sctpsysctl.sctp_peer_chunk_oh,
                                                ),
                                        )
                                    } else {
                                        0u32
                                    }
                                }

                                if system_base_info.sctpsysctl.sctp_logging_level & 0x20u32 != 0 {
                                    sctp_misc_ints(
                                        111u8,
                                        (*(*data_list[i as usize]).whoTo).flight_size,
                                        (*data_list[i as usize]).book_size as uint32_t,
                                        (*data_list[i as usize]).whoTo as uint32_t,
                                        (*data_list[i as usize]).rec.data.tsn,
                                    );
                                }

                                (*(*data_list[i as usize]).whoTo).flight_size =
                                    ((*(*data_list[i as usize]).whoTo).flight_size).wrapping_add(
                                        (*data_list[i as usize]).book_size as libc::c_uint,
                                    );

                                (*stcb).asoc.total_flight_count =
                                    (*stcb).asoc.total_flight_count.wrapping_add(1);

                                (*stcb).asoc.total_flight = (*stcb).asoc.total_flight.wrapping_add(
                                    (*data_list[i as usize]).book_size as libc::c_uint,
                                );

                                if (*asoc).peers_rwnd < (*(*stcb).sctp_ep).sctp_ep.sctp_sws_sender {
                                    /* SWS sender side engages */
                                    (*asoc).peers_rwnd = 0u32
                                }

                                if i == 0i32
                                    && (*data_list[i as usize]).rec.data.doing_fast_retransmit
                                        as libc::c_int
                                        != 0
                                {
                                    ::std::intrinsics::atomic_xadd(
                                        &mut system_base_info.sctpstat.sctps_sendfastretrans,
                                        1u32,
                                    );
                                    if data_list[i as usize] == (*asoc).sent_queue.tqh_first
                                        && tmr_started == 0i32
                                    {
                                        /*-
                                         * ok we just fast-retrans'd
                                         * the lowest TSN, i.e the
                                         * first on the list. In
                                         * this case we want to give
                                         * some more time to get a
                                         * SACK back without a
                                         * t3-expiring.
                                         */
                                        sctp_timer_stop(
                                            1i32,
                                            inp,
                                            stcb,
                                            net,
                                            (0x90000000u32).wrapping_add(0x2u32),
                                        );
                                        sctp_timer_start(1i32, inp, stcb, net);
                                    }
                                }
                            }
                            if system_base_info.sctpsysctl.sctp_logging_level & 0x4u32 != 0 {
                                sctp_log_cwnd(stcb, net, tsns_sent as libc::c_int, 66u8);
                            }
                        } else {
                            /* None will fit */
                            return 1i32;
                        }
                        if (*asoc).sent_queue_retran_cnt <= 0u32 {
                            /* all done we have no more to retran */
                            (*asoc).sent_queue_retran_cnt = 0u32;
                            break;
                        } else {
                            if one_chunk != 0 {
                                /* No more room in rwnd */
                                return 1i32;
                            }
                            break;
                        }
                    }
                }
            }
        }
        /* No, not sent to this net or not ready for rtx */
        chk = (*chk).sctp_next.tqe_next
    }
    return 0i32;
}
unsafe extern "C" fn sctp_timer_validation(
    mut inp: *mut sctp_inpcb,
    mut stcb: *mut sctp_tcb,
    mut asoc: *mut sctp_association,
) {
    let mut net = 0 as *mut sctp_nets;
    /* Validate that a timer is running somewhere */
    net = (*asoc).nets.tqh_first;
    while !net.is_null() {
        if (*net).rxt_timer.timer.c_flags & 0x4i32 != 0 {
            /* Here is a timer */
            return;
        }
        net = (*net).sctp_next.tqe_next
    }
    /* Gak, we did not have a timer somewhere */
    if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"Deadlock avoided starting timer on a dest at retran\n\x00" as *const u8
                    as *const libc::c_char,
            );
        }
    }
    if !(*asoc).alternate.is_null() {
        sctp_timer_start(1i32, inp, stcb, (*asoc).alternate);
    } else {
        sctp_timer_start(1i32, inp, stcb, (*asoc).primary_destination);
    };
}
#[no_mangle]
pub unsafe extern "C" fn sctp_chunk_output(
    mut inp: *mut sctp_inpcb,
    mut stcb: *mut sctp_tcb,
    mut from_where: libc::c_int,
    mut so_locked: libc::c_int,
) {
    let mut asoc = 0 as *mut sctp_association;
    let mut frag_point = sctp_get_frag_point(stcb, &mut (*stcb).asoc);

    asoc = &mut (*stcb).asoc;
    loop {
        let mut net = 0 as *mut sctp_nets;
        let mut num_out = 0;
        let mut tot_out = 0i32;
        let mut reason_code = 0;
        let mut burst_cnt = 0u32;
        let mut now = timeval {
            tv_sec: 0,
            tv_usec: 0,
        };
        let mut now_filled = 0i32;
        let mut nagle_on = 0;
        let mut un_sent = 0i32;
        if from_where == 0i32 {
            if (*inp).sctp_features & 0x100u64 == 0x100u64 {
                nagle_on = 0i32
            } else {
                nagle_on = 1i32
            }
        } else {
            nagle_on = 0i32
        }
        un_sent = (*stcb)
            .asoc
            .total_output_queue_size
            .wrapping_sub((*stcb).asoc.total_flight) as libc::c_int;
        if un_sent <= 0i32
            && (*asoc).control_send_queue.tqh_first.is_null()
            && (*asoc).asconf_send_queue.tqh_first.is_null()
            && (*asoc).sent_queue_retran_cnt == 0u32
            && (*asoc).trigger_reset as libc::c_int == 0i32
        {
            /* Nothing to do unless there is something to be sent left */
            return;
        }
        /* Do we have something to send, data or control AND
         * a sack timer running, if so piggy-back the sack.
         */
        if (*stcb).asoc.dack_timer.timer.c_flags & 0x4i32 != 0 {
            sctp_send_sack(stcb, so_locked);
            sctp_os_timer_stop(&mut (*stcb).asoc.dack_timer.timer);
        }
        while (*asoc).sent_queue_retran_cnt != 0 {
            let mut ret = 0i32;
            let mut tot_frs = 0u32;
            if from_where == 14i32 {
                /*-
                 * Special hook for handling cookiess discarded
                 * by peer that carried data. Send cookie-ack only
                 * and then the next call with get the retran's.
                 */
                sctp_med_chunk_output(
                    inp,
                    stcb,
                    asoc,
                    &mut num_out,
                    &mut reason_code,
                    1i32,
                    from_where,
                    &mut now,
                    &mut now_filled,
                    frag_point,
                    so_locked,
                );
                return;
            } else {
                if from_where != 6i32 {
                    let mut fr_done = 0;
                    fr_done = 0i32;
                    ret = sctp_chunk_retransmission(
                        inp,
                        stcb,
                        asoc,
                        &mut num_out,
                        &mut now,
                        &mut now_filled,
                        &mut fr_done,
                        so_locked,
                    );
                    if fr_done != 0 {
                        tot_frs = tot_frs.wrapping_add(1)
                    }
                } else {
                    /*
                     * its from any other place, we don't allow retran
                     * output (only control)
                     */
                    ret = 1i32
                }
            }
            if ret > 0i32 {
                /* Can't send anymore */
                /*-
                 * now lets push out control by calling med-level
                 * output once. this assures that we WILL send HB's
                 * if queued too.
                 */
                sctp_med_chunk_output(
                    inp,
                    stcb,
                    asoc,
                    &mut num_out,
                    &mut reason_code,
                    1i32,
                    from_where,
                    &mut now,
                    &mut now_filled,
                    frag_point,
                    so_locked,
                );
                sctp_timer_validation(inp, stcb, asoc);
                return;
            }
            if ret < 0i32 {
                /*-
                 * The count was off.. retran is not happening so do
                 * the normal retransmission.
                 */
                if ret == -(2i32) {
                    return;
                }
                break;
            } else {
                if from_where == 1i32 {
                    /* Only one transmission allowed out of a timeout */
                    /* Push out any control */
                    sctp_med_chunk_output(
                        inp,
                        stcb,
                        asoc,
                        &mut num_out,
                        &mut reason_code,
                        1i32,
                        from_where,
                        &mut now,
                        &mut now_filled,
                        frag_point,
                        so_locked,
                    );
                    return;
                }
                if (*asoc).fr_max_burst > 0u32 && tot_frs >= (*asoc).fr_max_burst {
                    /* Hit FR burst limit */
                    return;
                }
                if num_out == 0i32 && ret == 0i32 {
                    break;
                }
            }
        }
        /* Check for bad destinations, if they exist move chunks around. */
        net = (*asoc).nets.tqh_first;
        while !net.is_null() {
            if (*net).dest_state as libc::c_int & 0x1i32 == 0 {
                /*-
                 * if possible move things off of this address we
                 * still may send below due to the dormant state but
                 * we try to find an alternate address to send to
                 * and if we have one we move all queued data on the
                 * out wheel to this alternate address.
                 */
                if (*net).ref_count > 1i32 {
                    sctp_move_chunks_from_net(stcb, net);
                }
            } else if (*asoc).max_burst > 0u32 {
                if system_base_info.sctpsysctl.sctp_use_cwnd_based_maxburst != 0 {
                    if (*net)
                        .flight_size
                        .wrapping_add((*asoc).max_burst.wrapping_mul((*net).mtu))
                        < (*net).cwnd
                    {
                        /*-
                         * if ((asoc->sat_network) || (net->addr_is_local))
                         * { burst_limit = asoc->max_burst *
                         * SCTP_SAT_NETWORK_BURST_INCR; }
                         */
                        /* JRS - Use the congestion control given in the congestion control module */
                        (*asoc)
                            .cc_functions
                            .sctp_cwnd_update_after_output
                            .expect("non-null function pointer")(
                            stcb,
                            net,
                            (*asoc).max_burst as libc::c_int,
                        );
                        if system_base_info.sctpsysctl.sctp_logging_level & 0x80000u32 != 0 {
                            sctp_log_maxburst(
                                stcb,
                                net,
                                0i32,
                                (*asoc).max_burst as libc::c_int,
                                33u8,
                            );
                        }
                        ::std::intrinsics::atomic_xadd(
                            &mut system_base_info.sctpstat.sctps_maxburstqueued,
                            1u32,
                        );
                    }
                    (*net).fast_retran_ip = 0u8
                } else {
                    ((*net).flight_size) == 0u32;
                }
            }
            net = (*net).sctp_next.tqe_next
        }
        burst_cnt = 0u32;
        loop {
            let mut error = 0i32;
            error = sctp_med_chunk_output(
                inp,
                stcb,
                asoc,
                &mut num_out,
                &mut reason_code,
                0i32,
                from_where,
                &mut now,
                &mut now_filled,
                frag_point,
                so_locked,
            );
            if error != 0 {
                if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
                    if system_base_info.debug_printf.is_some() {
                        system_base_info
                            .debug_printf
                            .expect("non-null function pointer")(
                            b"Error %d was returned from med-c-op\n\x00" as *const u8
                                as *const libc::c_char,
                            error,
                        );
                    }
                }
                if system_base_info.sctpsysctl.sctp_logging_level & 0x80000u32 != 0 {
                    sctp_log_maxburst(
                        stcb,
                        (*asoc).primary_destination,
                        error,
                        burst_cnt as libc::c_int,
                        35u8,
                    );
                }
                if system_base_info.sctpsysctl.sctp_logging_level & 0x4u32 != 0 {
                    sctp_log_cwnd(stcb, 0 as *mut sctp_nets, error, 68u8);
                    sctp_log_cwnd(
                        stcb,
                        0 as *mut sctp_nets,
                        0xdeadbeefu32 as libc::c_int,
                        68u8,
                    );
                }
                break;
            } else {
                if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
                    if system_base_info.debug_printf.is_some() {
                        system_base_info
                            .debug_printf
                            .expect("non-null function pointer")(
                            b"m-c-o put out %d\n\x00" as *const u8 as *const libc::c_char,
                            num_out,
                        );
                    }
                }
                tot_out += num_out;
                burst_cnt = burst_cnt.wrapping_add(1);
                if system_base_info.sctpsysctl.sctp_logging_level & 0x4u32 != 0 {
                    sctp_log_cwnd(stcb, 0 as *mut sctp_nets, num_out, 68u8);
                    if num_out == 0i32 {
                        sctp_log_cwnd(stcb, 0 as *mut sctp_nets, reason_code, 68u8);
                    }
                }
                if nagle_on != 0 {
                    /*
                     * When the Nagle algorithm is used, look at how much
                     * is unsent, then if its smaller than an MTU and we
                     * have data in flight we stop, except if we are
                     * handling a fragmented user message.
                     */
                    un_sent = (*stcb)
                        .asoc
                        .total_output_queue_size
                        .wrapping_sub((*stcb).asoc.total_flight)
                        as libc::c_int;
                    if un_sent
                        < ((*stcb).asoc.smallest_mtu as libc::c_ulong).wrapping_sub(
                            (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
                                .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong),
                        ) as libc::c_int
                        && (*stcb).asoc.total_flight > 0u32
                    {
                        /*	&&		     sctp_is_feature_on(inp, SCTP_PCB_FLAGS_EXPLICIT_EOR))) {*/
                        break;
                    }
                }
                if (*asoc).control_send_queue.tqh_first.is_null()
                    && (*asoc).send_queue.tqh_first.is_null()
                    && sctp_is_there_unsent_data(stcb, so_locked) == 0i32
                {
                    /* Nothing left to send */
                    break;
                } else {
                    if (*stcb)
                        .asoc
                        .total_output_queue_size
                        .wrapping_sub((*stcb).asoc.total_flight)
                        <= 0u32
                    {
                        break;
                    }
                    if !(num_out != 0
                        && ((*asoc).max_burst == 0u32
                            || system_base_info.sctpsysctl.sctp_use_cwnd_based_maxburst != 0
                            || burst_cnt < (*asoc).max_burst))
                    {
                        break;
                    }
                }
            }
        }
        if system_base_info.sctpsysctl.sctp_use_cwnd_based_maxburst == 0u32 {
            if (*asoc).max_burst > 0u32 && burst_cnt >= (*asoc).max_burst {
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctpstat.sctps_maxburstqueued,
                    1u32,
                );
                (*asoc).burst_limit_applied = 1u8;
                if system_base_info.sctpsysctl.sctp_logging_level & 0x80000u32 != 0 {
                    sctp_log_maxburst(
                        stcb,
                        (*asoc).primary_destination,
                        0i32,
                        burst_cnt as libc::c_int,
                        33u8,
                    );
                }
            } else {
                (*asoc).burst_limit_applied = 0u8
            }
        }
        if system_base_info.sctpsysctl.sctp_logging_level & 0x4u32 != 0 {
            sctp_log_cwnd(stcb, 0 as *mut sctp_nets, tot_out, 68u8);
        }
        if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"Ok, we have put out %d chunks\n\x00" as *const u8 as *const libc::c_char,
                    tot_out,
                );
            }
        }
        /*-
         * Now we need to clean up the control chunk chain if a ECNE is on
         * it. It must be marked as UNSENT again so next call will continue
         * to send it until such time that we get a CWR, to remove it.
         */
        if (*stcb).asoc.ecn_echo_cnt_onq != 0 {
            sctp_fix_ecn_echo(asoc);
        }
        if !((*stcb).asoc.trigger_reset != 0) {
            break;
        }
        if !(sctp_send_stream_reset_out_if_possible(stcb, so_locked) == 0i32) {
            break;
        }
    }
}
/* sctp_output is called bu sctp_sendm. Not using sctp_sendm for __Userspace__ */
#[no_mangle]
pub unsafe extern "C" fn sctp_output(
    mut inp: *mut sctp_inpcb,
    mut m: *mut mbuf,
    mut addr: *mut sockaddr,
    mut control: *mut mbuf,
    mut p: *mut proc_0,
    mut flags: libc::c_int,
) -> libc::c_int {
    if inp.is_null() {
        return 22i32;
    }
    if (*inp).sctp_socket.is_null() {
        return 22i32;
    }
    return sctp_sosend(
        (*inp).sctp_socket,
        addr,
        0 as *mut uio,
        m,
        control,
        flags,
        p,
    );
}
#[no_mangle]
pub unsafe extern "C" fn send_forward_tsn(
    mut stcb: *mut sctp_tcb,
    mut asoc: *mut sctp_association,
) {
    let mut current_block: u64;
    let mut chk = 0 as *mut sctp_tmit_chunk;
    let mut at = 0 as *mut sctp_tmit_chunk;
    let mut fwdtsn = 0 as *mut sctp_forward_tsn_chunk;
    let mut strseq = 0 as *mut sctp_strseq;
    let mut strseq_m = 0 as *mut sctp_strseq_mid;
    let mut advance_peer_ack_point = 0;
    let mut cnt_of_space = 0;
    let mut i = 0;
    let mut ovh = 0;
    let mut space_needed = 0;
    let mut cnt_of_skipped = 0u32;
    chk = (*asoc).control_send_queue.tqh_first;
    loop {
        if chk.is_null() {
            current_block = 13460095289871124136;
            break;
        }
        if (*chk).rec.chunk_id.id as libc::c_int == 0xc0i32 {
            /* mark it to unsent */
            (*chk).sent = 0i32;
            (*chk).snd_count = 0u16;
            /* Do we correct its output location? */
            if !(*chk).whoTo.is_null() {
                if !(*chk).whoTo.is_null() {
                    if ::std::intrinsics::atomic_xadd(
                        &mut (*(*chk).whoTo).ref_count as *mut libc::c_int,
                        -(1i32),
                    ) == 1i32
                    {
                        sctp_os_timer_stop(&mut (*(*chk).whoTo).rxt_timer.timer);
                        sctp_os_timer_stop(&mut (*(*chk).whoTo).pmtu_timer.timer);
                        sctp_os_timer_stop(&mut (*(*chk).whoTo).hb_timer.timer);
                        if !(*(*chk).whoTo).ro.ro_rt.is_null() {
                            if (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt <= 1i64 {
                                sctp_userspace_rtfree((*(*chk).whoTo).ro.ro_rt);
                            } else {
                                (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt -= 1
                            }
                            (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t;
                            (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t
                        }
                        if (*(*chk).whoTo).src_addr_selected != 0 {
                            sctp_free_ifa((*(*chk).whoTo).ro._s_addr);
                            (*(*chk).whoTo).ro._s_addr = 0 as *mut sctp_ifa
                        }
                        (*(*chk).whoTo).src_addr_selected = 0u8;
                        (*(*chk).whoTo).dest_state =
                            ((*(*chk).whoTo).dest_state as libc::c_int & !(0x1i32)) as uint16_t;
                        free((*chk).whoTo as *mut libc::c_void);
                        ::std::intrinsics::atomic_xsub(
                            &mut system_base_info.sctppcbinfo.ipi_count_raddr,
                            1u32,
                        );
                    }
                }
                (*chk).whoTo = 0 as *mut sctp_nets
            }
            current_block = 4774323986390963515;
            break;
        } else {
            chk = (*chk).sctp_next.tqe_next
        }
    }
    match current_block {
        13460095289871124136 => {
            /* Ok if we reach here we must build one */
            if (*stcb).asoc.free_chunks.tqh_first.is_null() {
                chk = malloc(system_base_info.sctppcbinfo.ipi_zone_chunk) as *mut sctp_tmit_chunk;
                if !chk.is_null() {
                    ::std::intrinsics::atomic_xadd(
                        &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                        1u32,
                    );
                    (*chk).whoTo = 0 as *mut sctp_nets;
                    (*chk).holds_key_ref = 0u8
                }
            } else {
                chk = (*stcb).asoc.free_chunks.tqh_first;
                if !(*chk).sctp_next.tqe_next.is_null() {
                    (*(*chk).sctp_next.tqe_next).sctp_next.tqe_prev = (*chk).sctp_next.tqe_prev
                } else {
                    (*stcb).asoc.free_chunks.tqh_last = (*chk).sctp_next.tqe_prev
                }
                *(*chk).sctp_next.tqe_prev = (*chk).sctp_next.tqe_next;
                ::std::intrinsics::atomic_xsub(
                    &mut system_base_info.sctppcbinfo.ipi_free_chunks,
                    1u32,
                );
                (*chk).holds_key_ref = 0u8;
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctpstat.sctps_cached_chk,
                    1u32,
                );
                (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_sub(1)
            }
            if chk.is_null() {
                return;
            }
            (*asoc).fwd_tsn_cnt = (*asoc).fwd_tsn_cnt.wrapping_add(1);
            (*chk).copy_by_ref = 0u8;
            /*
             * We don't do the old thing here since
             * this is used not for on-wire but to
             * tell if we are sending a fwd-tsn by
             * the stack during output. And if its
             * a IFORWARD or a FORWARD it is a fwd-tsn.
             */
            (*chk).rec.chunk_id.id = 0xc0u8;
            (*chk).rec.chunk_id.can_take_data = 0u8;
            (*chk).flags = 0u16;
            (*chk).asoc = asoc;
            (*chk).whoTo = 0 as *mut sctp_nets;
            (*chk).data = sctp_get_mbuf_for_msg(2048u32, 0i32, 0x1i32, 1i32, 1i32);
            if (*chk).data.is_null() {
                if (*chk).holds_key_ref != 0 {
                    sctp_auth_key_release(stcb, (*chk).auth_keyid, 0i32);
                    (*chk).holds_key_ref = 0u8
                }
                if !stcb.is_null() {
                    if !(*chk).whoTo.is_null() {
                        if !(*chk).whoTo.is_null() {
                            if ::std::intrinsics::atomic_xadd(
                                &mut (*(*chk).whoTo).ref_count as *mut libc::c_int,
                                -(1i32),
                            ) == 1i32
                            {
                                sctp_os_timer_stop(&mut (*(*chk).whoTo).rxt_timer.timer);
                                sctp_os_timer_stop(&mut (*(*chk).whoTo).pmtu_timer.timer);
                                sctp_os_timer_stop(&mut (*(*chk).whoTo).hb_timer.timer);
                                if !(*(*chk).whoTo).ro.ro_rt.is_null() {
                                    if (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt <= 1i64 {
                                        sctp_userspace_rtfree((*(*chk).whoTo).ro.ro_rt);
                                    } else {
                                        (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt -= 1
                                    }
                                    (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t;
                                    (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t
                                }
                                if (*(*chk).whoTo).src_addr_selected != 0 {
                                    sctp_free_ifa((*(*chk).whoTo).ro._s_addr);
                                    (*(*chk).whoTo).ro._s_addr = 0 as *mut sctp_ifa
                                }
                                (*(*chk).whoTo).src_addr_selected = 0u8;
                                (*(*chk).whoTo).dest_state =
                                    ((*(*chk).whoTo).dest_state as libc::c_int & !(0x1i32))
                                        as uint16_t;
                                free((*chk).whoTo as *mut libc::c_void);
                                ::std::intrinsics::atomic_xsub(
                                    &mut system_base_info.sctppcbinfo.ipi_count_raddr,
                                    1u32,
                                );
                            }
                        }
                        (*chk).whoTo = 0 as *mut sctp_nets
                    }
                    if (*stcb).asoc.free_chunk_cnt as libc::c_uint
                        > system_base_info.sctpsysctl.sctp_asoc_free_resc_limit
                        || system_base_info.sctppcbinfo.ipi_free_chunks
                            > system_base_info.sctpsysctl.sctp_system_free_resc_limit
                    {
                        free(chk as *mut libc::c_void);
                        ::std::intrinsics::atomic_xsub(
                            &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                            1u32,
                        );
                    } else {
                        (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
                        (*chk).sctp_next.tqe_prev = (*stcb).asoc.free_chunks.tqh_last;
                        *(*stcb).asoc.free_chunks.tqh_last = chk;
                        (*stcb).asoc.free_chunks.tqh_last = &mut (*chk).sctp_next.tqe_next;
                        (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_add(1);
                        ::std::intrinsics::atomic_xadd(
                            &mut system_base_info.sctppcbinfo.ipi_free_chunks,
                            1u32,
                        );
                    }
                } else {
                    free(chk as *mut libc::c_void);
                    ::std::intrinsics::atomic_xsub(
                        &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                        1u32,
                    );
                }
                return;
            }
            (*(*chk).data).m_hdr.mh_data = (*(*chk).data).m_hdr.mh_data.offset(
                (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
                    .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong)
                    as isize,
            );
            (*chk).sent = 0i32;
            (*chk).snd_count = 0u16;
            (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
            (*chk).sctp_next.tqe_prev = (*asoc).control_send_queue.tqh_last;
            *(*asoc).control_send_queue.tqh_last = chk;
            (*asoc).control_send_queue.tqh_last = &mut (*chk).sctp_next.tqe_next;
            (*asoc).ctrl_queue_cnt += 1
        }
        _ => {}
    }
    /*-
     * Here we go through and fill out the part that deals with
     * stream/seq of the ones we skip.
     */
    (*(*chk).data).m_hdr.mh_len = 0i32;
    at = (*asoc).sent_queue.tqh_first;
    while !at.is_null() {
        if (*at).sent != 30010i32 && (*at).sent != 40010i32 {
            break;
        }
        if !((*asoc).idata_supported == 0 && (*at).rec.data.rcv_flags as libc::c_int & 0x4i32 != 0)
        {
            cnt_of_skipped = cnt_of_skipped.wrapping_add(1)
        }
        /* We don't report these */
        at = (*at).sctp_next.tqe_next
    }
    if (*asoc).idata_supported != 0 {
        space_needed = (::std::mem::size_of::<sctp_forward_tsn_chunk>() as libc::c_ulong)
            .wrapping_add(
                (cnt_of_skipped as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<sctp_strseq_mid>() as libc::c_ulong),
            ) as libc::c_uint
    } else {
        space_needed = (::std::mem::size_of::<sctp_forward_tsn_chunk>() as libc::c_ulong)
            .wrapping_add(
                (cnt_of_skipped as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<sctp_strseq>() as libc::c_ulong),
            ) as libc::c_uint
    }
    cnt_of_space = if (*(*chk).data).m_hdr.mh_flags & 0x1i32 != 0 {
        if (*(*chk).data).m_hdr.mh_flags & 0x8i32 == 0
            && ((*(*chk).data).m_hdr.mh_flags & 0x1i32 == 0
                || *(*(*chk).data).M_dat.MH.MH_dat.MH_ext.ref_cnt == 1u32)
        {
            (*(*chk).data)
                .M_dat
                .MH
                .MH_dat
                .MH_ext
                .ext_buf
                .offset((*(*chk).data).M_dat.MH.MH_dat.MH_ext.ext_size as isize)
                .wrapping_offset_from(
                    (*(*chk).data)
                        .m_hdr
                        .mh_data
                        .offset((*(*chk).data).m_hdr.mh_len as isize),
                ) as libc::c_long
        } else {
            0i64
        }
    } else {
        (&mut *(*(*chk).data).M_dat.M_databuf.as_mut_ptr().offset(
            (256u64).wrapping_sub(::std::mem::size_of::<m_hdr>() as libc::c_ulong) as libc::c_int
                as isize,
        ) as *mut libc::c_char)
            .wrapping_offset_from(
                (*(*chk).data)
                    .m_hdr
                    .mh_data
                    .offset((*(*chk).data).m_hdr.mh_len as isize),
            ) as libc::c_long
    } as libc::c_uint;
    if (*(*stcb).sctp_ep).sctp_flags & 0x4000000u32 != 0 {
        ovh = (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong)
            as libc::c_uint
    } else {
        ovh = (::std::mem::size_of::<ip>() as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong)
            as libc::c_uint
    }
    if cnt_of_space > (*asoc).smallest_mtu.wrapping_sub(ovh) {
        /* trim to a mtu size */
        cnt_of_space = (*asoc).smallest_mtu.wrapping_sub(ovh)
    }
    if system_base_info.sctpsysctl.sctp_logging_level & 0x10000000u32 != 0 {
        sctp_misc_ints(
            123u8,
            0xffu32,
            0u32,
            cnt_of_skipped,
            (*asoc).advanced_peer_ack_point,
        );
    }
    advance_peer_ack_point = (*asoc).advanced_peer_ack_point;
    if cnt_of_space < space_needed {
        let mut last = 0 as *mut sctp_tmit_chunk;
        if system_base_info.sctpsysctl.sctp_logging_level & 0x10000000u32 != 0 {
            sctp_misc_ints(123u8, 0xffu32, 0xffu32, cnt_of_space, space_needed);
        }
        cnt_of_skipped = (cnt_of_space as libc::c_ulong)
            .wrapping_sub(::std::mem::size_of::<sctp_forward_tsn_chunk>() as libc::c_ulong)
            as libc::c_uint;
        if (*asoc).idata_supported != 0 {
            cnt_of_skipped = (cnt_of_skipped as libc::c_ulong)
                .wrapping_div(::std::mem::size_of::<sctp_strseq_mid>() as libc::c_ulong)
                as libc::c_uint
        } else {
            cnt_of_skipped = (cnt_of_skipped as libc::c_ulong)
                .wrapping_div(::std::mem::size_of::<sctp_strseq>() as libc::c_ulong)
                as libc::c_uint
        }
        /*-
         * Go through and find the TSN that will be the one
         * we report.
         */
        at = (*asoc).sent_queue.tqh_first;
        if !at.is_null() {
            i = 0u32;
            while i < cnt_of_skipped {
                let mut tp1 = 0 as *mut sctp_tmit_chunk;
                tp1 = (*at).sctp_next.tqe_next;
                if tp1.is_null() {
                    break;
                }
                at = tp1;
                i = i.wrapping_add(1)
            }
        }
        if !at.is_null() && system_base_info.sctpsysctl.sctp_logging_level & 0x10000000u32 != 0 {
            sctp_misc_ints(
                123u8,
                0xffu32,
                cnt_of_skipped,
                (*at).rec.data.tsn,
                (*asoc).advanced_peer_ack_point,
            );
        }
        last = at;
        /*-
         * last now points to last one I can report, update
         * peer ack point
         */
        if !last.is_null() {
            advance_peer_ack_point = (*last).rec.data.tsn
        }
        if (*asoc).idata_supported != 0 {
            space_needed = (::std::mem::size_of::<sctp_forward_tsn_chunk>() as libc::c_ulong)
                .wrapping_add(
                    (cnt_of_skipped as libc::c_ulong)
                        .wrapping_mul(::std::mem::size_of::<sctp_strseq_mid>() as libc::c_ulong),
                ) as libc::c_uint
        } else {
            space_needed = (::std::mem::size_of::<sctp_forward_tsn_chunk>() as libc::c_ulong)
                .wrapping_add(
                    (cnt_of_skipped as libc::c_ulong)
                        .wrapping_mul(::std::mem::size_of::<sctp_strseq>() as libc::c_ulong),
                ) as libc::c_uint
        }
    }
    (*chk).send_size = space_needed as uint16_t;
    /* Setup the chunk */
    fwdtsn = (*(*chk).data).m_hdr.mh_data as *mut sctp_forward_tsn_chunk;
    (*fwdtsn).ch.chunk_length = htons((*chk).send_size);
    (*fwdtsn).ch.chunk_flags = 0u8;
    if (*asoc).idata_supported != 0 {
        (*fwdtsn).ch.chunk_type = 0xc2u8
    } else {
        (*fwdtsn).ch.chunk_type = 0xc0u8
    }
    (*fwdtsn).new_cumulative_tsn = htonl(advance_peer_ack_point);
    (*(*chk).data).m_hdr.mh_len = (*chk).send_size as libc::c_int;
    fwdtsn = fwdtsn.offset(1);
    /*-
     * Move pointer to after the fwdtsn and transfer to the
     * strseq pointer.
     */
    if (*asoc).idata_supported != 0 {
        strseq_m = fwdtsn as *mut sctp_strseq_mid;
        strseq = 0 as *mut sctp_strseq
    } else {
        strseq = fwdtsn as *mut sctp_strseq;
        strseq_m = 0 as *mut sctp_strseq_mid
    }
    /*-
     * Now populate the strseq list. This is done blindly
     * without pulling out duplicate stream info. This is
     * inefficent but won't harm the process since the peer will
     * look at these in sequence and will thus release anything.
     * It could mean we exceed the PMTU and chop off some that
     * we could have included.. but this is unlikely (aka 1432/4
     * would mean 300+ stream seq's would have to be reported in
     * one FWD-TSN. With a bit of work we can later FIX this to
     * optimize and pull out duplicates.. but it does add more
     * overhead. So for now... not!
     */
    i = 0u32;
    at = (*asoc).sent_queue.tqh_first;
    while !at.is_null() {
        if i >= cnt_of_skipped {
            break;
        }
        if !((*asoc).idata_supported == 0 && (*at).rec.data.rcv_flags as libc::c_int & 0x4i32 != 0)
        {
            if (*at).rec.data.tsn == advance_peer_ack_point {
                (*at).rec.data.fwd_tsn_cnt = 0u8
            }
            if (*asoc).idata_supported != 0 {
                (*strseq_m).sid = htons((*at).rec.data.sid);
                if (*at).rec.data.rcv_flags as libc::c_int & 0x4i32 != 0 {
                    (*strseq_m).flags = htons(0x1u16)
                } else {
                    (*strseq_m).flags = 0u16
                }
                (*strseq_m).mid = htonl((*at).rec.data.mid);
                strseq_m = strseq_m.offset(1)
            } else {
                (*strseq).sid = htons((*at).rec.data.sid);
                (*strseq).ssn = htons((*at).rec.data.mid as uint16_t);
                strseq = strseq.offset(1)
            }
            i = i.wrapping_add(1)
        }
        /* We don't report these */
        at = (*at).sctp_next.tqe_next
    }
}
#[no_mangle]
pub unsafe extern "C" fn sctp_send_sack(mut stcb: *mut sctp_tcb, mut so_locked: libc::c_int) {
    let mut asoc = 0 as *mut sctp_association;
    let mut chk = 0 as *mut sctp_tmit_chunk;
    let mut a_chk = 0 as *mut sctp_tmit_chunk;
    let mut sack = 0 as *mut sctp_sack_chunk;
    let mut nr_sack = 0 as *mut sctp_nr_sack_chunk;
    let mut gap_descriptor = 0 as *mut sctp_gap_ack_block;
    let mut selector = 0 as *const sack_track;
    let mut mergeable = 0i32;
    let mut offset = 0;
    let mut limit = 0 as *mut libc::c_char;
    let mut limit_reached = 0i32;
    let mut i = 0;
    let mut siz = 0;
    let mut j = 0;
    let mut num_gap_blocks = 0u32;
    let mut num_nr_gap_blocks = 0u32;
    let mut space = 0;
    let mut num_dups = 0i32;
    let mut space_req = 0;
    let mut highest_tsn = 0;
    let mut flags = 0;
    let mut type_0 = 0;
    let mut tsn_map = 0;
    if (*stcb).asoc.nrsack_supported as libc::c_int == 1i32 {
        type_0 = 0x10u8
    } else {
        type_0 = 0x3u8
    }
    a_chk = 0 as *mut sctp_tmit_chunk;
    asoc = &mut (*stcb).asoc;
    if (*asoc).last_data_chunk_from.is_null() {
        /* Hmm we never received anything */
        return;
    }
    sctp_slide_mapping_arrays(stcb);
    sctp_set_rwnd(stcb, asoc);
    chk = (*asoc).control_send_queue.tqh_first;
    while !chk.is_null() {
        if (*chk).rec.chunk_id.id as libc::c_int == type_0 as libc::c_int {
            /* Hmm, found a sack already on queue, remove it */
            if !(*chk).sctp_next.tqe_next.is_null() {
                (*(*chk).sctp_next.tqe_next).sctp_next.tqe_prev = (*chk).sctp_next.tqe_prev
            } else {
                (*asoc).control_send_queue.tqh_last = (*chk).sctp_next.tqe_prev
            }
            *(*chk).sctp_next.tqe_prev = (*chk).sctp_next.tqe_next;
            (*asoc).ctrl_queue_cnt -= 1;
            a_chk = chk;
            if !(*a_chk).data.is_null() {
                m_freem((*a_chk).data);
                (*a_chk).data = 0 as *mut mbuf
            }
            if !(*a_chk).whoTo.is_null() {
                if !(*a_chk).whoTo.is_null() {
                    if ::std::intrinsics::atomic_xadd(
                        &mut (*(*a_chk).whoTo).ref_count as *mut libc::c_int,
                        -(1i32),
                    ) == 1i32
                    {
                        sctp_os_timer_stop(&mut (*(*a_chk).whoTo).rxt_timer.timer);
                        sctp_os_timer_stop(&mut (*(*a_chk).whoTo).pmtu_timer.timer);
                        sctp_os_timer_stop(&mut (*(*a_chk).whoTo).hb_timer.timer);
                        if !(*(*a_chk).whoTo).ro.ro_rt.is_null() {
                            if (*(*(*a_chk).whoTo).ro.ro_rt).rt_refcnt <= 1i64 {
                                sctp_userspace_rtfree((*(*a_chk).whoTo).ro.ro_rt);
                            } else {
                                (*(*(*a_chk).whoTo).ro.ro_rt).rt_refcnt -= 1
                            }
                            (*(*a_chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t;
                            (*(*a_chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t
                        }
                        if (*(*a_chk).whoTo).src_addr_selected != 0 {
                            sctp_free_ifa((*(*a_chk).whoTo).ro._s_addr);
                            (*(*a_chk).whoTo).ro._s_addr = 0 as *mut sctp_ifa
                        }
                        (*(*a_chk).whoTo).src_addr_selected = 0u8;
                        (*(*a_chk).whoTo).dest_state =
                            ((*(*a_chk).whoTo).dest_state as libc::c_int & !(0x1i32)) as uint16_t;
                        free((*a_chk).whoTo as *mut libc::c_void);
                        ::std::intrinsics::atomic_xsub(
                            &mut system_base_info.sctppcbinfo.ipi_count_raddr,
                            1u32,
                        );
                    }
                }
                (*a_chk).whoTo = 0 as *mut sctp_nets
            }
            break;
        } else {
            chk = (*chk).sctp_next.tqe_next
        }
    }
    if a_chk.is_null() {
        if (*stcb).asoc.free_chunks.tqh_first.is_null() {
            a_chk = malloc(system_base_info.sctppcbinfo.ipi_zone_chunk) as *mut sctp_tmit_chunk;
            if !a_chk.is_null() {
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                    1u32,
                );
                (*a_chk).whoTo = 0 as *mut sctp_nets;
                (*a_chk).holds_key_ref = 0u8
            }
        } else {
            a_chk = (*stcb).asoc.free_chunks.tqh_first;
            if !(*a_chk).sctp_next.tqe_next.is_null() {
                (*(*a_chk).sctp_next.tqe_next).sctp_next.tqe_prev = (*a_chk).sctp_next.tqe_prev
            } else {
                (*stcb).asoc.free_chunks.tqh_last = (*a_chk).sctp_next.tqe_prev
            }
            *(*a_chk).sctp_next.tqe_prev = (*a_chk).sctp_next.tqe_next;
            ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_free_chunks, 1u32);
            (*a_chk).holds_key_ref = 0u8;
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_cached_chk, 1u32);
            (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_sub(1)
        }
        if a_chk.is_null() {
            /* No memory so we drop the idea, and set a timer */
            if (*stcb).asoc.delayed_ack != 0 {
                sctp_timer_stop(
                    3i32,
                    (*stcb).sctp_ep,
                    stcb,
                    0 as *mut sctp_nets,
                    (0x90000000u32).wrapping_add(0x3u32),
                );
                sctp_timer_start(3i32, (*stcb).sctp_ep, stcb, 0 as *mut sctp_nets);
            } else {
                (*stcb).asoc.send_sack = 1u8
            }
            return;
        }
        (*a_chk).copy_by_ref = 0u8;
        (*a_chk).rec.chunk_id.id = type_0;
        (*a_chk).rec.chunk_id.can_take_data = 1u8
    }
    /* Clear our pkt counts */
    (*asoc).data_pkts_seen = 0u32; /* fill in later */
    (*a_chk).flags = 0u16;
    (*a_chk).asoc = asoc;
    (*a_chk).snd_count = 0u16;
    (*a_chk).send_size = 0u16;
    (*a_chk).sent = 0i32;
    (*a_chk).whoTo = 0 as *mut sctp_nets;
    if (*(*asoc).last_data_chunk_from).dest_state as libc::c_int & 0x1i32 == 0 {
        /*-
         * Ok, the destination for the SACK is unreachable, lets see if
         * we can select an alternate to asoc->last_data_chunk_from
         */
        (*a_chk).whoTo = sctp_find_alternate_net(stcb, (*asoc).last_data_chunk_from, 0i32);
        if (*a_chk).whoTo.is_null() {
            /* Nope, no alternate */
            (*a_chk).whoTo = (*asoc).last_data_chunk_from
        }
    } else {
        (*a_chk).whoTo = (*asoc).last_data_chunk_from
    }
    if !(*a_chk).whoTo.is_null() {
        ::std::intrinsics::atomic_xadd(&mut (*(*a_chk).whoTo).ref_count, 1i32);
    }
    if (*asoc).highest_tsn_inside_map < (*asoc).highest_tsn_inside_nr_map
        && (*asoc)
            .highest_tsn_inside_nr_map
            .wrapping_sub((*asoc).highest_tsn_inside_map)
            > (1u32) << 31i32
        || (*asoc).highest_tsn_inside_map > (*asoc).highest_tsn_inside_nr_map
            && (*asoc)
                .highest_tsn_inside_map
                .wrapping_sub((*asoc).highest_tsn_inside_nr_map)
                < (1u32) << 31i32
    {
        highest_tsn = (*asoc).highest_tsn_inside_map
    } else {
        highest_tsn = (*asoc).highest_tsn_inside_nr_map
    }
    if highest_tsn == (*asoc).cumulative_tsn {
        /* no gaps */
        if type_0 as libc::c_int == 0x3i32 {
            space_req = ::std::mem::size_of::<sctp_sack_chunk>() as libc::c_int
        } else {
            space_req = ::std::mem::size_of::<sctp_nr_sack_chunk>() as libc::c_int
        }
    } else {
        /* gaps get a cluster */
        space_req = 2048i32
    }
    /* Ok now lets formulate a MBUF with our sack */
    (*a_chk).data = sctp_get_mbuf_for_msg(space_req as libc::c_uint, 0i32, 0x1i32, 1i32, 1i32);
    if (*a_chk).data.is_null() || (*a_chk).whoTo.is_null() {
        /* rats, no mbuf memory */
        if !(*a_chk).data.is_null() {
            /* was a problem with the destination */
            m_freem((*a_chk).data);
            (*a_chk).data = 0 as *mut mbuf
        }
        if (*a_chk).holds_key_ref != 0 {
            sctp_auth_key_release(stcb, (*a_chk).auth_keyid, so_locked);
            (*a_chk).holds_key_ref = 0u8
        }
        if !stcb.is_null() {
            if !(*a_chk).whoTo.is_null() {
                if !(*a_chk).whoTo.is_null() {
                    if ::std::intrinsics::atomic_xadd(
                        &mut (*(*a_chk).whoTo).ref_count as *mut libc::c_int,
                        -(1i32),
                    ) == 1i32
                    {
                        sctp_os_timer_stop(&mut (*(*a_chk).whoTo).rxt_timer.timer);
                        sctp_os_timer_stop(&mut (*(*a_chk).whoTo).pmtu_timer.timer);
                        sctp_os_timer_stop(&mut (*(*a_chk).whoTo).hb_timer.timer);
                        if !(*(*a_chk).whoTo).ro.ro_rt.is_null() {
                            if (*(*(*a_chk).whoTo).ro.ro_rt).rt_refcnt <= 1i64 {
                                sctp_userspace_rtfree((*(*a_chk).whoTo).ro.ro_rt);
                            } else {
                                (*(*(*a_chk).whoTo).ro.ro_rt).rt_refcnt -= 1
                            }
                            (*(*a_chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t;
                            (*(*a_chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t
                        }
                        if (*(*a_chk).whoTo).src_addr_selected != 0 {
                            sctp_free_ifa((*(*a_chk).whoTo).ro._s_addr);
                            (*(*a_chk).whoTo).ro._s_addr = 0 as *mut sctp_ifa
                        }
                        (*(*a_chk).whoTo).src_addr_selected = 0u8;
                        (*(*a_chk).whoTo).dest_state =
                            ((*(*a_chk).whoTo).dest_state as libc::c_int & !(0x1i32)) as uint16_t;
                        free((*a_chk).whoTo as *mut libc::c_void);
                        ::std::intrinsics::atomic_xsub(
                            &mut system_base_info.sctppcbinfo.ipi_count_raddr,
                            1u32,
                        );
                    }
                }
                (*a_chk).whoTo = 0 as *mut sctp_nets
            }
            if (*stcb).asoc.free_chunk_cnt as libc::c_uint
                > system_base_info.sctpsysctl.sctp_asoc_free_resc_limit
                || system_base_info.sctppcbinfo.ipi_free_chunks
                    > system_base_info.sctpsysctl.sctp_system_free_resc_limit
            {
                free(a_chk as *mut libc::c_void);
                ::std::intrinsics::atomic_xsub(
                    &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                    1u32,
                );
            } else {
                (*a_chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
                (*a_chk).sctp_next.tqe_prev = (*stcb).asoc.free_chunks.tqh_last;
                *(*stcb).asoc.free_chunks.tqh_last = a_chk;
                (*stcb).asoc.free_chunks.tqh_last = &mut (*a_chk).sctp_next.tqe_next;
                (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_add(1);
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctppcbinfo.ipi_free_chunks,
                    1u32,
                );
            }
        } else {
            free(a_chk as *mut libc::c_void);
            ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_count_chunk, 1u32);
        }
        /* sa_ignore NO_NULL_CHK */
        if (*stcb).asoc.delayed_ack != 0 {
            sctp_timer_stop(
                3i32,
                (*stcb).sctp_ep,
                stcb,
                0 as *mut sctp_nets,
                (0x90000000u32).wrapping_add(0x4u32),
            );
            sctp_timer_start(3i32, (*stcb).sctp_ep, stcb, 0 as *mut sctp_nets);
        } else {
            (*stcb).asoc.send_sack = 1u8
        }
        return;
    }
    /* ok, lets go through and fill it in */
    (*(*a_chk).data).m_hdr.mh_data = (*(*a_chk).data).m_hdr.mh_data.offset(
        (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong) as isize,
    );
    space = if (*(*a_chk).data).m_hdr.mh_flags & 0x1i32 != 0 {
        if (*(*a_chk).data).m_hdr.mh_flags & 0x8i32 == 0
            && ((*(*a_chk).data).m_hdr.mh_flags & 0x1i32 == 0
                || *(*(*a_chk).data).M_dat.MH.MH_dat.MH_ext.ref_cnt == 1u32)
        {
            (*(*a_chk).data)
                .M_dat
                .MH
                .MH_dat
                .MH_ext
                .ext_buf
                .offset((*(*a_chk).data).M_dat.MH.MH_dat.MH_ext.ext_size as isize)
                .wrapping_offset_from(
                    (*(*a_chk).data)
                        .m_hdr
                        .mh_data
                        .offset((*(*a_chk).data).m_hdr.mh_len as isize),
                ) as libc::c_long
        } else {
            0i64
        }
    } else {
        (&mut *(*(*a_chk).data).M_dat.M_databuf.as_mut_ptr().offset(
            (256u64).wrapping_sub(::std::mem::size_of::<m_hdr>() as libc::c_ulong) as libc::c_int
                as isize,
        ) as *mut libc::c_char)
            .wrapping_offset_from(
                (*(*a_chk).data)
                    .m_hdr
                    .mh_data
                    .offset((*(*a_chk).data).m_hdr.mh_len as isize),
            ) as libc::c_long
    } as libc::c_uint;
    if space as libc::c_ulong
        > ((*(*a_chk).whoTo).mtu as libc::c_ulong).wrapping_sub(
            (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong),
        )
    {
        space = ((*(*a_chk).whoTo).mtu as libc::c_ulong).wrapping_sub(
            (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong),
        ) as libc::c_uint
    }
    limit = (*(*a_chk).data).m_hdr.mh_data;
    limit = limit.offset(space as isize);
    flags = 0u8;
    if (*asoc).sctp_cmt_on_off as libc::c_int > 0i32
        && system_base_info.sctpsysctl.sctp_cmt_use_dac != 0
    {
        /*-
         * CMT DAC algorithm: If 2 (i.e., 0x10) packets have been
         * received, then set high bit to 1, else 0. Reset
         * pkts_rcvd.
         */
        flags =
            (flags as libc::c_int | ((*asoc).cmt_dac_pkts_rcvd as libc::c_int) << 6i32) as uint8_t;
        (*asoc).cmt_dac_pkts_rcvd = 0u8
    }
    /* reset the readers interpretation */
    (*stcb).freed_by_sorcv_sincelast = 0u32;
    if type_0 as libc::c_int == 0x3i32 {
        sack = (*(*a_chk).data).m_hdr.mh_data as *mut sctp_sack_chunk;
        nr_sack = 0 as *mut sctp_nr_sack_chunk;
        gap_descriptor = (sack as caddr_t).offset(::std::mem::size_of::<sctp_sack_chunk>() as isize)
            as *mut sctp_gap_ack_block;
        if highest_tsn > (*asoc).mapping_array_base_tsn {
            siz = highest_tsn
                .wrapping_sub((*asoc).mapping_array_base_tsn)
                .wrapping_add(1u32)
                .wrapping_add(7u32)
                .wrapping_div(8u32)
        } else {
            siz = (0xffffffffu32)
                .wrapping_sub(highest_tsn)
                .wrapping_add(1u32)
                .wrapping_add(highest_tsn)
                .wrapping_add(7u32)
                .wrapping_div(8u32)
        }
    } else {
        sack = 0 as *mut sctp_sack_chunk;
        nr_sack = (*(*a_chk).data).m_hdr.mh_data as *mut sctp_nr_sack_chunk;
        gap_descriptor = (nr_sack as caddr_t)
            .offset(::std::mem::size_of::<sctp_nr_sack_chunk>() as isize)
            as *mut sctp_gap_ack_block;
        if (*asoc).highest_tsn_inside_map > (*asoc).mapping_array_base_tsn {
            siz = (*asoc)
                .highest_tsn_inside_map
                .wrapping_sub((*asoc).mapping_array_base_tsn)
                .wrapping_add(1u32)
                .wrapping_add(7u32)
                .wrapping_div(8u32)
        } else {
            siz = (0xffffffffu32)
                .wrapping_sub((*asoc).mapping_array_base_tsn)
                .wrapping_add(1u32)
                .wrapping_add((*asoc).highest_tsn_inside_map)
                .wrapping_add(7u32)
                .wrapping_div(8u32)
        }
    }
    if (*asoc).mapping_array_base_tsn < (*asoc).cumulative_tsn
        && (*asoc)
            .cumulative_tsn
            .wrapping_sub((*asoc).mapping_array_base_tsn)
            > (1u32) << 31i32
        || (*asoc).mapping_array_base_tsn > (*asoc).cumulative_tsn
            && (*asoc)
                .mapping_array_base_tsn
                .wrapping_sub((*asoc).cumulative_tsn)
                < (1u32) << 31i32
    {
        offset = 1i32
    } else {
        offset = (*asoc)
            .mapping_array_base_tsn
            .wrapping_sub((*asoc).cumulative_tsn) as libc::c_int
    }
    if type_0 as libc::c_int == 0x3i32
        && (highest_tsn < (*asoc).cumulative_tsn
            && (*asoc).cumulative_tsn.wrapping_sub(highest_tsn) > (1u32) << 31i32
            || highest_tsn > (*asoc).cumulative_tsn
                && highest_tsn.wrapping_sub((*asoc).cumulative_tsn) < (1u32) << 31i32)
        || type_0 as libc::c_int == 0x10i32
            && ((*asoc).highest_tsn_inside_map < (*asoc).cumulative_tsn
                && (*asoc)
                    .cumulative_tsn
                    .wrapping_sub((*asoc).highest_tsn_inside_map)
                    > (1u32) << 31i32
                || (*asoc).highest_tsn_inside_map > (*asoc).cumulative_tsn
                    && (*asoc)
                        .highest_tsn_inside_map
                        .wrapping_sub((*asoc).cumulative_tsn)
                        < (1u32) << 31i32)
    {
        /* we have a gap .. maybe */
        i = 0u32;
        while i < siz {
            tsn_map = *(*asoc).mapping_array.offset(i as isize);
            if type_0 as libc::c_int == 0x3i32 {
                tsn_map = (tsn_map as libc::c_int
                    | *(*asoc).nr_mapping_array.offset(i as isize) as libc::c_int)
                    as uint8_t
            }
            if i == 0u32 {
                /*
                 * Clear all bits corresponding to TSNs
                 * smaller or equal to the cumulative TSN.
                 */
                tsn_map = (tsn_map as libc::c_uint & (!(0u32)) << 1i32 - offset) as uint8_t
            }
            selector = &*sack_array.as_ptr().offset(tsn_map as isize) as *const sack_track;
            if mergeable != 0 && (*selector).right_edge as libc::c_int != 0 {
                /*
                 * Backup, left and right edges were ok to
                 * merge.
                 */
                num_gap_blocks = num_gap_blocks.wrapping_sub(1);
                gap_descriptor = gap_descriptor.offset(-1)
            }
            if (*selector).num_entries as libc::c_int == 0i32 {
                mergeable = 0i32
            } else {
                j = 0u32;
                while j < (*selector).num_entries as libc::c_uint {
                    if mergeable != 0 && (*selector).right_edge as libc::c_int != 0 {
                        /*
                         * do a merge by NOT setting
                         * the left side
                         */
                        mergeable = 0i32
                    } else {
                        /*
                         * no merge, set the left
                         * side
                         */
                        mergeable = 0i32;
                        (*gap_descriptor).start = htons(
                            ((*selector).gaps[j as usize].start as libc::c_int + offset)
                                as uint16_t,
                        )
                    }
                    (*gap_descriptor).end = htons(
                        ((*selector).gaps[j as usize].end as libc::c_int + offset) as uint16_t,
                    );
                    num_gap_blocks = num_gap_blocks.wrapping_add(1);
                    gap_descriptor = gap_descriptor.offset(1);
                    if (gap_descriptor as caddr_t)
                        .offset(::std::mem::size_of::<sctp_gap_ack_block>() as isize)
                        > limit
                    {
                        /* no more room */
                        limit_reached = 1i32;
                        break;
                    } else {
                        j = j.wrapping_add(1)
                    }
                }
                if (*selector).left_edge != 0 {
                    mergeable = 1i32
                }
            }
            if limit_reached != 0 {
                break;
            }
            offset += 8i32;
            i = i.wrapping_add(1)
        }
    }
    if type_0 as libc::c_int == 0x10i32 && limit_reached == 0i32 {
        mergeable = 0i32;
        if (*asoc).highest_tsn_inside_nr_map > (*asoc).mapping_array_base_tsn {
            siz = (*asoc)
                .highest_tsn_inside_nr_map
                .wrapping_sub((*asoc).mapping_array_base_tsn)
                .wrapping_add(1u32)
                .wrapping_add(7u32)
                .wrapping_div(8u32)
        } else {
            siz = (0xffffffffu32)
                .wrapping_sub((*asoc).mapping_array_base_tsn)
                .wrapping_add(1u32)
                .wrapping_add((*asoc).highest_tsn_inside_nr_map)
                .wrapping_add(7u32)
                .wrapping_div(8u32)
        }
        if (*asoc).mapping_array_base_tsn < (*asoc).cumulative_tsn
            && (*asoc)
                .cumulative_tsn
                .wrapping_sub((*asoc).mapping_array_base_tsn)
                > (1u32) << 31i32
            || (*asoc).mapping_array_base_tsn > (*asoc).cumulative_tsn
                && (*asoc)
                    .mapping_array_base_tsn
                    .wrapping_sub((*asoc).cumulative_tsn)
                    < (1u32) << 31i32
        {
            offset = 1i32
        } else {
            offset = (*asoc)
                .mapping_array_base_tsn
                .wrapping_sub((*asoc).cumulative_tsn) as libc::c_int
        }
        if (*asoc).highest_tsn_inside_nr_map < (*asoc).cumulative_tsn
            && (*asoc)
                .cumulative_tsn
                .wrapping_sub((*asoc).highest_tsn_inside_nr_map)
                > (1u32) << 31i32
            || (*asoc).highest_tsn_inside_nr_map > (*asoc).cumulative_tsn
                && (*asoc)
                    .highest_tsn_inside_nr_map
                    .wrapping_sub((*asoc).cumulative_tsn)
                    < (1u32) << 31i32
        {
            /* we have a gap .. maybe */
            i = 0u32;
            while i < siz {
                tsn_map = *(*asoc).nr_mapping_array.offset(i as isize);
                if i == 0u32 {
                    /*
                     * Clear all bits corresponding to TSNs
                     * smaller or equal to the cumulative TSN.
                     */
                    tsn_map = (tsn_map as libc::c_uint & (!(0u32)) << 1i32 - offset) as uint8_t
                }
                selector = &*sack_array.as_ptr().offset(tsn_map as isize) as *const sack_track;
                if mergeable != 0 && (*selector).right_edge as libc::c_int != 0 {
                    /*
                    	* Backup, left and right edges were ok to
                    	* merge.
                    	*/
                    num_nr_gap_blocks = num_nr_gap_blocks.wrapping_sub(1);
                    gap_descriptor = gap_descriptor.offset(-1)
                }
                if (*selector).num_entries as libc::c_int == 0i32 {
                    mergeable = 0i32
                } else {
                    j = 0u32;
                    while j < (*selector).num_entries as libc::c_uint {
                        if mergeable != 0 && (*selector).right_edge as libc::c_int != 0 {
                            /*
                            	* do a merge by NOT setting
                            	* the left side
                            	*/
                            mergeable = 0i32
                        } else {
                            /*
                            	* no merge, set the left
                            	* side
                            	*/
                            mergeable = 0i32;
                            (*gap_descriptor).start = htons(
                                ((*selector).gaps[j as usize].start as libc::c_int + offset)
                                    as uint16_t,
                            )
                        }
                        (*gap_descriptor).end = htons(
                            ((*selector).gaps[j as usize].end as libc::c_int + offset) as uint16_t,
                        );
                        num_nr_gap_blocks = num_nr_gap_blocks.wrapping_add(1);
                        gap_descriptor = gap_descriptor.offset(1);
                        if (gap_descriptor as caddr_t)
                            .offset(::std::mem::size_of::<sctp_gap_ack_block>() as isize)
                            > limit
                        {
                            /* no more room */
                            limit_reached = 1i32;
                            break;
                        } else {
                            j = j.wrapping_add(1)
                        }
                    }
                    if (*selector).left_edge != 0 {
                        mergeable = 1i32
                    }
                }
                if limit_reached != 0 {
                    break;
                }
                offset += 8i32;
                i = i.wrapping_add(1)
            }
        }
    }
    /* now we must add any dups we are going to report. */
    if limit_reached == 0i32 && (*asoc).numduptsns != 0 {
        let mut dup = 0 as *mut uint32_t;
        dup = gap_descriptor as *mut uint32_t;
        i = 0u32;
        while i < (*asoc).numduptsns {
            *dup = htonl((*asoc).dup_tsns[i as usize] as uint32_t);
            dup = dup.offset(1);
            num_dups += 1;
            if (dup as caddr_t).offset(::std::mem::size_of::<uint32_t>() as isize) > limit {
                break;
            }
            i = i.wrapping_add(1)
        }
        (*asoc).numduptsns = 0u32
    }
    /*
     * now that the chunk is prepared queue it to the control chunk
     * queue.
     */
    if type_0 as libc::c_int == 0x3i32 {
        (*a_chk).send_size = (::std::mem::size_of::<sctp_sack_chunk>() as libc::c_ulong)
            .wrapping_add(
                (num_gap_blocks.wrapping_add(num_nr_gap_blocks) as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>() as libc::c_ulong),
            )
            .wrapping_add(
                (num_dups as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<int32_t>() as libc::c_ulong),
            ) as uint16_t;
        (*(*a_chk).data).m_hdr.mh_len = (*a_chk).send_size as libc::c_int;
        (*sack).sack.cum_tsn_ack = htonl((*asoc).cumulative_tsn);
        (*sack).sack.a_rwnd = htonl((*asoc).my_rwnd);
        (*sack).sack.num_gap_ack_blks = htons(num_gap_blocks as uint16_t);
        (*sack).sack.num_dup_tsns = htons(num_dups as uint16_t);
        (*sack).ch.chunk_type = type_0;
        (*sack).ch.chunk_flags = flags;
        (*sack).ch.chunk_length = htons((*a_chk).send_size)
    } else {
        (*a_chk).send_size = (::std::mem::size_of::<sctp_nr_sack_chunk>() as libc::c_ulong)
            .wrapping_add(
                (num_gap_blocks.wrapping_add(num_nr_gap_blocks) as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>() as libc::c_ulong),
            )
            .wrapping_add(
                (num_dups as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<int32_t>() as libc::c_ulong),
            ) as uint16_t;
        (*(*a_chk).data).m_hdr.mh_len = (*a_chk).send_size as libc::c_int;
        (*nr_sack).nr_sack.cum_tsn_ack = htonl((*asoc).cumulative_tsn);
        (*nr_sack).nr_sack.a_rwnd = htonl((*asoc).my_rwnd);
        (*nr_sack).nr_sack.num_gap_ack_blks = htons(num_gap_blocks as uint16_t);
        (*nr_sack).nr_sack.num_nr_gap_ack_blks = htons(num_nr_gap_blocks as uint16_t);
        (*nr_sack).nr_sack.num_dup_tsns = htons(num_dups as uint16_t);
        (*nr_sack).nr_sack.reserved = 0u16;
        (*nr_sack).ch.chunk_type = type_0;
        (*nr_sack).ch.chunk_flags = flags;
        (*nr_sack).ch.chunk_length = htons((*a_chk).send_size)
    }
    (*a_chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
    (*a_chk).sctp_next.tqe_prev = (*asoc).control_send_queue.tqh_last;
    *(*asoc).control_send_queue.tqh_last = a_chk;
    (*asoc).control_send_queue.tqh_last = &mut (*a_chk).sctp_next.tqe_next;
    (*asoc).my_last_reported_rwnd = (*asoc).my_rwnd;
    (*asoc).ctrl_queue_cnt += 1;
    (*asoc).send_sack = 0u8;
    ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_sendsacks, 1u32);
}
#[no_mangle]
pub unsafe extern "C" fn sctp_send_abort_tcb(
    mut stcb: *mut sctp_tcb,
    mut operr: *mut mbuf,
    mut so_locked: libc::c_int,
) {
    let mut m_abort = 0 as *mut mbuf;
    let mut m = 0 as *mut mbuf;
    let mut m_last_0 = 0 as *mut mbuf;
    let mut m_out = 0 as *mut mbuf;
    let mut m_end = 0 as *mut mbuf;
    let mut abort = 0 as *mut sctp_abort_chunk;
    let mut auth = 0 as *mut sctp_auth_chunk;
    let mut net = 0 as *mut sctp_nets;
    let mut vtag = 0;
    let mut auth_offset = 0u32;
    let mut error = 0;
    let mut cause_len = 0;
    let mut chunk_len = 0;
    let mut padding_len = 0;
    /*-
     * Add an AUTH chunk, if chunk requires it and save the offset into
     * the chain for AUTH
     */
    if if (*stcb).asoc.peer_auth_chunks.is_null() {
        0i32
    } else {
        ((*(*stcb).asoc.peer_auth_chunks).chunks[0x6usize] as libc::c_int != 0i32) as libc::c_int
    } != 0
    {
        m_out = sctp_add_auth_chunk(
            0 as *mut mbuf,
            &mut m_end,
            &mut auth,
            &mut auth_offset,
            stcb,
            0x6u8,
        );
        ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_outcontrolchunks, 1u32);
    } else {
        m_out = 0 as *mut mbuf
    }
    m_abort = sctp_get_mbuf_for_msg(
        ::std::mem::size_of::<sctp_abort_chunk>() as libc::c_uint,
        0i32,
        0x1i32,
        1i32,
        1i32,
    );
    if m_abort.is_null() {
        if !m_out.is_null() {
            m_freem(m_out);
        }
        if !operr.is_null() {
            m_freem(operr);
        }
        return;
    }
    /* link in any error */
    (*m_abort).m_hdr.mh_next = operr;
    cause_len = 0u16;
    m_last_0 = 0 as *mut mbuf;
    m = operr;
    while !m.is_null() {
        cause_len =
            (cause_len as libc::c_int + (*m).m_hdr.mh_len as uint16_t as libc::c_int) as uint16_t;
        if (*m).m_hdr.mh_next.is_null() {
            m_last_0 = m
        }
        m = (*m).m_hdr.mh_next
    }
    (*m_abort).m_hdr.mh_len = ::std::mem::size_of::<sctp_abort_chunk>() as libc::c_int;
    chunk_len = (::std::mem::size_of::<sctp_abort_chunk>() as uint16_t as libc::c_int
        + cause_len as libc::c_int) as uint16_t;
    padding_len = (((chunk_len as libc::c_int + 3i32 >> 2i32) << 2i32) - chunk_len as libc::c_int)
        as uint16_t;
    if m_out.is_null() {
        /* NO Auth chunk prepended, so reserve space in front */
        (*m_abort).m_hdr.mh_data = (*m_abort).m_hdr.mh_data.offset(
            (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong)
                as isize,
        );
        m_out = m_abort
    } else {
        /* Put AUTH chunk at the front of the chain */
        (*m_end).m_hdr.mh_next = m_abort
    }
    if !(*stcb).asoc.alternate.is_null() {
        net = (*stcb).asoc.alternate
    } else {
        net = (*stcb).asoc.primary_destination
    }
    /* Fill in the ABORT chunk header. */
    abort = (*m_abort).m_hdr.mh_data as *mut sctp_abort_chunk;
    (*abort).ch.chunk_type = 0x6u8;
    if (*stcb).asoc.peer_vtag == 0u32 {
        /* This happens iff the assoc is in COOKIE-WAIT state. */
        vtag = (*stcb).asoc.my_vtag;
        (*abort).ch.chunk_flags = 0x1u8
    } else {
        vtag = (*stcb).asoc.peer_vtag;
        (*abort).ch.chunk_flags = 0u8
    }
    (*abort).ch.chunk_length = htons(chunk_len);
    /* Add padding, if necessary. */
    if padding_len as libc::c_int > 0i32 {
        if m_last_0.is_null() || sctp_add_pad_tombuf(m_last_0, padding_len as libc::c_int).is_null()
        {
            m_freem(m_out);
            return;
        }
    }
    error = sctp_lowlevel_chunk_output(
        (*stcb).sctp_ep,
        stcb,
        net,
        &mut (*net).ro._l_addr as *mut sctp_sockstore as *mut sockaddr,
        m_out,
        auth_offset,
        auth,
        (*stcb).asoc.authinfo.active_keyid,
        1i32,
        0i32,
        0i32,
        (*(*stcb).sctp_ep).ip_inp.inp.inp_inc.inc_ie.ie_lport,
        (*stcb).rport,
        htonl(vtag),
        (*(*stcb).asoc.primary_destination).port,
        0 as *mut sctp_sockstore,
        so_locked,
    );
    if error != 0 {
        if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"Gak send error %d\n\x00" as *const u8 as *const libc::c_char,
                    error,
                );
            }
        }
        if error == 105i32 {
            (*stcb).asoc.ifp_had_enobuf = 1u8;
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_lowlevelerr, 1u32);
        }
    } else {
        (*stcb).asoc.ifp_had_enobuf = 0u8
    }
    ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_outcontrolchunks, 1u32);
}
#[no_mangle]
pub unsafe extern "C" fn sctp_send_shutdown_complete(
    mut stcb: *mut sctp_tcb,
    mut net: *mut sctp_nets,
    mut reflect_vtag: libc::c_int,
) {
    let mut m_shutdown_comp = 0 as *mut mbuf;
    let mut shutdown_complete = 0 as *mut sctp_shutdown_complete_chunk;
    let mut vtag = 0;
    let mut error = 0;
    let mut flags = 0;
    m_shutdown_comp = sctp_get_mbuf_for_msg(
        ::std::mem::size_of::<sctp_chunkhdr>() as libc::c_uint,
        0i32,
        0x1i32,
        1i32,
        1i32,
    );
    if m_shutdown_comp.is_null() {
        /* no mbuf's */
        return;
    }
    if reflect_vtag != 0 {
        flags = 0x1u8;
        vtag = (*stcb).asoc.my_vtag
    } else {
        flags = 0u8;
        vtag = (*stcb).asoc.peer_vtag
    }
    shutdown_complete = (*m_shutdown_comp).m_hdr.mh_data as *mut sctp_shutdown_complete_chunk;
    (*shutdown_complete).ch.chunk_type = 0xeu8;
    (*shutdown_complete).ch.chunk_flags = flags;
    (*shutdown_complete).ch.chunk_length =
        htons(::std::mem::size_of::<sctp_shutdown_complete_chunk>() as uint16_t);
    (*m_shutdown_comp).m_hdr.mh_len =
        ::std::mem::size_of::<sctp_shutdown_complete_chunk>() as libc::c_int;
    error = sctp_lowlevel_chunk_output(
        (*stcb).sctp_ep,
        stcb,
        net,
        &mut (*net).ro._l_addr as *mut sctp_sockstore as *mut sockaddr,
        m_shutdown_comp,
        0u32,
        0 as *mut sctp_auth_chunk,
        0u16,
        1i32,
        0i32,
        0i32,
        (*(*stcb).sctp_ep).ip_inp.inp.inp_inc.inc_ie.ie_lport,
        (*stcb).rport,
        htonl(vtag),
        (*net).port,
        0 as *mut sctp_sockstore,
        0i32,
    );
    if error != 0 {
        if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"Gak send error %d\n\x00" as *const u8 as *const libc::c_char,
                    error,
                );
            }
        }
        if error == 105i32 {
            (*stcb).asoc.ifp_had_enobuf = 1u8;
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_lowlevelerr, 1u32);
        }
    } else {
        (*stcb).asoc.ifp_had_enobuf = 0u8
    }
    ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_outcontrolchunks, 1u32);
}
unsafe extern "C" fn sctp_send_resp_msg(
    mut src: *mut sockaddr,
    mut dst: *mut sockaddr,
    mut sh: *mut sctphdr,
    mut vtag: uint32_t,
    mut type_0: uint8_t,
    mut cause: *mut mbuf,
    mut vrf_id: uint32_t,
    mut port: uint16_t,
) {
    let mut o_pak = 0 as *mut mbuf;
    let mut mout = 0 as *mut mbuf;
    let mut shout = 0 as *mut sctphdr;
    let mut ch = 0 as *mut sctp_chunkhdr;
    let mut udp = 0 as *mut udphdr;
    let mut ret = 0;
    let mut len = 0;
    let mut cause_len = 0;
    let mut padding_len = 0;
    let mut ip = 0 as *mut ip;
    let mut ip6 = 0 as *mut ip6_hdr;
    /* Compute the length of the cause and add final padding. */
    cause_len = 0i32;
    if !cause.is_null() {
        let mut m_at = 0 as *mut mbuf;
        let mut m_last_0 = 0 as *mut mbuf;
        m_at = cause;
        while !m_at.is_null() {
            if (*m_at).m_hdr.mh_next.is_null() {
                m_last_0 = m_at
            }
            cause_len += (*m_at).m_hdr.mh_len;
            m_at = (*m_at).m_hdr.mh_next
        }
        padding_len = cause_len % 4i32;
        if padding_len != 0i32 {
            padding_len = 4i32 - padding_len
        }
        if padding_len != 0i32 {
            if sctp_add_pad_tombuf(m_last_0, padding_len).is_null() {
                m_freem(cause);
                return;
            }
        }
    } else {
        padding_len = 0i32
    }
    /* Get an mbuf for the header. */
    len = (::std::mem::size_of::<sctphdr>() as libc::c_ulong)
        .wrapping_add(::std::mem::size_of::<sctp_chunkhdr>() as libc::c_ulong)
        as libc::c_int;
    match (*dst).sa_family as libc::c_int {
        2 => {
            len = (len as libc::c_ulong).wrapping_add(::std::mem::size_of::<ip>() as libc::c_ulong)
                as libc::c_int
        }
        10 => {
            len = (len as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
                as libc::c_int
        }
        _ => {}
    }
    if port != 0 {
        len = (len as libc::c_ulong).wrapping_add(::std::mem::size_of::<udphdr>() as libc::c_ulong)
            as libc::c_int
    }
    mout = sctp_get_mbuf_for_msg(
        (len + max_linkhdr) as libc::c_uint,
        1i32,
        0x1i32,
        1i32,
        1i32,
    );
    if mout.is_null() {
        if !cause.is_null() {
            m_freem(cause);
        }
        return;
    }
    (*mout).m_hdr.mh_data = (*mout).m_hdr.mh_data.offset(max_linkhdr as isize);
    (*mout).m_hdr.mh_len = len;
    (*mout).m_hdr.mh_next = cause;
    ip = 0 as *mut ip;
    ip6 = 0 as *mut ip6_hdr;
    match (*dst).sa_family as libc::c_int {
        2 => {
            let mut src_sin = 0 as *mut sockaddr_in;
            let mut dst_sin = 0 as *mut sockaddr_in;
            src_sin = src as *mut sockaddr_in;
            dst_sin = dst as *mut sockaddr_in;
            ip = (*mout).m_hdr.mh_data as *mut ip;
            (*ip).set_ip_v(4u32);
            (*ip).set_ip_hl((::std::mem::size_of::<ip>() as libc::c_ulong >> 2i32) as libc::c_uint);
            (*ip).ip_tos = 0u8;
            (*ip).ip_off = htons(0x4000u16);
            let fresh38 = ip_id;
            ip_id = ip_id.wrapping_add(1);
            (*ip).ip_id = htons(fresh38);
            (*ip).ip_ttl = ip_defttl as uint8_t;
            if port != 0 {
                (*ip).ip_p = IPPROTO_UDP as uint8_t
            } else {
                (*ip).ip_p = IPPROTO_SCTP as uint8_t
            }
            (*ip).ip_src.s_addr = (*dst_sin).sin_addr.s_addr;
            (*ip).ip_dst.s_addr = (*src_sin).sin_addr.s_addr;
            (*ip).ip_sum = 0u16;
            len = ::std::mem::size_of::<ip>() as libc::c_int;
            shout = (ip as caddr_t).offset(len as isize) as *mut sctphdr
        }
        10 => {
            let mut src_sin6 = 0 as *mut sockaddr_in6;
            let mut dst_sin6 = 0 as *mut sockaddr_in6;
            src_sin6 = src as *mut sockaddr_in6;
            dst_sin6 = dst as *mut sockaddr_in6;
            ip6 = (*mout).m_hdr.mh_data as *mut ip6_hdr;
            (*ip6).ip6_ctlun.ip6_un1.ip6_un1_flow = htonl(0x60000000u32);
            (*ip6).ip6_ctlun.ip6_un1.ip6_un1_hlim = 128u8;
            if port != 0 {
                (*ip6).ip6_ctlun.ip6_un1.ip6_un1_nxt = IPPROTO_UDP as uint8_t
            } else {
                (*ip6).ip6_ctlun.ip6_un1.ip6_un1_nxt = IPPROTO_SCTP as uint8_t
            }
            (*ip6).ip6_src = (*dst_sin6).sin6_addr;
            (*ip6).ip6_dst = (*src_sin6).sin6_addr;
            len = ::std::mem::size_of::<ip6_hdr>() as libc::c_int;
            shout = (ip6 as caddr_t).offset(len as isize) as *mut sctphdr
        }
        _ => {
            len = 0i32;
            shout = (*mout).m_hdr.mh_data as *mut sctphdr
        }
    }
    if port != 0 {
        if htons(system_base_info.sctpsysctl.sctp_udp_tunneling_port as uint16_t) as libc::c_int
            == 0i32
        {
            m_freem(mout);
            return;
        }
        udp = shout as *mut udphdr;
        (*udp).c2rust_unnamed.c2rust_unnamed.uh_sport =
            htons(system_base_info.sctpsysctl.sctp_udp_tunneling_port as uint16_t);
        (*udp).c2rust_unnamed.c2rust_unnamed.uh_dport = port;
        (*udp).c2rust_unnamed.c2rust_unnamed.uh_sum = 0u16;
        (*udp).c2rust_unnamed.c2rust_unnamed.uh_ulen = htons(
            (::std::mem::size_of::<udphdr>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<sctp_chunkhdr>() as libc::c_ulong)
                .wrapping_add(cause_len as libc::c_ulong)
                .wrapping_add(padding_len as libc::c_ulong) as uint16_t,
        );
        len = (len as libc::c_ulong).wrapping_add(::std::mem::size_of::<udphdr>() as libc::c_ulong)
            as libc::c_int;
        shout = (shout as caddr_t).offset(::std::mem::size_of::<udphdr>() as isize) as *mut sctphdr
    } else {
        udp = 0 as *mut udphdr
    }
    (*shout).src_port = (*sh).dest_port;
    (*shout).dest_port = (*sh).src_port;
    (*shout).checksum = 0u32;
    if vtag != 0 {
        (*shout).v_tag = htonl(vtag)
    } else {
        (*shout).v_tag = (*sh).v_tag
    }
    len = (len as libc::c_ulong).wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong)
        as libc::c_int;
    ch = (shout as caddr_t).offset(::std::mem::size_of::<sctphdr>() as isize) as *mut sctp_chunkhdr;
    (*ch).chunk_type = type_0;
    if vtag != 0 {
        (*ch).chunk_flags = 0u8
    } else {
        (*ch).chunk_flags = 0x1u8
    }
    (*ch).chunk_length = htons(
        (::std::mem::size_of::<sctp_chunkhdr>() as libc::c_ulong)
            .wrapping_add(cause_len as libc::c_ulong) as uint16_t,
    );
    len = (len as libc::c_ulong)
        .wrapping_add(::std::mem::size_of::<sctp_chunkhdr>() as libc::c_ulong)
        as libc::c_int;
    len += cause_len + padding_len;
    o_pak = mout;
    (*o_pak).M_dat.MH.MH_pkthdr.len = len;
    match (*dst).sa_family as libc::c_int {
        2 => {
            if port != 0 {
                (*udp).c2rust_unnamed.c2rust_unnamed.uh_sum = 0u16
            }
            (*ip).ip_len = len as libc::c_ushort;
            if port != 0 {
                (*shout).checksum = sctp_calculate_cksum(
                    mout,
                    (::std::mem::size_of::<ip>() as libc::c_ulong)
                        .wrapping_add(::std::mem::size_of::<udphdr>() as libc::c_ulong)
                        as uint32_t,
                );
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctpstat.sctps_sendswcrc,
                    1u32,
                );
            } else {
                (*shout).checksum =
                    sctp_calculate_cksum(mout, ::std::mem::size_of::<ip>() as uint32_t);
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctpstat.sctps_sendswcrc,
                    1u32,
                );
            }
            sctp_userspace_ip_output(
                &mut ret,
                o_pak,
                0 as *mut sctp_route_t,
                0 as *mut libc::c_void,
                vrf_id,
            );
        }
        10 => {
            (*ip6).ip6_ctlun.ip6_un1.ip6_un1_plen = htons(
                (len as libc::c_ulong)
                    .wrapping_sub(::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
                    as uint16_t,
            );
            if port != 0 {
                (*shout).checksum = sctp_calculate_cksum(
                    mout,
                    (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
                        .wrapping_add(::std::mem::size_of::<udphdr>() as libc::c_ulong)
                        as uint32_t,
                );
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctpstat.sctps_sendswcrc,
                    1u32,
                );
            } else {
                (*shout).checksum =
                    sctp_calculate_cksum(mout, ::std::mem::size_of::<ip6_hdr>() as uint32_t);
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctpstat.sctps_sendswcrc,
                    1u32,
                );
            }
            sctp_userspace_ip6_output(
                &mut ret,
                o_pak,
                0 as *mut route_in6,
                0 as *mut libc::c_void,
                vrf_id,
            );
        }
        123 => {
            let mut buffer = 0 as *mut libc::c_char;
            let mut sconn = 0 as *mut sockaddr_conn;
            sconn = src as *mut sockaddr_conn;
            if system_base_info.crc32c_offloaded == 0i32 {
                (*shout).checksum = sctp_calculate_cksum(mout, 0u32);
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctpstat.sctps_sendswcrc,
                    1u32,
                );
            } else {
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctpstat.sctps_sendhwcrc,
                    1u32,
                );
            }
            /* Don't alloc/free for each packet */
            buffer = malloc(len as libc::c_ulong) as *mut libc::c_char;
            if !buffer.is_null() {
                m_copydata(mout, 0i32, len, buffer);
                ret = system_base_info
                    .conn_output
                    .expect("non-null function pointer")(
                    (*sconn).sconn_addr,
                    buffer as *mut libc::c_void,
                    len as size_t,
                    0u8,
                    0u8,
                );
                free(buffer as *mut libc::c_void);
            } else {
                ret = 12i32
            }
            m_freem(mout);
        }
        _ => {
            if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"Unknown protocol (TSNH) type %d\n\x00" as *const u8
                            as *const libc::c_char,
                        (*dst).sa_family as libc::c_int,
                    );
                }
            }
            m_freem(mout);
            return;
        }
    }
    if system_base_info.sctpsysctl.sctp_debug_on & 0x40u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"return from send is %d\n\x00" as *const u8 as *const libc::c_char,
                ret,
            );
        }
    }
    ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_sendpackets, 1u32);
    ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_outpackets, 1u32);
    ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_outcontrolchunks, 1u32);
    if ret != 0 {
        ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_senderrors, 1u32);
    };
}
#[no_mangle]
pub unsafe extern "C" fn sctp_send_shutdown_complete2(
    mut src: *mut sockaddr,
    mut dst: *mut sockaddr,
    mut sh: *mut sctphdr,
    mut vrf_id: uint32_t,
    mut port: uint16_t,
) {
    sctp_send_resp_msg(src, dst, sh, 0u32, 0xeu8, 0 as *mut mbuf, vrf_id, port);
}
#[no_mangle]
pub unsafe extern "C" fn sctp_send_hb(
    mut stcb: *mut sctp_tcb,
    mut net: *mut sctp_nets,
    mut so_locked: libc::c_int,
) {
    let mut chk = 0 as *mut sctp_tmit_chunk;
    let mut hb = 0 as *mut sctp_heartbeat_chunk;
    let mut now = timeval {
        tv_sec: 0,
        tv_usec: 0,
    };
    if net.is_null() {
        return;
    }
    gettimeofday(&mut now, 0 as *mut timezone);
    match (*net).ro._l_addr.sa.sa_family as libc::c_int {
        2 | 10 | 123 => {}
        _ => return,
    }
    if (*stcb).asoc.free_chunks.tqh_first.is_null() {
        chk = malloc(system_base_info.sctppcbinfo.ipi_zone_chunk) as *mut sctp_tmit_chunk;
        if !chk.is_null() {
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctppcbinfo.ipi_count_chunk, 1u32);
            (*chk).whoTo = 0 as *mut sctp_nets;
            (*chk).holds_key_ref = 0u8
        }
    } else {
        chk = (*stcb).asoc.free_chunks.tqh_first;
        if !(*chk).sctp_next.tqe_next.is_null() {
            (*(*chk).sctp_next.tqe_next).sctp_next.tqe_prev = (*chk).sctp_next.tqe_prev
        } else {
            (*stcb).asoc.free_chunks.tqh_last = (*chk).sctp_next.tqe_prev
        }
        *(*chk).sctp_next.tqe_prev = (*chk).sctp_next.tqe_next;
        ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_free_chunks, 1u32);
        (*chk).holds_key_ref = 0u8;
        ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_cached_chk, 1u32);
        (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_sub(1)
    }
    if chk.is_null() {
        if system_base_info.sctpsysctl.sctp_debug_on & 0x80u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"Gak, can\'t get a chunk for hb\n\x00" as *const u8 as *const libc::c_char,
                );
            }
        }
        return;
    }
    (*chk).copy_by_ref = 0u8;
    (*chk).rec.chunk_id.id = 0x4u8;
    (*chk).rec.chunk_id.can_take_data = 1u8;
    (*chk).flags = 0u16;
    (*chk).asoc = &mut (*stcb).asoc;
    (*chk).send_size = ::std::mem::size_of::<sctp_heartbeat_chunk>() as uint16_t;
    (*chk).data = sctp_get_mbuf_for_msg((*chk).send_size as libc::c_uint, 0i32, 0x1i32, 1i32, 1i32);
    if (*chk).data.is_null() {
        if (*chk).holds_key_ref != 0 {
            sctp_auth_key_release(stcb, (*chk).auth_keyid, so_locked);
            (*chk).holds_key_ref = 0u8
        }
        if !stcb.is_null() {
            if !(*chk).whoTo.is_null() {
                if !(*chk).whoTo.is_null() {
                    if ::std::intrinsics::atomic_xadd(
                        &mut (*(*chk).whoTo).ref_count as *mut libc::c_int,
                        -(1i32),
                    ) == 1i32
                    {
                        sctp_os_timer_stop(&mut (*(*chk).whoTo).rxt_timer.timer);
                        sctp_os_timer_stop(&mut (*(*chk).whoTo).pmtu_timer.timer);
                        sctp_os_timer_stop(&mut (*(*chk).whoTo).hb_timer.timer);
                        if !(*(*chk).whoTo).ro.ro_rt.is_null() {
                            if (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt <= 1i64 {
                                sctp_userspace_rtfree((*(*chk).whoTo).ro.ro_rt);
                            } else {
                                (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt -= 1
                            }
                            (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t;
                            (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t
                        }
                        if (*(*chk).whoTo).src_addr_selected != 0 {
                            sctp_free_ifa((*(*chk).whoTo).ro._s_addr);
                            (*(*chk).whoTo).ro._s_addr = 0 as *mut sctp_ifa
                        }
                        (*(*chk).whoTo).src_addr_selected = 0u8;
                        (*(*chk).whoTo).dest_state =
                            ((*(*chk).whoTo).dest_state as libc::c_int & !(0x1i32)) as uint16_t;
                        free((*chk).whoTo as *mut libc::c_void);
                        ::std::intrinsics::atomic_xsub(
                            &mut system_base_info.sctppcbinfo.ipi_count_raddr,
                            1u32,
                        );
                    }
                }
                (*chk).whoTo = 0 as *mut sctp_nets
            }
            if (*stcb).asoc.free_chunk_cnt as libc::c_uint
                > system_base_info.sctpsysctl.sctp_asoc_free_resc_limit
                || system_base_info.sctppcbinfo.ipi_free_chunks
                    > system_base_info.sctpsysctl.sctp_system_free_resc_limit
            {
                free(chk as *mut libc::c_void);
                ::std::intrinsics::atomic_xsub(
                    &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                    1u32,
                );
            } else {
                (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
                (*chk).sctp_next.tqe_prev = (*stcb).asoc.free_chunks.tqh_last;
                *(*stcb).asoc.free_chunks.tqh_last = chk;
                (*stcb).asoc.free_chunks.tqh_last = &mut (*chk).sctp_next.tqe_next;
                (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_add(1);
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctppcbinfo.ipi_free_chunks,
                    1u32,
                );
            }
        } else {
            free(chk as *mut libc::c_void);
            ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_count_chunk, 1u32);
        }
        return;
    }
    (*(*chk).data).m_hdr.mh_data = (*(*chk).data).m_hdr.mh_data.offset(
        (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong) as isize,
    );
    (*(*chk).data).m_hdr.mh_len = (*chk).send_size as libc::c_int;
    (*chk).sent = 0i32;
    (*chk).snd_count = 0u16;
    (*chk).whoTo = net;
    ::std::intrinsics::atomic_xadd(&mut (*(*chk).whoTo).ref_count, 1i32);
    /* Now we have a mbuf that we can fill in with the details */
    hb = (*(*chk).data).m_hdr.mh_data as *mut sctp_heartbeat_chunk;
    memset(
        hb as *mut libc::c_void,
        0i32,
        ::std::mem::size_of::<sctp_heartbeat_chunk>() as libc::c_ulong,
    );
    /* fill out chunk header */
    (*hb).ch.chunk_type = 0x4u8;
    (*hb).ch.chunk_flags = 0u8;
    (*hb).ch.chunk_length = htons((*chk).send_size);
    /* Fill out hb parameter */
    (*hb).heartbeat.hb_info.ph.param_type = htons(0x1u16);
    (*hb).heartbeat.hb_info.ph.param_length =
        htons(::std::mem::size_of::<sctp_heartbeat_info_param>() as uint16_t);
    (*hb).heartbeat.hb_info.time_value_1 = now.tv_sec as uint32_t;
    (*hb).heartbeat.hb_info.time_value_2 = now.tv_usec as uint32_t;
    /* Did our user request this one, put it in */
    (*hb).heartbeat.hb_info.addr_family = (*net).ro._l_addr.sa.sa_family as uint8_t;
    match (*net).ro._l_addr.sa.sa_family as libc::c_int {
        2 => (*hb).heartbeat.hb_info.addr_len = ::std::mem::size_of::<sockaddr_in>() as uint8_t,
        10 => (*hb).heartbeat.hb_info.addr_len = ::std::mem::size_of::<sockaddr_in6>() as uint8_t,
        123 => (*hb).heartbeat.hb_info.addr_len = ::std::mem::size_of::<sockaddr_conn>() as uint8_t,
        _ => (*hb).heartbeat.hb_info.addr_len = 0u8,
    }
    if (*net).dest_state as libc::c_int & 0x200i32 != 0 {
        /*
         * we only take from the entropy pool if the address is not
         * confirmed.
         */
        (*hb).heartbeat.hb_info.random_value1 =
            sctp_select_initial_TSN(&mut (*(*stcb).sctp_ep).sctp_ep);
        (*net).heartbeat_random1 = (*hb).heartbeat.hb_info.random_value1;
        (*hb).heartbeat.hb_info.random_value2 =
            sctp_select_initial_TSN(&mut (*(*stcb).sctp_ep).sctp_ep);
        (*net).heartbeat_random2 = (*hb).heartbeat.hb_info.random_value2
    } else {
        (*hb).heartbeat.hb_info.random_value1 = 0u32;
        (*net).heartbeat_random1 = (*hb).heartbeat.hb_info.random_value1;
        (*hb).heartbeat.hb_info.random_value2 = 0u32;
        (*net).heartbeat_random2 = (*hb).heartbeat.hb_info.random_value2
    }
    match (*net).ro._l_addr.sa.sa_family as libc::c_int {
        2 => {
            memcpy(
                (*hb).heartbeat.hb_info.address.as_mut_ptr() as *mut libc::c_void,
                &mut (*net).ro._l_addr.sin.sin_addr as *mut in_addr as *const libc::c_void,
                ::std::mem::size_of::<in_addr>() as libc::c_ulong,
            );
        }
        10 => {
            memcpy(
                (*hb).heartbeat.hb_info.address.as_mut_ptr() as *mut libc::c_void,
                &mut (*net).ro._l_addr.sin6.sin6_addr as *mut in6_addr as *const libc::c_void,
                ::std::mem::size_of::<in6_addr>() as libc::c_ulong,
            );
        }
        123 => {
            memcpy(
                (*hb).heartbeat.hb_info.address.as_mut_ptr() as *mut libc::c_void,
                &mut (*net).ro._l_addr.sconn.sconn_addr as *mut *mut libc::c_void
                    as *const libc::c_void,
                ::std::mem::size_of::<*mut libc::c_void>() as libc::c_ulong,
            );
        }
        _ => {
            if !(*chk).data.is_null() {
                m_freem((*chk).data);
                (*chk).data = 0 as *mut mbuf
            }
            if (*chk).holds_key_ref != 0 {
                sctp_auth_key_release(stcb, (*chk).auth_keyid, so_locked);
                (*chk).holds_key_ref = 0u8
            }
            if !stcb.is_null() {
                if !(*chk).whoTo.is_null() {
                    if !(*chk).whoTo.is_null() {
                        if ::std::intrinsics::atomic_xadd(
                            &mut (*(*chk).whoTo).ref_count as *mut libc::c_int,
                            -(1i32),
                        ) == 1i32
                        {
                            sctp_os_timer_stop(&mut (*(*chk).whoTo).rxt_timer.timer);
                            sctp_os_timer_stop(&mut (*(*chk).whoTo).pmtu_timer.timer);
                            sctp_os_timer_stop(&mut (*(*chk).whoTo).hb_timer.timer);
                            if !(*(*chk).whoTo).ro.ro_rt.is_null() {
                                if (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt <= 1i64 {
                                    sctp_userspace_rtfree((*(*chk).whoTo).ro.ro_rt);
                                } else {
                                    (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt -= 1
                                }
                                (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t;
                                (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t
                            }
                            if (*(*chk).whoTo).src_addr_selected != 0 {
                                sctp_free_ifa((*(*chk).whoTo).ro._s_addr);
                                (*(*chk).whoTo).ro._s_addr = 0 as *mut sctp_ifa
                            }
                            (*(*chk).whoTo).src_addr_selected = 0u8;
                            (*(*chk).whoTo).dest_state =
                                ((*(*chk).whoTo).dest_state as libc::c_int & !(0x1i32)) as uint16_t;
                            free((*chk).whoTo as *mut libc::c_void);
                            ::std::intrinsics::atomic_xsub(
                                &mut system_base_info.sctppcbinfo.ipi_count_raddr,
                                1u32,
                            );
                        }
                    }
                    (*chk).whoTo = 0 as *mut sctp_nets
                }
                if (*stcb).asoc.free_chunk_cnt as libc::c_uint
                    > system_base_info.sctpsysctl.sctp_asoc_free_resc_limit
                    || system_base_info.sctppcbinfo.ipi_free_chunks
                        > system_base_info.sctpsysctl.sctp_system_free_resc_limit
                {
                    free(chk as *mut libc::c_void);
                    ::std::intrinsics::atomic_xsub(
                        &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                        1u32,
                    );
                } else {
                    (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
                    (*chk).sctp_next.tqe_prev = (*stcb).asoc.free_chunks.tqh_last;
                    *(*stcb).asoc.free_chunks.tqh_last = chk;
                    (*stcb).asoc.free_chunks.tqh_last = &mut (*chk).sctp_next.tqe_next;
                    (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_add(1);
                    ::std::intrinsics::atomic_xadd(
                        &mut system_base_info.sctppcbinfo.ipi_free_chunks,
                        1u32,
                    );
                }
            } else {
                free(chk as *mut libc::c_void);
                ::std::intrinsics::atomic_xsub(
                    &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                    1u32,
                );
            }
            return;
        }
    }
    (*net).hb_responded = 0u8;
    (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
    (*chk).sctp_next.tqe_prev = (*stcb).asoc.control_send_queue.tqh_last;
    *(*stcb).asoc.control_send_queue.tqh_last = chk;
    (*stcb).asoc.control_send_queue.tqh_last = &mut (*chk).sctp_next.tqe_next;
    (*stcb).asoc.ctrl_queue_cnt += 1;
    ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_sendheartbeat, 1u32);
}
#[no_mangle]
pub unsafe extern "C" fn sctp_send_ecn_echo(
    mut stcb: *mut sctp_tcb,
    mut net: *mut sctp_nets,
    mut high_tsn: uint32_t,
) {
    let mut asoc = 0 as *mut sctp_association;
    let mut ecne = 0 as *mut sctp_ecne_chunk;
    let mut chk = 0 as *mut sctp_tmit_chunk;
    if net.is_null() {
        return;
    }
    asoc = &mut (*stcb).asoc;
    chk = (*asoc).control_send_queue.tqh_first;
    while !chk.is_null() {
        if (*chk).rec.chunk_id.id as libc::c_int == 0xci32 && net == (*chk).whoTo {
            let mut cnt = 0;
            let mut ctsn = 0;
            ecne = (*(*chk).data).m_hdr.mh_data as *mut sctp_ecne_chunk;
            ctsn = ntohl((*ecne).tsn);
            if high_tsn < ctsn && ctsn.wrapping_sub(high_tsn) > (1u32) << 31i32
                || high_tsn > ctsn && high_tsn.wrapping_sub(ctsn) < (1u32) << 31i32
            {
                (*ecne).tsn = htonl(high_tsn);
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctpstat.sctps_queue_upd_ecne,
                    1u32,
                );
            }
            cnt = ntohl((*ecne).num_pkts_since_cwr);
            cnt = cnt.wrapping_add(1);
            (*ecne).num_pkts_since_cwr = htonl(cnt);
            return;
        }
        chk = (*chk).sctp_next.tqe_next
    }
    /* nope could not find one to update so we must build one */
    if (*stcb).asoc.free_chunks.tqh_first.is_null() {
        chk = malloc(system_base_info.sctppcbinfo.ipi_zone_chunk) as *mut sctp_tmit_chunk;
        if !chk.is_null() {
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctppcbinfo.ipi_count_chunk, 1u32);
            (*chk).whoTo = 0 as *mut sctp_nets;
            (*chk).holds_key_ref = 0u8
        }
    } else {
        chk = (*stcb).asoc.free_chunks.tqh_first;
        if !(*chk).sctp_next.tqe_next.is_null() {
            (*(*chk).sctp_next.tqe_next).sctp_next.tqe_prev = (*chk).sctp_next.tqe_prev
        } else {
            (*stcb).asoc.free_chunks.tqh_last = (*chk).sctp_next.tqe_prev
        }
        *(*chk).sctp_next.tqe_prev = (*chk).sctp_next.tqe_next;
        ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_free_chunks, 1u32);
        (*chk).holds_key_ref = 0u8;
        ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_cached_chk, 1u32);
        (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_sub(1)
    }
    if chk.is_null() {
        return;
    }
    ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_queue_upd_ecne, 1u32);
    (*chk).copy_by_ref = 0u8;
    (*chk).rec.chunk_id.id = 0xcu8;
    (*chk).rec.chunk_id.can_take_data = 0u8;
    (*chk).flags = 0u16;
    (*chk).asoc = &mut (*stcb).asoc;
    (*chk).send_size = ::std::mem::size_of::<sctp_ecne_chunk>() as uint16_t;
    (*chk).data = sctp_get_mbuf_for_msg((*chk).send_size as libc::c_uint, 0i32, 0x1i32, 1i32, 1i32);
    if (*chk).data.is_null() {
        if (*chk).holds_key_ref != 0 {
            sctp_auth_key_release(stcb, (*chk).auth_keyid, 0i32);
            (*chk).holds_key_ref = 0u8
        }
        if !stcb.is_null() {
            if !(*chk).whoTo.is_null() {
                if !(*chk).whoTo.is_null() {
                    if ::std::intrinsics::atomic_xadd(
                        &mut (*(*chk).whoTo).ref_count as *mut libc::c_int,
                        -(1i32),
                    ) == 1i32
                    {
                        sctp_os_timer_stop(&mut (*(*chk).whoTo).rxt_timer.timer);
                        sctp_os_timer_stop(&mut (*(*chk).whoTo).pmtu_timer.timer);
                        sctp_os_timer_stop(&mut (*(*chk).whoTo).hb_timer.timer);
                        if !(*(*chk).whoTo).ro.ro_rt.is_null() {
                            if (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt <= 1i64 {
                                sctp_userspace_rtfree((*(*chk).whoTo).ro.ro_rt);
                            } else {
                                (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt -= 1
                            }
                            (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t;
                            (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t
                        }
                        if (*(*chk).whoTo).src_addr_selected != 0 {
                            sctp_free_ifa((*(*chk).whoTo).ro._s_addr);
                            (*(*chk).whoTo).ro._s_addr = 0 as *mut sctp_ifa
                        }
                        (*(*chk).whoTo).src_addr_selected = 0u8;
                        (*(*chk).whoTo).dest_state =
                            ((*(*chk).whoTo).dest_state as libc::c_int & !(0x1i32)) as uint16_t;
                        free((*chk).whoTo as *mut libc::c_void);
                        ::std::intrinsics::atomic_xsub(
                            &mut system_base_info.sctppcbinfo.ipi_count_raddr,
                            1u32,
                        );
                    }
                }
                (*chk).whoTo = 0 as *mut sctp_nets
            }
            if (*stcb).asoc.free_chunk_cnt as libc::c_uint
                > system_base_info.sctpsysctl.sctp_asoc_free_resc_limit
                || system_base_info.sctppcbinfo.ipi_free_chunks
                    > system_base_info.sctpsysctl.sctp_system_free_resc_limit
            {
                free(chk as *mut libc::c_void);
                ::std::intrinsics::atomic_xsub(
                    &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                    1u32,
                );
            } else {
                (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
                (*chk).sctp_next.tqe_prev = (*stcb).asoc.free_chunks.tqh_last;
                *(*stcb).asoc.free_chunks.tqh_last = chk;
                (*stcb).asoc.free_chunks.tqh_last = &mut (*chk).sctp_next.tqe_next;
                (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_add(1);
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctppcbinfo.ipi_free_chunks,
                    1u32,
                );
            }
        } else {
            free(chk as *mut libc::c_void);
            ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_count_chunk, 1u32);
        }
        return;
    }
    (*(*chk).data).m_hdr.mh_data = (*(*chk).data).m_hdr.mh_data.offset(
        (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong) as isize,
    );
    (*(*chk).data).m_hdr.mh_len = (*chk).send_size as libc::c_int;
    (*chk).sent = 0i32;
    (*chk).snd_count = 0u16;
    (*chk).whoTo = net;
    ::std::intrinsics::atomic_xadd(&mut (*(*chk).whoTo).ref_count, 1i32);
    (*stcb).asoc.ecn_echo_cnt_onq = (*stcb).asoc.ecn_echo_cnt_onq.wrapping_add(1);
    ecne = (*(*chk).data).m_hdr.mh_data as *mut sctp_ecne_chunk;
    (*ecne).ch.chunk_type = 0xcu8;
    (*ecne).ch.chunk_flags = 0u8;
    (*ecne).ch.chunk_length = htons(::std::mem::size_of::<sctp_ecne_chunk>() as uint16_t);
    (*ecne).tsn = htonl(high_tsn);
    (*ecne).num_pkts_since_cwr = htonl(1u32);
    (*chk).sctp_next.tqe_next = (*stcb).asoc.control_send_queue.tqh_first;
    if !(*chk).sctp_next.tqe_next.is_null() {
        (*(*stcb).asoc.control_send_queue.tqh_first)
            .sctp_next
            .tqe_prev = &mut (*chk).sctp_next.tqe_next
    } else {
        (*stcb).asoc.control_send_queue.tqh_last = &mut (*chk).sctp_next.tqe_next
    }
    (*stcb).asoc.control_send_queue.tqh_first = chk;
    (*chk).sctp_next.tqe_prev = &mut (*stcb).asoc.control_send_queue.tqh_first;
    (*asoc).ctrl_queue_cnt += 1;
}
#[no_mangle]
pub unsafe extern "C" fn sctp_send_packet_dropped(
    mut stcb: *mut sctp_tcb,
    mut net: *mut sctp_nets,
    mut m: *mut mbuf,
    mut len: libc::c_int,
    mut iphlen: libc::c_int,
    mut bad_crc: libc::c_int,
) {
    let mut asoc = 0 as *mut sctp_association;
    let mut chk = 0 as *mut sctp_tmit_chunk;
    let mut was_trunc = 0i32;
    let mut fullsz = 0i32;
    let mut offset = 0;
    let mut ch = 0 as *mut sctp_chunkhdr;
    let mut chunk_buf = sctp_chunkhdr {
        chunk_type: 0,
        chunk_flags: 0,
        chunk_length: 0,
    };
    if stcb.is_null() {
        return;
    }
    asoc = &mut (*stcb).asoc;
    if (*asoc).pktdrop_supported as libc::c_int == 0i32 {
        /*-
         * peer must declare support before I send one.
         */
        return;
    }
    if (*stcb).sctp_socket.is_null() {
        return;
    }
    if (*stcb).asoc.free_chunks.tqh_first.is_null() {
        chk = malloc(system_base_info.sctppcbinfo.ipi_zone_chunk) as *mut sctp_tmit_chunk;
        if !chk.is_null() {
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctppcbinfo.ipi_count_chunk, 1u32);
            (*chk).whoTo = 0 as *mut sctp_nets;
            (*chk).holds_key_ref = 0u8
        }
    } else {
        chk = (*stcb).asoc.free_chunks.tqh_first;
        if !(*chk).sctp_next.tqe_next.is_null() {
            (*(*chk).sctp_next.tqe_next).sctp_next.tqe_prev = (*chk).sctp_next.tqe_prev
        } else {
            (*stcb).asoc.free_chunks.tqh_last = (*chk).sctp_next.tqe_prev
        }
        *(*chk).sctp_next.tqe_prev = (*chk).sctp_next.tqe_next;
        ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_free_chunks, 1u32);
        (*chk).holds_key_ref = 0u8;
        ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_cached_chk, 1u32);
        (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_sub(1)
    }
    if chk.is_null() {
        return;
    }
    (*chk).copy_by_ref = 0u8;
    (*chk).rec.chunk_id.id = 0x81u8;
    (*chk).rec.chunk_id.can_take_data = 1u8;
    (*chk).flags = 0u16;
    len -= iphlen;
    (*chk).send_size = len as uint16_t;
    /* Validate that we do not have an ABORT in here. */
    offset = (iphlen as libc::c_ulong)
        .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong)
        as libc::c_int;
    ch = sctp_m_getptr(
        m,
        offset,
        ::std::mem::size_of::<sctp_chunkhdr>() as libc::c_int,
        &mut chunk_buf as *mut sctp_chunkhdr as *mut uint8_t,
    ) as *mut sctp_chunkhdr;
    while !ch.is_null() {
        let mut chk_length = 0;
        chk_length = ntohs((*ch).chunk_length) as libc::c_uint;
        if (chk_length as libc::c_ulong) < ::std::mem::size_of::<sctp_chunkhdr>() as libc::c_ulong {
            break;
        }
        match (*ch).chunk_type as libc::c_int {
            129 | 6 | 2 => {
                /* *
                 * We don't respond with an PKT-DROP to an ABORT
                 * or PKT-DROP. We also do not respond to an
                 * INIT-ACK, because we can't know if the initiation
                 * tag is correct or not.
                 */
                if (*chk).holds_key_ref != 0 {
                    sctp_auth_key_release(stcb, (*chk).auth_keyid, 0i32);
                    (*chk).holds_key_ref = 0u8
                }
                if !stcb.is_null() {
                    if !(*chk).whoTo.is_null() {
                        if !(*chk).whoTo.is_null() {
                            if ::std::intrinsics::atomic_xadd(
                                &mut (*(*chk).whoTo).ref_count as *mut libc::c_int,
                                -(1i32),
                            ) == 1i32
                            {
                                sctp_os_timer_stop(&mut (*(*chk).whoTo).rxt_timer.timer);
                                sctp_os_timer_stop(&mut (*(*chk).whoTo).pmtu_timer.timer);
                                sctp_os_timer_stop(&mut (*(*chk).whoTo).hb_timer.timer);
                                if !(*(*chk).whoTo).ro.ro_rt.is_null() {
                                    if (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt <= 1i64 {
                                        sctp_userspace_rtfree((*(*chk).whoTo).ro.ro_rt);
                                    } else {
                                        (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt -= 1
                                    }
                                    (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t;
                                    (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t
                                }
                                if (*(*chk).whoTo).src_addr_selected != 0 {
                                    sctp_free_ifa((*(*chk).whoTo).ro._s_addr);
                                    (*(*chk).whoTo).ro._s_addr = 0 as *mut sctp_ifa
                                }
                                (*(*chk).whoTo).src_addr_selected = 0u8;
                                (*(*chk).whoTo).dest_state =
                                    ((*(*chk).whoTo).dest_state as libc::c_int & !(0x1i32))
                                        as uint16_t;
                                free((*chk).whoTo as *mut libc::c_void);
                                ::std::intrinsics::atomic_xsub(
                                    &mut system_base_info.sctppcbinfo.ipi_count_raddr,
                                    1u32,
                                );
                            }
                        }
                        (*chk).whoTo = 0 as *mut sctp_nets
                    }
                    if (*stcb).asoc.free_chunk_cnt as libc::c_uint
                        > system_base_info.sctpsysctl.sctp_asoc_free_resc_limit
                        || system_base_info.sctppcbinfo.ipi_free_chunks
                            > system_base_info.sctpsysctl.sctp_system_free_resc_limit
                    {
                        free(chk as *mut libc::c_void);
                        ::std::intrinsics::atomic_xsub(
                            &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                            1u32,
                        );
                    } else {
                        (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
                        (*chk).sctp_next.tqe_prev = (*stcb).asoc.free_chunks.tqh_last;
                        *(*stcb).asoc.free_chunks.tqh_last = chk;
                        (*stcb).asoc.free_chunks.tqh_last = &mut (*chk).sctp_next.tqe_next;
                        (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_add(1);
                        ::std::intrinsics::atomic_xadd(
                            &mut system_base_info.sctppcbinfo.ipi_free_chunks,
                            1u32,
                        );
                    }
                } else {
                    free(chk as *mut libc::c_void);
                    ::std::intrinsics::atomic_xsub(
                        &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                        1u32,
                    );
                }
                return;
            }
            _ => {}
        }
        offset = (offset as libc::c_uint)
            .wrapping_add((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
            as libc::c_int;
        ch = sctp_m_getptr(
            m,
            offset,
            ::std::mem::size_of::<sctp_chunkhdr>() as libc::c_int,
            &mut chunk_buf as *mut sctp_chunkhdr as *mut uint8_t,
        ) as *mut sctp_chunkhdr
    }
    if (len as libc::c_ulong)
        .wrapping_add(
            (::std::mem::size_of::<sctp_data_chunk>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<sctp_ecne_chunk>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<sctp_sack_chunk>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<ip6_hdr>() as libc::c_ulong),
        )
        .wrapping_add(::std::mem::size_of::<sctp_pktdrop_chunk>() as libc::c_ulong)
        > (if (*stcb).asoc.smallest_mtu > 2048u32 {
            2048u32
        } else {
            (*stcb).asoc.smallest_mtu
        }) as libc::c_ulong
    {
        /* only send 1 mtu worth, trim off the
         * excess on the end.
         */
        fullsz = len;
        len = ((if (*stcb).asoc.smallest_mtu > 2048u32 {
            2048u32
        } else {
            (*stcb).asoc.smallest_mtu
        }) as libc::c_ulong)
            .wrapping_sub(
                (::std::mem::size_of::<sctp_data_chunk>() as libc::c_ulong)
                    .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong)
                    .wrapping_add(::std::mem::size_of::<sctp_ecne_chunk>() as libc::c_ulong)
                    .wrapping_add(::std::mem::size_of::<sctp_sack_chunk>() as libc::c_ulong)
                    .wrapping_add(::std::mem::size_of::<ip6_hdr>() as libc::c_ulong),
            ) as libc::c_int;
        was_trunc = 1i32
    }
    (*chk).asoc = &mut (*stcb).asoc;
    (*chk).data = sctp_get_mbuf_for_msg(2048u32, 0i32, 0x1i32, 1i32, 1i32);
    if !(*chk).data.is_null() {
        let mut drp = 0 as *mut sctp_pktdrop_chunk;
        (*(*chk).data).m_hdr.mh_data = (*(*chk).data).m_hdr.mh_data.offset(
            (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong)
                as isize,
        );
        drp = (*(*chk).data).m_hdr.mh_data as *mut sctp_pktdrop_chunk;
        if drp.is_null() {
            m_freem((*chk).data);
            (*chk).data = 0 as *mut mbuf
        } else {
            let mut datap = 0 as *mut uint8_t;
            let mut spc = 0;
            (*chk).book_size = ((((*chk).send_size as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<sctp_pktdrop_chunk>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong)
                .wrapping_add(
                    (::std::mem::size_of::<sctp_data_chunk>() as libc::c_ulong)
                        .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong)
                        .wrapping_add(::std::mem::size_of::<ip6_hdr>() as libc::c_ulong),
                )
                .wrapping_add(3u64)
                >> 2i32)
                << 2i32) as uint16_t;
            (*chk).book_size_scale = 0u8;
            if was_trunc != 0 {
                (*drp).ch.chunk_flags = 0x4u8;
                (*drp).trunc_len = htons(fullsz as uint16_t);
                /* Len is already adjusted to size minus overhead above
                 * take out the pkt_drop chunk itself from it.
                 */
                (*chk).send_size = (len as libc::c_ulong)
                    .wrapping_sub(::std::mem::size_of::<sctp_pktdrop_chunk>() as libc::c_ulong)
                    as uint16_t;
                len = (*chk).send_size as libc::c_int
            } else {
                /* no truncation needed */
                (*drp).ch.chunk_flags = 0u8;
                (*drp).trunc_len = htons(0u16)
            }
            if bad_crc != 0 {
                (*drp).ch.chunk_flags = ((*drp).ch.chunk_flags as libc::c_int | 0x2i32) as uint8_t
            }
            (*chk).send_size = ((*chk).send_size as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<sctp_pktdrop_chunk>() as libc::c_ulong)
                as uint16_t;
            (*(*chk).data).m_hdr.mh_len = (*chk).send_size as libc::c_int;
            (*chk).sent = 0i32;
            (*chk).snd_count = 0u16;
            if !net.is_null() {
                /* we should hit here */
                (*chk).whoTo = net;
                ::std::intrinsics::atomic_xadd(&mut (*(*chk).whoTo).ref_count, 1i32);
            } else {
                (*chk).whoTo = 0 as *mut sctp_nets
            }
            (*drp).ch.chunk_type = 0x81u8;
            (*drp).ch.chunk_length = htons((*chk).send_size);
            spc = (*(*stcb).sctp_socket).so_rcv.sb_hiwat as libc::c_long;
            if spc < 0i64 {
                spc = 0i64
            }
            (*drp).bottle_bw = htonl(spc as uint32_t);
            if (*asoc).my_rwnd != 0 {
                (*drp).current_onq = htonl(
                    (*asoc)
                        .size_on_reasm_queue
                        .wrapping_add((*asoc).size_on_all_streams)
                        .wrapping_add((*asoc).my_rwnd_control_len)
                        .wrapping_add((*(*stcb).sctp_socket).so_rcv.sb_cc),
                )
            } else {
                /*-
                 * If my rwnd is 0, possibly from mbuf depletion as well as
                 * space used, tell the peer there is NO space aka onq == bw
                 */
                (*drp).current_onq = htonl(spc as uint32_t)
            }
            (*drp).reserved = 0u16;
            datap = (*drp).data.as_mut_ptr();
            m_copydata(m, iphlen, len, datap as caddr_t);
            (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
            (*chk).sctp_next.tqe_prev = (*stcb).asoc.control_send_queue.tqh_last;
            *(*stcb).asoc.control_send_queue.tqh_last = chk;
            (*stcb).asoc.control_send_queue.tqh_last = &mut (*chk).sctp_next.tqe_next;
            (*asoc).ctrl_queue_cnt += 1;
            return;
        }
    }
    if (*chk).holds_key_ref != 0 {
        sctp_auth_key_release(stcb, (*chk).auth_keyid, 0i32);
        (*chk).holds_key_ref = 0u8
    }
    if !stcb.is_null() {
        if !(*chk).whoTo.is_null() {
            if !(*chk).whoTo.is_null() {
                if ::std::intrinsics::atomic_xadd(
                    &mut (*(*chk).whoTo).ref_count as *mut libc::c_int,
                    -(1i32),
                ) == 1i32
                {
                    sctp_os_timer_stop(&mut (*(*chk).whoTo).rxt_timer.timer);
                    sctp_os_timer_stop(&mut (*(*chk).whoTo).pmtu_timer.timer);
                    sctp_os_timer_stop(&mut (*(*chk).whoTo).hb_timer.timer);
                    if !(*(*chk).whoTo).ro.ro_rt.is_null() {
                        if (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt <= 1i64 {
                            sctp_userspace_rtfree((*(*chk).whoTo).ro.ro_rt);
                        } else {
                            (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt -= 1
                        }
                        (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t;
                        (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t
                    }
                    if (*(*chk).whoTo).src_addr_selected != 0 {
                        sctp_free_ifa((*(*chk).whoTo).ro._s_addr);
                        (*(*chk).whoTo).ro._s_addr = 0 as *mut sctp_ifa
                    }
                    (*(*chk).whoTo).src_addr_selected = 0u8;
                    (*(*chk).whoTo).dest_state =
                        ((*(*chk).whoTo).dest_state as libc::c_int & !(0x1i32)) as uint16_t;
                    free((*chk).whoTo as *mut libc::c_void);
                    ::std::intrinsics::atomic_xsub(
                        &mut system_base_info.sctppcbinfo.ipi_count_raddr,
                        1u32,
                    );
                }
            }
            (*chk).whoTo = 0 as *mut sctp_nets
        }
        if (*stcb).asoc.free_chunk_cnt as libc::c_uint
            > system_base_info.sctpsysctl.sctp_asoc_free_resc_limit
            || system_base_info.sctppcbinfo.ipi_free_chunks
                > system_base_info.sctpsysctl.sctp_system_free_resc_limit
        {
            free(chk as *mut libc::c_void);
            ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_count_chunk, 1u32);
        } else {
            (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
            (*chk).sctp_next.tqe_prev = (*stcb).asoc.free_chunks.tqh_last;
            *(*stcb).asoc.free_chunks.tqh_last = chk;
            (*stcb).asoc.free_chunks.tqh_last = &mut (*chk).sctp_next.tqe_next;
            (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_add(1);
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctppcbinfo.ipi_free_chunks, 1u32);
        }
    } else {
        free(chk as *mut libc::c_void);
        ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_count_chunk, 1u32);
    };
}
#[no_mangle]
pub unsafe extern "C" fn sctp_send_cwr(
    mut stcb: *mut sctp_tcb,
    mut net: *mut sctp_nets,
    mut high_tsn: uint32_t,
    mut override_0: uint8_t,
) {
    let mut asoc = 0 as *mut sctp_association;
    let mut cwr = 0 as *mut sctp_cwr_chunk;
    let mut chk = 0 as *mut sctp_tmit_chunk;
    if net.is_null() {
        return;
    }
    asoc = &mut (*stcb).asoc;
    chk = (*asoc).control_send_queue.tqh_first;
    while !chk.is_null() {
        if (*chk).rec.chunk_id.id as libc::c_int == 0xdi32 && net == (*chk).whoTo {
            let mut ctsn = 0;
            cwr = (*(*chk).data).m_hdr.mh_data as *mut sctp_cwr_chunk;
            ctsn = ntohl((*cwr).tsn);
            if high_tsn < ctsn && ctsn.wrapping_sub(high_tsn) > (1u32) << 31i32
                || high_tsn > ctsn && high_tsn.wrapping_sub(ctsn) < (1u32) << 31i32
            {
                (*cwr).tsn = htonl(high_tsn)
            }
            if override_0 as libc::c_int & 0x1i32 != 0 {
                /* Make sure override is carried */
                (*cwr).ch.chunk_flags = ((*cwr).ch.chunk_flags as libc::c_int | 0x1i32) as uint8_t
            }
            return;
        }
        chk = (*chk).sctp_next.tqe_next
    }
    if (*stcb).asoc.free_chunks.tqh_first.is_null() {
        chk = malloc(system_base_info.sctppcbinfo.ipi_zone_chunk) as *mut sctp_tmit_chunk;
        if !chk.is_null() {
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctppcbinfo.ipi_count_chunk, 1u32);
            (*chk).whoTo = 0 as *mut sctp_nets;
            (*chk).holds_key_ref = 0u8
        }
    } else {
        chk = (*stcb).asoc.free_chunks.tqh_first;
        if !(*chk).sctp_next.tqe_next.is_null() {
            (*(*chk).sctp_next.tqe_next).sctp_next.tqe_prev = (*chk).sctp_next.tqe_prev
        } else {
            (*stcb).asoc.free_chunks.tqh_last = (*chk).sctp_next.tqe_prev
        }
        *(*chk).sctp_next.tqe_prev = (*chk).sctp_next.tqe_next;
        ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_free_chunks, 1u32);
        (*chk).holds_key_ref = 0u8;
        ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_cached_chk, 1u32);
        (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_sub(1)
    }
    if chk.is_null() {
        return;
    }
    (*chk).copy_by_ref = 0u8;
    (*chk).rec.chunk_id.id = 0xdu8;
    (*chk).rec.chunk_id.can_take_data = 1u8;
    (*chk).flags = 0u16;
    (*chk).asoc = &mut (*stcb).asoc;
    (*chk).send_size = ::std::mem::size_of::<sctp_cwr_chunk>() as uint16_t;
    (*chk).data = sctp_get_mbuf_for_msg((*chk).send_size as libc::c_uint, 0i32, 0x1i32, 1i32, 1i32);
    if (*chk).data.is_null() {
        if (*chk).holds_key_ref != 0 {
            sctp_auth_key_release(stcb, (*chk).auth_keyid, 0i32);
            (*chk).holds_key_ref = 0u8
        }
        if !stcb.is_null() {
            if !(*chk).whoTo.is_null() {
                if !(*chk).whoTo.is_null() {
                    if ::std::intrinsics::atomic_xadd(
                        &mut (*(*chk).whoTo).ref_count as *mut libc::c_int,
                        -(1i32),
                    ) == 1i32
                    {
                        sctp_os_timer_stop(&mut (*(*chk).whoTo).rxt_timer.timer);
                        sctp_os_timer_stop(&mut (*(*chk).whoTo).pmtu_timer.timer);
                        sctp_os_timer_stop(&mut (*(*chk).whoTo).hb_timer.timer);
                        if !(*(*chk).whoTo).ro.ro_rt.is_null() {
                            if (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt <= 1i64 {
                                sctp_userspace_rtfree((*(*chk).whoTo).ro.ro_rt);
                            } else {
                                (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt -= 1
                            }
                            (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t;
                            (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t
                        }
                        if (*(*chk).whoTo).src_addr_selected != 0 {
                            sctp_free_ifa((*(*chk).whoTo).ro._s_addr);
                            (*(*chk).whoTo).ro._s_addr = 0 as *mut sctp_ifa
                        }
                        (*(*chk).whoTo).src_addr_selected = 0u8;
                        (*(*chk).whoTo).dest_state =
                            ((*(*chk).whoTo).dest_state as libc::c_int & !(0x1i32)) as uint16_t;
                        free((*chk).whoTo as *mut libc::c_void);
                        ::std::intrinsics::atomic_xsub(
                            &mut system_base_info.sctppcbinfo.ipi_count_raddr,
                            1u32,
                        );
                    }
                }
                (*chk).whoTo = 0 as *mut sctp_nets
            }
            if (*stcb).asoc.free_chunk_cnt as libc::c_uint
                > system_base_info.sctpsysctl.sctp_asoc_free_resc_limit
                || system_base_info.sctppcbinfo.ipi_free_chunks
                    > system_base_info.sctpsysctl.sctp_system_free_resc_limit
            {
                free(chk as *mut libc::c_void);
                ::std::intrinsics::atomic_xsub(
                    &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                    1u32,
                );
            } else {
                (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
                (*chk).sctp_next.tqe_prev = (*stcb).asoc.free_chunks.tqh_last;
                *(*stcb).asoc.free_chunks.tqh_last = chk;
                (*stcb).asoc.free_chunks.tqh_last = &mut (*chk).sctp_next.tqe_next;
                (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_add(1);
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctppcbinfo.ipi_free_chunks,
                    1u32,
                );
            }
        } else {
            free(chk as *mut libc::c_void);
            ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_count_chunk, 1u32);
        }
        return;
    }
    (*(*chk).data).m_hdr.mh_data = (*(*chk).data).m_hdr.mh_data.offset(
        (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong) as isize,
    );
    (*(*chk).data).m_hdr.mh_len = (*chk).send_size as libc::c_int;
    (*chk).sent = 0i32;
    (*chk).snd_count = 0u16;
    (*chk).whoTo = net;
    ::std::intrinsics::atomic_xadd(&mut (*(*chk).whoTo).ref_count, 1i32);
    cwr = (*(*chk).data).m_hdr.mh_data as *mut sctp_cwr_chunk;
    (*cwr).ch.chunk_type = 0xdu8;
    (*cwr).ch.chunk_flags = override_0;
    (*cwr).ch.chunk_length = htons(::std::mem::size_of::<sctp_cwr_chunk>() as uint16_t);
    (*cwr).tsn = htonl(high_tsn);
    (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
    (*chk).sctp_next.tqe_prev = (*stcb).asoc.control_send_queue.tqh_last;
    *(*stcb).asoc.control_send_queue.tqh_last = chk;
    (*stcb).asoc.control_send_queue.tqh_last = &mut (*chk).sctp_next.tqe_next;
    (*asoc).ctrl_queue_cnt += 1;
}
unsafe extern "C" fn sctp_add_stream_reset_out(
    mut stcb: *mut sctp_tcb,
    mut chk: *mut sctp_tmit_chunk,
    mut seq: uint32_t,
    mut resp_seq: uint32_t,
    mut last_sent: uint32_t,
) -> libc::c_int {
    let mut len = 0;
    let mut old_len = 0;
    let mut i = 0;
    let mut req_out = 0 as *mut sctp_stream_reset_out_request;
    let mut ch = 0 as *mut sctp_chunkhdr;
    let mut at = 0;
    let mut number_entries = 0i32;
    ch = (*(*chk).data).m_hdr.mh_data as *mut sctp_chunkhdr;
    len = ((ntohs((*ch).chunk_length) as libc::c_int + 3i32 >> 2i32) << 2i32) as uint16_t;
    old_len = len;
    /* get to new offset for the param. */
    req_out =
        (ch as caddr_t).offset(len as libc::c_int as isize) as *mut sctp_stream_reset_out_request;
    /* now how long will this param be? */
    i = 0u16;
    while (i as libc::c_int) < (*stcb).asoc.streamoutcnt as libc::c_int {
        if (*(*stcb).asoc.strmout.offset(i as isize)).state as libc::c_int == 0x3i32
            && (*(*stcb).asoc.strmout.offset(i as isize)).chunks_on_queues == 0u32
            && (*(*stcb).asoc.strmout.offset(i as isize))
                .outqueue
                .tqh_first
                .is_null()
        {
            number_entries += 1
        }
        i = i.wrapping_add(1)
    }
    if number_entries == 0i32 {
        return 0i32;
    }
    if number_entries == (*stcb).asoc.streamoutcnt as libc::c_int {
        number_entries = 0i32
    }
    if number_entries > 200i32 {
        number_entries = 200i32
    }
    len = (::std::mem::size_of::<sctp_stream_reset_out_request>() as libc::c_ulong).wrapping_add(
        (::std::mem::size_of::<uint16_t>() as libc::c_ulong)
            .wrapping_mul(number_entries as libc::c_ulong),
    ) as uint16_t;
    (*req_out).ph.param_type = htons(0xdu16);
    (*req_out).ph.param_length = htons(len);
    (*req_out).request_seq = htonl(seq);
    (*req_out).response_seq = htonl(resp_seq);
    (*req_out).send_reset_at_tsn = htonl(last_sent);
    at = 0i32;
    if number_entries != 0 {
        i = 0u16;
        while (i as libc::c_int) < (*stcb).asoc.streamoutcnt as libc::c_int {
            if (*(*stcb).asoc.strmout.offset(i as isize)).state as libc::c_int == 0x3i32
                && (*(*stcb).asoc.strmout.offset(i as isize)).chunks_on_queues == 0u32
                && (*(*stcb).asoc.strmout.offset(i as isize))
                    .outqueue
                    .tqh_first
                    .is_null()
            {
                *(*req_out).list_of_streams.as_mut_ptr().offset(at as isize) = htons(i);
                at += 1;
                (*(*stcb).asoc.strmout.offset(i as isize)).state = 0x4u8;
                if at >= number_entries {
                    break;
                }
            }
            i = i.wrapping_add(1)
        }
    } else {
        i = 0u16;
        while (i as libc::c_int) < (*stcb).asoc.streamoutcnt as libc::c_int {
            (*(*stcb).asoc.strmout.offset(i as isize)).state = 0x4u8;
            i = i.wrapping_add(1)
        }
    }
    if (len as libc::c_int + 3i32 >> 2i32) << 2i32 > len as libc::c_int {
        /*-
         * Need to worry about the pad we may end up adding to the
         * end. This is easy since the struct is either aligned to 4
         * bytes or 2 bytes off.
         */
        *(*req_out)
            .list_of_streams
            .as_mut_ptr()
            .offset(number_entries as isize) = 0u16
    }
    /* now fix the chunk length */
    (*ch).chunk_length = htons((len as libc::c_int + old_len as libc::c_int) as uint16_t);
    (*chk).book_size = (len as libc::c_int + old_len as libc::c_int) as uint16_t;
    (*chk).book_size_scale = 0u8;
    (*chk).send_size = (((*chk).book_size as libc::c_int + 3i32 >> 2i32) << 2i32) as uint16_t;
    (*(*chk).data).m_hdr.mh_len = (*chk).send_size as libc::c_int;
    return 1i32;
}
unsafe extern "C" fn sctp_add_stream_reset_in(
    mut chk: *mut sctp_tmit_chunk,
    mut number_entries: libc::c_int,
    mut list: *mut uint16_t,
    mut seq: uint32_t,
) {
    let mut len = 0;
    let mut old_len = 0;
    let mut req_in = 0 as *mut sctp_stream_reset_in_request;
    let mut ch = 0 as *mut sctp_chunkhdr;
    ch = (*(*chk).data).m_hdr.mh_data as *mut sctp_chunkhdr;
    len = ((ntohs((*ch).chunk_length) as libc::c_int + 3i32 >> 2i32) << 2i32) as uint16_t;
    old_len = len;
    /* get to new offset for the param. */
    req_in =
        (ch as caddr_t).offset(len as libc::c_int as isize) as *mut sctp_stream_reset_in_request;
    /* now how long will this param be? */
    len = (::std::mem::size_of::<sctp_stream_reset_in_request>() as libc::c_ulong).wrapping_add(
        (::std::mem::size_of::<uint16_t>() as libc::c_ulong)
            .wrapping_mul(number_entries as libc::c_ulong),
    ) as uint16_t;
    (*req_in).ph.param_type = htons(0xeu16);
    (*req_in).ph.param_length = htons(len);
    (*req_in).request_seq = htonl(seq);
    if number_entries != 0 {
        let mut i = 0;
        i = 0u16;
        while (i as libc::c_int) < number_entries {
            *(*req_in).list_of_streams.as_mut_ptr().offset(i as isize) =
                htons(*list.offset(i as isize));
            i = i.wrapping_add(1)
        }
    }
    if (len as libc::c_int + 3i32 >> 2i32) << 2i32 > len as libc::c_int {
        /*-
         * Need to worry about the pad we may end up adding to the
         * end. This is easy since the struct is either aligned to 4
         * bytes or 2 bytes off.
         */
        *(*req_in)
            .list_of_streams
            .as_mut_ptr()
            .offset(number_entries as isize) = 0u16
    }
    /* now fix the chunk length */
    (*ch).chunk_length = htons((len as libc::c_int + old_len as libc::c_int) as uint16_t);
    (*chk).book_size = (len as libc::c_int + old_len as libc::c_int) as uint16_t;
    (*chk).book_size_scale = 0u8;
    (*chk).send_size = (((*chk).book_size as libc::c_int + 3i32 >> 2i32) << 2i32) as uint16_t;
    (*(*chk).data).m_hdr.mh_len = (*chk).send_size as libc::c_int;
}
unsafe extern "C" fn sctp_add_stream_reset_tsn(mut chk: *mut sctp_tmit_chunk, mut seq: uint32_t) {
    let mut len = 0;
    let mut old_len = 0;
    let mut req_tsn = 0 as *mut sctp_stream_reset_tsn_request;
    let mut ch = 0 as *mut sctp_chunkhdr;
    ch = (*(*chk).data).m_hdr.mh_data as *mut sctp_chunkhdr;
    len = ((ntohs((*ch).chunk_length) as libc::c_int + 3i32 >> 2i32) << 2i32) as uint16_t;
    old_len = len;
    /* get to new offset for the param. */
    req_tsn =
        (ch as caddr_t).offset(len as libc::c_int as isize) as *mut sctp_stream_reset_tsn_request;
    /* now how long will this param be? */
    len = ::std::mem::size_of::<sctp_stream_reset_tsn_request>() as uint16_t;
    (*req_tsn).ph.param_type = htons(0xfu16);
    (*req_tsn).ph.param_length = htons(len);
    (*req_tsn).request_seq = htonl(seq);
    /* now fix the chunk length */
    (*ch).chunk_length = htons((len as libc::c_int + old_len as libc::c_int) as uint16_t);
    (*chk).send_size = (len as libc::c_int + old_len as libc::c_int) as uint16_t;
    (*chk).book_size = (((*chk).send_size as libc::c_int + 3i32 >> 2i32) << 2i32) as uint16_t;
    (*chk).book_size_scale = 0u8;
    (*(*chk).data).m_hdr.mh_len = ((*chk).send_size as libc::c_int + 3i32 >> 2i32) << 2i32;
}
#[no_mangle]
pub unsafe extern "C" fn sctp_add_stream_reset_result(
    mut chk: *mut sctp_tmit_chunk,
    mut resp_seq: uint32_t,
    mut result: uint32_t,
) {
    let mut len = 0;
    let mut old_len = 0;
    let mut resp = 0 as *mut sctp_stream_reset_response;
    let mut ch = 0 as *mut sctp_chunkhdr;
    ch = (*(*chk).data).m_hdr.mh_data as *mut sctp_chunkhdr;
    len = ((ntohs((*ch).chunk_length) as libc::c_int + 3i32 >> 2i32) << 2i32) as uint16_t;
    old_len = len;
    /* get to new offset for the param. */
    resp = (ch as caddr_t).offset(len as libc::c_int as isize) as *mut sctp_stream_reset_response;
    /* now how long will this param be? */
    len = ::std::mem::size_of::<sctp_stream_reset_response>() as uint16_t;
    (*resp).ph.param_type = htons(0x10u16);
    (*resp).ph.param_length = htons(len);
    (*resp).response_seq = htonl(resp_seq);
    (*resp).result = ntohl(result);
    /* now fix the chunk length */
    (*ch).chunk_length = htons((len as libc::c_int + old_len as libc::c_int) as uint16_t);
    (*chk).book_size = (len as libc::c_int + old_len as libc::c_int) as uint16_t;
    (*chk).book_size_scale = 0u8;
    (*chk).send_size = (((*chk).book_size as libc::c_int + 3i32 >> 2i32) << 2i32) as uint16_t;
    (*(*chk).data).m_hdr.mh_len = (*chk).send_size as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn sctp_send_deferred_reset_response(
    mut stcb: *mut sctp_tcb,
    mut ent: *mut sctp_stream_reset_list,
    mut response: libc::c_int,
) {
    let mut asoc = 0 as *mut sctp_association;
    let mut chk = 0 as *mut sctp_tmit_chunk;
    let mut ch = 0 as *mut sctp_chunkhdr;
    asoc = &mut (*stcb).asoc;
    /*
     * Reset our last reset action to the new one IP -> response
     * (PERFORMED probably). This assures that if we fail to send, a
     * retran from the peer will get the new response.
     */
    (*asoc).last_reset_action[0usize] = response as uint32_t;
    if (*asoc).stream_reset_outstanding != 0 {
        return;
    }
    if (*stcb).asoc.free_chunks.tqh_first.is_null() {
        chk = malloc(system_base_info.sctppcbinfo.ipi_zone_chunk) as *mut sctp_tmit_chunk;
        if !chk.is_null() {
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctppcbinfo.ipi_count_chunk, 1u32);
            (*chk).whoTo = 0 as *mut sctp_nets;
            (*chk).holds_key_ref = 0u8
        }
    } else {
        chk = (*stcb).asoc.free_chunks.tqh_first;
        if !(*chk).sctp_next.tqe_next.is_null() {
            (*(*chk).sctp_next.tqe_next).sctp_next.tqe_prev = (*chk).sctp_next.tqe_prev
        } else {
            (*stcb).asoc.free_chunks.tqh_last = (*chk).sctp_next.tqe_prev
        }
        *(*chk).sctp_next.tqe_prev = (*chk).sctp_next.tqe_next;
        ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_free_chunks, 1u32);
        (*chk).holds_key_ref = 0u8;
        ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_cached_chk, 1u32);
        (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_sub(1)
    }
    if chk.is_null() {
        return;
    }
    (*chk).copy_by_ref = 0u8;
    (*chk).rec.chunk_id.id = 0x82u8;
    (*chk).rec.chunk_id.can_take_data = 0u8;
    (*chk).flags = 0u16;
    (*chk).asoc = &mut (*stcb).asoc;
    (*chk).book_size = ::std::mem::size_of::<sctp_chunkhdr>() as uint16_t;
    (*chk).send_size = (((*chk).book_size as libc::c_int + 3i32 >> 2i32) << 2i32) as uint16_t;
    (*chk).book_size_scale = 0u8;
    (*chk).data = sctp_get_mbuf_for_msg(2048u32, 0i32, 0x1i32, 1i32, 1i32);
    if (*chk).data.is_null() {
        if (*chk).holds_key_ref != 0 {
            sctp_auth_key_release(stcb, (*chk).auth_keyid, 1i32);
            (*chk).holds_key_ref = 0u8
        }
        if !stcb.is_null() {
            if !(*chk).whoTo.is_null() {
                if !(*chk).whoTo.is_null() {
                    if ::std::intrinsics::atomic_xadd(
                        &mut (*(*chk).whoTo).ref_count as *mut libc::c_int,
                        -(1i32),
                    ) == 1i32
                    {
                        sctp_os_timer_stop(&mut (*(*chk).whoTo).rxt_timer.timer);
                        sctp_os_timer_stop(&mut (*(*chk).whoTo).pmtu_timer.timer);
                        sctp_os_timer_stop(&mut (*(*chk).whoTo).hb_timer.timer);
                        if !(*(*chk).whoTo).ro.ro_rt.is_null() {
                            if (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt <= 1i64 {
                                sctp_userspace_rtfree((*(*chk).whoTo).ro.ro_rt);
                            } else {
                                (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt -= 1
                            }
                            (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t;
                            (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t
                        }
                        if (*(*chk).whoTo).src_addr_selected != 0 {
                            sctp_free_ifa((*(*chk).whoTo).ro._s_addr);
                            (*(*chk).whoTo).ro._s_addr = 0 as *mut sctp_ifa
                        }
                        (*(*chk).whoTo).src_addr_selected = 0u8;
                        (*(*chk).whoTo).dest_state =
                            ((*(*chk).whoTo).dest_state as libc::c_int & !(0x1i32)) as uint16_t;
                        free((*chk).whoTo as *mut libc::c_void);
                        ::std::intrinsics::atomic_xsub(
                            &mut system_base_info.sctppcbinfo.ipi_count_raddr,
                            1u32,
                        );
                    }
                }
                (*chk).whoTo = 0 as *mut sctp_nets
            }
            if (*stcb).asoc.free_chunk_cnt as libc::c_uint
                > system_base_info.sctpsysctl.sctp_asoc_free_resc_limit
                || system_base_info.sctppcbinfo.ipi_free_chunks
                    > system_base_info.sctpsysctl.sctp_system_free_resc_limit
            {
                free(chk as *mut libc::c_void);
                ::std::intrinsics::atomic_xsub(
                    &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                    1u32,
                );
            } else {
                (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
                (*chk).sctp_next.tqe_prev = (*stcb).asoc.free_chunks.tqh_last;
                *(*stcb).asoc.free_chunks.tqh_last = chk;
                (*stcb).asoc.free_chunks.tqh_last = &mut (*chk).sctp_next.tqe_next;
                (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_add(1);
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctppcbinfo.ipi_free_chunks,
                    1u32,
                );
            }
        } else {
            free(chk as *mut libc::c_void);
            ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_count_chunk, 1u32);
        }
        return;
    }
    (*(*chk).data).m_hdr.mh_data = (*(*chk).data).m_hdr.mh_data.offset(
        (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong) as isize,
    );
    /* setup chunk parameters */
    (*chk).sent = 0i32;
    (*chk).snd_count = 0u16;
    if !(*stcb).asoc.alternate.is_null() {
        (*chk).whoTo = (*stcb).asoc.alternate
    } else {
        (*chk).whoTo = (*stcb).asoc.primary_destination
    }
    ch = (*(*chk).data).m_hdr.mh_data as *mut sctp_chunkhdr;
    (*ch).chunk_type = 0x82u8;
    (*ch).chunk_flags = 0u8;
    (*ch).chunk_length = htons((*chk).book_size);
    ::std::intrinsics::atomic_xadd(&mut (*(*chk).whoTo).ref_count, 1i32);
    (*(*chk).data).m_hdr.mh_len = (*chk).send_size as libc::c_int;
    sctp_add_stream_reset_result(chk, (*ent).seq, response as uint32_t);
    /* insert the chunk for sending */
    (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
    (*chk).sctp_next.tqe_prev = (*asoc).control_send_queue.tqh_last;
    *(*asoc).control_send_queue.tqh_last = chk;
    (*asoc).control_send_queue.tqh_last = &mut (*chk).sctp_next.tqe_next;
    (*asoc).ctrl_queue_cnt += 1;
}
#[no_mangle]
pub unsafe extern "C" fn sctp_add_stream_reset_result_tsn(
    mut chk: *mut sctp_tmit_chunk,
    mut resp_seq: uint32_t,
    mut result: uint32_t,
    mut send_una: uint32_t,
    mut recv_next: uint32_t,
) {
    let mut len = 0;
    let mut old_len = 0;
    let mut resp = 0 as *mut sctp_stream_reset_response_tsn;
    let mut ch = 0 as *mut sctp_chunkhdr;
    ch = (*(*chk).data).m_hdr.mh_data as *mut sctp_chunkhdr;
    len = ((ntohs((*ch).chunk_length) as libc::c_int + 3i32 >> 2i32) << 2i32) as uint16_t;
    old_len = len;
    /* get to new offset for the param. */
    resp =
        (ch as caddr_t).offset(len as libc::c_int as isize) as *mut sctp_stream_reset_response_tsn;
    /* now how long will this param be? */
    len = ::std::mem::size_of::<sctp_stream_reset_response_tsn>() as uint16_t;
    (*resp).ph.param_type = htons(0x10u16);
    (*resp).ph.param_length = htons(len);
    (*resp).response_seq = htonl(resp_seq);
    (*resp).result = htonl(result);
    (*resp).senders_next_tsn = htonl(send_una);
    (*resp).receivers_next_tsn = htonl(recv_next);
    /* now fix the chunk length */
    (*ch).chunk_length = htons((len as libc::c_int + old_len as libc::c_int) as uint16_t);
    (*chk).book_size = (len as libc::c_int + old_len as libc::c_int) as uint16_t;
    (*chk).send_size = (((*chk).book_size as libc::c_int + 3i32 >> 2i32) << 2i32) as uint16_t;
    (*chk).book_size_scale = 0u8;
    (*(*chk).data).m_hdr.mh_len = (*chk).send_size as libc::c_int;
}
unsafe extern "C" fn sctp_add_an_out_stream(
    mut chk: *mut sctp_tmit_chunk,
    mut seq: uint32_t,
    mut adding: uint16_t,
) {
    let mut len = 0;
    let mut old_len = 0;
    let mut ch = 0 as *mut sctp_chunkhdr;
    let mut addstr = 0 as *mut sctp_stream_reset_add_strm;
    ch = (*(*chk).data).m_hdr.mh_data as *mut sctp_chunkhdr;
    len = ((ntohs((*ch).chunk_length) as libc::c_int + 3i32 >> 2i32) << 2i32) as uint16_t;
    old_len = len;
    /* get to new offset for the param. */
    addstr = (ch as caddr_t).offset(len as libc::c_int as isize) as *mut sctp_stream_reset_add_strm;
    /* now how long will this param be? */
    len = ::std::mem::size_of::<sctp_stream_reset_add_strm>() as uint16_t;
    /* Fill it out. */
    (*addstr).ph.param_type = htons(0x11u16);
    (*addstr).ph.param_length = htons(len);
    (*addstr).request_seq = htonl(seq);
    (*addstr).number_of_streams = htons(adding);
    (*addstr).reserved = 0u16;
    /* now fix the chunk length */
    (*ch).chunk_length = htons((len as libc::c_int + old_len as libc::c_int) as uint16_t);
    (*chk).send_size = (len as libc::c_int + old_len as libc::c_int) as uint16_t;
    (*chk).book_size = (((*chk).send_size as libc::c_int + 3i32 >> 2i32) << 2i32) as uint16_t;
    (*chk).book_size_scale = 0u8;
    (*(*chk).data).m_hdr.mh_len = ((*chk).send_size as libc::c_int + 3i32 >> 2i32) << 2i32;
}
unsafe extern "C" fn sctp_add_an_in_stream(
    mut chk: *mut sctp_tmit_chunk,
    mut seq: uint32_t,
    mut adding: uint16_t,
) {
    let mut len = 0;
    let mut old_len = 0;
    let mut ch = 0 as *mut sctp_chunkhdr;
    let mut addstr = 0 as *mut sctp_stream_reset_add_strm;
    ch = (*(*chk).data).m_hdr.mh_data as *mut sctp_chunkhdr;
    len = ((ntohs((*ch).chunk_length) as libc::c_int + 3i32 >> 2i32) << 2i32) as uint16_t;
    old_len = len;
    /* get to new offset for the param. */
    addstr = (ch as caddr_t).offset(len as libc::c_int as isize) as *mut sctp_stream_reset_add_strm;
    /* now how long will this param be? */
    len = ::std::mem::size_of::<sctp_stream_reset_add_strm>() as uint16_t;
    /* Fill it out. */
    (*addstr).ph.param_type = htons(0x12u16);
    (*addstr).ph.param_length = htons(len);
    (*addstr).request_seq = htonl(seq);
    (*addstr).number_of_streams = htons(adding);
    (*addstr).reserved = 0u16;
    /* now fix the chunk length */
    (*ch).chunk_length = htons((len as libc::c_int + old_len as libc::c_int) as uint16_t);
    (*chk).send_size = (len as libc::c_int + old_len as libc::c_int) as uint16_t;
    (*chk).book_size = (((*chk).send_size as libc::c_int + 3i32 >> 2i32) << 2i32) as uint16_t;
    (*chk).book_size_scale = 0u8;
    (*(*chk).data).m_hdr.mh_len = ((*chk).send_size as libc::c_int + 3i32 >> 2i32) << 2i32;
}
#[no_mangle]
pub unsafe extern "C" fn sctp_send_stream_reset_out_if_possible(
    mut stcb: *mut sctp_tcb,
    mut so_locked: libc::c_int,
) -> libc::c_int {
    let mut asoc = 0 as *mut sctp_association;
    let mut chk = 0 as *mut sctp_tmit_chunk;
    let mut ch = 0 as *mut sctp_chunkhdr;
    let mut seq = 0;
    asoc = &mut (*stcb).asoc;
    (*asoc).trigger_reset = 0u8;
    if (*asoc).stream_reset_outstanding != 0 {
        return 114i32;
    }
    if (*stcb).asoc.free_chunks.tqh_first.is_null() {
        chk = malloc(system_base_info.sctppcbinfo.ipi_zone_chunk) as *mut sctp_tmit_chunk;
        if !chk.is_null() {
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctppcbinfo.ipi_count_chunk, 1u32);
            (*chk).whoTo = 0 as *mut sctp_nets;
            (*chk).holds_key_ref = 0u8
        }
    } else {
        chk = (*stcb).asoc.free_chunks.tqh_first;
        if !(*chk).sctp_next.tqe_next.is_null() {
            (*(*chk).sctp_next.tqe_next).sctp_next.tqe_prev = (*chk).sctp_next.tqe_prev
        } else {
            (*stcb).asoc.free_chunks.tqh_last = (*chk).sctp_next.tqe_prev
        }
        *(*chk).sctp_next.tqe_prev = (*chk).sctp_next.tqe_next;
        ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_free_chunks, 1u32);
        (*chk).holds_key_ref = 0u8;
        ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_cached_chk, 1u32);
        (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_sub(1)
    }
    if chk.is_null() {
        return 12i32;
    }
    (*chk).copy_by_ref = 0u8;
    (*chk).rec.chunk_id.id = 0x82u8;
    (*chk).rec.chunk_id.can_take_data = 0u8;
    (*chk).flags = 0u16;
    (*chk).asoc = &mut (*stcb).asoc;
    (*chk).book_size = ::std::mem::size_of::<sctp_chunkhdr>() as uint16_t;
    (*chk).send_size = (((*chk).book_size as libc::c_int + 3i32 >> 2i32) << 2i32) as uint16_t;
    (*chk).book_size_scale = 0u8;
    (*chk).data = sctp_get_mbuf_for_msg(2048u32, 0i32, 0x1i32, 1i32, 1i32);
    if (*chk).data.is_null() {
        if (*chk).holds_key_ref != 0 {
            sctp_auth_key_release(stcb, (*chk).auth_keyid, so_locked);
            (*chk).holds_key_ref = 0u8
        }
        if !stcb.is_null() {
            if !(*chk).whoTo.is_null() {
                if !(*chk).whoTo.is_null() {
                    if ::std::intrinsics::atomic_xadd(
                        &mut (*(*chk).whoTo).ref_count as *mut libc::c_int,
                        -(1i32),
                    ) == 1i32
                    {
                        sctp_os_timer_stop(&mut (*(*chk).whoTo).rxt_timer.timer);
                        sctp_os_timer_stop(&mut (*(*chk).whoTo).pmtu_timer.timer);
                        sctp_os_timer_stop(&mut (*(*chk).whoTo).hb_timer.timer);
                        if !(*(*chk).whoTo).ro.ro_rt.is_null() {
                            if (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt <= 1i64 {
                                sctp_userspace_rtfree((*(*chk).whoTo).ro.ro_rt);
                            } else {
                                (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt -= 1
                            }
                            (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t;
                            (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t
                        }
                        if (*(*chk).whoTo).src_addr_selected != 0 {
                            sctp_free_ifa((*(*chk).whoTo).ro._s_addr);
                            (*(*chk).whoTo).ro._s_addr = 0 as *mut sctp_ifa
                        }
                        (*(*chk).whoTo).src_addr_selected = 0u8;
                        (*(*chk).whoTo).dest_state =
                            ((*(*chk).whoTo).dest_state as libc::c_int & !(0x1i32)) as uint16_t;
                        free((*chk).whoTo as *mut libc::c_void);
                        ::std::intrinsics::atomic_xsub(
                            &mut system_base_info.sctppcbinfo.ipi_count_raddr,
                            1u32,
                        );
                    }
                }
                (*chk).whoTo = 0 as *mut sctp_nets
            }
            if (*stcb).asoc.free_chunk_cnt as libc::c_uint
                > system_base_info.sctpsysctl.sctp_asoc_free_resc_limit
                || system_base_info.sctppcbinfo.ipi_free_chunks
                    > system_base_info.sctpsysctl.sctp_system_free_resc_limit
            {
                free(chk as *mut libc::c_void);
                ::std::intrinsics::atomic_xsub(
                    &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                    1u32,
                );
            } else {
                (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
                (*chk).sctp_next.tqe_prev = (*stcb).asoc.free_chunks.tqh_last;
                *(*stcb).asoc.free_chunks.tqh_last = chk;
                (*stcb).asoc.free_chunks.tqh_last = &mut (*chk).sctp_next.tqe_next;
                (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_add(1);
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctppcbinfo.ipi_free_chunks,
                    1u32,
                );
            }
        } else {
            free(chk as *mut libc::c_void);
            ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_count_chunk, 1u32);
        }
        return 12i32;
    }
    (*(*chk).data).m_hdr.mh_data = (*(*chk).data).m_hdr.mh_data.offset(
        (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong) as isize,
    );
    /* setup chunk parameters */
    (*chk).sent = 0i32;
    (*chk).snd_count = 0u16;
    if !(*stcb).asoc.alternate.is_null() {
        (*chk).whoTo = (*stcb).asoc.alternate
    } else {
        (*chk).whoTo = (*stcb).asoc.primary_destination
    }
    ch = (*(*chk).data).m_hdr.mh_data as *mut sctp_chunkhdr;
    (*ch).chunk_type = 0x82u8;
    (*ch).chunk_flags = 0u8;
    (*ch).chunk_length = htons((*chk).book_size);
    ::std::intrinsics::atomic_xadd(&mut (*(*chk).whoTo).ref_count, 1i32);
    (*(*chk).data).m_hdr.mh_len = (*chk).send_size as libc::c_int;
    seq = (*stcb).asoc.str_reset_seq_out;
    if sctp_add_stream_reset_out(
        stcb,
        chk,
        seq,
        (*stcb).asoc.str_reset_seq_in.wrapping_sub(1u32),
        (*stcb).asoc.sending_seq.wrapping_sub(1u32),
    ) != 0
    {
        seq = seq.wrapping_add(1);
        (*asoc).stream_reset_outstanding = (*asoc).stream_reset_outstanding.wrapping_add(1)
    } else {
        m_freem((*chk).data);
        (*chk).data = 0 as *mut mbuf;
        if (*chk).holds_key_ref != 0 {
            sctp_auth_key_release(stcb, (*chk).auth_keyid, so_locked);
            (*chk).holds_key_ref = 0u8
        }
        if !stcb.is_null() {
            if !(*chk).whoTo.is_null() {
                if !(*chk).whoTo.is_null() {
                    if ::std::intrinsics::atomic_xadd(
                        &mut (*(*chk).whoTo).ref_count as *mut libc::c_int,
                        -(1i32),
                    ) == 1i32
                    {
                        sctp_os_timer_stop(&mut (*(*chk).whoTo).rxt_timer.timer);
                        sctp_os_timer_stop(&mut (*(*chk).whoTo).pmtu_timer.timer);
                        sctp_os_timer_stop(&mut (*(*chk).whoTo).hb_timer.timer);
                        if !(*(*chk).whoTo).ro.ro_rt.is_null() {
                            if (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt <= 1i64 {
                                sctp_userspace_rtfree((*(*chk).whoTo).ro.ro_rt);
                            } else {
                                (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt -= 1
                            }
                            (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t;
                            (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t
                        }
                        if (*(*chk).whoTo).src_addr_selected != 0 {
                            sctp_free_ifa((*(*chk).whoTo).ro._s_addr);
                            (*(*chk).whoTo).ro._s_addr = 0 as *mut sctp_ifa
                        }
                        (*(*chk).whoTo).src_addr_selected = 0u8;
                        (*(*chk).whoTo).dest_state =
                            ((*(*chk).whoTo).dest_state as libc::c_int & !(0x1i32)) as uint16_t;
                        free((*chk).whoTo as *mut libc::c_void);
                        ::std::intrinsics::atomic_xsub(
                            &mut system_base_info.sctppcbinfo.ipi_count_raddr,
                            1u32,
                        );
                    }
                }
                (*chk).whoTo = 0 as *mut sctp_nets
            }
            if (*stcb).asoc.free_chunk_cnt as libc::c_uint
                > system_base_info.sctpsysctl.sctp_asoc_free_resc_limit
                || system_base_info.sctppcbinfo.ipi_free_chunks
                    > system_base_info.sctpsysctl.sctp_system_free_resc_limit
            {
                free(chk as *mut libc::c_void);
                ::std::intrinsics::atomic_xsub(
                    &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                    1u32,
                );
            } else {
                (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
                (*chk).sctp_next.tqe_prev = (*stcb).asoc.free_chunks.tqh_last;
                *(*stcb).asoc.free_chunks.tqh_last = chk;
                (*stcb).asoc.free_chunks.tqh_last = &mut (*chk).sctp_next.tqe_next;
                (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_add(1);
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctppcbinfo.ipi_free_chunks,
                    1u32,
                );
            }
        } else {
            free(chk as *mut libc::c_void);
            ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_count_chunk, 1u32);
        }
        return 2i32;
    }
    (*asoc).str_reset = chk;
    /* insert the chunk for sending */
    (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
    (*chk).sctp_next.tqe_prev = (*asoc).control_send_queue.tqh_last;
    *(*asoc).control_send_queue.tqh_last = chk;
    (*asoc).control_send_queue.tqh_last = &mut (*chk).sctp_next.tqe_next;
    (*asoc).ctrl_queue_cnt += 1;
    if (*stcb).asoc.send_sack != 0 {
        sctp_send_sack(stcb, so_locked);
    }
    sctp_timer_start(14i32, (*stcb).sctp_ep, stcb, (*chk).whoTo);
    return 0i32;
}
#[no_mangle]
pub unsafe extern "C" fn sctp_send_str_reset_req(
    mut stcb: *mut sctp_tcb,
    mut number_entries: uint16_t,
    mut list: *mut uint16_t,
    mut send_in_req: uint8_t,
    mut send_tsn_req: uint8_t,
    mut add_stream: uint8_t,
    mut adding_o: uint16_t,
    mut adding_i: uint16_t,
    mut peer_asked: uint8_t,
) -> libc::c_int {
    let mut asoc = 0 as *mut sctp_association;
    let mut chk = 0 as *mut sctp_tmit_chunk;
    let mut ch = 0 as *mut sctp_chunkhdr;
    let mut can_send_out_req = 0i32;
    let mut seq = 0;
    asoc = &mut (*stcb).asoc;
    if (*asoc).stream_reset_outstanding != 0 {
        /*-
         * Already one pending, must get ACK back to clear the flag.
         */
        return 16i32;
    }
    if send_in_req as libc::c_int == 0i32
        && send_tsn_req as libc::c_int == 0i32
        && add_stream as libc::c_int == 0i32
    {
        /* nothing to do */
        return 22i32;
    }
    if send_tsn_req as libc::c_int != 0 && send_in_req as libc::c_int != 0 {
        /* error, can't do that */
        return 22i32;
    } else {
        if send_in_req != 0 {
            can_send_out_req = 1i32
        }
    }
    if number_entries as libc::c_ulong
        > (2048u64)
            .wrapping_sub(
                (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
                    .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong),
            )
            .wrapping_sub(::std::mem::size_of::<sctp_chunkhdr>() as libc::c_ulong)
            .wrapping_sub(::std::mem::size_of::<sctp_stream_reset_out_request>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<uint16_t>() as libc::c_ulong)
    {
        return 12i32;
    }
    if (*stcb).asoc.free_chunks.tqh_first.is_null() {
        chk = malloc(system_base_info.sctppcbinfo.ipi_zone_chunk) as *mut sctp_tmit_chunk;
        if !chk.is_null() {
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctppcbinfo.ipi_count_chunk, 1u32);
            (*chk).whoTo = 0 as *mut sctp_nets;
            (*chk).holds_key_ref = 0u8
        }
    } else {
        chk = (*stcb).asoc.free_chunks.tqh_first;
        if !(*chk).sctp_next.tqe_next.is_null() {
            (*(*chk).sctp_next.tqe_next).sctp_next.tqe_prev = (*chk).sctp_next.tqe_prev
        } else {
            (*stcb).asoc.free_chunks.tqh_last = (*chk).sctp_next.tqe_prev
        }
        *(*chk).sctp_next.tqe_prev = (*chk).sctp_next.tqe_next;
        ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_free_chunks, 1u32);
        (*chk).holds_key_ref = 0u8;
        ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_cached_chk, 1u32);
        (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_sub(1)
    }
    if chk.is_null() {
        return 12i32;
    }
    (*chk).copy_by_ref = 0u8;
    (*chk).rec.chunk_id.id = 0x82u8;
    (*chk).rec.chunk_id.can_take_data = 0u8;
    (*chk).flags = 0u16;
    (*chk).asoc = &mut (*stcb).asoc;
    (*chk).book_size = ::std::mem::size_of::<sctp_chunkhdr>() as uint16_t;
    (*chk).send_size = (((*chk).book_size as libc::c_int + 3i32 >> 2i32) << 2i32) as uint16_t;
    (*chk).book_size_scale = 0u8;
    (*chk).data = sctp_get_mbuf_for_msg(2048u32, 0i32, 0x1i32, 1i32, 1i32);
    if (*chk).data.is_null() {
        if (*chk).holds_key_ref != 0 {
            sctp_auth_key_release(stcb, (*chk).auth_keyid, 1i32);
            (*chk).holds_key_ref = 0u8
        }
        if !stcb.is_null() {
            if !(*chk).whoTo.is_null() {
                if !(*chk).whoTo.is_null() {
                    if ::std::intrinsics::atomic_xadd(
                        &mut (*(*chk).whoTo).ref_count as *mut libc::c_int,
                        -(1i32),
                    ) == 1i32
                    {
                        sctp_os_timer_stop(&mut (*(*chk).whoTo).rxt_timer.timer);
                        sctp_os_timer_stop(&mut (*(*chk).whoTo).pmtu_timer.timer);
                        sctp_os_timer_stop(&mut (*(*chk).whoTo).hb_timer.timer);
                        if !(*(*chk).whoTo).ro.ro_rt.is_null() {
                            if (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt <= 1i64 {
                                sctp_userspace_rtfree((*(*chk).whoTo).ro.ro_rt);
                            } else {
                                (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt -= 1
                            }
                            (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t;
                            (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t
                        }
                        if (*(*chk).whoTo).src_addr_selected != 0 {
                            sctp_free_ifa((*(*chk).whoTo).ro._s_addr);
                            (*(*chk).whoTo).ro._s_addr = 0 as *mut sctp_ifa
                        }
                        (*(*chk).whoTo).src_addr_selected = 0u8;
                        (*(*chk).whoTo).dest_state =
                            ((*(*chk).whoTo).dest_state as libc::c_int & !(0x1i32)) as uint16_t;
                        free((*chk).whoTo as *mut libc::c_void);
                        ::std::intrinsics::atomic_xsub(
                            &mut system_base_info.sctppcbinfo.ipi_count_raddr,
                            1u32,
                        );
                    }
                }
                (*chk).whoTo = 0 as *mut sctp_nets
            }
            if (*stcb).asoc.free_chunk_cnt as libc::c_uint
                > system_base_info.sctpsysctl.sctp_asoc_free_resc_limit
                || system_base_info.sctppcbinfo.ipi_free_chunks
                    > system_base_info.sctpsysctl.sctp_system_free_resc_limit
            {
                free(chk as *mut libc::c_void);
                ::std::intrinsics::atomic_xsub(
                    &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                    1u32,
                );
            } else {
                (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
                (*chk).sctp_next.tqe_prev = (*stcb).asoc.free_chunks.tqh_last;
                *(*stcb).asoc.free_chunks.tqh_last = chk;
                (*stcb).asoc.free_chunks.tqh_last = &mut (*chk).sctp_next.tqe_next;
                (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_add(1);
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctppcbinfo.ipi_free_chunks,
                    1u32,
                );
            }
        } else {
            free(chk as *mut libc::c_void);
            ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_count_chunk, 1u32);
        }
        return 12i32;
    }
    (*(*chk).data).m_hdr.mh_data = (*(*chk).data).m_hdr.mh_data.offset(
        (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong) as isize,
    );
    /* setup chunk parameters */
    (*chk).sent = 0i32;
    (*chk).snd_count = 0u16;
    if !(*stcb).asoc.alternate.is_null() {
        (*chk).whoTo = (*stcb).asoc.alternate
    } else {
        (*chk).whoTo = (*stcb).asoc.primary_destination
    }
    ::std::intrinsics::atomic_xadd(&mut (*(*chk).whoTo).ref_count, 1i32);
    ch = (*(*chk).data).m_hdr.mh_data as *mut sctp_chunkhdr;
    (*ch).chunk_type = 0x82u8;
    (*ch).chunk_flags = 0u8;
    (*ch).chunk_length = htons((*chk).book_size);
    (*(*chk).data).m_hdr.mh_len = (*chk).send_size as libc::c_int;
    seq = (*stcb).asoc.str_reset_seq_out;
    if can_send_out_req != 0 {
        let mut ret = 0;
        ret = sctp_add_stream_reset_out(
            stcb,
            chk,
            seq,
            (*stcb).asoc.str_reset_seq_in.wrapping_sub(1u32),
            (*stcb).asoc.sending_seq.wrapping_sub(1u32),
        );
        if ret != 0 {
            seq = seq.wrapping_add(1);
            (*asoc).stream_reset_outstanding = (*asoc).stream_reset_outstanding.wrapping_add(1)
        }
    }
    if add_stream as libc::c_int & 1i32 != 0
        && ((*stcb).asoc.strm_realoutsize as libc::c_int - (*stcb).asoc.streamoutcnt as libc::c_int)
            < adding_o as libc::c_int
    {
        let mut oldstream = 0 as *mut sctp_stream_out;
        oldstream = (*stcb).asoc.strmout;
        /* get some more */
        (*stcb).asoc.strmout = malloc(
            (((*stcb).asoc.streamoutcnt as libc::c_int + adding_o as libc::c_int) as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<sctp_stream_out>() as libc::c_ulong),
        ) as *mut sctp_stream_out;
        if 0x1i32 & 0x100i32 != 0 {
            memset(
                (*stcb).asoc.strmout as *mut libc::c_void,
                0i32,
                (((*stcb).asoc.streamoutcnt as libc::c_int + adding_o as libc::c_int)
                    as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<sctp_stream_out>() as libc::c_ulong),
            );
        }
        if (*stcb).asoc.strmout.is_null() {
            let mut x = 0;
            (*stcb).asoc.strmout = oldstream;
            /* Turn off the bit */
            x = (add_stream as libc::c_int & 0xfei32) as uint8_t;
            add_stream = x
        } else {
            /* Ok now we proceed with copying the old out stuff and
             * initializing the new stuff.
             */
            pthread_mutex_lock(&mut (*stcb).tcb_send_mtx);
            (*stcb)
                .asoc
                .ss_functions
                .sctp_ss_clear
                .expect("non-null function pointer")(
                stcb, &mut (*stcb).asoc, 0i32, 1i32
            );

            for i in 0i32..(*stcb).asoc.streamoutcnt as libc::c_int {
                let mut sp = 0 as *mut sctp_stream_queue_pending;
                let mut nsp = 0 as *mut sctp_stream_queue_pending;
                let ref mut fresh39 = (*(*stcb).asoc.strmout.offset(i as isize))
                    .outqueue
                    .tqh_first;

                *fresh39 = 0 as *mut sctp_stream_queue_pending;

                let ref mut fresh40 = (*(*stcb).asoc.strmout.offset(i as isize)).outqueue.tqh_last;

                *fresh40 = &mut (*(*stcb).asoc.strmout.offset(i as isize))
                    .outqueue
                    .tqh_first;

                (*(*stcb).asoc.strmout.offset(i as isize)).chunks_on_queues =
                    (*oldstream.offset(i as isize)).chunks_on_queues;

                (*(*stcb).asoc.strmout.offset(i as isize)).next_mid_ordered =
                    (*oldstream.offset(i as isize)).next_mid_ordered;

                (*(*stcb).asoc.strmout.offset(i as isize)).next_mid_unordered =
                    (*oldstream.offset(i as isize)).next_mid_unordered;

                (*(*stcb).asoc.strmout.offset(i as isize)).last_msg_incomplete =
                    (*oldstream.offset(i as isize)).last_msg_incomplete;

                (*(*stcb).asoc.strmout.offset(i as isize)).sid = i as uint16_t;

                (*(*stcb).asoc.strmout.offset(i as isize)).state =
                    (*oldstream.offset(i as isize)).state;
                /* FIX ME FIX ME */
                /* This should be a SS_COPY operation FIX ME STREAM SCHEDULER EXPERT */
                (*stcb)
                    .asoc
                    .ss_functions
                    .sctp_ss_init_stream
                    .expect("non-null function pointer")(
                    stcb,
                    &mut *(*stcb).asoc.strmout.offset(i as isize),
                    &mut *oldstream.offset(i as isize),
                );
                /* now anything on those queues? */
                sp = (*oldstream.offset(i as isize)).outqueue.tqh_first;

                while !sp.is_null() && {
                    nsp = (*sp).next.tqe_next;
                    (1i32) != 0
                } {
                    if !(*sp).next.tqe_next.is_null() {
                        (*(*sp).next.tqe_next).next.tqe_prev = (*sp).next.tqe_prev
                    } else {
                        let ref mut fresh41 = (*oldstream.offset(i as isize)).outqueue.tqh_last;
                        *fresh41 = (*sp).next.tqe_prev
                    }
                    *(*sp).next.tqe_prev = (*sp).next.tqe_next;
                    (*sp).next.tqe_next = 0 as *mut sctp_stream_queue_pending;
                    (*sp).next.tqe_prev =
                        (*(*stcb).asoc.strmout.offset(i as isize)).outqueue.tqh_last;
                    let ref mut fresh42 =
                        *(*(*stcb).asoc.strmout.offset(i as isize)).outqueue.tqh_last;
                    *fresh42 = sp;
                    let ref mut fresh43 =
                        (*(*stcb).asoc.strmout.offset(i as isize)).outqueue.tqh_last;
                    *fresh43 = &mut (*sp).next.tqe_next;
                    sp = nsp
                }
            }
            /* now the new streams */
            (*stcb)
                .asoc
                .ss_functions
                .sctp_ss_init
                .expect("non-null function pointer")(stcb, &mut (*stcb).asoc, 1i32);

            for i in (*stcb).asoc.streamoutcnt as libc::c_int
                ..(*stcb).asoc.streamoutcnt as libc::c_int + adding_o as libc::c_int
            {
                let ref mut fresh44 = (*(*stcb).asoc.strmout.offset(i as isize))
                    .outqueue
                    .tqh_first;

                *fresh44 = 0 as *mut sctp_stream_queue_pending;

                let ref mut fresh45 = (*(*stcb).asoc.strmout.offset(i as isize)).outqueue.tqh_last;

                *fresh45 = &mut (*(*stcb).asoc.strmout.offset(i as isize))
                    .outqueue
                    .tqh_first;

                (*(*stcb).asoc.strmout.offset(i as isize)).chunks_on_queues = 0u32;

                (*(*stcb).asoc.strmout.offset(i as isize)).abandoned_sent[0usize] = 0u32;

                (*(*stcb).asoc.strmout.offset(i as isize)).abandoned_unsent[0usize] = 0u32;

                (*(*stcb).asoc.strmout.offset(i as isize)).next_mid_ordered = 0u32;

                (*(*stcb).asoc.strmout.offset(i as isize)).next_mid_unordered = 0u32;

                (*(*stcb).asoc.strmout.offset(i as isize)).sid = i as uint16_t;

                (*(*stcb).asoc.strmout.offset(i as isize)).last_msg_incomplete = 0u8;

                (*stcb)
                    .asoc
                    .ss_functions
                    .sctp_ss_init_stream
                    .expect("non-null function pointer")(
                    stcb,
                    &mut *(*stcb).asoc.strmout.offset(i as isize),
                    0 as *mut sctp_stream_out,
                );

                (*(*stcb).asoc.strmout.offset(i as isize)).state = 0u8;
            }
            (*stcb).asoc.strm_realoutsize =
                ((*stcb).asoc.streamoutcnt as libc::c_int + adding_o as libc::c_int) as uint16_t;
            free(oldstream as *mut libc::c_void);
            pthread_mutex_unlock(&mut (*stcb).tcb_send_mtx);
        }
    }
    if add_stream as libc::c_int & 1i32 != 0 && adding_o as libc::c_int > 0i32 {
        (*asoc).strm_pending_add_size = adding_o;
        (*asoc).peer_req_out = peer_asked;
        sctp_add_an_out_stream(chk, seq, adding_o);
        seq = seq.wrapping_add(1);
        (*asoc).stream_reset_outstanding = (*asoc).stream_reset_outstanding.wrapping_add(1)
    }
    if add_stream as libc::c_int & 2i32 != 0 && adding_i as libc::c_int > 0i32 {
        sctp_add_an_in_stream(chk, seq, adding_i);
        seq = seq.wrapping_add(1);
        (*asoc).stream_reset_outstanding = (*asoc).stream_reset_outstanding.wrapping_add(1)
    }
    if send_in_req != 0 {
        sctp_add_stream_reset_in(chk, number_entries as libc::c_int, list, seq);
        seq = seq.wrapping_add(1);
        (*asoc).stream_reset_outstanding = (*asoc).stream_reset_outstanding.wrapping_add(1)
    }
    if send_tsn_req != 0 {
        sctp_add_stream_reset_tsn(chk, seq);
        (*asoc).stream_reset_outstanding = (*asoc).stream_reset_outstanding.wrapping_add(1)
    }
    (*asoc).str_reset = chk;
    /* insert the chunk for sending */
    (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
    (*chk).sctp_next.tqe_prev = (*asoc).control_send_queue.tqh_last;
    *(*asoc).control_send_queue.tqh_last = chk;
    (*asoc).control_send_queue.tqh_last = &mut (*chk).sctp_next.tqe_next;
    (*asoc).ctrl_queue_cnt += 1;
    if (*stcb).asoc.send_sack != 0 {
        sctp_send_sack(stcb, 1i32);
    }
    sctp_timer_start(14i32, (*stcb).sctp_ep, stcb, (*chk).whoTo);
    return 0i32;
}
#[no_mangle]
pub unsafe extern "C" fn sctp_send_abort(
    mut m: *mut mbuf,
    mut iphlen: libc::c_int,
    mut src: *mut sockaddr,
    mut dst: *mut sockaddr,
    mut sh: *mut sctphdr,
    mut vtag: uint32_t,
    mut cause: *mut mbuf,
    mut vrf_id: uint32_t,
    mut port: uint16_t,
) {
    /* Don't respond to an ABORT with an ABORT. */
    if sctp_is_there_an_abort_here(m, iphlen, &mut vtag) != 0 {
        if !cause.is_null() {
            m_freem(cause);
        }
        return;
    }
    sctp_send_resp_msg(src, dst, sh, vtag, 0x6u8, cause, vrf_id, port);
}
#[no_mangle]
pub unsafe extern "C" fn sctp_send_operr_to(
    mut src: *mut sockaddr,
    mut dst: *mut sockaddr,
    mut sh: *mut sctphdr,
    mut vtag: uint32_t,
    mut cause: *mut mbuf,
    mut vrf_id: uint32_t,
    mut port: uint16_t,
) {
    sctp_send_resp_msg(src, dst, sh, vtag, 0x9u8, cause, vrf_id, port);
}
unsafe extern "C" fn sctp_copy_resume(
    mut uio: *mut uio,
    mut max_send_len: libc::c_int,
    mut user_marks_eor: libc::c_int,
    mut error: *mut libc::c_int,
    mut sndout: *mut uint32_t,
    mut new_tail: *mut *mut mbuf,
) -> *mut mbuf {
    let mut m = 0 as *mut mbuf;
    m = m_uiotombuf(
        uio,
        0x2i32,
        max_send_len,
        0i32,
        0x2i32 | (if user_marks_eor != 0 { 0x4i32 } else { 0i32 }),
    );
    if m.is_null() {
        *error = 105i32
    } else {
        *sndout = m_length(m, 0 as *mut *mut mbuf);
        *new_tail = m_last(m)
    }
    return m;
}
unsafe extern "C" fn sctp_copy_one(
    mut sp: *mut sctp_stream_queue_pending,
    mut uio: *mut uio,
    mut resv_upfront: libc::c_int,
) -> libc::c_int {
    (*sp).data = m_uiotombuf(uio, 0x2i32, (*sp).length as libc::c_int, resv_upfront, 0i32);
    if (*sp).data.is_null() {
        return 105i32;
    }
    (*sp).tail_mbuf = m_last((*sp).data);
    return 0i32;
}
unsafe extern "C" fn sctp_copy_it_in(
    mut stcb: *mut sctp_tcb,
    mut asoc: *mut sctp_association,
    mut srcv: *mut sctp_sndrcvinfo,
    mut uio: *mut uio,
    mut net: *mut sctp_nets,
    mut max_send_len: ssize_t,
    mut user_marks_eor: libc::c_int,
    mut error: *mut libc::c_int,
) -> *mut sctp_stream_queue_pending {
    let mut sp = 0 as *mut sctp_stream_queue_pending;
    *error = 0i32;
    /* Now can we send this? */
    if (*stcb).asoc.state & 0x7fi32 == 0x10i32
        || (*stcb).asoc.state & 0x7fi32 == 0x40i32
        || (*stcb).asoc.state & 0x7fi32 == 0x20i32
        || (*asoc).state & 0x80i32 != 0
    {
        /* got data while shutting down */
        *error = 104i32
    } else {
        sp = malloc(system_base_info.sctppcbinfo.ipi_zone_strmoq) as *mut sctp_stream_queue_pending;
        if !sp.is_null() {
            memset(
                sp as *mut libc::c_void,
                0i32,
                ::std::mem::size_of::<sctp_stream_queue_pending>() as libc::c_ulong,
            );
            ::std::intrinsics::atomic_xadd(
                &mut system_base_info.sctppcbinfo.ipi_count_strmoq,
                1u32,
            );
            (*sp).holds_key_ref = 0u8
        }
        if sp.is_null() {
            *error = 12i32
        } else {
            let mut resv_in_first = 0;
            (*sp).act_flags = 0u16;
            (*sp).sender_all_done = 0u8;
            (*sp).sinfo_flags = (*srcv).sinfo_flags;
            (*sp).timetolive = (*srcv).sinfo_timetolive;
            (*sp).ppid = (*srcv).sinfo_ppid;
            (*sp).context = (*srcv).sinfo_context;
            (*sp).fsn = 0u32;
            gettimeofday(&mut (*sp).ts, 0 as *mut timezone);
            (*sp).sid = (*srcv).sinfo_stream;
            (*sp).length = if (*uio).uio_resid > max_send_len {
                max_send_len
            } else {
                (*uio).uio_resid
            } as uint32_t;
            if (*sp).length == (*uio).uio_resid as uint32_t
                && (user_marks_eor == 0i32
                    || (*srcv).sinfo_flags as libc::c_int & 0x100i32 != 0
                    || user_marks_eor != 0 && (*srcv).sinfo_flags as libc::c_int & 0x2000i32 != 0)
            {
                (*sp).msg_is_complete = 1u8
            } else {
                (*sp).msg_is_complete = 0u8
            }
            (*sp).sender_all_done = 0u8;
            (*sp).some_taken = 0u8;
            (*sp).put_last_out = 0u8;
            resv_in_first = if (*stcb).asoc.idata_supported as libc::c_int != 0 {
                ::std::mem::size_of::<sctp_idata_chunk>() as libc::c_ulong
            } else {
                ::std::mem::size_of::<sctp_data_chunk>() as libc::c_ulong
            } as libc::c_int;
            (*sp).tail_mbuf = 0 as *mut mbuf;
            (*sp).data = (*sp).tail_mbuf;
            if !((*sp).length == 0u32) {
                if (*srcv).sinfo_keynumber_valid != 0 {
                    (*sp).auth_keyid = (*srcv).sinfo_keynumber
                } else {
                    (*sp).auth_keyid = (*stcb).asoc.authinfo.active_keyid
                }
                if if (*stcb).asoc.peer_auth_chunks.is_null() {
                    0i32
                } else {
                    ((*(*stcb).asoc.peer_auth_chunks).chunks[0usize] as libc::c_int != 0i32)
                        as libc::c_int
                } != 0
                {
                    sctp_auth_key_acquire(stcb, (*sp).auth_keyid);
                    (*sp).holds_key_ref = 1u8
                }
                *error = sctp_copy_one(sp, uio, resv_in_first)
            }
            if *error != 0 {
                pthread_mutex_lock(&mut (*stcb).tcb_mtx);
                if (*sp).holds_key_ref != 0 {
                    sctp_auth_key_release(stcb, (*sp).auth_keyid, 1i32);
                    (*sp).holds_key_ref = 0u8
                }
                free(sp as *mut libc::c_void);
                ::std::intrinsics::atomic_xsub(
                    &mut system_base_info.sctppcbinfo.ipi_count_strmoq,
                    1u32,
                );
                pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                sp = 0 as *mut sctp_stream_queue_pending
            } else {
                if (*sp).sinfo_flags as libc::c_int & 0x800i32 != 0 {
                    (*sp).net = net;
                    ::std::intrinsics::atomic_xadd(&mut (*(*sp).net).ref_count, 1i32);
                } else {
                    (*sp).net = 0 as *mut sctp_nets
                }
                sctp_set_prsctp_policy(sp);
            }
        }
    }
    return sp;
}
/* _KERNEL || __Userspace__ */
#[no_mangle]
pub unsafe extern "C" fn sctp_sosend(
    mut so: *mut socket,
    mut addr: *mut sockaddr,
    mut uio: *mut uio,
    mut top: *mut mbuf,
    mut control: *mut mbuf,
    mut flags: libc::c_int,
    mut p: *mut proc_0,
) -> libc::c_int {
    let mut error = 0;
    let mut use_sndinfo = 0i32;
    let mut sndrcvninfo = sctp_sndrcvinfo {
        sinfo_stream: 0,
        sinfo_ssn: 0,
        sinfo_flags: 0,
        sinfo_ppid: 0,
        sinfo_context: 0,
        sinfo_timetolive: 0,
        sinfo_tsn: 0,
        sinfo_cumtsn: 0,
        sinfo_assoc_id: 0,
        sinfo_keynumber: 0,
        sinfo_keynumber_valid: 0,
        __reserve_pad: [0; 92],
    };
    let mut addr_to_use = 0 as *mut sockaddr;
    if !control.is_null() {
        /* process cmsg snd/rcv info (maybe a assoc-id) */
        if sctp_find_cmsg(
            0x2i32,
            &mut sndrcvninfo as *mut sctp_sndrcvinfo as *mut libc::c_void,
            control,
            ::std::mem::size_of::<sctp_sndrcvinfo>() as libc::c_ulong,
        ) != 0
        {
            /* got one */
            use_sndinfo = 1i32
        }
    }
    addr_to_use = addr;
    if !addr.is_null() && (*addr).sa_family as libc::c_int == 10i32 {
        let mut sin6 = 0 as *mut sockaddr_in6;
        sin6 = addr as *mut sockaddr_in6;
        if ({
            let mut __a = &mut (*sin6).sin6_addr as *mut in6_addr as *const in6_addr;
            ((*__a).__in6_u.__u6_addr32[0usize] == 0u32
                && (*__a).__in6_u.__u6_addr32[1usize] == 0u32
                && (*__a).__in6_u.__u6_addr32[2usize] == htonl(0xffffu32))
                as libc::c_int
        }) != 0
        {
            let mut sin = sockaddr_in {
                sin_family: 0,
                sin_port: 0,
                sin_addr: in_addr { s_addr: 0 },
                sin_zero: [0; 8],
            };
            in6_sin6_2_sin(&mut sin, sin6);
            addr_to_use = &mut sin as *mut sockaddr_in as *mut sockaddr
        }
    }
    error = sctp_lower_sosend(
        so,
        addr_to_use,
        uio,
        top,
        control,
        flags,
        if use_sndinfo != 0 {
            &mut sndrcvninfo
        } else {
            0 as *mut sctp_sndrcvinfo
        },
    );
    return error;
}
/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 2001-2007, by Cisco Systems, Inc. All rights reserved.
 * Copyright (c) 2008-2012, by Randall Stewart. All rights reserved.
 * Copyright (c) 2008-2012, by Michael Tuexen. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * a) Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * b) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the distribution.
 *
 * c) Neither the name of Cisco Systems, Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
/* Compatibility to previous define's */
/* On/Off setup for subscription to events */
/* ancillary data types */
/*
 * ancillary data structures
 */
/* We add 96 bytes to the size of sctp_sndrcvinfo.
 * This makes the current structure 128 bytes long
 * which is nicely 64 bit aligned but also has room
 * for us to add more and keep ABI compatibility.
 * For example, already we have the sctp_extrcvinfo
 * when enabled which is 48 bytes.
 */
/*
 * The assoc up needs a verfid
 * all sendrcvinfo's need a verfid for SENDING only.
 */
/* should have been sinfo_pr_value */
/* Flags that go into the sinfo->sinfo_flags field */
/* next message is a notification */
/* next message is complete */
/* Start shutdown procedures */
/* Send an ABORT to peer */
/* Message is un-ordered */
/* Override the primary-address */
/* Send this on all associations */
/* end of message signal */
/* Set I-Bit */
/* for the endpoint */
/* The lower four bits is an enumeration of PR-SCTP policies */
/* Reliable transfer */
/* Time based PR-SCTP */
/* Buffer based PR-SCTP */
/* For backwards compatibility */
/* Number of retransmissions based PR-SCTP */
/* Used for aggregated stats */
/* Stat's */
/*
 * notification event structures
 */
/*
 * association change event
 */
/* sac_state values */
/* sac_info values */
/*
 * Address event
 */
/* paddr state values */
/* SCTP_ADDR_REACHABLE */
/* neither SCTP_ADDR_REACHABLE
nor SCTP_ADDR_UNCONFIRMED */
/* SCTP_ADDR_UNCONFIRMED */
/* remote error events */
/* data send failure event (deprecated) */
/* data send failure event (not deprecated) */
/* flag that indicates state of data */
/* inqueue never on wire */
/* on wire at failure */
/* shutdown event */
/* Adaptation layer indication stuff */
/* compatible old spelling */
/*
 * Partial Delivery API event
 */
/* indication values */
/*
 * authentication key event
 */
/* indication values */
/*
 * Stream reset event - subscribe to SCTP_STREAM_RESET_EVENT
 */
/* flags in stream_reset_event (strreset_flags) */
/*
 * Assoc reset event - subscribe to SCTP_ASSOC_RESET_EVENT
 */
/*
 * Stream change event - subscribe to SCTP_STREAM_CHANGE_EVENT
 */
/* SCTP notification event */
/* compatibility same as above */
/* notification types */
/* same as above */
/* we don't send this*/
/*
 * socket option structs
 */
/* addr is filled in for N * sockaddr_storage */
/*
 * AUTHENTICATION support
 */
/* SCTP_AUTH_CHUNK */
/* SCTP_AUTH_KEY */
/* SCTP_HMAC_IDENT */
/* AUTH hmac_id */
/* default, mandatory */
/* SCTP_AUTH_ACTIVE_KEY / SCTP_AUTH_DELETE_KEY */
/* SCTP_PEER_AUTH_CHUNKS / SCTP_LOCAL_AUTH_CHUNKS */
/* network to */
/* FIXME: LP64 issue */
/* cwnd in k */
/* flightsize in k */
/* increment to it */
/* in 1k bytes */
/* len of send being attempted */
/* rwnd of peer */
/* chnk cnt */
/* chnk cnt */
/* chunks out */
/* flight size in k */
/*
 * Max we can reset in one setting, note this is dictated not by the define
 * but the size of a mbuf cluster so don't change this define and think you
 * can specify more. You must do multiple resets if you want to reset more
 * than SCTP_MAX_EXPLICIT_STR_RESET.
 */
/* 0 == ALL */
/* list if strrst_num_streams is not 0 */
/* Debugging logs */
/* FIXME: LP64 issue */
/* FIXME: LP64 issue */
/* FIXME: LP64 issue */
/* FIXME: LP64 issue */
/* FIXME: LP64 issue */
/* FIXME: LP64 issue */
/* FIXME: LP64 issue */
/* chnk cnt */
/* chunks out */
/* FIXME: LP64 issue */
/* FIXME: LP64 issue */
/* FIXME: LP64 issue */
/* Number in log */
/* Number returned */
/* start at this one */
/* end at this one */
/* sctpStats 18 (TimeStamp) */
/* MIB according to RFC 3873 */
/* sctpStats  1   (Gauge32) */
/* sctpStats  2 (Counter32) */
/* sctpStats  3 (Counter32) */
/* sctpStats  4 (Counter32) */
/* sctpStats  5 (Counter32) */
/* sctpStats  6 (Counter32) */
/* sctpStats  7 (Counter32) */
/* sctpStats  8 (Counter64) */
/* sctpStats  9 (Counter64) */
/* sctpStats 10 (Counter64) */
/* sctpStats 11 (Counter64) */
/* sctpStats 12 (Counter64) */
/* sctpStats 13 (Counter64) */
/* sctpStats 14 (Counter64) */
/* sctpStats 15 (Counter64) */
/* sctpStats 16 (Counter64) */
/* sctpStats 17 (Counter64) */
/* input statistics: */
/* total input packets        */
/* total input datagrams      */
/* total packets that had data */
/* total input SACK chunks    */
/* total input DATA chunks    */
/* total input duplicate DATA chunks */
/* total input HB chunks      */
/* total input HB-ACK chunks  */
/* total input ECNE chunks    */
/* total input AUTH chunks    */
/* total input chunks missing AUTH */
/* total number of invalid HMAC ids received */
/* total number of invalid secret ids received */
/* total number of auth failed */
/* total fast path receives all one chunk */
/* total fast path multi-part data */
/* formerly sctps_recvnocrc */
/* output statistics: */
/* total output packets       */
/* total output SACKs         */
/* total output DATA chunks   */
/* total output retransmitted DATA chunks */
/* total output fast retransmitted DATA chunks */
/* total FR's that happened more than once
 * to same chunk (u-del multi-fr algo).
 */
/* total output HB chunks     */
/* total output ECNE chunks    */
/* total output AUTH chunks FIXME   */
/* ip_output error counter */
/* formerly sctps_sendnocrc */
/* PCKDROPREP statistics: */
/* Packet drop from middle box */
/* P-drop from end host */
/* P-drops with data */
/* P-drops, non-data, non-endhost */
/* P-drop, non-endhost, bandwidth rep only */
/* P-drop, not enough for chunk header */
/* P-drop, not enough data to confirm */
/* P-drop, where process_chunk_drop said break */
/* P-drop, could not find TSN */
/* P-drop, attempt reverse TSN lookup */
/* P-drop, e-host confirms zero-rwnd */
/* P-drop, midbox confirms no space */
/* P-drop, data did not match TSN */
/* P-drop, TSN's marked for Fast Retran */
/* timeouts */
/* Number of iterator timers that fired */
/* Number of T3 data time outs */
/* Number of window probe (T3) timers that fired */
/* Number of INIT timers that fired */
/* Number of sack timers that fired */
/* Number of shutdown timers that fired */
/* Number of heartbeat timers that fired */
/* Number of times a cookie timeout fired */
/* Number of times an endpoint changed its cookie secret*/
/* Number of PMTU timers that fired */
/* Number of shutdown ack timers that fired */
/* Number of shutdown guard timers that fired */
/* Number of stream reset timers that fired */
/* Number of early FR timers that fired */
/* Number of times an asconf timer fired */
/* Number of times a prim_deleted timer fired */
/* Number of times auto close timer fired */
/* Number of asoc free timers expired */
/* Number of inp free timers expired */
/* former early FR counters */
/* others */
/* packet shorter than header */
/* checksum error             */
/* no endpoint for port       */
/* bad v-tag                  */
/* bad SID                    */
/* no memory                  */
/* number of multiple FR in a RTT window */
/* nagle allowed sending      */
/* nagle doesn't allow sending */
/* max burst doesn't allow sending */
/* look ahead tells us no memory in
 * interface ring buffer OR we had a
 * send error and are queuing one send.
 */
/* total number of window probes sent */
/* total times an output error causes us
 * to clamp down on next user send.
 */
/* total times sctp_senderrors were caused from
 * a user send from a user invoked send not
 * a sack response
 */
/* Number of in data drops due to chunk limit reached */
/* Number of in data drops due to rwnd limit reached */
/* Number of times a ECN reduced the cwnd */
/* Used express lookup via vtag */
/* Collision in express lookup. */
/* Number of times the sender ran dry of user data on primary */
/* Same for above */
/* Sacks the slow way */
/* Window Update only sacks sent */
/* number of sends with sinfo_flags !=0 */
/* number of unordered sends */
/* number of sends with EOF flag set */
/* number of sends with ABORT flag set */
/* number of times protocol drain called */
/* number of times we did a protocol drain */
/* Number of times recv was called with peek */
/* Number of cached chunks used */
/* Number of cached stream oq's used */
/* Number of unread messages abandoned by close */
/* Unused */
/* Send cwnd full  avoidance, already max burst inflight to net */
/* number of map array over-runs via fwd-tsn's */
/* Number of times we queued or updated an ECN chunk on send queue */
/* Future ABI compat - remove int's from here when adding new */
/* The following macros are for handling MIB values, */
/* **********************************/
/* And something for us old timers */
/* **********************************/
/* **********************************/
/* future */
/* sctpAssocEntry 5/6 */
/* sctpAssocEntry 7   */
/* sctpAssocEntry 8   */
/* sctpAssocEntry 9   */
/* sctpAssocEntry 10  */
/* sctpAssocEntry 11  */
/* sctpAssocEntry 12  */
/* sctpAssocEntry 13  */
/* sctpAssocEntry 14  */
/* sctpAssocEntry 15  */
/* sctpAssocEntry 3   */
/* sctpAssocEntry 4   */
/* sctpAssocEntry 16  */
/* sctpAssocEntry 17  */
/* sctpAssocEntry 1   */
/* future */
/* sctpAssocLocalAddrEntry 1/2 */
/* sctpAssocLocalAddrEntry 3   */
/* future */
/* sctpAssocLocalRemEntry 1/2 */
/* sctpAssocLocalRemEntry 5   */
/* sctpAssocLocalRemEntry 6   */
/* sctpAssocLocalRemEntry 7   */
/*                            */
/*                            */
/*                            */
/*                            */
/* sctpAssocLocalRemEntry 3   */
/*                            */
/* sctpAssocLocalRemEntry 4   */
/* sctpAssocLocalRemEntry 8   */
/* future */
/* This number MUST be even   */
/*
 * Kernel defined for sctp_send
 */
#[no_mangle]
pub unsafe extern "C" fn sctp_lower_sosend(
    mut so: *mut socket,
    mut addr: *mut sockaddr,
    mut uio: *mut uio,
    mut i_pak: *mut mbuf,
    mut control: *mut mbuf,
    mut flags: libc::c_int,
    mut srcv: *mut sctp_sndrcvinfo,
) -> libc::c_int {
    let mut sndlen = 0i64;
    let mut error = 0;
    let mut top = 0 as *mut mbuf;
    let mut free_cnt_applied = 0i32;
    let mut inp = 0 as *mut sctp_inpcb;
    let mut stcb = 0 as *mut sctp_tcb;
    let mut net = 0 as *mut sctp_nets;
    let mut asoc = 0 as *mut sctp_association;
    let mut t_inp = 0 as *mut sctp_inpcb;
    let mut user_marks_eor = 0;
    let mut create_lock_applied = 0i32;
    let mut hold_tcblock = 0i32;
    let mut local_soresv = 0i64;
    error = 0i32;
    net = 0 as *mut sctp_nets;
    stcb = 0 as *mut sctp_tcb;
    asoc = 0 as *mut sctp_association;
    inp = (*so).so_pcb as *mut sctp_inpcb;
    t_inp = inp;
    if inp.is_null() {
        error = 22i32;
        if !i_pak.is_null() {
            m_freem(i_pak);
        }
        return error;
    }
    if uio.is_null() && i_pak.is_null() {
        return 22i32;
    }
    user_marks_eor = ((*inp).sctp_features & 0x400000u64 == 0x400000u64) as libc::c_int;
    ::std::intrinsics::atomic_xadd(&mut (*inp).total_sends, 1u32);
    if !uio.is_null() {
        if (*uio).uio_resid < 0i64 {
            return 22i32;
        }
        sndlen = (*uio).uio_resid
    } else {
        top = i_pak;
        sndlen = (*i_pak).M_dat.MH.MH_pkthdr.len as ssize_t
    }
    if system_base_info.sctpsysctl.sctp_debug_on & 0x10u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"Send called addr:%p send length %zu\n\x00" as *const u8 as *const libc::c_char,
                addr as *mut libc::c_void,
                sndlen,
            );
        }
    }
    if (*inp).sctp_flags & 0x2u32 != 0 && (*inp).sctp_flags & 0x8u32 != 0u32 {
        /* The listener can NOT send */
        error = 107i32
    } else {
        let mut current_block: u64;
        let mut port = 0;
        if !addr.is_null() {
            let mut raddr = addr as *mut sctp_sockstore;
            match (*raddr).sa.sa_family as libc::c_int {
                2 => {
                    port = (*raddr).sin.sin_port;
                    current_block = 13125627826496529465;
                }
                10 => {
                    port = (*raddr).sin6.sin6_port;
                    current_block = 13125627826496529465;
                }
                123 => {
                    port = (*raddr).sconn.sconn_port;
                    current_block = 13125627826496529465;
                }
                _ => {
                    error = 97i32;
                    current_block = 14645908287508918710;
                }
            }
        } else {
            port = 0u16;
            current_block = 13125627826496529465;
        }
        match current_block {
            14645908287508918710 => {}
            _ => {
                let mut sinfo_flags = 0;
                let mut sinfo_assoc_id = 0;
                if !srcv.is_null() {
                    sinfo_flags = (*srcv).sinfo_flags;
                    sinfo_assoc_id = (*srcv).sinfo_assoc_id;
                    if sinfo_flags as libc::c_uint
                        & 0xfffffff0u32
                        & !(0x100i32
                            | 0x200i32
                            | 0x400i32
                            | 0x800i32
                            | 0x1000i32
                            | 0x2000i32
                            | 0x4000i32) as libc::c_uint
                        != 0u32
                        || sinfo_flags as libc::c_int & 0xfi32 > 0x3i32
                    {
                        error = 22i32;
                        current_block = 14645908287508918710;
                    } else {
                        if (*srcv).sinfo_flags != 0 {
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_sends_with_flags,
                                1u32,
                            );
                        }
                        current_block = 2168227384378665163;
                    }
                } else {
                    sinfo_flags = (*inp).def_send.sinfo_flags;
                    sinfo_assoc_id = (*inp).def_send.sinfo_assoc_id;
                    current_block = 2168227384378665163;
                }
                match current_block {
                    14645908287508918710 => {}
                    _ => {
                        if sinfo_flags as libc::c_int & 0x1000i32 != 0 {
                            /* its a sendall */
                            error = sctp_sendall(inp, uio, top, srcv);
                            top = 0 as *mut mbuf
                        } else if sinfo_flags as libc::c_int & 0x800i32 != 0 && addr.is_null() {
                            error = 22i32
                        } else {
                            /* now we must find the assoc */
                            if (*inp).sctp_flags & 0x200000u32 != 0
                                || (*inp).sctp_flags & 0x400000u32 != 0
                            {
                                pthread_mutex_lock(&mut (*inp).inp_mtx);
                                stcb = (*inp).sctp_asoc_list.lh_first;
                                if !stcb.is_null() {
                                    pthread_mutex_lock(&mut (*stcb).tcb_mtx);
                                    hold_tcblock = 1i32
                                }
                                pthread_mutex_unlock(&mut (*inp).inp_mtx);
                            } else if sinfo_assoc_id != 0 {
                                stcb = sctp_findassociation_ep_asocid(inp, sinfo_assoc_id, 1i32);
                                if !stcb.is_null() {
                                    hold_tcblock = 1i32
                                }
                            } else if !addr.is_null() {
                                /*-
                                 * Since we did not use findep we must
                                 * increment it, and if we don't find a tcb
                                 * decrement it.
                                 */
                                pthread_mutex_lock(&mut (*inp).inp_mtx);
                                ::std::intrinsics::atomic_xadd(&mut (*inp).refcount, 1i32);
                                pthread_mutex_unlock(&mut (*inp).inp_mtx);
                                stcb = sctp_findassociation_ep_addr(
                                    &mut t_inp,
                                    addr,
                                    &mut net,
                                    0 as *mut sockaddr,
                                    0 as *mut sctp_tcb,
                                );
                                if stcb.is_null() {
                                    pthread_mutex_lock(&mut (*inp).inp_mtx);
                                    ::std::intrinsics::atomic_xadd(&mut (*inp).refcount, -(1i32));
                                    pthread_mutex_unlock(&mut (*inp).inp_mtx);
                                } else {
                                    hold_tcblock = 1i32
                                }
                            }
                            if stcb.is_null() && !addr.is_null() {
                                /* Possible implicit send? */
                                pthread_mutex_lock(&mut (*inp).inp_create_mtx);
                                create_lock_applied = 1i32;
                                if (*inp).sctp_flags & 0x10000000u32 != 0
                                    || (*inp).sctp_flags & 0x20000000u32 != 0
                                {
                                    /* Should I really unlock ? */
                                    error = 22i32;
                                    current_block = 14645908287508918710;
                                } else if (*inp).sctp_flags & 0x4000000u32 == 0u32
                                    && (*addr).sa_family as libc::c_int == 10i32
                                {
                                    error = 22i32;
                                    current_block = 14645908287508918710;
                                } else {
                                    pthread_mutex_lock(&mut (*inp).inp_mtx);
                                    ::std::intrinsics::atomic_xadd(&mut (*inp).refcount, 1i32);
                                    pthread_mutex_unlock(&mut (*inp).inp_mtx);
                                    /* With the lock applied look again */
                                    stcb = sctp_findassociation_ep_addr(
                                        &mut t_inp,
                                        addr,
                                        &mut net,
                                        0 as *mut sockaddr,
                                        0 as *mut sctp_tcb,
                                    );
                                    if stcb.is_null()
                                        && !control.is_null()
                                        && port as libc::c_int > 0i32
                                    {
                                        stcb = sctp_findassociation_cmsgs(
                                            &mut t_inp, port, control, &mut net, &mut error,
                                        )
                                    }
                                    if stcb.is_null() {
                                        pthread_mutex_lock(&mut (*inp).inp_mtx);
                                        ::std::intrinsics::atomic_xadd(
                                            &mut (*inp).refcount,
                                            -(1i32),
                                        );
                                        pthread_mutex_unlock(&mut (*inp).inp_mtx);
                                    } else {
                                        hold_tcblock = 1i32
                                    }
                                    if error != 0 {
                                        current_block = 14645908287508918710;
                                    } else if t_inp != inp {
                                        error = 107i32;
                                        current_block = 14645908287508918710;
                                    } else {
                                        current_block = 7370318721998929769;
                                    }
                                }
                            } else {
                                current_block = 7370318721998929769;
                            }
                            match current_block {
                                14645908287508918710 => {}
                                _ => {
                                    let mut queue_only = 0i32;
                                    let mut queue_only_for_init = 0i32;
                                    if stcb.is_null() {
                                        if addr.is_null() {
                                            error = 2i32;
                                            current_block = 14645908287508918710;
                                        } else {
                                            if sinfo_flags as libc::c_int & 0x200i32 != 0
                                                || sinfo_flags as libc::c_int & 0x100i32 != 0
                                                    && sndlen == 0i64
                                            {
                                                /*-
                                                 * User asks to abort a non-existant assoc,
                                                 * or EOF a non-existant assoc with no data
                                                 */
                                                error = 2i32;
                                                current_block = 14645908287508918710;
                                            } else {
                                                let mut vrf_id = 0;
                                                vrf_id = (*inp).def_vrf_id;
                                                stcb = sctp_aloc_assoc(
                                                    inp,
                                                    addr,
                                                    &mut error,
                                                    0u32,
                                                    vrf_id,
                                                    (*inp).sctp_ep.pre_open_stream_count,
                                                    (*inp).sctp_ep.port,
                                                    0 as *mut proc_0,
                                                    1i32,
                                                );
                                                if stcb.is_null() {
                                                    current_block = 14645908287508918710;
                                                } else {
                                                    if (*(*stcb).sctp_ep).sctp_flags & 0x2u32 != 0 {
                                                        (*(*stcb).sctp_ep).sctp_flags |=
                                                            0x200000u32;
                                                        /* Set the connected flag so we can queue data */
                                                        soisconnecting(so);
                                                    }
                                                    hold_tcblock = 1i32;
                                                    if create_lock_applied != 0 {
                                                        pthread_mutex_unlock(
                                                            &mut (*inp).inp_create_mtx,
                                                        );
                                                        create_lock_applied = 0i32
                                                    } else if system_base_info
                                                        .debug_printf
                                                        .is_some()
                                                    {
                                                        system_base_info.debug_printf.expect("non-null function pointer")(b"Huh-3? create lock should have been on??\n\x00"
                                                                                                                              as
                                                                                                                              *const u8
                                                                                                                              as
                                                                                                                              *const libc::c_char);
                                                    }
                                                    /* Turn on queue only flag to prevent data from being sent */
                                                    queue_only = 1i32;
                                                    asoc = &mut (*stcb).asoc;
                                                    sctp_set_state(stcb, 0x2i32);
                                                    gettimeofday(
                                                        &mut (*asoc).time_entered,
                                                        0 as *mut timezone,
                                                    );
                                                    if !control.is_null() {
                                                        if sctp_process_cmsgs_for_init(
                                                            stcb, control, &mut error,
                                                        ) != 0
                                                        {
                                                            sctp_free_assoc(
                                                                inp,
                                                                stcb,
                                                                2i32,
                                                                (0x90000000u32).wrapping_add(0x5u32)
                                                                    as libc::c_int,
                                                            );
                                                            hold_tcblock = 0i32;
                                                            stcb = 0 as *mut sctp_tcb;
                                                            current_block = 14645908287508918710;
                                                        } else {
                                                            current_block = 7621726606299503655;
                                                        }
                                                    } else {
                                                        current_block = 7621726606299503655;
                                                    }
                                                    match current_block {
                                                        14645908287508918710 => {}
                                                        _ => {
                                                            /* out with the INIT */
                                                            queue_only_for_init = 1i32;
                                                            current_block = 2413388577390654262;
                                                        }
                                                    }
                                                }
                                            }
                                            /*-
                                             * we may want to dig in after this call and adjust the MTU
                                             * value. It defaulted to 1500 (constant) but the ro
                                             * structure may now have an update and thus we may need to
                                             * change it BEFORE we append the message.
                                             */
                                        }
                                    } else {
                                        asoc = &mut (*stcb).asoc;
                                        current_block = 2413388577390654262;
                                    }
                                    match current_block {
                                        14645908287508918710 => {}
                                        _ => {
                                            if srcv.is_null() {
                                                srcv = &mut (*asoc).def_send
                                                    as *mut sctp_nonpad_sndrcvinfo
                                                    as *mut sctp_sndrcvinfo;
                                                sinfo_flags = (*srcv).sinfo_flags
                                            }
                                            if sinfo_flags as libc::c_int & 0x800i32 != 0 {
                                                if !addr.is_null() {
                                                    net = sctp_findnet(stcb, addr)
                                                } else {
                                                    net = 0 as *mut sctp_nets
                                                }
                                                if net.is_null()
                                                    || port as libc::c_int != 0i32
                                                        && port as libc::c_int
                                                            != (*stcb).rport as libc::c_int
                                                {
                                                    error = 22i32;
                                                    current_block = 14645908287508918710;
                                                } else {
                                                    current_block = 8551376836414271792;
                                                }
                                            } else {
                                                if !(*stcb).asoc.alternate.is_null() {
                                                    net = (*stcb).asoc.alternate
                                                } else {
                                                    net = (*stcb).asoc.primary_destination
                                                }
                                                current_block = 8551376836414271792;
                                            }
                                            match current_block {
                                                14645908287508918710 => {}
                                                _ => {
                                                    ::std::intrinsics::atomic_xadd(
                                                        &mut (*stcb).total_sends,
                                                        1u32,
                                                    );
                                                    /* Keep the stcb from being freed under our feet */
                                                    ::std::intrinsics::atomic_xadd(
                                                        &mut (*asoc).refcnt,
                                                        1u32,
                                                    );
                                                    free_cnt_applied = 1i32;
                                                    if (*inp).sctp_features & 0x100000u64
                                                        == 0x100000u64
                                                    {
                                                        if sndlen > (*asoc).smallest_mtu as ssize_t
                                                        {
                                                            error = 90i32;
                                                            current_block = 14645908287508918710;
                                                        } else {
                                                            current_block = 12331189130864541647;
                                                        }
                                                    } else {
                                                        current_block = 12331189130864541647;
                                                    }
                                                    match current_block {
                                                        14645908287508918710 => {}
                                                        _ => {
                                                            let mut inqueue_bytes = 0u32;
                                                            let mut non_blocking = 0i32;
                                                            if (*inp).recv_callback.is_some() {
                                                                non_blocking = 1i32
                                                            }
                                                            if (*so).so_state as libc::c_int
                                                                & 0x100i32
                                                                != 0
                                                            {
                                                                non_blocking = 1i32
                                                            }
                                                            /* would we block? */
                                                            if non_blocking != 0 {
                                                                let mut amount = 0;
                                                                if hold_tcblock == 0i32 {
                                                                    pthread_mutex_lock(
                                                                        &mut (*stcb).tcb_mtx,
                                                                    );
                                                                    hold_tcblock = 1i32
                                                                }
                                                                inqueue_bytes
                                                                    =
                                                                    ((*stcb).asoc.total_output_queue_size
                                                                         as
                                                                         libc::c_ulong).wrapping_sub(((*stcb).asoc.chunks_on_out_queue
                                                                                                          as
                                                                                                          libc::c_ulong).wrapping_mul((if (*stcb).asoc.idata_supported
                                                                                                                                              as
                                                                                                                                              libc::c_int
                                                                                                                                              !=
                                                                                                                                              0
                                                                                                                                          {
                                                                                                                                           ::std::mem::size_of::<sctp_idata_chunk>()
                                                                                                                                               as
                                                                                                                                               libc::c_ulong
                                                                                                                                       } else {
                                                                                                                                           ::std::mem::size_of::<sctp_data_chunk>()
                                                                                                                                               as
                                                                                                                                               libc::c_ulong
                                                                                                                                       })))
                                                                        as
                                                                        libc::c_uint;
                                                                if user_marks_eor == 0i32 {
                                                                    amount = sndlen
                                                                } else {
                                                                    amount = 1i64
                                                                }
                                                                if ((*so).so_snd.sb_hiwat
                                                                        as
                                                                        libc::c_long)
                                                                       <
                                                                       amount
                                                                           +
                                                                           inqueue_bytes
                                                                               as
                                                                               libc::c_long
                                                                           +
                                                                           (*stcb).asoc.sb_send_resv
                                                                               as
                                                                               libc::c_long
                                                                       ||
                                                                       (*stcb).asoc.chunks_on_out_queue
                                                                           >=
                                                                           system_base_info.sctpsysctl.sctp_max_chunks_on_queue
                                                                   {
                                                                    if sndlen
                                                                           >
                                                                           (*so).so_snd.sb_hiwat
                                                                               as
                                                                               ssize_t
                                                                       {
                                                                        error
                                                                            =
                                                                            90i32
                                                                    } else {
                                                                        error
                                                                            =
                                                                            11i32
                                                                    }
                                                                    current_block
                                                                        =
                                                                        14645908287508918710;
                                                                } else {
                                                                    (*stcb).asoc.sb_send_resv
                                                                        =
                                                                        ((*stcb).asoc.sb_send_resv).wrapping_add(sndlen
                                                                                                            as
                                                                                                            uint32_t);
                                                                    pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                                                    hold_tcblock
                                                                        =
                                                                        0i32;
                                                                    current_block
                                                                        =
                                                                        3879551714951528895;
                                                                }
                                                            } else {
                                                                ::std::intrinsics::atomic_xadd(
                                                                    &mut (*stcb).asoc.sb_send_resv,
                                                                    sndlen as uint32_t,
                                                                );
                                                                current_block = 3879551714951528895;
                                                            }
                                                            match current_block {
                                                                14645908287508918710 => {}
                                                                _ => {
                                                                    local_soresv = sndlen;
                                                                    if (*stcb).asoc.state & 0x200i32
                                                                        != 0
                                                                    {
                                                                        error = 104i32
                                                                    } else {
                                                                        if create_lock_applied != 0
                                                                        {
                                                                            pthread_mutex_unlock(
                                                                                &mut (*inp)
                                                                                    .inp_create_mtx,
                                                                            );
                                                                            create_lock_applied =
                                                                                0i32
                                                                        }
                                                                        /* Is the stream no. valid? */
                                                                        if (*srcv).sinfo_stream
                                                                            as libc::c_int
                                                                            >= (*asoc).streamoutcnt
                                                                                as libc::c_int
                                                                        {
                                                                            /* Invalid stream number */
                                                                            error = 22i32
                                                                        } else if (*(*asoc)
                                                                            .strmout
                                                                            .offset(
                                                                                (*srcv).sinfo_stream
                                                                                    as isize,
                                                                            ))
                                                                        .state
                                                                            as libc::c_int
                                                                            != 0x2i32
                                                                            && (*(*asoc)
                                                                                .strmout
                                                                                .offset(
                                                                                (*srcv).sinfo_stream
                                                                                    as isize,
                                                                            ))
                                                                            .state
                                                                                as libc::c_int
                                                                                != 0x1i32
                                                                        {
                                                                            /*
                                                                             * Can't queue any data while stream reset is underway.
                                                                             */
                                                                            if (*(*asoc)
                                                                                .strmout
                                                                                .offset(
                                                                                (*srcv).sinfo_stream
                                                                                    as isize,
                                                                            ))
                                                                            .state
                                                                                as libc::c_int
                                                                                > 0x2i32
                                                                            {
                                                                                error = 11i32
                                                                            } else {
                                                                                error = 22i32
                                                                            }
                                                                        } else {
                                                                            if (*stcb).asoc.state
                                                                                & 0x7fi32
                                                                                == 0x2i32
                                                                                || (*stcb)
                                                                                    .asoc
                                                                                    .state
                                                                                    & 0x7fi32
                                                                                    == 0x4i32
                                                                            {
                                                                                queue_only = 1i32
                                                                            }
                                                                            /* we are now done with all control */
                                                                            if !control.is_null() {
                                                                                m_freem(control);
                                                                                control =
                                                                                    0 as *mut mbuf
                                                                            }
                                                                            if (*stcb).asoc.state
                                                                                & 0x7fi32
                                                                                == 0x10i32
                                                                                || (*stcb)
                                                                                    .asoc
                                                                                    .state
                                                                                    & 0x7fi32
                                                                                    == 0x20i32
                                                                                || (*stcb)
                                                                                    .asoc
                                                                                    .state
                                                                                    & 0x7fi32
                                                                                    == 0x40i32
                                                                                || (*asoc).state
                                                                                    & 0x80i32
                                                                                    != 0
                                                                            {
                                                                                if sinfo_flags
                                                                                    as libc::c_int
                                                                                    & 0x200i32
                                                                                    != 0
                                                                                {
                                                                                    current_block
                                                                                        =
                                                                                        12364753662483254401;
                                                                                } else {
                                                                                    error = 104i32;
                                                                                    current_block
                                                                                        =
                                                                                        14645908287508918710;
                                                                                }
                                                                            } else {
                                                                                current_block
                                                                                    =
                                                                                    12364753662483254401;
                                                                            }
                                                                            match current_block
                                                                                {
                                                                                14645908287508918710
                                                                                =>
                                                                                {
                                                                                }
                                                                                _
                                                                                =>

                                                                                /* Ok, we will attempt a msgsnd :> */
                                                                                /* Are we aborting? */
                                                                                {
                                                                                    if sinfo_flags
                                                                                           as
                                                                                           libc::c_int
                                                                                           &
                                                                                           0x200i32
                                                                                           !=
                                                                                           0
                                                                                       {
                                                                                        ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_sends_with_abort,
                                                                                                                       1u32);
                                                                                        if (*stcb).asoc.state
                                                                                               &
                                                                                               0x7fi32
                                                                                               ==
                                                                                               0x2i32
                                                                                               ||
                                                                                               (*stcb).asoc.state
                                                                                                   &
                                                                                                   0x7fi32
                                                                                                   ==
                                                                                                   0x4i32
                                                                                           {
                                                                                            /* It has to be up before we abort */
			/* how big is the user initiated abort? */
                                                                                            error
                                                                                                =
                                                                                                22i32
                                                                                        } else {
                                                                                                 let mut mm =
                                                                                            0
                                                                                                as
                                                                                                *mut mbuf; let mut tot_out =
                                                                                            0i64;if hold_tcblock
                                                                                                   !=
                                                                                                   0
                                                                                               {
                                                                                                pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                                                                                hold_tcblock
                                                                                                    =
                                                                                                    0i32
                                                                                            }
                                                                                            if !top.is_null()
                                                                                               {
                                                                                                mm
                                                                                                    =
                                                                                                    sctp_get_mbuf_for_msg(::std::mem::size_of::<sctp_paramhdr>()
                                                                                                                              as
                                                                                                                              libc::c_uint,
                                                                                                                          0i32,
                                                                                                                          0x2i32,
                                                                                                                          1i32,
                                                                                                                          1i32);
                                                                                                if sndlen
                                                                                                       !=
                                                                                                       0i64
                                                                                                   {
                                                                                                       let mut cntm =
                                                                                                    0
                                                                                                        as
                                                                                                        *mut mbuf;cntm
                                                                                                        =
                                                                                                        top;
                                                                                                    while !cntm.is_null()
                                                                                                          {
                                                                                                        tot_out
                                                                                                            +=
                                                                                                            (*cntm).m_hdr.mh_len
                                                                                                                as
                                                                                                                libc::c_long;
                                                                                                        cntm
                                                                                                            =
                                                                                                            (*cntm).m_hdr.mh_next
                                                                                                    }
                                                                                                }
                                                                                                current_block
                                                                                                    =
                                                                                                    8298116646536739282;
                                                                                            } else {
                                                                                                  let mut tot_demand =
                                                                                            0;tot_out
                                                                                                    =
                                                                                                    sndlen;
                                                                                                tot_demand
                                                                                                    =
                                                                                                    (tot_out
                                                                                                         as
                                                                                                         libc::c_ulong).wrapping_add(::std::mem::size_of::<sctp_paramhdr>()
                                                                                                                                         as
                                                                                                                                         libc::c_ulong)
                                                                                                        as
                                                                                                        ssize_t;
                                                                                                if tot_demand
                                                                                                       >
                                                                                                       1452i64
                                                                                                   {
                                                                                                    /* To big */
                                                                                                    error
                                                                                                        =
                                                                                                        90i32;
                                                                                                    current_block
                                                                                                        =
                                                                                                        14645908287508918710;
                                                                                                } else {
                                                                                                    mm
                                                                                                        =
                                                                                                        sctp_get_mbuf_for_msg(tot_demand
                                                                                                                                  as
                                                                                                                                  libc::c_uint,
                                                                                                                              0i32,
                                                                                                                              0x2i32,
                                                                                                                              1i32,
                                                                                                                              1i32);
                                                                                                    current_block
                                                                                                        =
                                                                                                        8298116646536739282;
                                                                                                }
                                                                                            }
                                                                                            match current_block
                                                                                                {
                                                                                                14645908287508918710
                                                                                                =>
                                                                                                {
                                                                                                }
                                                                                                _
                                                                                                =>
                                                                                                {
                                                                                                    if mm.is_null()
                                                                                                       {
                                                                                                        error
                                                                                                            =
                                                                                                            12i32
                                                                                                    } else {
                                                                                                           let mut max_out =
                                                                                            0;max_out
                                                                                                            =
                                                                                                            ((*asoc).smallest_mtu
                                                                                                                 as
                                                                                                                 libc::c_ulong).wrapping_sub(::std::mem::size_of::<sctp_paramhdr>()
                                                                                                                                                 as
                                                                                                                                                 libc::c_ulong)
                                                                                                                as
                                                                                                                ssize_t;
                                                                                                        max_out
                                                                                                            =

                                                                                                            (max_out
                                                                                                                 as
                                                                                                                 libc::c_ulong).wrapping_sub(::std::mem::size_of::<sctp_abort_msg>()
                                                                                                                                                 as
                                                                                                                                                 libc::c_ulong)
                                                                                                                as
                                                                                                                ssize_t;
                                                                                                        if tot_out
                                                                                                               >
                                                                                                               max_out
                                                                                                           {
                                                                                                            tot_out
                                                                                                                =
                                                                                                                max_out
                                                                                                        }
                                                                                                        if !mm.is_null()
                                                                                                           {
                                                                                                               let mut ph =
                                                                                                                0
                                                                                                                    as
                                                                                                                    *mut sctp_paramhdr;
                                                                                                            /* now move forward the data pointer */
                                                                                                            ph
                                                                                                                =
                                                                                                                (*mm).m_hdr.mh_data
                                                                                                                    as
                                                                                                                    *mut sctp_paramhdr;
                                                                                                            (*ph).param_type
                                                                                                                =
                                                                                                                htons(0xcu16);
                                                                                                            (*ph).param_length
                                                                                                                =
                                                                                                                htons((::std::mem::size_of::<sctp_paramhdr>()
                                                                                                                           as
                                                                                                                           libc::c_ulong).wrapping_add(tot_out
                                                                                                                                                           as
                                                                                                                                                           libc::c_ulong)
                                                                                                                          as
                                                                                                                          uint16_t);
                                                                                                            ph
                                                                                                                =
                                                                                                                ph.offset(1);
                                                                                                            (*mm).m_hdr.mh_len
                                                                                                                =
                                                                                                                (tot_out
                                                                                                                     as
                                                                                                                     libc::c_ulong).wrapping_add(::std::mem::size_of::<sctp_paramhdr>()
                                                                                                                                                     as
                                                                                                                                                     libc::c_ulong)
                                                                                                                    as
                                                                                                                    libc::c_int;
                                                                                                            if top.is_null()
                                                                                                               {
                                                                                                                error
                                                                                                                    =
                                                                                                                    uiomove(ph
                                                                                                                                as
                                                                                                                                *mut libc::c_void,
                                                                                                                            tot_out
                                                                                                                                as
                                                                                                                                libc::c_int,
                                                                                                                            uio);
                                                                                                                if error
                                                                                                                       !=
                                                                                                                       0
                                                                                                                   {
                                                                                                                    /*-
					 * Here if we can't get his data we
					 * still abort we just don't get to
					 * send the users note :-0
					 */
                                                                                                                    m_freem(mm);
                                                                                                                    mm
                                                                                                                        =
                                                                                                                        0
                                                                                                                            as
                                                                                                                            *mut mbuf
                                                                                                                }
                                                                                                            } else if sndlen
                                                                                                                          !=
                                                                                                                          0i64
                                                                                                             {
                                                                                                                (*mm).m_hdr.mh_next
                                                                                                                    =
                                                                                                                    top
                                                                                                            }
                                                                                                        }
                                                                                                        if hold_tcblock
                                                                                                               ==
                                                                                                               0i32
                                                                                                           {
                                                                                                            pthread_mutex_lock(&mut (*stcb).tcb_mtx);
                                                                                                        }
                                                                                                        ::std::intrinsics::atomic_xadd(&mut (*stcb).asoc.refcnt,
                                                                                                                                       -(1i32)
                                                                                                                                           as
                                                                                                                                           uint32_t);
                                                                                                        free_cnt_applied
                                                                                                            =
                                                                                                            0i32;
                                                                                                        /* release this lock, otherwise we hang on ourselves */
                                                                                                        sctp_abort_an_association((*stcb).sctp_ep,
                                                                                                                                  stcb,
                                                                                                                                  mm,
                                                                                                                                  1i32);
                                                                                                        /* now relock the stcb so everything is sane */
                                                                                                        hold_tcblock
                                                                                                            =
                                                                                                            0i32;
                                                                                                        stcb
                                                                                                            =
                                                                                                            0
                                                                                                                as
                                                                                                                *mut sctp_tcb;
                                                                                                        /* In this case top is already chained to mm
		 * avoid double free, since we free it below if
		 * top != NULL and driver would free it after sending
		 * the packet out
		 */
                                                                                                        if sndlen
                                                                                                               !=
                                                                                                               0i64
                                                                                                           {
                                                                                                            top
                                                                                                                =
                                                                                                                0
                                                                                                                    as
                                                                                                                    *mut mbuf
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    } else {
                                                                                          let mut max_len =    0;inqueue_bytes
                                                                                            =
                                                                                            ((*stcb).asoc.total_output_queue_size
                                                                                                 as
                                                                                                 libc::c_ulong).wrapping_sub(((*stcb).asoc.chunks_on_out_queue
                                                                                                                                  as
                                                                                                                                  libc::c_ulong).wrapping_mul((if (*stcb).asoc.idata_supported
                                                                                                                                                                      as
                                                                                                                                                                      libc::c_int
                                                                                                                                                                      !=
                                                                                                                                                                      0
                                                                                                                                                                  {
                                                                                                                                                                   ::std::mem::size_of::<sctp_idata_chunk>()
                                                                                                                                                                       as
                                                                                                                                                                       libc::c_ulong
                                                                                                                                                               } else {
                                                                                                                                                                   ::std::mem::size_of::<sctp_data_chunk>()
                                                                                                                                                                       as
                                                                                                                                                                       libc::c_ulong
                                                                                                                                                               })))
                                                                                                as
                                                                                                libc::c_uint;
                                                                                        if (*so).so_snd.sb_hiwat
                                                                                               >
                                                                                               inqueue_bytes
                                                                                           {
                                                                                            max_len
                                                                                                =
                                                                                                (*so).so_snd.sb_hiwat.wrapping_sub(inqueue_bytes)
                                                                                                    as
                                                                                                    ssize_t
                                                                                        } else {
                                                                                            max_len
                                                                                                =
                                                                                                0i64
                                                                                        }
                                                                                        if hold_tcblock
                                                                                               !=
                                                                                               0
                                                                                           {
                                                                                            pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                                                                            hold_tcblock
                                                                                                =
                                                                                                0i32
                                                                                        }
                                                                                        if (*asoc).strmout.is_null()
                                                                                           {
                                                                                            /* huh? software error */
                                                                                            error
                                                                                                =
                                                                                                14i32
                                                                                        } else if user_marks_eor
                                                                                                      ==
                                                                                                      0i32
                                                                                                      &&
                                                                                                      sndlen
                                                                                                          >
                                                                                                          (*(*stcb).sctp_socket).so_snd.sb_hiwat
                                                                                                              as
                                                                                                              ssize_t
                                                                                         {
                                                                                            /* Unless E_EOR mode is on, we must make a send FIT in one call. */
                                                                                            /* It will NEVER fit */
                                                                                            error
                                                                                                =
                                                                                                90i32
                                                                                        } else if uio.is_null()
                                                                                                      &&
                                                                                                      user_marks_eor
                                                                                                          !=
                                                                                                          0
                                                                                         {
                                                                                            /*-
		 * We do not support eeor mode for
		 * sending with mbuf chains (like sendfile).
		 */
                                                                                            error
                                                                                                =
                                                                                                22i32
                                                                                        } else {
                                                                                                   let mut local_add_more =    0; let mut len =    0; let mut be =    sctp_block_entry{error: 0,};if user_marks_eor
                                                                                                   !=
                                                                                                   0
                                                                                               {
                                                                                                local_add_more
                                                                                                    =
                                                                                                    if (*so).so_snd.sb_hiwat
                                                                                                           >
                                                                                                           system_base_info.sctpsysctl.sctp_add_more_threshold
                                                                                                       {
                                                                                                        system_base_info.sctpsysctl.sctp_add_more_threshold
                                                                                                    } else {
                                                                                                        (*so).so_snd.sb_hiwat
                                                                                                    }
                                                                                                        as
                                                                                                        ssize_t
                                                                                            } else {
                                                                                                /*-
		 * For non-eeor the whole message must fit in
		 * the socket send buffer.
		 */
                                                                                                local_add_more
                                                                                                    =
                                                                                                    sndlen
                                                                                            }
                                                                                            len
                                                                                                =
                                                                                                0i32;
                                                                                            if non_blocking
                                                                                                   !=
                                                                                                   0
                                                                                               {
                                                                                                current_block
                                                                                                    =
                                                                                                    8517026427801523144;
                                                                                            } else if max_len
                                                                                                          <=
                                                                                                          local_add_more
                                                                                                          &&
                                                                                                          (*so).so_snd.sb_hiwat
                                                                                                              as
                                                                                                              ssize_t
                                                                                                              >=
                                                                                                              local_add_more
                                                                                                          ||
                                                                                                          max_len
                                                                                                              ==
                                                                                                              0i64
                                                                                                          ||
                                                                                                          (*stcb).asoc.chunks_on_out_queue.wrapping_add((*stcb).asoc.stream_queue_cnt)
                                                                                                              >=
                                                                                                              system_base_info.sctpsysctl.sctp_max_chunks_on_queue
                                                                                             {
                                                                                                /* No room right now ! */
                                                                                                pthread_mutex_lock(&mut (*so).so_snd.sb_mtx);
                                                                                                inqueue_bytes
                                                                                                    =
                                                                                                    ((*stcb).asoc.total_output_queue_size
                                                                                                         as
                                                                                                         libc::c_ulong).wrapping_sub(((*stcb).asoc.chunks_on_out_queue
                                                                                                                                          as
                                                                                                                                          libc::c_ulong).wrapping_mul((if (*stcb).asoc.idata_supported
                                                                                                                                                                              as
                                                                                                                                                                              libc::c_int
                                                                                                                                                                              !=
                                                                                                                                                                              0
                                                                                                                                                                          {
                                                                                                                                                                           ::std::mem::size_of::<sctp_idata_chunk>()
                                                                                                                                                                               as
                                                                                                                                                                               libc::c_ulong
                                                                                                                                                                       } else {
                                                                                                                                                                           ::std::mem::size_of::<sctp_data_chunk>()
                                                                                                                                                                               as
                                                                                                                                                                               libc::c_ulong
                                                                                                                                                                       })))
                                                                                                        as
                                                                                                        libc::c_uint;
                                                                                                loop
                                                                                                     {
                                                                                                    if !(((*so).so_snd.sb_hiwat
                                                                                                              as
                                                                                                              libc::c_long)
                                                                                                             <
                                                                                                             inqueue_bytes
                                                                                                                 as
                                                                                                                 libc::c_long
                                                                                                                 +
                                                                                                                 local_add_more
                                                                                                             ||
                                                                                                             (*stcb).asoc.stream_queue_cnt.wrapping_add((*stcb).asoc.chunks_on_out_queue)
                                                                                                                 >=
                                                                                                                 system_base_info.sctpsysctl.sctp_max_chunks_on_queue)
                                                                                                       {
                                                                                                        current_block
                                                                                                            =
                                                                                                            9598485154371622742;
                                                                                                        break
                                                                                                            ;
                                                                                                    }
                                                                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                                                                           &
                                                                                                           0x10u32
                                                                                                           !=
                                                                                                           0
                                                                                                       {
                                                                                                        if system_base_info.debug_printf.is_some()
                                                                                                           {
                                                                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"pre_block limit:%u <(inq:%d + %zd) || (%d+%d > %d)\n\x00"
                                                                                                                                                                                  as
                                                                                                                                                                                  *const u8
                                                                                                                                                                                  as
                                                                                                                                                                                  *const libc::c_char,
                                                                                                                                                                              (*so).so_snd.sb_hiwat,
                                                                                                                                                                              inqueue_bytes,
                                                                                                                                                                              local_add_more,
                                                                                                                                                                              (*stcb).asoc.stream_queue_cnt,
                                                                                                                                                                              (*stcb).asoc.chunks_on_out_queue,
                                                                                                                                                                              system_base_info.sctpsysctl.sctp_max_chunks_on_queue);
                                                                                                        }
                                                                                                    }
                                                                                                    if system_base_info.sctpsysctl.sctp_logging_level
                                                                                                           &
                                                                                                           0x1u32
                                                                                                           !=
                                                                                                           0
                                                                                                       {
                                                                                                        sctp_log_block(81u8,
                                                                                                                       asoc,
                                                                                                                       sndlen);
                                                                                                    }
                                                                                                    be.error
                                                                                                        =
                                                                                                        0i32;
                                                                                                    (*stcb).block_entry
                                                                                                        =
                                                                                                        &mut be;
                                                                                                    error
                                                                                                        =
                                                                                                        sbwait(&mut (*so).so_snd);
                                                                                                    (*stcb).block_entry
                                                                                                        =
                                                                                                        0
                                                                                                            as
                                                                                                            *mut sctp_block_entry;
                                                                                                    if error
                                                                                                           !=
                                                                                                           0
                                                                                                           ||
                                                                                                           (*so).so_error
                                                                                                               as
                                                                                                               libc::c_int
                                                                                                               !=
                                                                                                               0
                                                                                                           ||
                                                                                                           be.error
                                                                                                               !=
                                                                                                               0
                                                                                                       {
                                                                                                        if error
                                                                                                               ==
                                                                                                               0i32
                                                                                                           {
                                                                                                            if (*so).so_error
                                                                                                                   !=
                                                                                                                   0
                                                                                                               {
                                                                                                                error
                                                                                                                    =
                                                                                                                    (*so).so_error
                                                                                                                        as
                                                                                                                        libc::c_int
                                                                                                            }
                                                                                                            if be.error
                                                                                                                   !=
                                                                                                                   0
                                                                                                               {
                                                                                                                error
                                                                                                                    =
                                                                                                                    be.error
                                                                                                            }
                                                                                                        }
                                                                                                        pthread_mutex_unlock(&mut (*so).so_snd.sb_mtx);
                                                                                                        current_block
                                                                                                            =
                                                                                                            14645908287508918710;
                                                                                                        break
                                                                                                            ;
                                                                                                    } else {
                                                                                                        if system_base_info.sctpsysctl.sctp_logging_level
                                                                                                               &
                                                                                                               0x1u32
                                                                                                               !=
                                                                                                               0
                                                                                                           {
                                                                                                            sctp_log_block(8u8,
                                                                                                                           asoc,
                                                                                                                           (*stcb).asoc.total_output_queue_size
                                                                                                                               as
                                                                                                                               ssize_t);
                                                                                                        }
                                                                                                        if (*stcb).asoc.state
                                                                                                               &
                                                                                                               0x200i32
                                                                                                               !=
                                                                                                               0
                                                                                                           {
                                                                                                            pthread_mutex_unlock(&mut (*so).so_snd.sb_mtx);
                                                                                                            current_block
                                                                                                                =
                                                                                                                14645908287508918710;
                                                                                                            break
                                                                                                                ;
                                                                                                        } else {
                                                                                                            inqueue_bytes
                                                                                                                =
                                                                                                                ((*stcb).asoc.total_output_queue_size
                                                                                                                     as
                                                                                                                     libc::c_ulong).wrapping_sub(((*stcb).asoc.chunks_on_out_queue
                                                                                                                                                      as
                                                                                                                                                      libc::c_ulong).wrapping_mul((if (*stcb).asoc.idata_supported
                                                                                                                                                                                          as
                                                                                                                                                                                          libc::c_int
                                                                                                                                                                                          !=
                                                                                                                                                                                          0
                                                                                                                                                                                      {
                                                                                                                                                                                       ::std::mem::size_of::<sctp_idata_chunk>()
                                                                                                                                                                                           as
                                                                                                                                                                                           libc::c_ulong
                                                                                                                                                                                   } else {
                                                                                                                                                                                       ::std::mem::size_of::<sctp_data_chunk>()
                                                                                                                                                                                           as
                                                                                                                                                                                           libc::c_ulong
                                                                                                                                                                                   })))
                                                                                                                    as
                                                                                                                    libc::c_uint
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                                match current_block
                                                                                                    {
                                                                                                    14645908287508918710
                                                                                                    =>
                                                                                                    {
                                                                                                    }
                                                                                                    _
                                                                                                    =>
                                                                                                    {
                                                                                                        if (*so).so_snd.sb_hiwat
                                                                                                               >
                                                                                                               inqueue_bytes
                                                                                                           {
                                                                                                            max_len
                                                                                                                =
                                                                                                                (*so).so_snd.sb_hiwat.wrapping_sub(inqueue_bytes)
                                                                                                                    as
                                                                                                                    ssize_t
                                                                                                        } else {
                                                                                                            max_len
                                                                                                                =
                                                                                                                0i64
                                                                                                        }
                                                                                                        pthread_mutex_unlock(&mut (*so).so_snd.sb_mtx);
                                                                                                        current_block
                                                                                                            =
                                                                                                            8517026427801523144;
                                                                                                    }
                                                                                                }
                                                                                            } else {
                                                                                                current_block
                                                                                                    =
                                                                                                    8517026427801523144;
                                                                                            }
                                                                                            match current_block
                                                                                                {
                                                                                                14645908287508918710
                                                                                                =>
                                                                                                {
                                                                                                }
                                                                                                _
                                                                                                =>
                                                                                                {
                                                                                                    if !((*stcb).asoc.state
                                                                                                             &
                                                                                                             0x200i32
                                                                                                             !=
                                                                                                             0)
                                                                                                       {
                                                                                                              let mut un_sent =    0; let mut nagle_applies =    0i32; let mut got_all_of_the_send =    0i32;if sndlen
                                                                                                               ==
                                                                                                               0i64
                                                                                                           {
                                                                                                            if sinfo_flags
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   &
                                                                                                                   0x100i32
                                                                                                                   !=
                                                                                                                   0
                                                                                                               {
                                                                                                                got_all_of_the_send
                                                                                                                    =
                                                                                                                    1i32;
                                                                                                                current_block
                                                                                                                    =
                                                                                                                    14249592727310794991;
                                                                                                            } else {
                                                                                                                error
                                                                                                                    =
                                                                                                                    22i32;
                                                                                                                current_block
                                                                                                                    =
                                                                                                                    14645908287508918710;
                                                                                                            }
                                                                                                        } else {
                                                                                                            if top.is_null()
                                                                                                               {



                                                                                                                pthread_mutex_lock(&mut (*stcb).tcb_send_mtx);
                                                                                                                if (*asoc).stream_locked
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       !=
                                                                                                                       0
                                                                                                                       &&
                                                                                                                       (*asoc).stream_locked_on
                                                                                                                           as
                                                                                                                           libc::c_int
                                                                                                                           !=
                                                                                                                           (*srcv).sinfo_stream
                                                                                                                               as
                                                                                                                               libc::c_int
                                                                                                                   {
                                                                                                                    pthread_mutex_unlock(&mut (*stcb).tcb_send_mtx);
                                                                                                                    error
                                                                                                                        =
                                                                                                                        22i32;
                                                                                                                    current_block
                                                                                                                        =
                                                                                                                        14645908287508918710;
                                                                                                                } else {
                                                                                                                         let mut sp =

                                                                                                                    0
                                                                                                                        as
                                                                                                                        *mut sctp_stream_queue_pending; let mut strm =
                                                                                                                    0
                                                                                                                        as
                                                                                                                        *mut sctp_stream_out;pthread_mutex_unlock(&mut (*stcb).tcb_send_mtx);
                                                                                                                    strm
                                                                                                                        =
                                                                                                                        &mut *(*stcb).asoc.strmout.offset((*srcv).sinfo_stream
                                                                                                                                                              as
                                                                                                                                                              isize)
                                                                                                                            as
                                                                                                                            *mut sctp_stream_out;
                                                                                                                    if (*strm).last_msg_incomplete
                                                                                                                           as
                                                                                                                           libc::c_int
                                                                                                                           ==
                                                                                                                           0i32
                                                                                                                       {
                                                                                                                        current_block
                                                                                                                            =
                                                                                                                            14912324292491694597;
                                                                                                                    } else {
                                                                                                                        pthread_mutex_lock(&mut (*stcb).tcb_send_mtx);
                                                                                                                        sp
                                                                                                                            =
                                                                                                                            *(*((*strm).outqueue.tqh_last
                                                                                                                                    as
                                                                                                                                    *mut sctp_streamhead)).tqh_last;
                                                                                                                        pthread_mutex_unlock(&mut (*stcb).tcb_send_mtx);
                                                                                                                        if sp.is_null()
                                                                                                                           {
                                                                                                                            /* ???? Huh ??? last msg is gone */
                                                                                                                            if system_base_info.debug_printf.is_some()
                                                                                                                               {
                                                                                                                                system_base_info.debug_printf.expect("non-null function pointer")(b"Warning: Last msg marked incomplete, yet nothing left?\n\x00"
                                                                                                                                                                                                      as
                                                                                                                                                                                                      *const u8
                                                                                                                                                                                                      as
                                                                                                                                                                                                      *const libc::c_char);
                                                                                                                            }
                                                                                                                            (*strm).last_msg_incomplete
                                                                                                                                =
                                                                                                                                0u8;
                                                                                                                            current_block
                                                                                                                                =
                                                                                                                                14912324292491694597;
                                                                                                                        } else {
                                                                                                                            current_block
                                                                                                                                =
                                                                                                                                12841893240905684395;
                                                                                                                        }
                                                                                                                    }
                                                                                                                    match current_block
                                                                                                                        {
                                                                                                                        14912324292491694597
                                                                                                                        =>
                                                                                                                        {
                                                                                                                            sp
                                                                                                                                =
                                                                                                                                sctp_copy_it_in(stcb,
                                                                                                                                                asoc,
                                                                                                                                                srcv,
                                                                                                                                                uio,
                                                                                                                                                net,
                                                                                                                                                max_len,
                                                                                                                                                user_marks_eor,
                                                                                                                                                &mut error);
                                                                                                                            if error
                                                                                                                                   !=
                                                                                                                                   0
                                                                                                                               {
                                                                                                                                current_block
                                                                                                                                    =
                                                                                                                                    14645908287508918710;
                                                                                                                            } else {
                                                                                                                                pthread_mutex_lock(&mut (*stcb).tcb_send_mtx);
                                                                                                                                if (*sp).msg_is_complete
                                                                                                                                       !=
                                                                                                                                       0
                                                                                                                                   {
                                                                                                                                    (*strm).last_msg_incomplete
                                                                                                                                        =
                                                                                                                                        0u8;
                                                                                                                                    (*asoc).stream_locked
                                                                                                                                        =
                                                                                                                                        0u8
                                                                                                                                } else {
                                                                                                                                    /* Just got locked to this guy in
				 * case of an interrupt.
				 */
                                                                                                                                    (*strm).last_msg_incomplete
                                                                                                                                        =
                                                                                                                                        1u8;
                                                                                                                                    if (*stcb).asoc.idata_supported
                                                                                                                                           as
                                                                                                                                           libc::c_int
                                                                                                                                           ==
                                                                                                                                           0i32
                                                                                                                                       {
                                                                                                                                        (*asoc).stream_locked
                                                                                                                                            =
                                                                                                                                            1u8;
                                                                                                                                        (*asoc).stream_locked_on
                                                                                                                                            =
                                                                                                                                            (*srcv).sinfo_stream
                                                                                                                                    }
                                                                                                                                    (*sp).sender_all_done
                                                                                                                                        =
                                                                                                                                        0u8
                                                                                                                                }
                                                                                                                                ::std::intrinsics::atomic_xadd(&mut (*stcb).asoc.total_output_queue_size,
                                                                                                                                                               (*sp).length);
                                                                                                                                if !(*stcb).sctp_socket.is_null()
                                                                                                                                       &&
                                                                                                                                       ((*(*stcb).sctp_ep).sctp_flags
                                                                                                                                            &
                                                                                                                                            0x2u32
                                                                                                                                            !=
                                                                                                                                            0
                                                                                                                                            ||
                                                                                                                                            (*(*stcb).sctp_ep).sctp_flags
                                                                                                                                                &
                                                                                                                                                0x400000u32
                                                                                                                                                !=
                                                                                                                                                0)
                                                                                                                                   {
                                                                                                                                    ::std::intrinsics::atomic_xadd(&mut (*(*stcb).sctp_socket).so_snd.sb_cc,
                                                                                                                                                                   (*sp).length);
                                                                                                                                }
                                                                                                                                ::std::intrinsics::atomic_xadd(&mut (*asoc).stream_queue_cnt,
                                                                                                                                                               1u32);
                                                                                                                                if sinfo_flags
                                                                                                                                       as
                                                                                                                                       libc::c_int
                                                                                                                                       &
                                                                                                                                       0x400i32
                                                                                                                                       !=
                                                                                                                                       0
                                                                                                                                   {
                                                                                                                                    ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_sends_with_unord,
                                                                                                                                                                   1u32);
                                                                                                                                }
                                                                                                                                (*sp).next.tqe_next
                                                                                                                                    =
                                                                                                                                    0
                                                                                                                                        as
                                                                                                                                        *mut sctp_stream_queue_pending;
                                                                                                                                (*sp).next.tqe_prev
                                                                                                                                    =
                                                                                                                                    (*strm).outqueue.tqh_last;
                                                                                                                                *(*strm).outqueue.tqh_last
                                                                                                                                    =
                                                                                                                                    sp;
                                                                                                                                (*strm).outqueue.tqh_last
                                                                                                                                    =
                                                                                                                                    &mut (*sp).next.tqe_next;
                                                                                                                                (*stcb).asoc.ss_functions.sctp_ss_add_to_stream.expect("non-null function pointer")(stcb,
                                                                                                                                                                                                                    asoc,
                                                                                                                                                                                                                    strm,
                                                                                                                                                                                                                    sp,
                                                                                                                                                                                                                    1i32);
                                                                                                                                pthread_mutex_unlock(&mut (*stcb).tcb_send_mtx);
                                                                                                                                current_block
                                                                                                                                    =
                                                                                                                                    12841893240905684395;
                                                                                                                            }
                                                                                                                        }
                                                                                                                        _
                                                                                                                        =>
                                                                                                                        {
                                                                                                                        }
                                                                                                                    }
                                                                                                                    match current_block
                                                                                                                        {
                                                                                                                        14645908287508918710
                                                                                                                        =>
                                                                                                                        {
                                                                                                                        }
                                                                                                                        _
                                                                                                                        =>
                                                                                                                        {
                                                                                                                            loop

                                                                                                                                 /* got it all? */
                                                                                                                                 {
                                                                                                                                if !((*uio).uio_resid
                                                                                                                                         >
                                                                                                                                         0i64)
                                                                                                                                   {
                                                                                                                                    current_block
                                                                                                                                        =
                                                                                                                                        17927085222977126794;
                                                                                                                                    break
                                                                                                                                        ;
                                                                                                                                }


                                                                                                                                inqueue_bytes
                                                                                                                                    =
                                                                                                                                    ((*stcb).asoc.total_output_queue_size
                                                                                                                                         as
                                                                                                                                         libc::c_ulong).wrapping_sub(((*stcb).asoc.chunks_on_out_queue
                                                                                                                                                                          as
                                                                                                                                                                          libc::c_ulong).wrapping_mul((if (*stcb).asoc.idata_supported
                                                                                                                                                                                                              as
                                                                                                                                                                                                              libc::c_int
                                                                                                                                                                                                              !=
                                                                                                                                                                                                              0
                                                                                                                                                                                                          {
                                                                                                                                                                                                           ::std::mem::size_of::<sctp_idata_chunk>()
                                                                                                                                                                                                               as
                                                                                                                                                                                                               libc::c_ulong
                                                                                                                                                                                                       } else {
                                                                                                                                                                                                           ::std::mem::size_of::<sctp_data_chunk>()
                                                                                                                                                                                                               as
                                                                                                                                                                                                               libc::c_ulong
                                                                                                                                                                                                       })))
                                                                                                                                        as
                                                                                                                                        libc::c_uint;
                                                                                                                                if (*so).so_snd.sb_hiwat
                                                                                                                                       >
                                                                                                                                       inqueue_bytes
                                                                                                                                   {
                                                                                                                                    max_len
                                                                                                                                        =
                                                                                                                                        (*so).so_snd.sb_hiwat.wrapping_sub(inqueue_bytes)
                                                                                                                                            as
                                                                                                                                            ssize_t
                                                                                                                                } else {
                                                                                                                                    max_len
                                                                                                                                        =
                                                                                                                                        0i64
                                                                                                                                }
                                                                                                                                if max_len
                                                                                                                                       >
                                                                                                                                       system_base_info.sctpsysctl.sctp_add_more_threshold
                                                                                                                                           as
                                                                                                                                           ssize_t
                                                                                                                                       ||
                                                                                                                                       max_len
                                                                                                                                           !=
                                                                                                                                           0
                                                                                                                                           &&
                                                                                                                                           (*so).so_snd.sb_hiwat
                                                                                                                                               <
                                                                                                                                               system_base_info.sctpsysctl.sctp_add_more_threshold
                                                                                                                                       ||
                                                                                                                                       (*uio).uio_resid
                                                                                                                                           !=
                                                                                                                                           0
                                                                                                                                           &&
                                                                                                                                           (*uio).uio_resid
                                                                                                                                               <=
                                                                                                                                               max_len
                                                                                                                                   {
                                                                                                                                           let mut sndout =
                                                                                                                    0; let mut new_tail =
                                                                                                                                    0
                                                                                                                                        as
                                                                                                                                        *mut mbuf; let mut mm_0 =
                                                                                                                                    0
                                                                                                                                        as
                                                                                                                                        *mut mbuf;sndout
                                                                                                                                        =
                                                                                                                                        0u32;
                                                                                                                                    new_tail
                                                                                                                                        =
                                                                                                                                        0
                                                                                                                                            as
                                                                                                                                            *mut mbuf;
                                                                                                                                    if hold_tcblock
                                                                                                                                           !=
                                                                                                                                           0
                                                                                                                                       {
                                                                                                                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                                                                                                                        hold_tcblock
                                                                                                                                            =
                                                                                                                                            0i32
                                                                                                                                    }
                                                                                                                                    mm_0
                                                                                                                                        =
                                                                                                                                        sctp_copy_resume(uio,
                                                                                                                                                         max_len
                                                                                                                                                             as
                                                                                                                                                             libc::c_int,
                                                                                                                                                         user_marks_eor,
                                                                                                                                                         &mut error,
                                                                                                                                                         &mut sndout,
                                                                                                                                                         &mut new_tail);
                                                                                                                                    if mm_0.is_null()
                                                                                                                                           ||
                                                                                                                                           error
                                                                                                                                               !=
                                                                                                                                               0
                                                                                                                                       {
                                                                                                                                        if !mm_0.is_null()
                                                                                                                                           {
                                                                                                                                            m_freem(mm_0);
                                                                                                                                        }
                                                                                                                                        current_block
                                                                                                                                            =
                                                                                                                                            14645908287508918710;
                                                                                                                                        break
                                                                                                                                            ;
                                                                                                                                    } else {
                                                                                                                                        /* Update the mbuf and count */
                                                                                                                                        pthread_mutex_lock(&mut (*stcb).tcb_send_mtx);
                                                                                                                                        if (*stcb).asoc.state
                                                                                                                                               &
                                                                                                                                               0x200i32
                                                                                                                                               !=
                                                                                                                                               0
                                                                                                                                           {
                                                                                                                                            /* we need to get out.
					 * Peer probably aborted.
					 */
                                                                                                                                            m_freem(mm_0);
                                                                                                                                            if (*stcb).asoc.state
                                                                                                                                                   &
                                                                                                                                                   0x100000i32
                                                                                                                                                   !=
                                                                                                                                                   0
                                                                                                                                               {
                                                                                                                                                error
                                                                                                                                                    =
                                                                                                                                                    104i32
                                                                                                                                            }
                                                                                                                                            pthread_mutex_unlock(&mut (*stcb).tcb_send_mtx);
                                                                                                                                            current_block
                                                                                                                                                =
                                                                                                                                                14645908287508918710;
                                                                                                                                            break
                                                                                                                                                ;
                                                                                                                                        } else {
                                                                                                                                            if !(*sp).tail_mbuf.is_null()
                                                                                                                                               {
                                                                                                                                                /* tack it to the end */
                                                                                                                                                (*(*sp).tail_mbuf).m_hdr.mh_next
                                                                                                                                                    =
                                                                                                                                                    mm_0;
                                                                                                                                                (*sp).tail_mbuf
                                                                                                                                                    =
                                                                                                                                                    new_tail
                                                                                                                                            } else {
                                                                                                                                                /* A stolen mbuf */
                                                                                                                                                (*sp).data
                                                                                                                                                    =
                                                                                                                                                    mm_0;
                                                                                                                                                (*sp).tail_mbuf
                                                                                                                                                    =
                                                                                                                                                    new_tail
                                                                                                                                            }
                                                                                                                                            ::std::intrinsics::atomic_xadd(&mut (*stcb).asoc.total_output_queue_size,
                                                                                                                                                                           sndout);
                                                                                                                                            if !(*stcb).sctp_socket.is_null()
                                                                                                                                                   &&
                                                                                                                                                   ((*(*stcb).sctp_ep).sctp_flags
                                                                                                                                                        &
                                                                                                                                                        0x2u32
                                                                                                                                                        !=
                                                                                                                                                        0
                                                                                                                                                        ||
                                                                                                                                                        (*(*stcb).sctp_ep).sctp_flags
                                                                                                                                                            &
                                                                                                                                                            0x400000u32
                                                                                                                                                            !=
                                                                                                                                                            0)
                                                                                                                                               {
                                                                                                                                                ::std::intrinsics::atomic_xadd(&mut (*(*stcb).sctp_socket).so_snd.sb_cc,
                                                                                                                                                                               sndout);
                                                                                                                                            }
                                                                                                                                            ::std::intrinsics::atomic_xadd(&mut (*sp).length,
                                                                                                                                                                           sndout);
                                                                                                                                            len
                                                                                                                                                =
                                                                                                                                                (len
                                                                                                                                                     as
                                                                                                                                                     libc::c_uint).wrapping_add(sndout)
                                                                                                                                                    as
                                                                                                                                                    libc::c_int;
                                                                                                                                            if sinfo_flags
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   &
                                                                                                                                                   0x4000i32
                                                                                                                                                   !=
                                                                                                                                                   0
                                                                                                                                               {
                                                                                                                                                (*sp).sinfo_flags
                                                                                                                                                    =
                                                                                                                                                    ((*sp).sinfo_flags
                                                                                                                                                         as
                                                                                                                                                         libc::c_int
                                                                                                                                                         |
                                                                                                                                                         0x4000i32)
                                                                                                                                                        as
                                                                                                                                                        uint16_t
                                                                                                                                            }
                                                                                                                                            /* Did we reach EOR? */
                                                                                                                                            if (*uio).uio_resid
                                                                                                                                                   ==
                                                                                                                                                   0i64
                                                                                                                                                   &&
                                                                                                                                                   (user_marks_eor
                                                                                                                                                        ==
                                                                                                                                                        0i32
                                                                                                                                                        ||
                                                                                                                                                        sinfo_flags
                                                                                                                                                            as
                                                                                                                                                            libc::c_int
                                                                                                                                                            &
                                                                                                                                                            0x100i32
                                                                                                                                                            !=
                                                                                                                                                            0
                                                                                                                                                        ||
                                                                                                                                                        user_marks_eor
                                                                                                                                                            !=
                                                                                                                                                            0
                                                                                                                                                            &&
                                                                                                                                                            sinfo_flags
                                                                                                                                                                as
                                                                                                                                                                libc::c_int
                                                                                                                                                                &
                                                                                                                                                                0x2000i32
                                                                                                                                                                !=
                                                                                                                                                                0)
                                                                                                                                               {
                                                                                                                                                (*sp).msg_is_complete
                                                                                                                                                    =
                                                                                                                                                    1u8
                                                                                                                                            } else {
                                                                                                                                                (*sp).msg_is_complete
                                                                                                                                                    =
                                                                                                                                                    0u8
                                                                                                                                            }
                                                                                                                                            pthread_mutex_unlock(&mut (*stcb).tcb_send_mtx);
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                                if (*uio).uio_resid
                                                                                                                                       ==
                                                                                                                                       0i64
                                                                                                                                   {
                                                                                                                                    continue
                                                                                                                                        ;
                                                                                                                                }
                                                                                                                                /* PR-SCTP? */
                                                                                                                                if (*asoc).prsctp_supported
                                                                                                                                       as
                                                                                                                                       libc::c_int
                                                                                                                                       !=
                                                                                                                                       0
                                                                                                                                       &&
                                                                                                                                       (*asoc).sent_queue_cnt_removeable
                                                                                                                                           >
                                                                                                                                           0u32
                                                                                                                                   {
                                                                                                                                    /* This is ugly but we must assure locking order */
                                                                                                                                    if hold_tcblock
                                                                                                                                           ==
                                                                                                                                           0i32
                                                                                                                                       {
                                                                                                                                        pthread_mutex_lock(&mut (*stcb).tcb_mtx);
                                                                                                                                        hold_tcblock
                                                                                                                                            =
                                                                                                                                            1i32
                                                                                                                                    }
                                                                                                                                    sctp_prune_prsctp(stcb,
                                                                                                                                                      asoc,
                                                                                                                                                      srcv,
                                                                                                                                                      sndlen
                                                                                                                                                          as
                                                                                                                                                          libc::c_int);
                                                                                                                                    inqueue_bytes
                                                                                                                                        =
                                                                                                                                        ((*stcb).asoc.total_output_queue_size
                                                                                                                                             as
                                                                                                                                             libc::c_ulong).wrapping_sub(((*stcb).asoc.chunks_on_out_queue
                                                                                                                                                                              as
                                                                                                                                                                              libc::c_ulong).wrapping_mul((if (*stcb).asoc.idata_supported
                                                                                                                                                                                                                  as
                                                                                                                                                                                                                  libc::c_int
                                                                                                                                                                                                                  !=
                                                                                                                                                                                                                  0
                                                                                                                                                                                                              {
                                                                                                                                                                                                               ::std::mem::size_of::<sctp_idata_chunk>()
                                                                                                                                                                                                                   as
                                                                                                                                                                                                                   libc::c_ulong
                                                                                                                                                                                                           } else {
                                                                                                                                                                                                               ::std::mem::size_of::<sctp_data_chunk>()
                                                                                                                                                                                                                   as
                                                                                                                                                                                                                   libc::c_ulong
                                                                                                                                                                                                           })))
                                                                                                                                            as
                                                                                                                                            libc::c_uint;
                                                                                                                                    if (*so).so_snd.sb_hiwat
                                                                                                                                           >
                                                                                                                                           inqueue_bytes
                                                                                                                                       {
                                                                                                                                        max_len
                                                                                                                                            =
                                                                                                                                            (*so).so_snd.sb_hiwat.wrapping_sub(inqueue_bytes)
                                                                                                                                                as
                                                                                                                                                ssize_t
                                                                                                                                    } else {
                                                                                                                                        max_len
                                                                                                                                            =
                                                                                                                                            0i64
                                                                                                                                    }
                                                                                                                                    if max_len
                                                                                                                                           >
                                                                                                                                           0i64
                                                                                                                                       {
                                                                                                                                        continue
                                                                                                                                            ;
                                                                                                                                    }
                                                                                                                                    pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                                                                                                                    hold_tcblock
                                                                                                                                        =
                                                                                                                                        0i32
                                                                                                                                }
                                                                                                                                /* wait for space now */
                                                                                                                                if non_blocking
                                                                                                                                       !=
                                                                                                                                       0
                                                                                                                                   {
                                                                                                                                    current_block
                                                                                                                                        =
                                                                                                                                        11481649088357702079;
                                                                                                                                    break
                                                                                                                                        ;
                                                                                                                                }
                                                                                                                                /* What about the INIT, send it maybe */
                                                                                                                                if queue_only_for_init
                                                                                                                                       !=
                                                                                                                                       0
                                                                                                                                   {
                                                                                                                                    if hold_tcblock
                                                                                                                                           ==
                                                                                                                                           0i32
                                                                                                                                       {
                                                                                                                                        pthread_mutex_lock(&mut (*stcb).tcb_mtx);
                                                                                                                                        hold_tcblock
                                                                                                                                            =
                                                                                                                                            1i32
                                                                                                                                    }
                                                                                                                                    if (*stcb).asoc.state
                                                                                                                                           &
                                                                                                                                           0x7fi32
                                                                                                                                           ==
                                                                                                                                           0x8i32
                                                                                                                                       {
                                                                                                                                        /* a collision took us forward? */
                                                                                                                                        queue_only
                                                                                                                                            =
                                                                                                                                            0i32
                                                                                                                                    } else {
                                                                                                                                        sctp_send_initiate(inp,
                                                                                                                                                           stcb,
                                                                                                                                                           1i32);
                                                                                                                                        sctp_set_state(stcb,
                                                                                                                                                       0x2i32);
                                                                                                                                        queue_only
                                                                                                                                            =
                                                                                                                                            1i32
                                                                                                                                    }
                                                                                                                                }
                                                                                                                                if (*net).flight_size
                                                                                                                                       >
                                                                                                                                       (*net).cwnd
                                                                                                                                       &&
                                                                                                                                       (*asoc).sctp_cmt_on_off
                                                                                                                                           as
                                                                                                                                           libc::c_int
                                                                                                                                           ==
                                                                                                                                           0i32
                                                                                                                                   {
                                                                                                                                    ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_send_cwnd_avoid,
                                                                                                                                                                   1u32);
                                                                                                                                    queue_only
                                                                                                                                        =
                                                                                                                                        1i32
                                                                                                                                } else if (*asoc).ifp_had_enobuf
                                                                                                                                              !=
                                                                                                                                              0
                                                                                                                                 {
                                                                                                                                    ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_ifnomemqueued,
                                                                                                                                                                   1u32);
                                                                                                                                    if (*net).flight_size
                                                                                                                                           >
                                                                                                                                           (2u32).wrapping_mul((*net).mtu)
                                                                                                                                       {
                                                                                                                                        queue_only
                                                                                                                                            =
                                                                                                                                            1i32
                                                                                                                                    }
                                                                                                                                    (*asoc).ifp_had_enobuf
                                                                                                                                        =
                                                                                                                                        0u8
                                                                                                                                }
                                                                                                                                un_sent
                                                                                                                                    =
                                                                                                                                    (*stcb).asoc.total_output_queue_size.wrapping_sub((*stcb).asoc.total_flight)
                                                                                                                                        as
                                                                                                                                        libc::c_int;
                                                                                                                                if (*inp).sctp_features
                                                                                                                                       &
                                                                                                                                       0x100u64
                                                                                                                                       ==
                                                                                                                                       0u64
                                                                                                                                       &&
                                                                                                                                       (*stcb).asoc.total_flight
                                                                                                                                           >
                                                                                                                                           0u32
                                                                                                                                       &&
                                                                                                                                       (*stcb).asoc.stream_queue_cnt
                                                                                                                                           <
                                                                                                                                           256u32
                                                                                                                                       &&
                                                                                                                                       un_sent
                                                                                                                                           <
                                                                                                                                           ((*stcb).asoc.smallest_mtu
                                                                                                                                                as
                                                                                                                                                libc::c_ulong).wrapping_sub((::std::mem::size_of::<ip6_hdr>()
                                                                                                                                                                                 as
                                                                                                                                                                                 libc::c_ulong).wrapping_add(::std::mem::size_of::<sctphdr>()
                                                                                                                                                                                                                 as
                                                                                                                                                                                                                 libc::c_ulong))
                                                                                                                                               as
                                                                                                                                               libc::c_int
                                                                                                                                   {
                                                                                                                                    /*-
				 * Ok, Nagle is set on and we have data outstanding.
				 * Don't send anything and let SACKs drive out the
				 * data unless we have a "full" segment to send.
				 */
                                                                                                                                    if system_base_info.sctpsysctl.sctp_logging_level
                                                                                                                                           &
                                                                                                                                           0x800u32
                                                                                                                                           !=
                                                                                                                                           0
                                                                                                                                       {
                                                                                                                                        sctp_log_nagle_event(stcb,
                                                                                                                                                             72i32);
                                                                                                                                    }
                                                                                                                                    ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_naglequeued,
                                                                                                                                                                   1u32);
                                                                                                                                    nagle_applies
                                                                                                                                        =
                                                                                                                                        1i32
                                                                                                                                } else {
                                                                                                                                    if system_base_info.sctpsysctl.sctp_logging_level
                                                                                                                                           &
                                                                                                                                           0x800u32
                                                                                                                                           !=
                                                                                                                                           0
                                                                                                                                       {
                                                                                                                                        if (*inp).sctp_features
                                                                                                                                               &
                                                                                                                                               0x100u64
                                                                                                                                               ==
                                                                                                                                               0u64
                                                                                                                                           {
                                                                                                                                            sctp_log_nagle_event(stcb,
                                                                                                                                                                 73i32);
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                    ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_naglesent,
                                                                                                                                                                   1u32);
                                                                                                                                    nagle_applies
                                                                                                                                        =
                                                                                                                                        0i32
                                                                                                                                }
                                                                                                                                if system_base_info.sctpsysctl.sctp_logging_level
                                                                                                                                       &
                                                                                                                                       0x1u32
                                                                                                                                       !=
                                                                                                                                       0
                                                                                                                                   {
                                                                                                                                    sctp_misc_ints(77u8,
                                                                                                                                                   queue_only_for_init
                                                                                                                                                       as
                                                                                                                                                       uint32_t,
                                                                                                                                                   queue_only
                                                                                                                                                       as
                                                                                                                                                       uint32_t,
                                                                                                                                                   nagle_applies
                                                                                                                                                       as
                                                                                                                                                       uint32_t,
                                                                                                                                                   un_sent
                                                                                                                                                       as
                                                                                                                                                       uint32_t);
                                                                                                                                    sctp_misc_ints(77u8,
                                                                                                                                                   (*stcb).asoc.total_output_queue_size,
                                                                                                                                                   (*stcb).asoc.total_flight,
                                                                                                                                                   (*stcb).asoc.chunks_on_out_queue,
                                                                                                                                                   (*stcb).asoc.total_flight_count);
                                                                                                                                }
                                                                                                                                if queue_only_for_init
                                                                                                                                       !=
                                                                                                                                       0
                                                                                                                                   {
                                                                                                                                    queue_only_for_init
                                                                                                                                        =
                                                                                                                                        0i32
                                                                                                                                }
                                                                                                                                if queue_only
                                                                                                                                       ==
                                                                                                                                       0i32
                                                                                                                                       &&
                                                                                                                                       nagle_applies
                                                                                                                                           ==
                                                                                                                                           0i32
                                                                                                                                   {
                                                                                                                                    /*-
				 * need to start chunk output
				 * before blocking.. note that if
				 * a lock is already applied, then
				 * the input via the net is happening
				 * and I don't need to start output :-D
				 */
                                                                                                                                    if hold_tcblock
                                                                                                                                           ==
                                                                                                                                           0i32
                                                                                                                                       {
                                                                                                                                        if pthread_mutex_trylock(&mut (*stcb).tcb_mtx)
                                                                                                                                               ==
                                                                                                                                               0
                                                                                                                                           {
                                                                                                                                            hold_tcblock
                                                                                                                                                =
                                                                                                                                                1i32;
                                                                                                                                            sctp_chunk_output(inp,
                                                                                                                                                              stcb,
                                                                                                                                                              0i32,
                                                                                                                                                              1i32);
                                                                                                                                        }
                                                                                                                                    } else {
                                                                                                                                        sctp_chunk_output(inp,
                                                                                                                                                          stcb,
                                                                                                                                                          0i32,
                                                                                                                                                          1i32);
                                                                                                                                    }
                                                                                                                                }
                                                                                                                                if hold_tcblock
                                                                                                                                       ==
                                                                                                                                       1i32
                                                                                                                                   {
                                                                                                                                    pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                                                                                                                    hold_tcblock
                                                                                                                                        =
                                                                                                                                        0i32
                                                                                                                                }
                                                                                                                                pthread_mutex_lock(&mut (*so).so_snd.sb_mtx);
                                                                                                                                /*-
			 * This is a bit strange, but I think it will
			 * work. The total_output_queue_size is locked and
			 * protected by the TCB_LOCK, which we just released.
			 * There is a race that can occur between releasing it
			 * above, and me getting the socket lock, where sacks
			 * come in but we have not put the SB_WAIT on the
			 * so_snd buffer to get the wakeup. After the LOCK
			 * is applied the sack_processing will also need to
			 * LOCK the so->so_snd to do the actual sowwakeup(). So
			 * once we have the socket buffer lock if we recheck the
			 * size we KNOW we will get to sleep safely with the
			 * wakeup flag in place.
			 */
                                                                                                                                inqueue_bytes
                                                                                                                                    =
                                                                                                                                    ((*stcb).asoc.total_output_queue_size
                                                                                                                                         as
                                                                                                                                         libc::c_ulong).wrapping_sub(((*stcb).asoc.chunks_on_out_queue
                                                                                                                                                                          as
                                                                                                                                                                          libc::c_ulong).wrapping_mul((if (*stcb).asoc.idata_supported
                                                                                                                                                                                                              as
                                                                                                                                                                                                              libc::c_int
                                                                                                                                                                                                              !=
                                                                                                                                                                                                              0
                                                                                                                                                                                                          {
                                                                                                                                                                                                           ::std::mem::size_of::<sctp_idata_chunk>()
                                                                                                                                                                                                               as
                                                                                                                                                                                                               libc::c_ulong
                                                                                                                                                                                                       } else {
                                                                                                                                                                                                           ::std::mem::size_of::<sctp_data_chunk>()
                                                                                                                                                                                                               as
                                                                                                                                                                                                               libc::c_ulong
                                                                                                                                                                                                       })))
                                                                                                                                        as
                                                                                                                                        libc::c_uint;
                                                                                                                                if (*so).so_snd.sb_hiwat
                                                                                                                                       <=
                                                                                                                                       inqueue_bytes.wrapping_add((if system_base_info.sctpsysctl.sctp_add_more_threshold
                                                                                                                                                                          >
                                                                                                                                                                          (*so).so_snd.sb_hiwat
                                                                                                                                                                      {
                                                                                                                                                                       (*so).so_snd.sb_hiwat
                                                                                                                                                                   } else {
                                                                                                                                                                       system_base_info.sctpsysctl.sctp_add_more_threshold
                                                                                                                                                                   }))
                                                                                                                                   {
                                                                                                                                    if system_base_info.sctpsysctl.sctp_logging_level
                                                                                                                                           &
                                                                                                                                           0x1u32
                                                                                                                                           !=
                                                                                                                                           0
                                                                                                                                       {
                                                                                                                                        sctp_log_block(7u8,
                                                                                                                                                       asoc,
                                                                                                                                                       (*uio).uio_resid);
                                                                                                                                    }
                                                                                                                                    be.error
                                                                                                                                        =
                                                                                                                                        0i32;
                                                                                                                                    (*stcb).block_entry
                                                                                                                                        =
                                                                                                                                        &mut be;
                                                                                                                                    error
                                                                                                                                        =
                                                                                                                                        sbwait(&mut (*so).so_snd);
                                                                                                                                    (*stcb).block_entry
                                                                                                                                        =
                                                                                                                                        0
                                                                                                                                            as
                                                                                                                                            *mut sctp_block_entry;
                                                                                                                                    if error
                                                                                                                                           !=
                                                                                                                                           0
                                                                                                                                           ||
                                                                                                                                           (*so).so_error
                                                                                                                                               as
                                                                                                                                               libc::c_int
                                                                                                                                               !=
                                                                                                                                               0
                                                                                                                                           ||
                                                                                                                                           be.error
                                                                                                                                               !=
                                                                                                                                               0
                                                                                                                                       {
                                                                                                                                        if error
                                                                                                                                               ==
                                                                                                                                               0i32
                                                                                                                                           {
                                                                                                                                            if (*so).so_error
                                                                                                                                                   !=
                                                                                                                                                   0
                                                                                                                                               {
                                                                                                                                                error
                                                                                                                                                    =
                                                                                                                                                    (*so).so_error
                                                                                                                                                        as
                                                                                                                                                        libc::c_int
                                                                                                                                            }
                                                                                                                                            if be.error
                                                                                                                                                   !=
                                                                                                                                                   0
                                                                                                                                               {
                                                                                                                                                error
                                                                                                                                                    =
                                                                                                                                                    be.error
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                        pthread_mutex_unlock(&mut (*so).so_snd.sb_mtx);
                                                                                                                                        current_block
                                                                                                                                            =
                                                                                                                                            14645908287508918710;
                                                                                                                                        break
                                                                                                                                            ;
                                                                                                                                    } else if system_base_info.sctpsysctl.sctp_logging_level
                                                                                                                                                  &
                                                                                                                                                  0x1u32
                                                                                                                                                  !=
                                                                                                                                                  0
                                                                                                                                     {
                                                                                                                                        sctp_log_block(8u8,
                                                                                                                                                       asoc,
                                                                                                                                                       (*stcb).asoc.total_output_queue_size
                                                                                                                                                           as
                                                                                                                                                           ssize_t);
                                                                                                                                    }
                                                                                                                                }
                                                                                                                                pthread_mutex_unlock(&mut (*so).so_snd.sb_mtx);
                                                                                                                                if (*stcb).asoc.state
                                                                                                                                       &
                                                                                                                                       0x200i32
                                                                                                                                       !=
                                                                                                                                       0
                                                                                                                                   {
                                                                                                                                    current_block
                                                                                                                                        =
                                                                                                                                        14645908287508918710;
                                                                                                                                    break
                                                                                                                                        ;
                                                                                                                                }
                                                                                                                            }
                                                                                                                            match current_block
                                                                                                                                {
                                                                                                                                14645908287508918710
                                                                                                                                =>
                                                                                                                                {
                                                                                                                                }
                                                                                                                                11481649088357702079
                                                                                                                                =>
                                                                                                                                {
                                                                                                                                }
                                                                                                                                _
                                                                                                                                =>
                                                                                                                                {
                                                                                                                                    pthread_mutex_lock(&mut (*stcb).tcb_send_mtx);
                                                                                                                                    if (*stcb).asoc.state
                                                                                                                                           &
                                                                                                                                           0x200i32
                                                                                                                                           !=
                                                                                                                                           0
                                                                                                                                       {
                                                                                                                                        pthread_mutex_unlock(&mut (*stcb).tcb_send_mtx);
                                                                                                                                        current_block
                                                                                                                                            =
                                                                                                                                            14645908287508918710;
                                                                                                                                    } else {
                                                                                                                                        if !sp.is_null()
                                                                                                                                           {
                                                                                                                                            if (*sp).msg_is_complete
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   ==
                                                                                                                                                   0i32
                                                                                                                                               {
                                                                                                                                                (*strm).last_msg_incomplete
                                                                                                                                                    =
                                                                                                                                                    1u8;
                                                                                                                                                if (*stcb).asoc.idata_supported
                                                                                                                                                       as
                                                                                                                                                       libc::c_int
                                                                                                                                                       ==
                                                                                                                                                       0i32
                                                                                                                                                   {
                                                                                                                                                    (*asoc).stream_locked
                                                                                                                                                        =
                                                                                                                                                        1u8;
                                                                                                                                                    (*asoc).stream_locked_on
                                                                                                                                                        =
                                                                                                                                                        (*srcv).sinfo_stream
                                                                                                                                                }
                                                                                                                                            } else {
                                                                                                                                                (*sp).sender_all_done
                                                                                                                                                    =
                                                                                                                                                    1u8;
                                                                                                                                                (*strm).last_msg_incomplete
                                                                                                                                                    =
                                                                                                                                                    0u8;
                                                                                                                                                (*asoc).stream_locked
                                                                                                                                                    =
                                                                                                                                                    0u8
                                                                                                                                            }
                                                                                                                                        } else {
                                                                                                                                            if system_base_info.debug_printf.is_some()
                                                                                                                                               {
                                                                                                                                                system_base_info.debug_printf.expect("non-null function pointer")(b"Huh no sp TSNH?\n\x00"
                                                                                                                                                                                                                      as
                                                                                                                                                                                                                      *const u8
                                                                                                                                                                                                                      as
                                                                                                                                                                                                                      *const libc::c_char);
                                                                                                                                            }
                                                                                                                                            (*strm).last_msg_incomplete
                                                                                                                                                =
                                                                                                                                                0u8;
                                                                                                                                            (*asoc).stream_locked
                                                                                                                                                =
                                                                                                                                                0u8
                                                                                                                                        }
                                                                                                                                        pthread_mutex_unlock(&mut (*stcb).tcb_send_mtx);
                                                                                                                                        if (*uio).uio_resid
                                                                                                                                               ==
                                                                                                                                               0i64
                                                                                                                                           {
                                                                                                                                            got_all_of_the_send
                                                                                                                                                =
                                                                                                                                                1i32
                                                                                                                                        }
                                                                                                                                        current_block
                                                                                                                                            =
                                                                                                                                            4623852661432193157;
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            } else {
                                                                                                                /* We send in a 0, since we do NOT have any locks */
                                                                                                                error
                                                                                                                    =
                                                                                                                    sctp_msg_append(stcb,
                                                                                                                                    net,
                                                                                                                                    top,
                                                                                                                                    srcv,
                                                                                                                                    0i32);
                                                                                                                top
                                                                                                                    =
                                                                                                                    0
                                                                                                                        as
                                                                                                                        *mut mbuf;
                                                                                                                if sinfo_flags
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       &
                                                                                                                       0x100i32
                                                                                                                       !=
                                                                                                                       0
                                                                                                                   {
                                                                                                                    /*
			 * This should only happen for Panda for the mbuf
			 * send case, which does NOT yet support EEOR mode.
			 * Thus, we can just set this flag to do the proper
			 * EOF handling.
			 */
                                                                                                                    got_all_of_the_send
                                                                                                                        =
                                                                                                                        1i32
                                                                                                                }
                                                                                                                current_block
                                                                                                                    =
                                                                                                                    4623852661432193157;
                                                                                                            }
                                                                                                            match current_block
                                                                                                                {
                                                                                                                14645908287508918710
                                                                                                                =>
                                                                                                                {
                                                                                                                }
                                                                                                                11481649088357702079
                                                                                                                =>
                                                                                                                {
                                                                                                                }
                                                                                                                _
                                                                                                                =>
                                                                                                                {
                                                                                                                    if error
                                                                                                                           !=
                                                                                                                           0
                                                                                                                       {
                                                                                                                        current_block
                                                                                                                            =
                                                                                                                            14645908287508918710;
                                                                                                                    } else {
                                                                                                                        current_block
                                                                                                                            =
                                                                                                                            14249592727310794991;
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                        match current_block
                                                                                                            {
                                                                                                            14645908287508918710
                                                                                                            =>
                                                                                                            {
                                                                                                            }
                                                                                                            _
                                                                                                            =>
                                                                                                            {
                                                                                                                match current_block
                                                                                                                    {
                                                                                                                    14249592727310794991
                                                                                                                    =>

                                                                                                                    /* EOF thing ? */
                                                                                                                    {
                                                                                                                        if sinfo_flags
                                                                                                                               as
                                                                                                                               libc::c_int
                                                                                                                               &
                                                                                                                               0x100i32
                                                                                                                               !=
                                                                                                                               0
                                                                                                                               &&
                                                                                                                               got_all_of_the_send
                                                                                                                                   ==
                                                                                                                                   1i32
                                                                                                                           {
                                                                                                                                 let mut op_err =    0 as *mut mbuf; let mut msg =    [0; 128];::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_sends_with_eof,
                                                                                                                                                           1u32);
                                                                                                                            error
                                                                                                                                =
                                                                                                                                0i32;
                                                                                                                            if hold_tcblock
                                                                                                                                   ==
                                                                                                                                   0i32
                                                                                                                               {
                                                                                                                                pthread_mutex_lock(&mut (*stcb).tcb_mtx);
                                                                                                                                hold_tcblock
                                                                                                                                    =
                                                                                                                                    1i32
                                                                                                                            }
                                                                                                                            if (*asoc).send_queue.tqh_first.is_null()
                                                                                                                                   &&
                                                                                                                                   (*asoc).sent_queue.tqh_first.is_null()
                                                                                                                                   &&
                                                                                                                                   sctp_is_there_unsent_data(stcb,
                                                                                                                                                             1i32)
                                                                                                                                       ==
                                                                                                                                       0i32
                                                                                                                               {
                                                                                                                                if Some((*asoc).ss_functions.sctp_ss_is_user_msgs_incomplete.expect("non-null function pointer")).expect("non-null function pointer")(stcb,
                                                                                                                                                                                                                                                                      asoc)
                                                                                                                                       !=
                                                                                                                                       0
                                                                                                                                   {
                                                                                                                                    current_block
                                                                                                                                        =
                                                                                                                                        16290059257333490674;
                                                                                                                                } else {
                                                                                                                                    /* there is nothing queued to send, so I'm done... */
                                                                                                                                    if (*stcb).asoc.state
                                                                                                                                           &
                                                                                                                                           0x7fi32
                                                                                                                                           !=
                                                                                                                                           0x10i32
                                                                                                                                           &&
                                                                                                                                           (*stcb).asoc.state
                                                                                                                                               &
                                                                                                                                               0x7fi32
                                                                                                                                               !=
                                                                                                                                               0x20i32
                                                                                                                                           &&
                                                                                                                                           (*stcb).asoc.state
                                                                                                                                               &
                                                                                                                                               0x7fi32
                                                                                                                                               !=
                                                                                                                                               0x40i32
                                                                                                                                       {
                                                                                                                                           let mut netp =
                                                                                                                                            0
                                                                                                                                                as
                                                                                                                                                *mut sctp_nets;
                                                                                                                                        /* only send SHUTDOWN the first time through */
                                                                                                                                        if (*stcb).asoc.state
                                                                                                                                               &
                                                                                                                                               0x7fi32
                                                                                                                                               ==
                                                                                                                                               0x8i32
                                                                                                                                           {
                                                                                                                                            ::std::intrinsics::atomic_xsub(&mut system_base_info.sctpstat.sctps_currestab,
                                                                                                                                                                           1u32);
                                                                                                                                        }
                                                                                                                                        sctp_set_state(stcb,
                                                                                                                                                       0x10i32);
                                                                                                                                        sctp_stop_timers_for_shutdown(stcb);
                                                                                                                                        if !(*stcb).asoc.alternate.is_null()
                                                                                                                                           {
                                                                                                                                            netp
                                                                                                                                                =
                                                                                                                                                (*stcb).asoc.alternate
                                                                                                                                        } else {
                                                                                                                                            netp
                                                                                                                                                =
                                                                                                                                                (*stcb).asoc.primary_destination
                                                                                                                                        }
                                                                                                                                        sctp_send_shutdown(stcb,
                                                                                                                                                           netp);
                                                                                                                                        sctp_timer_start(4i32,
                                                                                                                                                         (*stcb).sctp_ep,
                                                                                                                                                         stcb,
                                                                                                                                                         netp);
                                                                                                                                        sctp_timer_start(11i32,
                                                                                                                                                         (*stcb).sctp_ep,
                                                                                                                                                         stcb,
                                                                                                                                                         (*asoc).primary_destination);
                                                                                                                                    }
                                                                                                                                    current_block
                                                                                                                                        =
                                                                                                                                        11481649088357702079;
                                                                                                                                }
                                                                                                                            } else if (*stcb).asoc.state
                                                                                                                                          &
                                                                                                                                          0x7fi32
                                                                                                                                          !=
                                                                                                                                          0x10i32
                                                                                                                                          &&
                                                                                                                                          (*stcb).asoc.state
                                                                                                                                              &
                                                                                                                                              0x7fi32
                                                                                                                                              !=
                                                                                                                                              0x20i32
                                                                                                                                          &&
                                                                                                                                          (*stcb).asoc.state
                                                                                                                                              &
                                                                                                                                              0x7fi32
                                                                                                                                              !=
                                                                                                                                              0x40i32
                                                                                                                             {
                                                                                                                                if hold_tcblock
                                                                                                                                       ==
                                                                                                                                       0i32
                                                                                                                                   {
                                                                                                                                    pthread_mutex_lock(&mut (*stcb).tcb_mtx);
                                                                                                                                    hold_tcblock
                                                                                                                                        =
                                                                                                                                        1i32
                                                                                                                                }
                                                                                                                                if Some((*asoc).ss_functions.sctp_ss_is_user_msgs_incomplete.expect("non-null function pointer")).expect("non-null function pointer")(stcb,
                                                                                                                                                                                                                                                                      asoc)
                                                                                                                                       !=
                                                                                                                                       0
                                                                                                                                   {
                                                                                                                                    sctp_add_substate(stcb,
                                                                                                                                                      0x400i32);
                                                                                                                                }
                                                                                                                                sctp_add_substate(stcb,
                                                                                                                                                  0x80i32);
                                                                                                                                if (*asoc).send_queue.tqh_first.is_null()
                                                                                                                                       &&
                                                                                                                                       (*asoc).sent_queue.tqh_first.is_null()
                                                                                                                                       &&
                                                                                                                                       (*asoc).state
                                                                                                                                           &
                                                                                                                                           0x400i32
                                                                                                                                           !=
                                                                                                                                           0
                                                                                                                                   {
                                                                                                                                    op_err
                                                                                                                                        =
                                                                                                                                        0
                                                                                                                                            as
                                                                                                                                            *mut mbuf;
                                                                                                                                    msg
                                                                                                                                        =
                                                                                                                                        [0;
                                                                                                                                            128];
                                                                                                                                    current_block
                                                                                                                                        =
                                                                                                                                        16290059257333490674;
                                                                                                                                } else {
                                                                                                                                    sctp_timer_start(11i32,
                                                                                                                                                     (*stcb).sctp_ep,
                                                                                                                                                     stcb,
                                                                                                                                                     (*asoc).primary_destination);
                                                                                                                                    (*inp).sctp_features
                                                                                                                                        &=
                                                                                                                                        !(0x100i32)
                                                                                                                                            as
                                                                                                                                            libc::c_ulong;
                                                                                                                                    current_block
                                                                                                                                        =
                                                                                                                                        11481649088357702079;
                                                                                                                                }
                                                                                                                            } else {
                                                                                                                                current_block
                                                                                                                                    =
                                                                                                                                    11481649088357702079;
                                                                                                                            }
                                                                                                                            match current_block
                                                                                                                                {
                                                                                                                                11481649088357702079
                                                                                                                                =>
                                                                                                                                {
                                                                                                                                }
                                                                                                                                _
                                                                                                                                =>
                                                                                                                                {
                                                                                                                                    if free_cnt_applied
                                                                                                                                           !=
                                                                                                                                           0
                                                                                                                                       {
                                                                                                                                        ::std::intrinsics::atomic_xadd(&mut (*stcb).asoc.refcnt,
                                                                                                                                                                       -(1i32)
                                                                                                                                                                           as
                                                                                                                                                                           uint32_t);
                                                                                                                                        free_cnt_applied
                                                                                                                                            =
                                                                                                                                            0i32
                                                                                                                                    }
                                                                                                                                    snprintf(msg.as_mut_ptr(),
                                                                                                                                             ::std::mem::size_of::<[libc::c_char; 128]>()
                                                                                                                                                 as
                                                                                                                                                 libc::c_ulong,
                                                                                                                                             b"%s:%d at %s\x00"
                                                                                                                                                 as
                                                                                                                                                 *const u8
                                                                                                                                                 as
                                                                                                                                                 *const libc::c_char,
                                                                                                                                             b"/usr/local/google/home/winniexiao/chromium/src/third_party/usrsctp/usrsctplib/usrsctplib/netinet/sctp_output.c\x00"
                                                                                                                                                 as
                                                                                                                                                 *const u8
                                                                                                                                                 as
                                                                                                                                                 *const libc::c_char,
                                                                                                                                             14734i32,
                                                                                                                                             (*::std::mem::transmute::<&[u8; 18],
                                                                                                                                                                       &[libc::c_char; 18]>(b"sctp_lower_sosend\x00")).as_ptr());
                                                                                                                                    op_err
                                                                                                                                        =
                                                                                                                                        sctp_generate_cause(system_base_info.sctpsysctl.sctp_diag_info_code
                                                                                                                                                                as
                                                                                                                                                                uint16_t,
                                                                                                                                                            msg.as_mut_ptr());
                                                                                                                                    sctp_abort_an_association((*stcb).sctp_ep,
                                                                                                                                                              stcb,
                                                                                                                                                              op_err,
                                                                                                                                                              1i32);
                                                                                                                                    /*-
			 * we still got (or just got) data to send, so set
			 * SHUTDOWN_PENDING
			 */
			/*-
			 * XXX sockets draft says that SCTP_EOF should be
			 * sent with no data.  currently, we will allow user
			 * data to be sent first and move to
			 * SHUTDOWN-PENDING
			 */
                                                                                                                                    /* now relock the stcb so everything is sane */
                                                                                                                                    hold_tcblock
                                                                                                                                        =
                                                                                                                                        0i32;
                                                                                                                                    stcb
                                                                                                                                        =
                                                                                                                                        0
                                                                                                                                            as
                                                                                                                                            *mut sctp_tcb;
                                                                                                                                    current_block
                                                                                                                                        =
                                                                                                                                        14645908287508918710;
                                                                                                                                }
                                                                                                                            }
                                                                                                                        } else {
                                                                                                                            current_block
                                                                                                                                =
                                                                                                                                11481649088357702079;
                                                                                                                        }
                                                                                                                    }
                                                                                                                    _
                                                                                                                    =>
                                                                                                                    {
                                                                                                                    }
                                                                                                                }
                                                                                                                match current_block
                                                                                                                    {
                                                                                                                    14645908287508918710
                                                                                                                    =>
                                                                                                                    {
                                                                                                                    }
                                                                                                                    _
                                                                                                                    =>

                                                                                                                    /* Non-blocking io in place out */
                                                                                                                    {
                                                                                                                           let mut some_on_control =    0i32;if !(*stcb).asoc.control_send_queue.tqh_first.is_null()
                                                                                                                           {
                                                                                                                            some_on_control
                                                                                                                                =
                                                                                                                                1i32
                                                                                                                        }
                                                                                                                        if queue_only_for_init
                                                                                                                               !=
                                                                                                                               0
                                                                                                                           {
                                                                                                                            if hold_tcblock
                                                                                                                                   ==
                                                                                                                                   0i32
                                                                                                                               {
                                                                                                                                pthread_mutex_lock(&mut (*stcb).tcb_mtx);
                                                                                                                                hold_tcblock
                                                                                                                                    =
                                                                                                                                    1i32
                                                                                                                            }
                                                                                                                            if (*stcb).asoc.state
                                                                                                                                   &
                                                                                                                                   0x7fi32
                                                                                                                                   ==
                                                                                                                                   0x8i32
                                                                                                                               {
                                                                                                                                /* a collision took us forward? */
                                                                                                                                queue_only
                                                                                                                                    =
                                                                                                                                    0i32
                                                                                                                            } else {
                                                                                                                                sctp_send_initiate(inp,
                                                                                                                                                   stcb,
                                                                                                                                                   1i32);
                                                                                                                                sctp_set_state(stcb,
                                                                                                                                               0x2i32);
                                                                                                                                queue_only
                                                                                                                                    =
                                                                                                                                    1i32
                                                                                                                            }
                                                                                                                        }
                                                                                                                        if (*net).flight_size
                                                                                                                               >
                                                                                                                               (*net).cwnd
                                                                                                                               &&
                                                                                                                               (*stcb).asoc.sctp_cmt_on_off
                                                                                                                                   as
                                                                                                                                   libc::c_int
                                                                                                                                   ==
                                                                                                                                   0i32
                                                                                                                           {
                                                                                                                            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_send_cwnd_avoid,
                                                                                                                                                           1u32);
                                                                                                                            queue_only
                                                                                                                                =
                                                                                                                                1i32
                                                                                                                        } else if (*asoc).ifp_had_enobuf
                                                                                                                                      !=
                                                                                                                                      0
                                                                                                                         {
                                                                                                                            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_ifnomemqueued,
                                                                                                                                                           1u32);
                                                                                                                            if (*net).flight_size
                                                                                                                                   >
                                                                                                                                   (2u32).wrapping_mul((*net).mtu)
                                                                                                                               {
                                                                                                                                queue_only
                                                                                                                                    =
                                                                                                                                    1i32
                                                                                                                            }
                                                                                                                            (*asoc).ifp_had_enobuf
                                                                                                                                =
                                                                                                                                0u8
                                                                                                                        }
                                                                                                                        un_sent
                                                                                                                            =
                                                                                                                            (*stcb).asoc.total_output_queue_size.wrapping_sub((*stcb).asoc.total_flight)
                                                                                                                                as
                                                                                                                                libc::c_int;
                                                                                                                        if (*inp).sctp_features
                                                                                                                               &
                                                                                                                               0x100u64
                                                                                                                               ==
                                                                                                                               0u64
                                                                                                                               &&
                                                                                                                               (*stcb).asoc.total_flight
                                                                                                                                   >
                                                                                                                                   0u32
                                                                                                                               &&
                                                                                                                               (*stcb).asoc.stream_queue_cnt
                                                                                                                                   <
                                                                                                                                   256u32
                                                                                                                               &&
                                                                                                                               un_sent
                                                                                                                                   <
                                                                                                                                   ((*stcb).asoc.smallest_mtu
                                                                                                                                        as
                                                                                                                                        libc::c_ulong).wrapping_sub((::std::mem::size_of::<ip6_hdr>()
                                                                                                                                                                         as
                                                                                                                                                                         libc::c_ulong).wrapping_add(::std::mem::size_of::<sctphdr>()
                                                                                                                                                                                                         as
                                                                                                                                                                                                         libc::c_ulong))
                                                                                                                                       as
                                                                                                                                       libc::c_int
                                                                                                                           {
                                                                                                                            /*-
		 * Ok, Nagle is set on and we have data outstanding.
		 * Don't send anything and let SACKs drive out the
		 * data unless wen have a "full" segment to send.
		 */
                                                                                                                            if system_base_info.sctpsysctl.sctp_logging_level
                                                                                                                                   &
                                                                                                                                   0x800u32
                                                                                                                                   !=
                                                                                                                                   0
                                                                                                                               {
                                                                                                                                sctp_log_nagle_event(stcb,
                                                                                                                                                     72i32);
                                                                                                                            }
                                                                                                                            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_naglequeued,
                                                                                                                                                           1u32);
                                                                                                                            nagle_applies
                                                                                                                                =
                                                                                                                                1i32
                                                                                                                        } else {
                                                                                                                            if system_base_info.sctpsysctl.sctp_logging_level
                                                                                                                                   &
                                                                                                                                   0x800u32
                                                                                                                                   !=
                                                                                                                                   0
                                                                                                                               {
                                                                                                                                if (*inp).sctp_features
                                                                                                                                       &
                                                                                                                                       0x100u64
                                                                                                                                       ==
                                                                                                                                       0u64
                                                                                                                                   {
                                                                                                                                    sctp_log_nagle_event(stcb,
                                                                                                                                                         73i32);
                                                                                                                                }
                                                                                                                            }
                                                                                                                            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_naglesent,
                                                                                                                                                           1u32);
                                                                                                                            nagle_applies
                                                                                                                                =
                                                                                                                                0i32
                                                                                                                        }
                                                                                                                        if system_base_info.sctpsysctl.sctp_logging_level
                                                                                                                               &
                                                                                                                               0x1u32
                                                                                                                               !=
                                                                                                                               0
                                                                                                                           {
                                                                                                                            sctp_misc_ints(77u8,
                                                                                                                                           queue_only_for_init
                                                                                                                                               as
                                                                                                                                               uint32_t,
                                                                                                                                           queue_only
                                                                                                                                               as
                                                                                                                                               uint32_t,
                                                                                                                                           nagle_applies
                                                                                                                                               as
                                                                                                                                               uint32_t,
                                                                                                                                           un_sent
                                                                                                                                               as
                                                                                                                                               uint32_t);
                                                                                                                            sctp_misc_ints(77u8,
                                                                                                                                           (*stcb).asoc.total_output_queue_size,
                                                                                                                                           (*stcb).asoc.total_flight,
                                                                                                                                           (*stcb).asoc.chunks_on_out_queue,
                                                                                                                                           (*stcb).asoc.total_flight_count);
                                                                                                                        }
                                                                                                                        if queue_only
                                                                                                                               ==
                                                                                                                               0i32
                                                                                                                               &&
                                                                                                                               nagle_applies
                                                                                                                                   ==
                                                                                                                                   0i32
                                                                                                                               &&
                                                                                                                               ((*stcb).asoc.peers_rwnd
                                                                                                                                    !=
                                                                                                                                    0
                                                                                                                                    &&
                                                                                                                                    un_sent
                                                                                                                                        !=
                                                                                                                                        0)
                                                                                                                           {
                                                                                                                            /* we can attempt to send too. */
                                                                                                                            if hold_tcblock
                                                                                                                                   ==
                                                                                                                                   0i32
                                                                                                                               {
                                                                                                                                /* If there is activity recv'ing sacks no need to send */
                                                                                                                                if pthread_mutex_trylock(&mut (*stcb).tcb_mtx)
                                                                                                                                       ==
                                                                                                                                       0
                                                                                                                                   {
                                                                                                                                    sctp_chunk_output(inp,
                                                                                                                                                      stcb,
                                                                                                                                                      0i32,
                                                                                                                                                      1i32);
                                                                                                                                    hold_tcblock
                                                                                                                                        =
                                                                                                                                        1i32
                                                                                                                                }
                                                                                                                            } else {
                                                                                                                                sctp_chunk_output(inp,
                                                                                                                                                  stcb,
                                                                                                                                                  0i32,
                                                                                                                                                  1i32);
                                                                                                                            }
                                                                                                                        } else if queue_only
                                                                                                                                      ==
                                                                                                                                      0i32
                                                                                                                                      &&
                                                                                                                                      (*stcb).asoc.peers_rwnd
                                                                                                                                          ==
                                                                                                                                          0u32
                                                                                                                                      &&
                                                                                                                                      (*stcb).asoc.total_flight
                                                                                                                                          ==
                                                                                                                                          0u32
                                                                                                                         {
                                                                                                                            /* We get to have a probe outstanding */
                                                                                                                            if hold_tcblock
                                                                                                                                   ==
                                                                                                                                   0i32
                                                                                                                               {
                                                                                                                                hold_tcblock
                                                                                                                                    =
                                                                                                                                    1i32;
                                                                                                                                pthread_mutex_lock(&mut (*stcb).tcb_mtx);
                                                                                                                            }
                                                                                                                            sctp_chunk_output(inp,
                                                                                                                                              stcb,
                                                                                                                                              0i32,
                                                                                                                                              1i32);
                                                                                                                        } else if some_on_control
                                                                                                                                      !=
                                                                                                                                      0
                                                                                                                         {
                                                                                                                                       let mut now_filled =    0i32; let mut now =    timeval{tv_sec: 0, tv_usec: 0,}; let mut num_out =
                                                                                                                                0; let mut reason =
                                                                                                                                0; let mut frag_point =
                                                                                                                                0;
                                                                                                                            /* Here we do control only */
                                                                                                                            if hold_tcblock
                                                                                                                                   ==
                                                                                                                                   0i32
                                                                                                                               {
                                                                                                                                hold_tcblock
                                                                                                                                    =
                                                                                                                                    1i32;
                                                                                                                                pthread_mutex_lock(&mut (*stcb).tcb_mtx);
                                                                                                                            }
                                                                                                                            frag_point
                                                                                                                                =
                                                                                                                                sctp_get_frag_point(stcb,
                                                                                                                                                    &mut (*stcb).asoc);
                                                                                                                            sctp_med_chunk_output(inp,
                                                                                                                                                  stcb,
                                                                                                                                                  &mut (*stcb).asoc,
                                                                                                                                                  &mut num_out,
                                                                                                                                                  &mut reason,
                                                                                                                                                  1i32,
                                                                                                                                                  1i32,
                                                                                                                                                  &mut now,
                                                                                                                                                  &mut now_filled,
                                                                                                                                                  frag_point,
                                                                                                                                                  1i32);
                                                                                                                        }
                                                                                                                        if system_base_info.sctpsysctl.sctp_debug_on
                                                                                                                               &
                                                                                                                               0x10u32
                                                                                                                               !=
                                                                                                                               0
                                                                                                                           {
                                                                                                                            if system_base_info.debug_printf.is_some()
                                                                                                                               {
                                                                                                                                system_base_info.debug_printf.expect("non-null function pointer")(b"USR Send complete qo:%d prw:%d unsent:%d tf:%d cooq:%d toqs:%d err:%d\n\x00"
                                                                                                                                                                                                      as
                                                                                                                                                                                                      *const u8
                                                                                                                                                                                                      as
                                                                                                                                                                                                      *const libc::c_char,
                                                                                                                                                                                                  queue_only,
                                                                                                                                                                                                  (*stcb).asoc.peers_rwnd,
                                                                                                                                                                                                  un_sent,
                                                                                                                                                                                                  (*stcb).asoc.total_flight,
                                                                                                                                                                                                  (*stcb).asoc.chunks_on_out_queue,
                                                                                                                                                                                                  (*stcb).asoc.total_output_queue_size,
                                                                                                                                                                                                  error);
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    /* Error is setup for us in the call */
    if local_soresv != 0 && !stcb.is_null() {
        ::std::intrinsics::atomic_xsub(&mut (*stcb).asoc.sb_send_resv, sndlen as uint32_t);
    }
    if create_lock_applied != 0 {
        pthread_mutex_unlock(&mut (*inp).inp_create_mtx);
    }
    if !stcb.is_null() && hold_tcblock != 0 {
        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
    }
    if !stcb.is_null() && free_cnt_applied != 0 {
        ::std::intrinsics::atomic_xadd(&mut (*stcb).asoc.refcnt, -(1i32) as uint32_t);
    }
    if !top.is_null() {
        m_freem(top);
    }
    if !control.is_null() {
        m_freem(control);
    }
    return error;
}
/* shared key handling */
/* ref counts on shared keys, by key id */
/* hmac list handling */
/* keyed-HMAC functions */
/* mbuf versions */
/*
 * authentication routines
 */
/*
 * generate an AUTHentication chunk, if required
 */
#[no_mangle]
pub unsafe extern "C" fn sctp_add_auth_chunk(
    mut m: *mut mbuf,
    mut m_end: *mut *mut mbuf,
    mut auth_ret: *mut *mut sctp_auth_chunk,
    mut offset: *mut uint32_t,
    mut stcb: *mut sctp_tcb,
    mut chunk: uint8_t,
) -> *mut mbuf {
    let mut m_auth = 0 as *mut mbuf;
    let mut auth = 0 as *mut sctp_auth_chunk;
    let mut chunk_len = 0;
    let mut cn = 0 as *mut mbuf;
    if m_end.is_null() || auth_ret.is_null() || offset.is_null() || stcb.is_null() {
        return m;
    }
    if (*stcb).asoc.auth_supported as libc::c_int == 0i32 {
        return m;
    }
    /* does the requested chunk require auth? */
    if if (*stcb).asoc.peer_auth_chunks.is_null() {
        0i32
    } else {
        ((*(*stcb).asoc.peer_auth_chunks).chunks[chunk as usize] as libc::c_int != 0i32)
            as libc::c_int
    } == 0
    {
        return m;
    }
    m_auth = sctp_get_mbuf_for_msg(
        ::std::mem::size_of::<sctp_auth_chunk>() as libc::c_uint,
        0i32,
        0x1i32,
        1i32,
        1i32,
    );
    if m_auth.is_null() {
        /* no mbuf's */
        return m;
    }
    /* reserve some space if this will be the first mbuf */
    if m.is_null() {
        (*m_auth).m_hdr.mh_data = (*m_auth).m_hdr.mh_data.offset(
            (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong)
                as isize,
        )
    }
    /* fill in the AUTH chunk details */
    auth = (*m_auth).m_hdr.mh_data as *mut sctp_auth_chunk;
    memset(
        auth as *mut libc::c_void,
        0i32,
        ::std::mem::size_of::<sctp_auth_chunk>() as libc::c_ulong,
    );
    (*auth).ch.chunk_type = 0xfu8;
    (*auth).ch.chunk_flags = 0u8;
    chunk_len = (::std::mem::size_of::<sctp_auth_chunk>() as libc::c_ulong)
        .wrapping_add(sctp_get_hmac_digest_len((*stcb).asoc.peer_hmac_id) as libc::c_ulong)
        as libc::c_int;
    (*auth).ch.chunk_length = htons(chunk_len as uint16_t);
    (*auth).hmac_id = htons((*stcb).asoc.peer_hmac_id);
    /* key id and hmac digest will be computed and filled in upon send */
    /* save the offset where the auth was inserted into the chain */
    *offset = 0u32;
    cn = m;
    while !cn.is_null() {
        *offset = (*offset).wrapping_add((*cn).m_hdr.mh_len as libc::c_uint);
        cn = (*cn).m_hdr.mh_next
    }
    /* update length and return pointer to the auth chunk */
    (*m_auth).m_hdr.mh_len = chunk_len;
    m = sctp_copy_mbufchain(m_auth, m, m_end, 1i32, chunk_len, 0u8);
    if !auth_ret.is_null() {
        *auth_ret = auth
    }
    return m;
}
/* TODO __Userspace__ versions of sctp_vXsrc_match_nexthop(). */
#[no_mangle]
pub unsafe extern "C" fn sctp_v6src_match_nexthop(
    mut src6: *mut sockaddr_in6,
    mut ro: *mut sctp_route_t,
) -> libc::c_int {
    return 0i32;
}
#[no_mangle]
pub unsafe extern "C" fn sctp_v4src_match_nexthop(
    mut sifa: *mut sctp_ifa,
    mut ro: *mut sctp_route_t,
) -> libc::c_int {
    return 0i32;
}
