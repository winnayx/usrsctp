use ::libc;
extern "C" {
    pub type accept_filter;
    pub type label;
    pub type ifnet;
    pub type aiocblist;
    pub type sigio;
    pub type iface;
    /*-
     * Copyright (c) 1982, 1986, 1990, 1993
     *	The Regents of the University of California.  All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions
     * are met:
     * 1. Redistributions of source code must retain the above copyright
     *    notice, this list of conditions and the following disclaimer.
     * 2. Redistributions in binary form must reproduce the above copyright
     *    notice, this list of conditions and the following disclaimer in the
     *    documentation and/or other materials provided with the distribution.
     * 4. Neither the name of the University nor the names of its contributors
     *    may be used to endorse or promote products derived from this software
     *    without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
     * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
     * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
     * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
     * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
     * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
     * SUCH DAMAGE.
     *
     *	@(#)in_pcb.h	8.1 (Berkeley) 6/10/93
     * $FreeBSD: src/sys/netinet/in_pcb.h,v 1.100.2.1 2007/12/07 05:46:08 kmacy Exp $
     */
    pub type inpcbpolicy;
    /* temp compatibility */
    pub type icmp6_filter;
    pub type ip6_pktopts;
    pub type ip_moptions;
    pub type uma_zone;
    #[no_mangle]
    fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    #[no_mangle]
    fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    #[no_mangle]
    fn snprintf(
        _: *mut libc::c_char,
        _: libc::c_ulong,
        _: *const libc::c_char,
        _: ...
    ) -> libc::c_int;
    #[no_mangle]
    fn memcpy(_: *mut libc::c_void, _: *const libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
    #[no_mangle]
    fn memset(_: *mut libc::c_void, _: libc::c_int, _: libc::c_ulong) -> *mut libc::c_void;
    #[no_mangle]
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    #[no_mangle]
    fn free(__ptr: *mut libc::c_void);
    /*CONSTCOND*/
    /*
     * Global accept mutex to serialize access to accept queues and
     * fields associated with multiple sockets.  This allows us to
     * avoid defining a lock order between listen and accept sockets
     * until such time as it proves to be a good idea.
     */
    #[no_mangle]
    static mut accept_mtx: userland_mutex_t;
    #[no_mangle]
    fn soisconnected(so: *mut socket);
    #[no_mangle]
    fn sonewconn(head: *mut socket, connstatus: libc::c_int) -> *mut socket;
    #[no_mangle]
    fn sofree(so: *mut socket);
    #[no_mangle]
    fn sowakeup(so: *mut socket, sb: *mut sockbuf);
    /* int hz; is declared in sys/kern/subr_param.c and refers to kernel timer frequency.
     * See http://ivoras.sharanet.org/freebsd/vmware.html for additional info about kern.hz
     * hz is initialized in void init_param1(void) in that file.
     */
    #[no_mangle]
    static mut hz: libc::c_int;
    #[no_mangle]
    fn m_split(_: *mut mbuf, _: libc::c_int, _: libc::c_int) -> *mut mbuf;
    #[no_mangle]
    fn m_freem(_: *mut mbuf);
    #[no_mangle]
    fn m_copym(_: *mut mbuf, _: libc::c_int, _: libc::c_int, _: libc::c_int) -> *mut mbuf;
    #[no_mangle]
    fn ntohl(__netlong: uint32_t) -> uint32_t;
    #[no_mangle]
    fn ntohs(__netshort: uint16_t) -> uint16_t;
    #[no_mangle]
    fn htonl(__hostlong: uint32_t) -> uint32_t;
    #[no_mangle]
    fn htons(__hostshort: uint16_t) -> uint16_t;
    #[no_mangle]
    fn sctp_os_timer_stop(_: *mut sctp_os_timer_t) -> libc::c_int;
    #[no_mangle]
    fn sctp_get_mbuf_for_msg(
        space_needed: libc::c_uint,
        want_header: libc::c_int,
        how: libc::c_int,
        allonebuf: libc::c_int,
        type_0: libc::c_int,
    ) -> *mut mbuf;
    /* with the current included files, this is defined in Linux but
     *  in FreeBSD, it is behind a _KERNEL in sys/socket.h ...
     */
    #[no_mangle]
    fn timingsafe_bcmp(_: *const libc::c_void, _: *const libc::c_void, _: size_t) -> libc::c_int;
    #[no_mangle]
    fn sctp_pathmtu_adjustment(_: *mut sctp_tcb, _: uint16_t);
    #[no_mangle]
    fn sctp_validate_init_auth_params(
        m: *mut mbuf,
        offset: libc::c_int,
        limit: libc::c_int,
    ) -> libc::c_int;
    #[no_mangle]
    fn sctp_handle_auth(
        stcb: *mut sctp_tcb,
        ch: *mut sctp_auth_chunk,
        m: *mut mbuf,
        offset: uint32_t,
    ) -> libc::c_int;
    #[no_mangle]
    fn sctp_auth_get_cookie_params(
        stcb: *mut sctp_tcb,
        m: *mut mbuf,
        offset: uint32_t,
        length: uint32_t,
    );
    #[no_mangle]
    fn sctp_hmac_m(
        hmac_algo: uint16_t,
        key: *mut uint8_t,
        keylen: uint32_t,
        m: *mut mbuf,
        m_offset: uint32_t,
        digest: *mut uint8_t,
        trailer: uint32_t,
    ) -> uint32_t;
    #[no_mangle]
    fn gettimeofday(__tv: *mut timeval, __tz: __timezone_ptr_t) -> libc::c_int;
    #[no_mangle]
    fn sctp_negotiate_hmacid(peer: *mut sctp_hmaclist_t, local: *mut sctp_hmaclist_t) -> uint16_t;
    #[no_mangle]
    fn sctp_copy_hmaclist(list: *mut sctp_hmaclist_t) -> *mut sctp_hmaclist_t;
    #[no_mangle]
    fn sctp_free_hmaclist(list: *mut sctp_hmaclist_t);
    #[no_mangle]
    fn sctp_auth_key_release(stcb: *mut sctp_tcb, keyid: uint16_t, so_locked: libc::c_int);
    #[no_mangle]
    fn sctp_copy_chunklist(chklist: *mut sctp_auth_chklist_t) -> *mut sctp_auth_chklist_t;
    #[no_mangle]
    fn sctp_free_chunklist(chklist: *mut sctp_auth_chklist_t);
    #[no_mangle]
    fn sctp_free_ifa(sctp_ifap: *mut sctp_ifa);
    #[no_mangle]
    fn sctp_findnet(_: *mut sctp_tcb, _: *mut sockaddr) -> *mut sctp_nets;
    #[no_mangle]
    fn sctp_findassociation_addr(
        _: *mut mbuf,
        _: libc::c_int,
        _: *mut sockaddr,
        _: *mut sockaddr,
        _: *mut sctphdr,
        _: *mut sctp_chunkhdr,
        _: *mut *mut sctp_inpcb,
        _: *mut *mut sctp_nets,
        vrf_id: uint32_t,
    ) -> *mut sctp_tcb;
    #[no_mangle]
    fn sctp_move_pcb_and_assoc(_: *mut sctp_inpcb, _: *mut sctp_inpcb, _: *mut sctp_tcb);
    #[no_mangle]
    fn sctp_findassociation_ep_addr(
        _: *mut *mut sctp_inpcb,
        _: *mut sockaddr,
        _: *mut *mut sctp_nets,
        _: *mut sockaddr,
        _: *mut sctp_tcb,
    ) -> *mut sctp_tcb;
    #[no_mangle]
    fn sctp_findassociation_ep_asconf(
        _: *mut mbuf,
        _: libc::c_int,
        _: *mut sockaddr,
        _: *mut sctphdr,
        _: *mut *mut sctp_inpcb,
        _: *mut *mut sctp_nets,
        vrf_id: uint32_t,
    ) -> *mut sctp_tcb;
    #[no_mangle]
    fn sctp_aloc_assoc(
        _: *mut sctp_inpcb,
        _: *mut sockaddr,
        _: *mut libc::c_int,
        _: uint32_t,
        _: uint32_t,
        _: uint16_t,
        _: uint16_t,
        _: *mut proc_0,
        _: libc::c_int,
    ) -> *mut sctp_tcb;
    #[no_mangle]
    fn sctp_free_assoc(
        _: *mut sctp_inpcb,
        _: *mut sctp_tcb,
        _: libc::c_int,
        _: libc::c_int,
    ) -> libc::c_int;
    #[no_mangle]
    static mut system_base_info: sctp_base_info;
    #[no_mangle]
    fn sctp_add_remote_addr(
        _: *mut sctp_tcb,
        _: *mut sockaddr,
        _: *mut *mut sctp_nets,
        _: uint16_t,
        _: libc::c_int,
        _: libc::c_int,
    ) -> libc::c_int;
    #[no_mangle]
    fn sctp_load_addresses_from_init(
        _: *mut sctp_tcb,
        _: *mut mbuf,
        _: libc::c_int,
        _: libc::c_int,
        _: *mut sockaddr,
        _: *mut sockaddr,
        _: *mut sockaddr,
        _: uint16_t,
    ) -> libc::c_int;
    #[no_mangle]
    fn sctp_set_primary_addr(_: *mut sctp_tcb, _: *mut sockaddr, _: *mut sctp_nets) -> libc::c_int;
    #[no_mangle]
    fn sctp_clean_up_stream(stcb: *mut sctp_tcb, rh: *mut sctp_readhead);
    #[no_mangle]
    fn sctp_select_a_tag(
        _: *mut sctp_inpcb,
        lport: uint16_t,
        rport: uint16_t,
        _: libc::c_int,
    ) -> uint32_t;
    #[no_mangle]
    fn sctp_notify_stream_reset_add(
        stcb: *mut sctp_tcb,
        numberin: uint16_t,
        numberout: uint16_t,
        flag: libc::c_int,
    );
    #[no_mangle]
    fn sctp_notify_stream_reset_tsn(
        stcb: *mut sctp_tcb,
        sending_tsn: uint32_t,
        recv_tsn: uint32_t,
        flag: libc::c_int,
    );
    #[no_mangle]
    fn sctp_timer_start(_: libc::c_int, _: *mut sctp_inpcb, _: *mut sctp_tcb, _: *mut sctp_nets);
    #[no_mangle]
    fn sctp_timer_stop(
        _: libc::c_int,
        _: *mut sctp_inpcb,
        _: *mut sctp_tcb,
        _: *mut sctp_nets,
        _: uint32_t,
    );
    #[no_mangle]
    fn sctp_calculate_rto(
        _: *mut sctp_tcb,
        _: *mut sctp_association,
        _: *mut sctp_nets,
        _: *mut timeval,
        _: libc::c_int,
    ) -> libc::c_int;
    #[no_mangle]
    fn sctp_m_getptr(_: *mut mbuf, _: libc::c_int, _: libc::c_int, _: *mut uint8_t) -> caddr_t;
    #[no_mangle]
    fn sctp_ulp_notify(
        _: uint32_t,
        _: *mut sctp_tcb,
        _: uint32_t,
        _: *mut libc::c_void,
        _: libc::c_int,
    );
    #[no_mangle]
    fn sctp_pull_off_control_to_new_inp(
        old_inp: *mut sctp_inpcb,
        new_inp: *mut sctp_inpcb,
        stcb: *mut sctp_tcb,
        waitflags: libc::c_int,
    );
    #[no_mangle]
    fn sctp_stop_timers_for_shutdown(_: *mut sctp_tcb);
    #[no_mangle]
    fn sctp_report_all_outbound(_: *mut sctp_tcb, _: uint16_t, _: libc::c_int, _: libc::c_int);
    #[no_mangle]
    fn sctp_abort_notification(
        _: *mut sctp_tcb,
        _: uint8_t,
        _: uint16_t,
        _: *mut sctp_abort_chunk,
        _: libc::c_int,
    );
    /* We abort responding to an IP packet for some reason */
    #[no_mangle]
    fn sctp_abort_association(
        _: *mut sctp_inpcb,
        _: *mut sctp_tcb,
        _: *mut mbuf,
        _: libc::c_int,
        _: *mut sockaddr,
        _: *mut sockaddr,
        _: *mut sctphdr,
        _: *mut mbuf,
        _: uint32_t,
        _: uint16_t,
    );
    /* We choose to abort via user input */
    #[no_mangle]
    fn sctp_abort_an_association(
        _: *mut sctp_inpcb,
        _: *mut sctp_tcb,
        _: *mut mbuf,
        _: libc::c_int,
    );
    #[no_mangle]
    fn sctp_handle_ootb(
        _: *mut mbuf,
        _: libc::c_int,
        _: libc::c_int,
        _: *mut sockaddr,
        _: *mut sockaddr,
        _: *mut sctphdr,
        _: *mut sctp_inpcb,
        _: *mut mbuf,
        _: uint32_t,
        _: uint16_t,
    );
    #[no_mangle]
    fn sctp_generate_cause(_: uint16_t, _: *mut libc::c_char) -> *mut mbuf;
    #[no_mangle]
    fn sctp_misc_ints(from: uint8_t, a: uint32_t, b: uint32_t, c: uint32_t, d: uint32_t);
    #[no_mangle]
    fn sctp_log_cwnd(stcb: *mut sctp_tcb, _: *mut sctp_nets, _: libc::c_int, _: uint8_t);
    #[no_mangle]
    fn sctp_log_map(_: uint32_t, _: uint32_t, _: uint32_t, _: libc::c_int);
    #[no_mangle]
    fn sctp_set_state(_: *mut sctp_tcb, _: libc::c_int);
    #[no_mangle]
    fn sctp_add_substate(_: *mut sctp_tcb, _: libc::c_int);
    #[no_mangle]
    fn sctp_send_initiate(_: *mut sctp_inpcb, _: *mut sctp_tcb, _: libc::c_int);
    #[no_mangle]
    fn sctp_send_initiate_ack(
        _: *mut sctp_inpcb,
        _: *mut sctp_tcb,
        _: *mut sctp_nets,
        _: *mut mbuf,
        _: libc::c_int,
        _: libc::c_int,
        _: *mut sockaddr,
        _: *mut sockaddr,
        _: *mut sctphdr,
        _: *mut sctp_init_chunk,
        _: uint32_t,
        _: uint16_t,
    );
    #[no_mangle]
    fn sctp_arethere_unrecognized_parameters(
        _: *mut mbuf,
        _: libc::c_int,
        _: *mut libc::c_int,
        _: *mut sctp_chunkhdr,
        _: *mut libc::c_int,
        _: *mut libc::c_int,
    ) -> *mut mbuf;
    #[no_mangle]
    fn sctp_queue_op_err(_: *mut sctp_tcb, _: *mut mbuf);
    #[no_mangle]
    fn sctp_send_cookie_echo(
        _: *mut mbuf,
        _: libc::c_int,
        _: libc::c_int,
        _: *mut sctp_tcb,
        _: *mut sctp_nets,
    ) -> libc::c_int;
    #[no_mangle]
    fn sctp_send_cookie_ack(_: *mut sctp_tcb);
    #[no_mangle]
    fn sctp_send_heartbeat_ack(
        _: *mut sctp_tcb,
        _: *mut mbuf,
        _: libc::c_int,
        _: libc::c_int,
        _: *mut sctp_nets,
    );
    #[no_mangle]
    fn sctp_send_shutdown(_: *mut sctp_tcb, _: *mut sctp_nets);
    #[no_mangle]
    fn sctp_send_shutdown_ack(_: *mut sctp_tcb, _: *mut sctp_nets);
    #[no_mangle]
    fn sctp_send_shutdown_complete(_: *mut sctp_tcb, _: *mut sctp_nets, _: libc::c_int);
    #[no_mangle]
    fn sctp_send_shutdown_complete2(
        _: *mut sockaddr,
        _: *mut sockaddr,
        _: *mut sctphdr,
        _: uint32_t,
        _: uint16_t,
    );
    #[no_mangle]
    fn sctp_send_asconf(_: *mut sctp_tcb, _: *mut sctp_nets, addr_locked: libc::c_int);
    #[no_mangle]
    fn sctp_send_asconf_ack(_: *mut sctp_tcb);
    #[no_mangle]
    fn sctp_toss_old_cookies(_: *mut sctp_tcb, _: *mut sctp_association);
    #[no_mangle]
    fn sctp_move_chunks_from_net(stcb: *mut sctp_tcb, net: *mut sctp_nets);
    #[no_mangle]
    fn sctp_chunk_output(_: *mut sctp_inpcb, _: *mut sctp_tcb, _: libc::c_int, _: libc::c_int);
    #[no_mangle]
    fn send_forward_tsn(_: *mut sctp_tcb, _: *mut sctp_association);
    #[no_mangle]
    fn sctp_send_sack(_: *mut sctp_tcb, _: libc::c_int);
    #[no_mangle]
    fn sctp_send_hb(_: *mut sctp_tcb, _: *mut sctp_nets, _: libc::c_int);
    #[no_mangle]
    fn sctp_send_ecn_echo(_: *mut sctp_tcb, _: *mut sctp_nets, _: uint32_t);
    #[no_mangle]
    fn sctp_send_packet_dropped(
        _: *mut sctp_tcb,
        _: *mut sctp_nets,
        _: *mut mbuf,
        _: libc::c_int,
        _: libc::c_int,
        _: libc::c_int,
    );
    #[no_mangle]
    fn sctp_send_cwr(_: *mut sctp_tcb, _: *mut sctp_nets, _: uint32_t, _: uint8_t);
    #[no_mangle]
    fn sctp_add_stream_reset_result(_: *mut sctp_tmit_chunk, _: uint32_t, _: uint32_t);
    #[no_mangle]
    fn sctp_add_stream_reset_result_tsn(
        _: *mut sctp_tmit_chunk,
        _: uint32_t,
        _: uint32_t,
        _: uint32_t,
        _: uint32_t,
    );
    #[no_mangle]
    fn sctp_send_stream_reset_out_if_possible(_: *mut sctp_tcb, _: libc::c_int) -> libc::c_int;
    #[no_mangle]
    fn sctp_send_str_reset_req(
        _: *mut sctp_tcb,
        _: uint16_t,
        _: *mut uint16_t,
        _: uint8_t,
        _: uint8_t,
        _: uint8_t,
        _: uint16_t,
        _: uint16_t,
        _: uint8_t,
    ) -> libc::c_int;
    #[no_mangle]
    fn sctp_send_abort(
        _: *mut mbuf,
        _: libc::c_int,
        _: *mut sockaddr,
        _: *mut sockaddr,
        _: *mut sctphdr,
        _: uint32_t,
        _: *mut mbuf,
        _: uint32_t,
        _: uint16_t,
    );
    #[no_mangle]
    fn sctp_send_operr_to(
        _: *mut sockaddr,
        _: *mut sockaddr,
        _: *mut sctphdr,
        _: uint32_t,
        _: *mut mbuf,
        _: uint32_t,
        _: uint16_t,
    );
    #[no_mangle]
    fn sctp_express_handle_sack(
        stcb: *mut sctp_tcb,
        cumack: uint32_t,
        rwnd: uint32_t,
        abort_now: *mut libc::c_int,
        ecne_seen: libc::c_int,
    );
    #[no_mangle]
    fn sctp_handle_sack(
        m: *mut mbuf,
        offset_seg: libc::c_int,
        offset_dup: libc::c_int,
        stcb: *mut sctp_tcb,
        num_seg: uint16_t,
        num_nr_seg: uint16_t,
        num_dup: uint16_t,
        abort_now: *mut libc::c_int,
        flags: uint8_t,
        cum_ack: uint32_t,
        rwnd: uint32_t,
        ecne_seen: libc::c_int,
    );
    /* draft-ietf-tsvwg-usctp */
    #[no_mangle]
    fn sctp_handle_forward_tsn(
        _: *mut sctp_tcb,
        _: *mut sctp_forward_tsn_chunk,
        _: *mut libc::c_int,
        _: *mut mbuf,
        _: libc::c_int,
    );
    #[no_mangle]
    fn sctp_update_acked(_: *mut sctp_tcb, _: *mut sctp_shutdown_chunk, _: *mut libc::c_int);
    #[no_mangle]
    fn sctp_process_data(
        _: *mut *mut mbuf,
        _: libc::c_int,
        _: *mut libc::c_int,
        _: libc::c_int,
        _: *mut sctp_inpcb,
        _: *mut sctp_tcb,
        _: *mut sctp_nets,
        _: *mut uint32_t,
    ) -> libc::c_int;
    #[no_mangle]
    fn sctp_sack_check(_: *mut sctp_tcb, _: libc::c_int);
    /*-
     * SPDX-License-Identifier: BSD-3-Clause
     *
     * Copyright (c) 2001-2007, by Cisco Systems, Inc. All rights reserved.
     * Copyright (c) 2008-2012, by Randall Stewart. All rights reserved.
     * Copyright (c) 2008-2012, by Michael Tuexen. All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * a) Redistributions of source code must retain the above copyright notice,
     *    this list of conditions and the following disclaimer.
     *
     * b) Redistributions in binary form must reproduce the above copyright
     *    notice, this list of conditions and the following disclaimer in
     *    the documentation and/or other materials provided with the distribution.
     *
     * c) Neither the name of Cisco Systems, Inc. nor the names of its
     *    contributors may be used to endorse or promote products derived
     *    from this software without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
     * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
     * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
     * THE POSSIBILITY OF SUCH DAMAGE.
     */
    /*
     * function prototypes
     */
    #[no_mangle]
    fn sctp_asconf_cleanup(_: *mut sctp_tcb, _: *mut sctp_nets);
    #[no_mangle]
    fn sctp_handle_asconf(
        _: *mut mbuf,
        _: libc::c_uint,
        _: *mut sockaddr,
        _: *mut sctp_asconf_chunk,
        _: *mut sctp_tcb,
        _: libc::c_int,
    );
    #[no_mangle]
    fn sctp_handle_asconf_ack(
        _: *mut mbuf,
        _: libc::c_int,
        _: *mut sctp_asconf_ack_chunk,
        _: *mut sctp_tcb,
        _: *mut sctp_nets,
        _: *mut libc::c_int,
    );
    #[no_mangle]
    fn sctp_check_address_list(
        _: *mut sctp_tcb,
        _: *mut mbuf,
        _: libc::c_int,
        _: libc::c_int,
        _: *mut sockaddr,
        _: uint16_t,
        _: uint16_t,
        _: uint16_t,
        _: uint16_t,
    );
    #[no_mangle]
    fn sctp_assoc_immediate_retrans(_: *mut sctp_tcb, _: *mut sctp_nets);
    #[no_mangle]
    fn sctp_asconf_send_nat_state_update(stcb: *mut sctp_tcb, net: *mut sctp_nets);
    #[no_mangle]
    fn sctp_delete_prim_timer(_: *mut sctp_inpcb, _: *mut sctp_tcb, _: *mut sctp_nets);
    #[no_mangle]
    fn sctp_calculate_cksum(_: *mut mbuf, _: uint32_t) -> uint32_t;
}
pub type size_t = libc::c_ulong;
pub type __u_char = libc::c_uchar;
pub type __u_short = libc::c_ushort;
pub type __u_int = libc::c_uint;
pub type __u_long = libc::c_ulong;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __uint64_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __pid_t = libc::c_int;
pub type __time_t = libc::c_long;
pub type __suseconds_t = libc::c_long;
pub type __caddr_t = *mut libc::c_char;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type gid_t = __gid_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type caddr_t = __caddr_t;
pub type int16_t = __int16_t;
pub type int32_t = __int32_t;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
pub type __pthread_list_t = __pthread_internal_list;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: libc::c_int,
    pub __count: libc::c_uint,
    pub __owner: libc::c_int,
    pub __nusers: libc::c_uint,
    pub __kind: libc::c_int,
    pub __spins: libc::c_short,
    pub __elision: libc::c_short,
    pub __list: __pthread_list_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub c2rust_unnamed: C2RustUnnamed_328,
    pub c2rust_unnamed_0: C2RustUnnamed_326,
    pub __g_refs: [libc::c_uint; 2],
    pub __g_size: [libc::c_uint; 2],
    pub __g1_orig_size: libc::c_uint,
    pub __wrefs: libc::c_uint,
    pub __g_signals: [libc::c_uint; 2],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union C2RustUnnamed_326 {
    pub __g1_start: libc::c_ulonglong,
    pub __g1_start32: C2RustUnnamed_327,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_327 {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union C2RustUnnamed_328 {
    pub __wseq: libc::c_ulonglong,
    pub __wseq32: C2RustUnnamed_329,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_329 {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}
pub type pthread_t = libc::c_ulong;

#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [libc::c_char; 4],
    pub __align: libc::c_int,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [libc::c_char; 40],
    pub __align: libc::c_long,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [libc::c_char; 48],
    pub __align: libc::c_longlong,
}
pub type sa_family_t = libc::c_ushort;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [libc::c_char; 14],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ucred {
    pub pid: pid_t,
    pub uid: uid_t,
    pub gid: gid_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: uint32_t,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: uint32_t,
}
pub type uint32_t = __uint32_t;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: C2RustUnnamed_330,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union C2RustUnnamed_330 {
    pub __u6_addr8: [uint8_t; 16],
    pub __u6_addr16: [uint16_t; 8],
    pub __u6_addr32: [uint32_t; 4],
}
pub type uint16_t = __uint16_t;
pub type uint8_t = __uint8_t;
pub type in_port_t = uint16_t;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [libc::c_uchar; 8],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
pub type in_addr_t = uint32_t;
/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 2006-2007, by Cisco Systems, Inc. All rights reserved.
 * Copyright (c) 2008-2011, by Randall Stewart. All rights reserved.
 * Copyright (c) 2008-2011, by Michael Tuexen. All rights reserved.
 * Copyright (c) 2008-2011, by Brad Penoff. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * a) Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * b) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *   the documentation and/or other materials provided with the distribution.
 *
 * c) Neither the name of Cisco Systems, Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Userspace includes
 * All the opt_xxx.h files are placed in the kernel build directory.
 * We will place them in userspace stack build directory.
 */
/* !defined(Userspace_os_Windows) */
pub type userland_mutex_t = pthread_mutex_t;
pub type userland_cond_t = pthread_cond_t;
pub type userland_thread_t = pthread_t;
/* sys/mutex.h typically on FreeBSD */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct mtx {
    pub dummy: libc::c_int,
}
pub type uint64_t = __uint64_t;
pub type uintptr_t = libc::c_ulong;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct proc_0 {
    pub stub: libc::c_int,
}
/* operation */
/* __Userspace__ */
/*
 * Kernel structure per socket.
 * Contains send and receive buffer queues,
 * handle on protocol and pointer to protocol
 * private data and error information.
 */
/*-
 * Locking key to struct socket:
 * (a) constant after allocation, no locking required.
 * (b) locked by SOCK_LOCK(so).
 * (c) locked by SOCKBUF_LOCK(&so->so_rcv).
 * (d) locked by SOCKBUF_LOCK(&so->so_snd).
 * (e) locked by ACCEPT_LOCK().
 * (f) not locked since integer reads/writes are atomic.
 * (g) used only as a sleep/wakeup address, no value.
 * (h) locked by global mutex so_global_mtx.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct socket {
    pub so_count: libc::c_int,
    pub so_type: libc::c_short,
    pub so_options: libc::c_short,
    pub so_linger: libc::c_short,
    pub so_state: libc::c_short,
    pub so_qstate: libc::c_int,
    pub so_pcb: *mut libc::c_void,
    pub so_dom: libc::c_int,
    pub so_head: *mut socket,
    pub so_incomp: C2RustUnnamed_338,
    pub so_comp: C2RustUnnamed_337,
    pub so_list: C2RustUnnamed_336,
    pub so_qlen: u_short,
    pub so_incqlen: u_short,
    pub so_qlimit: u_short,
    pub so_timeo: libc::c_short,
    pub timeo_cond: userland_cond_t,
    pub so_error: u_short,
    pub so_sigio: *mut sigio,
    pub so_oobmark: u_long,
    pub so_aiojobq: C2RustUnnamed_335,
    pub so_rcv: sockbuf,
    pub so_snd: sockbuf,
    pub so_upcall:
        Option<unsafe extern "C" fn(_: *mut socket, _: *mut libc::c_void, _: libc::c_int) -> ()>,
    pub so_upcallarg: *mut libc::c_void,
    pub so_cred: *mut ucred,
    pub so_label: *mut label,
    pub so_peerlabel: *mut label,
    pub so_gencnt: uint32_t,
    pub so_emuldata: *mut libc::c_void,
    pub so_accf: *mut so_accf,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct so_accf {
    pub so_accept_filter: *mut accept_filter,
    pub so_accept_filter_arg: *mut libc::c_void,
    pub so_accept_filter_str: *mut libc::c_char,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockbuf {
    pub sb_cond: userland_cond_t,
    pub sb_mtx: userland_mutex_t,
    pub sb_state: libc::c_short,
    pub sb_mb: *mut mbuf,
    pub sb_mbtail: *mut mbuf,
    pub sb_lastrecord: *mut mbuf,
    pub sb_sndptr: *mut mbuf,
    pub sb_sndptroff: u_int,
    pub sb_cc: u_int,
    pub sb_hiwat: u_int,
    pub sb_mbcnt: u_int,
    pub sb_mbmax: u_int,
    pub sb_ctl: u_int,
    pub sb_lowat: libc::c_int,
    pub sb_timeo: libc::c_int,
    pub sb_flags: libc::c_short,
}
/* type of external storage */
/*
 * The core of the mbuf object along with some shortcut defined for practical
 * purposes.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbuf {
    pub m_hdr: m_hdr,
    pub M_dat: C2RustUnnamed_331,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union C2RustUnnamed_331 {
    pub MH: C2RustUnnamed_332,
    pub M_databuf: [libc::c_char; 216],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_332 {
    pub MH_pkthdr: pkthdr,
    pub MH_dat: C2RustUnnamed_333,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union C2RustUnnamed_333 {
    pub MH_ext: m_ext,
    pub MH_databuf: [libc::c_char; 176],
}
/*-
 * Copyright (c) 1982, 1986, 1988, 1993
 *      The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
/* __Userspace__ header file for mbufs */
/* For Linux */
/* #define MSIZE 1024 */
/* mbuf initialization function */
/* modified for __Userspace__ */
/* Length to m_copy to copy all. */
/* umem_cache_t is defined in user_include/umem.h as
 * typedef struct umem_cache umem_cache_t;
 * Note:umem_zone_t is a pointer.
 */
/*-
 * Macros for type conversion:
 * mtod(m, t)	-- Convert mbuf pointer to data pointer of correct type.
 * dtom(x)	-- Convert data pointer within mbuf to mbuf pointer (XXX).
 */
/* Flags for mbuf being allocated */
/* Type of mbuf being allocated */
/* Not a type but a flag to allocate
a non-initialized mbuf */
/*
 * General mbuf allocator statistics structure.
 * __Userspace__ mbstat may be useful for gathering statistics.
 * In the kernel many of these statistics are no longer used as
 * they track allocator statistics through kernel UMA's built in statistics mechanism.
 */
/* XXX */
/* XXX */
/* times drained protocols for space */
/* XXX: times m_copym failed */
/* XXX: times m_pullup failed */
/* length of an mbuf */
/* length of an mbuf cluster */
/* min length of data to allocate a cluster */
/* length of data in an mbuf */
/* length of data in a header mbuf */
/* Number of mbtypes (gives # elems in mbtypes[] array: */
/* XXX: Sendfile stats should eventually move to their own struct */
/* times sendfile had to do disk I/O */
/* times sfbuf allocation failed */
/* times sfbuf allocation had to wait */
/*
 * Mbufs are of a single size, MSIZE (sys/param.h), which includes overhead.
 * An mbuf may add a single "mbuf cluster" of size MCLBYTES (also in
 * sys/param.h), which has no additional overhead and is used instead of the
 * internal data area; this is done when at least MINCLSIZE of data must be
 * stored.  Additionally, it is possible to allocate a separate buffer
 * externally and attach it to the mbuf in a way similar to that of mbuf
 * clusters.
 */
/* normal data len */
/* data len w/pkthdr */
/* smallest amount to put in cluster */
/* max amount to copy for compression */
/*
 * Header present at the beginning of every mbuf.
 */
/* next buffer in chain */
/* next chain in queue/record */
/* location of data */
/* amount of data in this mbuf */
/* flags; see below */
/* type of data in this mbuf */
/* word align                  */
/*
 * Packet tag structure (see below for details).
 */
/* List of packet tags */
/* Tag ID */
/* Length of data */
/* ABI/Module ID */
/*
 * Record/packet header in first mbuf of chain; valid only if M_PKTHDR is set.
 */
/* rcv interface */
/* variables for ip and tcp reassembly */
/* pointer to packet header */
/* total packet length */
/* variables for hardware checksum */
/* flags regarding checksum */
/* data field used by csum routines */
/* TSO segment size */
/* Ethernet 802.1p+q vlan tag */
/* list of packet tags */
/*
 * Description of external storage mapped into mbuf; valid only if M_EXT is
 * set.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct m_ext {
    pub ext_buf: caddr_t,
    pub ext_free: Option<unsafe extern "C" fn(_: *mut libc::c_void, _: *mut libc::c_void) -> ()>,
    pub ext_args: *mut libc::c_void,
    pub ext_size: u_int,
    pub ref_cnt: *mut u_int,
    pub ext_type: libc::c_int,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pkthdr {
    pub rcvif: *mut ifnet,
    pub header: *mut libc::c_void,
    pub len: libc::c_int,
    pub csum_flags: libc::c_int,
    pub csum_data: libc::c_int,
    pub tso_segsz: u_int16_t,
    pub ether_vtag: u_int16_t,
    pub tags: packet_tags,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct packet_tags {
    pub slh_first: *mut m_tag,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct m_tag {
    pub m_tag_link: C2RustUnnamed_334,
    pub m_tag_id: u_int16_t,
    pub m_tag_len: u_int16_t,
    pub m_tag_cookie: u_int32_t,
    pub m_tag_free: Option<unsafe extern "C" fn(_: *mut m_tag) -> ()>,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_334 {
    pub sle_next: *mut m_tag,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct m_hdr {
    pub mh_next: *mut mbuf,
    pub mh_nextpkt: *mut mbuf,
    pub mh_data: caddr_t,
    pub mh_len: libc::c_int,
    pub mh_flags: libc::c_int,
    pub mh_type: libc::c_short,
    pub pad: [uint8_t; 6],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_335 {
    pub tqh_first: *mut aiocblist,
    pub tqh_last: *mut *mut aiocblist,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_336 {
    pub tqe_next: *mut socket,
    pub tqe_prev: *mut *mut socket,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_337 {
    pub tqh_first: *mut socket,
    pub tqh_last: *mut *mut socket,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_338 {
    pub tqh_first: *mut socket,
    pub tqh_last: *mut *mut socket,
}
pub type sctp_zone_t = size_t;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifaddr {
    pub ifa_addr: sockaddr,
    pub ifa_ifu: C2RustUnnamed_339,
    pub ifa_ifp: *mut iface,
    pub ifa_next: *mut ifaddr,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union C2RustUnnamed_339 {
    pub ifu_broadaddr: sockaddr,
    pub ifu_dstaddr: sockaddr,
}
/* MTU for this path */
/*
 * We distinguish between routes to hosts and routes to networks,
 * preferring the former if available.  For each route we infer
 * the interface to use from the gateway address supplied when
 * the route was entered.  Routes that forward packets through
 * gateways are marked so that the output routines know to address the
 * gateway rather than the ultimate destination.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_rtentry {
    pub rt_ifp: *mut ifnet,
    pub rt_ifa: *mut ifaddr,
    pub rt_rmx: sctp_rt_metrics_lite,
    pub rt_refcnt: libc::c_long,
    pub rt_mtx: mtx,
}
/*
 * These numbers are used by reliable protocols for determining
 * retransmission behavior and are included in the routing structure.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_rt_metrics_lite {
    pub rmx_mtu: uint32_t,
}
/*
 * Struct inpcb is the ommon structure pcb for the Internet Protocol
 * implementation.
 *
 * Pointers to local and foreign host table entries, local and foreign socket
 * numbers, and pointers up (to a socket structure) and down (to a
 * protocol-specific control block) are stored here.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct inpcbhead {
    pub lh_first: *mut inpcb,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct inpcb {
    pub inp_hash: C2RustUnnamed_347,
    pub inp_list: C2RustUnnamed_346,
    pub inp_ppcb: *mut libc::c_void,
    pub inp_pcbinfo: *mut inpcbinfo,
    pub inp_socket: *mut socket,
    pub inp_flow: u_int32_t,
    pub inp_flags: libc::c_int,
    pub inp_vflag: u_char,
    pub inp_ip_ttl: u_char,
    pub inp_ip_p: u_char,
    pub inp_ip_minttl: u_char,
    pub inp_ispare1: uint32_t,
    pub inp_pspare: [*mut libc::c_void; 2],
    pub inp_inc: in_conninfo,
    pub inp_label: *mut label,
    pub inp_sp: *mut inpcbpolicy,
    pub inp_depend4: C2RustUnnamed_343,
    pub inp_depend6: C2RustUnnamed_342,
    pub inp_portlist: C2RustUnnamed_341,
    pub inp_phd: *mut inpcbport,
    pub inp_mtx: mtx,
}
/* default hop limit */
/* for KAME src sync over BSD*'s */
/* for KAME src sync over BSD*'s */
/* for KAME src sync over BSD*'s */
/* for KAME src sync over BSD*'s */
/* for KAME src sync over BSD*'s */
/*
 * The range of the generation count, as used in this implementation, is 9e19.
 * We would have to create 300 billion connections per second for this number
 * to roll over in a year.  This seems sufficiently unlikely that we simply
 * don't concern ourselves with that possibility.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct inpcbport {
    pub phd_hash: C2RustUnnamed_340,
    pub phd_pcblist: inpcbhead,
    pub phd_port: u_short,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_340 {
    pub le_next: *mut inpcbport,
    pub le_prev: *mut *mut inpcbport,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_341 {
    pub le_next: *mut inpcb,
    pub le_prev: *mut *mut inpcb,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_342 {
    pub inp6_options: *mut mbuf,
    pub inp6_outputopts: *mut ip6_pktopts,
    pub inp6_icmp6filt: *mut crate::sctp6_usrreq::icmp6_filter,
    pub inp6_cksum: libc::c_int,
    pub inp6_hops: libc::c_short,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_343 {
    pub inp4_ip_tos: u_char,
    pub inp4_options: *mut mbuf,
    pub inp4_moptions: *mut ip_moptions,
}
/*
 * XXX The defines for inc_* are hacks and should be changed to direct
 * references.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct in_conninfo {
    pub inc_flags: u_int8_t,
    pub inc_len: u_int8_t,
    pub inc_pad: u_int16_t,
    pub inc_ie: in_endpoints,
}
/*
 * NOTE: ipv6 addrs should be 64-bit aligned, per RFC 2553.  in_conninfo has
 * some extra padding to accomplish this.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct in_endpoints {
    pub ie_fport: u_int16_t,
    pub ie_lport: u_int16_t,
    pub ie_dependfaddr: C2RustUnnamed_345,
    pub ie_dependladdr: C2RustUnnamed_344,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union C2RustUnnamed_344 {
    pub ie46_local: in_addr_4in6,
    pub ie6_local: in6_addr,
}
/*
 * PCB with AF_INET6 null bind'ed laddr can receive AF_INET input packet.
 * So, AF_INET6 null laddr is also used as AF_INET null laddr, by utilizing
 * the following structure.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct in_addr_4in6 {
    pub ia46_pad32: [u_int32_t; 3],
    pub ia46_addr4: in_addr,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union C2RustUnnamed_345 {
    pub ie46_foreign: in_addr_4in6,
    pub ie6_foreign: in6_addr,
}
/*
 * Global data structure for each high-level protocol (UDP, TCP, ...) in both
 * IPv4 and IPv6.  Holds inpcb lists and information for managing them.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct inpcbinfo {
    pub ipi_listhead: *mut inpcbhead,
    pub ipi_count: u_int,
    pub ipi_hashbase: *mut inpcbhead,
    pub ipi_hashmask: u_long,
    pub ipi_porthashbase: *mut inpcbporthead,
    pub ipi_porthashmask: u_long,
    pub ipi_lastport: u_short,
    pub ipi_lastlow: u_short,
    pub ipi_lasthi: u_short,
    pub ipi_zone: *mut uma_zone,
    pub ipi_mtx: mtx,
    pub ipi_pspare: [*mut libc::c_void; 2],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct inpcbporthead {
    pub lh_first: *mut inpcbport,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_346 {
    pub le_next: *mut inpcb,
    pub le_prev: *mut *mut inpcb,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_347 {
    pub le_next: *mut inpcb,
    pub le_prev: *mut *mut inpcb,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_hdr {
    pub ip6_ctlun: C2RustUnnamed_348,
    pub ip6_src: in6_addr,
    pub ip6_dst: in6_addr,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union C2RustUnnamed_348 {
    pub ip6_un1: ip6_hdrctl,
    pub ip6_un2_vfc: uint8_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_hdrctl {
    pub ip6_un1_flow: uint32_t,
    pub ip6_un1_plen: uint16_t,
    pub ip6_un1_nxt: uint8_t,
    pub ip6_un1_hlim: uint8_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct calloutlist {
    pub tqh_first: *mut sctp_callout,
    pub tqh_last: *mut *mut sctp_callout,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_callout {
    pub tqe: C2RustUnnamed_349,
    pub c_time: uint32_t,
    pub c_arg: *mut libc::c_void,
    pub c_func: Option<unsafe extern "C" fn(_: *mut libc::c_void) -> ()>,
    pub c_flags: libc::c_int,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_349 {
    pub tqe_next: *mut sctp_callout,
    pub tqe_prev: *mut *mut sctp_callout,
}
/* state of this entry */
pub type sctp_os_timer_t = sctp_callout;
pub type sctp_rtentry_t = sctp_rtentry;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_tmit_chunk {
    pub rec: C2RustUnnamed_378,
    pub asoc: *mut sctp_association,
    pub sent_rcv_time: timeval,
    pub data: *mut mbuf,
    pub last_mbuf: *mut mbuf,
    pub whoTo: *mut sctp_nets,
    pub sctp_next: C2RustUnnamed_350,
    pub sent: int32_t,
    pub snd_count: uint16_t,
    pub flags: uint16_t,
    pub send_size: uint16_t,
    pub book_size: uint16_t,
    pub mbcnt: uint16_t,
    pub auth_keyid: uint16_t,
    pub holds_key_ref: uint8_t,
    pub pad_inplace: uint8_t,
    pub do_rtt: uint8_t,
    pub book_size_scale: uint8_t,
    pub no_fr_allowed: uint8_t,
    pub copy_by_ref: uint8_t,
    pub window_probe: uint8_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_350 {
    pub tqe_next: *mut sctp_tmit_chunk,
    pub tqe_prev: *mut *mut sctp_tmit_chunk,
}
/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 2001-2008, by Cisco Systems, Inc. All rights reserved.
 * Copyright (c) 2008-2012, by Randall Stewart. All rights reserved.
 * Copyright (c) 2008-2012, by Michael Tuexen. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * a) Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * b) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the distribution.
 *
 * c) Neither the name of Cisco Systems, Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
/* managing mobility_feature in inpcb (by micchie) */
/*
 * I tried to cache the readq entries at one point. But the reality
 * is that it did not add any performance since this meant we had to
 * lock the STCB on read. And at that point once you have to do an
 * extra lock, it really does not matter if the lock is in the ZONE
 * stuff or in our code. Note that this same problem would occur with
 * an mbuf cache as well so it is not really worth doing, at least
 * right now :-D
 */
/* FreeBSD Version <= 500000 or non-FreeBSD */
/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 2001-2008, by Cisco Systems, Inc. All rights reserved.
 * Copyright (c) 2008-2012, by Randall Stewart. All rights reserved.
 * Copyright (c) 2008-2012, by Michael Tuexen. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * a) Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * b) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the distribution.
 *
 * c) Neither the name of Cisco Systems, Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Depending on the timer type these will be setup and cast with the
 * appropriate entity.
 */
/* for sanity checking */
/*
 * This is the information we track on each interface that we know about from
 * the distant end.
 */
/*
 * Users of the iterator need to malloc a iterator with a call to
 * sctp_initiate_iterator(inp_func, assoc_func, inp_func,  pcb_flags, pcb_features,
 *     asoc_state, void-ptr-arg, uint32-arg, end_func, inp);
 *
 * Use the following two defines if you don't care what pcb flags are on the EP
 * and/or you don't care what state the association is in.
 *
 * Note that if you specify an INP as the last argument then ONLY each
 * association of that single INP will be executed upon. Note that the pcb
 * flags STILL apply so if the inp you specify has different pcb_flags then
 * what you put in pcb_flags nothing will happen. use SCTP_PCB_ANY_FLAGS to
 * assure the inp you specify gets treated.
 */
/* current endpoint */
/* current* assoc */
/* special hook to skip to */
/* per assoc function */
/* per endpoint function */
/* end INP function */
/* iterator completion function */
/* pointer for apply func to use */
/* value for apply func to use */
/* endpoint flags being checked */
/* endpoint features being checked */
/* assoc state being checked */
/* iterator_flags values */
/* ep */
/* remote peer addr */
/* our selected src addr */
/* Fixed point arith, << 7 */
/* Fixed point arith, << 7 */
/* Delay modeswitch until we had at least one congestion event */
/* Time since last congestion event end */
/* Bandwidth estimation */
/* The time we started the sending  */
/* Our last estimated bw */
/* RTT at bw estimate */
/* The total bytes since this sending began */
/* The total time since sending began */
/* temp holding the new value */
/* What bw_bytes was at last rtt calc */
/* Cwnd at last bw saved - lbw */
/* cnt of voluntary reductions */
/* The number required to be in steady state*/
/* The current number */
/* When all things are equal what do I return 0/1 - 1 no cc advance */
/* Flag to enable DCCC ECN */
/* Flag to indicate we need to set tls 0 or 1 means set at send 2 not */
/* Last state if steady state stepdown is on */
/* Flag saying this sack had RTT calc on it */
/* Last saved inst indication */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_nets {
    pub sctp_next: C2RustUnnamed_356,
    pub pmtu_timer: sctp_timer,
    pub hb_timer: sctp_timer,
    pub ro: sctp_net_route,
    pub mtu: uint32_t,
    pub ssthresh: uint32_t,
    pub last_cwr_tsn: uint32_t,
    pub cwr_window_tsn: uint32_t,
    pub ecn_ce_pkt_cnt: uint32_t,
    pub lost_cnt: uint32_t,
    pub lastsa: libc::c_int,
    pub lastsv: libc::c_int,
    pub rtt: uint64_t,
    pub RTO: libc::c_uint,
    pub rxt_timer: sctp_timer,
    pub last_sent_time: timeval,
    pub cc_mod: cc_control_data,
    pub ref_count: libc::c_int,
    pub flight_size: uint32_t,
    pub cwnd: uint32_t,
    pub prev_cwnd: uint32_t,
    pub ecn_prev_cwnd: uint32_t,
    pub partial_bytes_acked: uint32_t,
    pub net_ack: libc::c_uint,
    pub net_ack2: libc::c_uint,
    pub last_active: uint32_t,
    pub this_sack_highest_newack: uint32_t,
    pub pseudo_cumack: uint32_t,
    pub rtx_pseudo_cumack: uint32_t,
    pub fast_recovery_tsn: uint32_t,
    pub heartbeat_random1: uint32_t,
    pub heartbeat_random2: uint32_t,
    pub flowlabel: uint32_t,
    pub dscp: uint8_t,
    pub start_time: timeval,
    pub marked_retrans: uint32_t,
    pub marked_fastretrans: uint32_t,
    pub heart_beat_delay: uint32_t,
    pub dest_state: uint16_t,
    pub failure_threshold: uint16_t,
    pub pf_threshold: uint16_t,
    pub error_count: uint16_t,
    pub port: uint16_t,
    pub fast_retran_loss_recovery: uint8_t,
    pub will_exit_fast_recovery: uint8_t,
    pub fast_retran_ip: uint8_t,
    pub hb_responded: uint8_t,
    pub saw_newack: uint8_t,
    pub src_addr_selected: uint8_t,
    pub indx_of_eligible_next_to_use: uint8_t,
    pub addr_is_local: uint8_t,
    pub find_pseudo_cumack: uint8_t,
    pub find_rtx_pseudo_cumack: uint8_t,
    pub new_pseudo_cumack: uint8_t,
    pub window_probe: uint8_t,
    pub RTO_measured: uint8_t,
    pub last_hs_used: uint8_t,
    pub lan_type: uint8_t,
    pub rto_needed: uint8_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union cc_control_data {
    pub htcp_ca: htcp,
    pub rtcc: rtcc_cc,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct rtcc_cc {
    pub tls: timeval,
    pub lbw: uint64_t,
    pub lbw_rtt: uint64_t,
    pub bw_bytes: uint64_t,
    pub bw_tot_time: uint64_t,
    pub new_tot_time: uint64_t,
    pub bw_bytes_at_last_rttc: uint64_t,
    pub cwnd_at_bw_set: uint32_t,
    pub vol_reduce: uint32_t,
    pub steady_step: uint16_t,
    pub step_cnt: uint16_t,
    pub ret_from_eq: uint8_t,
    pub use_dccc_ecn: uint8_t,
    pub tls_needs_set: uint8_t,
    pub last_step_state: uint8_t,
    pub rtt_set_this_sack: uint8_t,
    pub last_inst_ind: uint8_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct htcp {
    pub alpha: uint16_t,
    pub beta: uint8_t,
    pub modeswitch: uint8_t,
    pub last_cong: uint32_t,
    pub undo_last_cong: uint32_t,
    pub bytes_acked: uint16_t,
    pub bytecount: uint32_t,
    pub minRTT: uint32_t,
    pub maxRTT: uint32_t,
    pub undo_maxRTT: uint32_t,
    pub undo_old_maxB: uint32_t,
    pub minB: uint32_t,
    pub maxB: uint32_t,
    pub old_maxB: uint32_t,
    pub Bi: uint32_t,
    pub lasttime: uint32_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_timer {
    pub timer: sctp_os_timer_t,
    pub type_0: libc::c_int,
    pub ep: *mut libc::c_void,
    pub tcb: *mut libc::c_void,
    pub net: *mut libc::c_void,
    pub self_0: *mut libc::c_void,
    pub ticks: uint32_t,
    pub stopped_from: uint32_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_net_route {
    pub ro_rt: *mut sctp_rtentry_t,
    pub _l_addr: sctp_sockstore,
    pub _s_addr: *mut sctp_ifa,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_ifa {
    pub next_ifa: C2RustUnnamed_355,
    pub next_bucket: C2RustUnnamed_354,
    pub ifn_p: *mut sctp_ifn,
    pub ifa: *mut libc::c_void,
    pub address: sctp_sockstore,
    pub refcount: uint32_t,
    pub flags: uint32_t,
    pub localifa_flags: uint32_t,
    pub vrf_id: uint32_t,
    pub src_is_loop: uint8_t,
    pub src_is_priv: uint8_t,
    pub src_is_glob: uint8_t,
    pub resv: uint8_t,
}
/*
 * ancillary data structures
 */
/* We add 96 bytes to the size of sctp_sndrcvinfo.
 * This makes the current structure 128 bytes long
 * which is nicely 64 bit aligned but also has room
 * for us to add more and keep ABI compatibility.
 * For example, already we have the sctp_extrcvinfo
 * when enabled which is 48 bytes.
 */
/*
 * The assoc up needs a verfid
 * all sendrcvinfo's need a verfid for SENDING only.
 */
/* should have been sinfo_pr_value */
/* Flags that go into the sinfo->sinfo_flags field */
/* next message is a notification */
/* next message is complete */
/* Start shutdown procedures */
/* Send an ABORT to peer */
/* Message is un-ordered */
/* Override the primary-address */
/* Send this on all associations */
/* end of message signal */
/* Set I-Bit */
/* for the endpoint */
/* The lower four bits is an enumeration of PR-SCTP policies */
/* Reliable transfer */
/* Time based PR-SCTP */
/* Buffer based PR-SCTP */
/* For backwards compatibility */
/* Number of retransmissions based PR-SCTP */
/* Used for aggregated stats */
/* Stat's */
/*
 * notification event structures
 */
/*
 * association change event
 */
/* sac_state values */
/* sac_info values */
/*
 * Address event
 */
/* paddr state values */
/* SCTP_ADDR_REACHABLE */
/* neither SCTP_ADDR_REACHABLE
nor SCTP_ADDR_UNCONFIRMED */
/* SCTP_ADDR_UNCONFIRMED */
/* remote error events */
/* data send failure event (deprecated) */
/* data send failure event (not deprecated) */
/* flag that indicates state of data */
/* inqueue never on wire */
/* on wire at failure */
/* shutdown event */
/* Adaptation layer indication stuff */
/* compatible old spelling */
/*
 * Partial Delivery API event
 */
/* indication values */
/*
 * authentication key event
 */
/* indication values */
/*
 * Stream reset event - subscribe to SCTP_STREAM_RESET_EVENT
 */
/* flags in stream_reset_event (strreset_flags) */
/*
 * Assoc reset event - subscribe to SCTP_ASSOC_RESET_EVENT
 */
/*
 * Stream change event - subscribe to SCTP_STREAM_CHANGE_EVENT
 */
/* SCTP notification event */
/* compatibility same as above */
/* notification types */
/* same as above */
/* we don't send this*/
/*
 * socket option structs
 */
/* addr is filled in for N * sockaddr_storage */
/*
 * AUTHENTICATION support
 */
/* SCTP_AUTH_CHUNK */
/* SCTP_AUTH_KEY */
/* SCTP_HMAC_IDENT */
/* AUTH hmac_id */
/* default, mandatory */
/* SCTP_AUTH_ACTIVE_KEY / SCTP_AUTH_DELETE_KEY */
/* SCTP_PEER_AUTH_CHUNKS / SCTP_LOCAL_AUTH_CHUNKS */
/* network to */
/* FIXME: LP64 issue */
/* cwnd in k */
/* flightsize in k */
/* increment to it */
/* in 1k bytes */
/* len of send being attempted */
/* rwnd of peer */
/* chnk cnt */
/* chnk cnt */
/* chunks out */
/* flight size in k */
/*
 * Max we can reset in one setting, note this is dictated not by the define
 * but the size of a mbuf cluster so don't change this define and think you
 * can specify more. You must do multiple resets if you want to reset more
 * than SCTP_MAX_EXPLICIT_STR_RESET.
 */
/* 0 == ALL */
/* list if strrst_num_streams is not 0 */
/* Debugging logs */
/* FIXME: LP64 issue */
/* FIXME: LP64 issue */
/* FIXME: LP64 issue */
/* FIXME: LP64 issue */
/* FIXME: LP64 issue */
/* FIXME: LP64 issue */
/* FIXME: LP64 issue */
/* chnk cnt */
/* chunks out */
/* FIXME: LP64 issue */
/* FIXME: LP64 issue */
/* FIXME: LP64 issue */
/* Number in log */
/* Number returned */
/* start at this one */
/* end at this one */
/* sctpStats 18 (TimeStamp) */
/* MIB according to RFC 3873 */
/* sctpStats  1   (Gauge32) */
/* sctpStats  2 (Counter32) */
/* sctpStats  3 (Counter32) */
/* sctpStats  4 (Counter32) */
/* sctpStats  5 (Counter32) */
/* sctpStats  6 (Counter32) */
/* sctpStats  7 (Counter32) */
/* sctpStats  8 (Counter64) */
/* sctpStats  9 (Counter64) */
/* sctpStats 10 (Counter64) */
/* sctpStats 11 (Counter64) */
/* sctpStats 12 (Counter64) */
/* sctpStats 13 (Counter64) */
/* sctpStats 14 (Counter64) */
/* sctpStats 15 (Counter64) */
/* sctpStats 16 (Counter64) */
/* sctpStats 17 (Counter64) */
/* input statistics: */
/* total input packets        */
/* total input datagrams      */
/* total packets that had data */
/* total input SACK chunks    */
/* total input DATA chunks    */
/* total input duplicate DATA chunks */
/* total input HB chunks      */
/* total input HB-ACK chunks  */
/* total input ECNE chunks    */
/* total input AUTH chunks    */
/* total input chunks missing AUTH */
/* total number of invalid HMAC ids received */
/* total number of invalid secret ids received */
/* total number of auth failed */
/* total fast path receives all one chunk */
/* total fast path multi-part data */
/* formerly sctps_recvnocrc */
/* output statistics: */
/* total output packets       */
/* total output SACKs         */
/* total output DATA chunks   */
/* total output retransmitted DATA chunks */
/* total output fast retransmitted DATA chunks */
/* total FR's that happened more than once
 * to same chunk (u-del multi-fr algo).
 */
/* total output HB chunks     */
/* total output ECNE chunks    */
/* total output AUTH chunks FIXME   */
/* ip_output error counter */
/* formerly sctps_sendnocrc */
/* PCKDROPREP statistics: */
/* Packet drop from middle box */
/* P-drop from end host */
/* P-drops with data */
/* P-drops, non-data, non-endhost */
/* P-drop, non-endhost, bandwidth rep only */
/* P-drop, not enough for chunk header */
/* P-drop, not enough data to confirm */
/* P-drop, where process_chunk_drop said break */
/* P-drop, could not find TSN */
/* P-drop, attempt reverse TSN lookup */
/* P-drop, e-host confirms zero-rwnd */
/* P-drop, midbox confirms no space */
/* P-drop, data did not match TSN */
/* P-drop, TSN's marked for Fast Retran */
/* timeouts */
/* Number of iterator timers that fired */
/* Number of T3 data time outs */
/* Number of window probe (T3) timers that fired */
/* Number of INIT timers that fired */
/* Number of sack timers that fired */
/* Number of shutdown timers that fired */
/* Number of heartbeat timers that fired */
/* Number of times a cookie timeout fired */
/* Number of times an endpoint changed its cookie secret*/
/* Number of PMTU timers that fired */
/* Number of shutdown ack timers that fired */
/* Number of shutdown guard timers that fired */
/* Number of stream reset timers that fired */
/* Number of early FR timers that fired */
/* Number of times an asconf timer fired */
/* Number of times a prim_deleted timer fired */
/* Number of times auto close timer fired */
/* Number of asoc free timers expired */
/* Number of inp free timers expired */
/* former early FR counters */
/* others */
/* packet shorter than header */
/* checksum error             */
/* no endpoint for port       */
/* bad v-tag                  */
/* bad SID                    */
/* no memory                  */
/* number of multiple FR in a RTT window */
/* nagle allowed sending      */
/* nagle doesn't allow sending */
/* max burst doesn't allow sending */
/* look ahead tells us no memory in
 * interface ring buffer OR we had a
 * send error and are queuing one send.
 */
/* total number of window probes sent */
/* total times an output error causes us
 * to clamp down on next user send.
 */
/* total times sctp_senderrors were caused from
 * a user send from a user invoked send not
 * a sack response
 */
/* Number of in data drops due to chunk limit reached */
/* Number of in data drops due to rwnd limit reached */
/* Number of times a ECN reduced the cwnd */
/* Used express lookup via vtag */
/* Collision in express lookup. */
/* Number of times the sender ran dry of user data on primary */
/* Same for above */
/* Sacks the slow way */
/* Window Update only sacks sent */
/* number of sends with sinfo_flags !=0 */
/* number of unordered sends */
/* number of sends with EOF flag set */
/* number of sends with ABORT flag set */
/* number of times protocol drain called */
/* number of times we did a protocol drain */
/* Number of times recv was called with peek */
/* Number of cached chunks used */
/* Number of cached stream oq's used */
/* Number of unread messages abandoned by close */
/* Unused */
/* Send cwnd full  avoidance, already max burst inflight to net */
/* number of map array over-runs via fwd-tsn's */
/* Number of times we queued or updated an ECN chunk on send queue */
/* Future ABI compat - remove int's from here when adding new */
/* The following macros are for handling MIB values, */

#[repr(C)]
#[derive(Copy, Clone)]
pub union sctp_sockstore {
    pub sin: sockaddr_in,
    pub sin6: sockaddr_in6,
    pub sconn: sockaddr_conn,
    pub sa: sockaddr,
}
/* dummy rtfree needed once user_route.h is included */
/* ************************/
/*      MTU              */
/* ************************/
/* (de-)register interface event notifications */
/* ************************/
/* These are for logging */
/* ************************/
/* return the base ext data pointer */
/* return the refcnt of the data pointer */
/* return any buffer related flags, this is
 * used beyond logging for apple only.
 */
/* For BSD this just accesses the M_PKTHDR length
 * so it operates on an mbuf with hdr flag. Other
 * O/S's may have seperate packet header and mbuf
 * chain pointers.. thus the macro.
 */
/* Attach the chain of data into the sendable packet. */
/* Other m_pkthdr type things */
/* FIXME need real definitions */
/* OOTB only #define SCTP_IS_IT_BROADCAST(dst, m) ((m->m_flags & M_PKTHDR) ? in_broadcast(dst, m->m_pkthdr.rcvif) : 0)  BSD def */
/* OOTB ONLY #define SCTP_IS_IT_LOOPBACK(m) ((m->m_flags & M_PKTHDR) && ((m->m_pkthdr.rcvif == NULL) || (m->m_pkthdr.rcvif->if_type == IFT_LOOP)))  BSD def */
/* This converts any input packet header
 * into the chain of data holders, for BSD
 * its a NOP.
 */
/* get the v6 hop limit */
/* As done for __Windows__ */
/* is the endpoint v6only? */
/* is the socket non-blocking? */
/* get the socket type */
/* reserve sb space for a socket */
/* wakeup a socket */
/* clear the socket buffer state */
/* start OOTB only stuff */
/* TODO IFT_LOOP is in net/if_types.h on Linux */
/* sctp_pcb.h */
/* netinet/ip_var.h defintions are behind an if defined for _KERNEL on FreeBSD */
/* end OOTB only stuff */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_conn {
    pub sconn_family: uint16_t,
    pub sconn_port: uint16_t,
    pub sconn_addr: *mut libc::c_void,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_ifn {
    pub ifalist: sctp_ifalist,
    pub vrf: *mut sctp_vrf,
    pub next_ifn: C2RustUnnamed_352,
    pub next_bucket: C2RustUnnamed_351,
    pub ifn_p: *mut libc::c_void,
    pub ifn_mtu: uint32_t,
    pub ifn_type: uint32_t,
    pub ifn_index: uint32_t,
    pub refcount: uint32_t,
    pub ifa_count: uint32_t,
    pub num_v6: uint32_t,
    pub num_v4: uint32_t,
    pub registered_af: uint32_t,
    pub ifn_name: [libc::c_char; 16],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_351 {
    pub le_next: *mut sctp_ifn,
    pub le_prev: *mut *mut sctp_ifn,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_352 {
    pub le_next: *mut sctp_ifn,
    pub le_prev: *mut *mut sctp_ifn,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_vrf {
    pub next_vrf: C2RustUnnamed_353,
    pub vrf_addr_hash: *mut sctp_ifalist,
    pub ifnlist: sctp_ifnlist,
    pub vrf_id: uint32_t,
    pub tbl_id_v4: uint32_t,
    pub tbl_id_v6: uint32_t,
    pub total_ifa_count: uint32_t,
    pub vrf_addr_hashmark: u_long,
    pub refcount: uint32_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_ifnlist {
    pub lh_first: *mut sctp_ifn,
}
/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 2001-2007, by Cisco Systems, Inc. All rights reserved.
 * Copyright (c) 2008-2012, by Randall Stewart. All rights reserved.
 * Copyright (c) 2008-2012, by Michael Tuexen. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * a) Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * b) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the distribution.
 *
 * c) Neither the name of Cisco Systems, Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_ifalist {
    pub lh_first: *mut sctp_ifa,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_353 {
    pub le_next: *mut sctp_vrf,
    pub le_prev: *mut *mut sctp_vrf,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_354 {
    pub le_next: *mut sctp_ifa,
    pub le_prev: *mut *mut sctp_ifa,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_355 {
    pub le_next: *mut sctp_ifa,
    pub le_prev: *mut *mut sctp_ifa,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_356 {
    pub tqe_next: *mut sctp_nets,
    pub tqe_prev: *mut *mut sctp_nets,
}
/* This struct is here to cut out the compatiabilty
 * pad that bulks up both the inp and stcb. The non
 * pad portion MUST stay in complete sync with
 * sctp_sndrcvinfo... i.e. if sinfo_xxxx is added
 * this must be done here too.
 */
/*
 * JRS - Structure to hold function pointers to the functions responsible
 * for congestion control.
 */
/*
 * RS - Structure to hold function pointers to the functions responsible
 * for stream scheduling.
 */
/* used to save ASCONF chunks for retransmission */
/* used to save ASCONF-ACK chunks for retransmission */
/*
 * Here we have information about each individual association that we track.
 * We probably in production would be more dynamic. But for ease of
 * implementation we will have a fixed array that we hunt for in a linear
 * fashion.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_association {
    pub state: libc::c_int,
    pub asconf_queue: sctp_asconf_addrhead,
    pub time_entered: timeval,
    pub time_last_rcvd: timeval,
    pub time_last_sent: timeval,
    pub time_last_sat_advance: timeval,
    pub def_send: sctp_nonpad_sndrcvinfo,
    pub dack_timer: sctp_timer,
    pub asconf_timer: sctp_timer,
    pub strreset_timer: sctp_timer,
    pub shut_guard_timer: sctp_timer,
    pub autoclose_timer: sctp_timer,
    pub delayed_event_timer: sctp_timer,
    pub delete_prim_timer: sctp_timer,
    pub sctp_restricted_addrs: sctpladdr,
    pub asconf_addr_del_pending: *mut sctp_ifa,
    pub deleted_primary: *mut sctp_nets,
    pub nets: sctpnetlisthead,
    pub free_chunks: sctpchunk_listhead,
    pub control_send_queue: sctpchunk_listhead,
    pub asconf_send_queue: sctpchunk_listhead,
    pub sent_queue: sctpchunk_listhead,
    pub send_queue: sctpchunk_listhead,
    pub ss_data: scheduling_data,
    pub stcb_starting_point_for_iterator: *mut sctp_iterator,
    pub asconf_ack_sent: sctp_asconf_ackhead,
    pub str_reset: *mut sctp_tmit_chunk,
    pub last_used_address: *mut sctp_laddr,
    pub strmin: *mut sctp_stream_in,
    pub strmout: *mut sctp_stream_out,
    pub mapping_array: *mut uint8_t,
    pub primary_destination: *mut sctp_nets,
    pub alternate: *mut sctp_nets,
    pub last_net_cmt_send_started: *mut sctp_nets,
    pub last_data_chunk_from: *mut sctp_nets,
    pub last_control_chunk_from: *mut sctp_nets,
    pub resetHead: sctp_resethead,
    pub pending_reply_queue: sctp_readhead,
    pub cc_functions: sctp_cc_functions,
    pub congestion_control_module: uint32_t,
    pub ss_functions: sctp_ss_functions,
    pub stream_scheduling_module: uint32_t,
    pub vrf_id: uint32_t,
    pub cookie_preserve_req: uint32_t,
    pub asconf_seq_out: uint32_t,
    pub asconf_seq_out_acked: uint32_t,
    pub asconf_seq_in: uint32_t,
    pub str_reset_seq_out: uint32_t,
    pub str_reset_seq_in: uint32_t,
    pub my_vtag: uint32_t,
    pub peer_vtag: uint32_t,
    pub my_vtag_nonce: uint32_t,
    pub peer_vtag_nonce: uint32_t,
    pub assoc_id: uint32_t,
    pub smallest_mtu: uint32_t,
    pub this_sack_highest_gap: uint32_t,
    pub last_acked_seq: uint32_t,
    pub sending_seq: uint32_t,
    pub init_seq_number: uint32_t,
    pub advanced_peer_ack_point: uint32_t,
    pub cumulative_tsn: uint32_t,
    pub mapping_array_base_tsn: uint32_t,
    pub highest_tsn_inside_map: uint32_t,
    pub nr_mapping_array: *mut uint8_t,
    pub highest_tsn_inside_nr_map: uint32_t,
    pub fast_recovery_tsn: uint32_t,
    pub sat_t3_recovery_tsn: uint32_t,
    pub tsn_last_delivered: uint32_t,
    pub control_pdapi: *mut sctp_queued_to_read,
    pub tsn_of_pdapi_last_delivered: uint32_t,
    pub pdapi_ppid: uint32_t,
    pub context: uint32_t,
    pub last_reset_action: [uint32_t; 2],
    pub last_sending_seq: [uint32_t; 2],
    pub last_base_tsnsent: [uint32_t; 2],
    pub peers_rwnd: uint32_t,
    pub my_rwnd: uint32_t,
    pub my_last_reported_rwnd: uint32_t,
    pub sctp_frag_point: uint32_t,
    pub total_output_queue_size: uint32_t,
    pub sb_cc: uint32_t,
    pub sb_send_resv: uint32_t,
    pub my_rwnd_control_len: uint32_t,
    pub default_flowlabel: uint32_t,
    pub pr_sctp_cnt: uint32_t,
    pub ctrl_queue_cnt: libc::c_int,
    pub stream_queue_cnt: libc::c_uint,
    pub send_queue_cnt: libc::c_uint,
    pub sent_queue_cnt: libc::c_uint,
    pub sent_queue_cnt_removeable: libc::c_uint,
    pub sent_queue_retran_cnt: libc::c_uint,
    pub size_on_reasm_queue: libc::c_uint,
    pub cnt_on_reasm_queue: libc::c_uint,
    pub fwd_tsn_cnt: libc::c_uint,
    pub total_flight: libc::c_uint,
    pub total_flight_count: libc::c_uint,
    pub numnets: libc::c_uint,
    pub overall_error_count: libc::c_uint,
    pub cnt_msg_on_sb: libc::c_uint,
    pub size_on_all_streams: libc::c_uint,
    pub cnt_on_all_streams: libc::c_uint,
    pub heart_beat_delay: uint32_t,
    pub sctp_autoclose_ticks: libc::c_uint,
    pub pre_open_streams: libc::c_uint,
    pub max_inbound_streams: libc::c_uint,
    pub cookie_life: libc::c_uint,
    pub delayed_ack: libc::c_uint,
    pub old_delayed_ack: libc::c_uint,
    pub sack_freq: libc::c_uint,
    pub data_pkts_seen: libc::c_uint,
    pub numduptsns: libc::c_uint,
    pub dup_tsns: [libc::c_int; 20],
    pub initial_init_rto_max: libc::c_uint,
    pub initial_rto: libc::c_uint,
    pub minrto: libc::c_uint,
    pub maxrto: libc::c_uint,
    pub local_auth_chunks: *mut sctp_auth_chklist_t,
    pub peer_auth_chunks: *mut sctp_auth_chklist_t,
    pub local_hmacs: *mut sctp_hmaclist_t,
    pub peer_hmacs: *mut sctp_hmaclist_t,
    pub shared_keys: sctp_keyhead,
    pub authinfo: sctp_authinfo_t,
    pub refcnt: uint32_t,
    pub chunks_on_out_queue: uint32_t,
    pub peers_adaptation: uint32_t,
    pub default_mtu: uint32_t,
    pub peer_hmac_id: uint16_t,
    pub stale_cookie_count: uint16_t,
    pub str_of_pdapi: uint16_t,
    pub ssn_of_pdapi: uint16_t,
    pub streamincnt: uint16_t,
    pub streamoutcnt: uint16_t,
    pub strm_realoutsize: uint16_t,
    pub strm_pending_add_size: uint16_t,
    pub max_init_times: uint16_t,
    pub max_send_times: uint16_t,
    pub def_net_failure: uint16_t,
    pub def_net_pf_threshold: uint16_t,
    pub mapping_array_size: uint16_t,
    pub last_strm_seq_delivered: uint16_t,
    pub last_strm_no_delivered: uint16_t,
    pub last_revoke_count: uint16_t,
    pub num_send_timers_up: int16_t,
    pub stream_locked_on: uint16_t,
    pub ecn_echo_cnt_onq: uint16_t,
    pub free_chunk_cnt: uint16_t,
    pub stream_locked: uint8_t,
    pub authenticated: uint8_t,
    pub send_sack: uint8_t,
    pub max_burst: uint32_t,
    pub fr_max_burst: uint32_t,
    pub sat_network: uint8_t,
    pub sat_network_lockout: uint8_t,
    pub burst_limit_applied: uint8_t,
    pub hb_random_values: [uint8_t; 4],
    pub fragmented_delivery_inprogress: uint8_t,
    pub fragment_flags: uint8_t,
    pub last_flags_delivered: uint8_t,
    pub hb_ect_randombit: uint8_t,
    pub hb_random_idx: uint8_t,
    pub default_dscp: uint8_t,
    pub asconf_del_pending: uint8_t,
    pub trigger_reset: uint8_t,
    pub ecn_supported: uint8_t,
    pub prsctp_supported: uint8_t,
    pub auth_supported: uint8_t,
    pub asconf_supported: uint8_t,
    pub reconfig_supported: uint8_t,
    pub nrsack_supported: uint8_t,
    pub pktdrop_supported: uint8_t,
    pub idata_supported: uint8_t,
    pub peer_req_out: uint8_t,
    pub local_strreset_support: uint8_t,
    pub peer_supports_nat: uint8_t,
    pub scope: sctp_scoping,
    pub used_alt_asconfack: uint8_t,
    pub fast_retran_loss_recovery: uint8_t,
    pub sat_t3_loss_recovery: uint8_t,
    pub dropped_special_cnt: uint8_t,
    pub seen_a_sack_this_pkt: uint8_t,
    pub stream_reset_outstanding: uint8_t,
    pub stream_reset_out_is_outstanding: uint8_t,
    pub delayed_connection: uint8_t,
    pub ifp_had_enobuf: uint8_t,
    pub saw_sack_with_frags: uint8_t,
    pub saw_sack_with_nr_frags: uint8_t,
    pub in_asocid_hash: uint8_t,
    pub assoc_up_sent: uint8_t,
    pub adaptation_needed: uint8_t,
    pub adaptation_sent: uint8_t,
    pub cmt_dac_pkts_rcvd: uint8_t,
    pub sctp_cmt_on_off: uint8_t,
    pub iam_blocking: uint8_t,
    pub cookie_how: [uint8_t; 8],
    pub sctp_cmt_pf: uint8_t,
    pub use_precise_time: uint8_t,
    pub sctp_features: uint64_t,
    pub max_cwnd: uint32_t,
    pub port: uint16_t,
    pub marked_retrans: uint32_t,
    pub timoinit: uint32_t,
    pub timodata: uint32_t,
    pub timosack: uint32_t,
    pub timoshutdown: uint32_t,
    pub timoheartbeat: uint32_t,
    pub timocookie: uint32_t,
    pub timoshutdownack: uint32_t,
    pub start_time: timeval,
    pub discontinuity_time: timeval,
    pub abandoned_unsent: [uint64_t; 4],
    pub abandoned_sent: [uint64_t; 4],
}
/* not to be used in lookup */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_scoping {
    pub ipv4_addr_legal: uint8_t,
    pub ipv6_addr_legal: uint8_t,
    pub conn_addr_legal: uint8_t,
    pub loopback_scope: uint8_t,
    pub ipv4_local_scope: uint8_t,
    pub local_scope: uint8_t,
    pub site_scope: uint8_t,
}
pub type sctp_authinfo_t = sctp_authinformation;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_authinformation {
    pub random: *mut sctp_key_t,
    pub random_len: uint32_t,
    pub peer_random: *mut sctp_key_t,
    pub assoc_key: *mut sctp_key_t,
    pub recv_key: *mut sctp_key_t,
    pub active_keyid: uint16_t,
    pub assoc_keyid: uint16_t,
    pub recv_keyid: uint16_t,
}
pub type sctp_key_t = sctp_key;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_key {
    pub keylen: uint32_t,
    pub key: [uint8_t; 0],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_keyhead {
    pub lh_first: *mut sctp_shared_key,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_shared_key {
    pub next: C2RustUnnamed_357,
    pub key: *mut sctp_key_t,
    pub refcount: uint32_t,
    pub keyid: uint16_t,
    pub deactivated: uint8_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_357 {
    pub le_next: *mut sctp_shared_key,
    pub le_prev: *mut *mut sctp_shared_key,
}
pub type sctp_hmaclist_t = sctp_hmaclist;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_hmaclist {
    pub max_algo: uint16_t,
    pub num_algo: uint16_t,
    pub hmac: [uint16_t; 0],
}
pub type sctp_auth_chklist_t = sctp_auth_chklist;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_auth_chklist {
    pub chunks: [uint8_t; 256],
    pub num_chunks: uint8_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_queued_to_read {
    pub sinfo_stream: uint16_t,
    pub sinfo_flags: uint16_t,
    pub sinfo_ppid: uint32_t,
    pub sinfo_context: uint32_t,
    pub sinfo_timetolive: uint32_t,
    pub sinfo_tsn: uint32_t,
    pub sinfo_cumtsn: uint32_t,
    pub sinfo_assoc_id: sctp_assoc_t,
    pub mid: uint32_t,
    pub length: uint32_t,
    pub held_length: uint32_t,
    pub top_fsn: uint32_t,
    pub fsn_included: uint32_t,
    pub whoFrom: *mut sctp_nets,
    pub data: *mut mbuf,
    pub tail_mbuf: *mut mbuf,
    pub aux_data: *mut mbuf,
    pub stcb: *mut sctp_tcb,
    pub next: C2RustUnnamed_359,
    pub next_instrm: C2RustUnnamed_358,
    pub reasm: sctpchunk_listhead,
    pub port_from: uint16_t,
    pub spec_flags: uint16_t,
    pub do_not_ref_stcb: uint8_t,
    pub end_added: uint8_t,
    pub pdapi_aborted: uint8_t,
    pub pdapi_started: uint8_t,
    pub some_taken: uint8_t,
    pub last_frag_seen: uint8_t,
    pub first_frag_seen: uint8_t,
    pub on_read_q: uint8_t,
    pub on_strm_q: uint8_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctpchunk_listhead {
    pub tqh_first: *mut sctp_tmit_chunk,
    pub tqh_last: *mut *mut sctp_tmit_chunk,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_358 {
    pub tqe_next: *mut sctp_queued_to_read,
    pub tqe_prev: *mut *mut sctp_queued_to_read,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_359 {
    pub tqe_next: *mut sctp_queued_to_read,
    pub tqe_prev: *mut *mut sctp_queued_to_read,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_tcb {
    pub sctp_socket: *mut socket,
    pub sctp_ep: *mut sctp_inpcb,
    pub sctp_tcbhash: C2RustUnnamed_363,
    pub sctp_tcblist: C2RustUnnamed_362,
    pub sctp_tcbasocidhash: C2RustUnnamed_361,
    pub sctp_asocs: C2RustUnnamed_360,
    pub block_entry: *mut sctp_block_entry,
    pub asoc: sctp_association,
    pub freed_by_sorcv_sincelast: uint32_t,
    pub total_sends: uint32_t,
    pub total_recvs: uint32_t,
    pub freed_from_where: libc::c_int,
    pub rport: uint16_t,
    pub resv: uint16_t,
    pub tcb_mtx: userland_mutex_t,
    pub tcb_send_mtx: userland_mutex_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_block_entry {
    pub error: libc::c_int,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_360 {
    pub le_next: *mut sctp_tcb,
    pub le_prev: *mut *mut sctp_tcb,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_361 {
    pub le_next: *mut sctp_tcb,
    pub le_prev: *mut *mut sctp_tcb,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_362 {
    pub le_next: *mut sctp_tcb,
    pub le_prev: *mut *mut sctp_tcb,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_363 {
    pub le_next: *mut sctp_tcb,
    pub le_prev: *mut *mut sctp_tcb,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_inpcb {
    pub ip_inp: C2RustUnnamed_368,
    pub read_queue: sctp_readhead,
    pub sctp_list: C2RustUnnamed_367,
    pub sctp_hash: C2RustUnnamed_366,
    pub laddr_count: libc::c_int,
    pub sctp_addr_list: sctpladdr,
    pub next_addr_touse: *mut sctp_laddr,
    pub sctp_socket: *mut socket,
    pub sctp_features: uint64_t,
    pub sctp_flags: uint32_t,
    pub sctp_mobility_features: uint32_t,
    pub sctp_ep: sctp_pcb,
    pub sctp_tcbhash: *mut sctpasochead,
    pub sctp_hashmark: u_long,
    pub sctp_asoc_list: sctpasochead,
    pub inp_starting_point_for_iterator: *mut sctp_iterator,
    pub sctp_frag_point: uint32_t,
    pub partial_delivery_point: uint32_t,
    pub sctp_context: uint32_t,
    pub max_cwnd: uint32_t,
    pub local_strreset_support: uint8_t,
    pub sctp_cmt_on_off: uint32_t,
    pub ecn_supported: uint8_t,
    pub prsctp_supported: uint8_t,
    pub auth_supported: uint8_t,
    pub idata_supported: uint8_t,
    pub asconf_supported: uint8_t,
    pub reconfig_supported: uint8_t,
    pub nrsack_supported: uint8_t,
    pub pktdrop_supported: uint8_t,
    pub def_send: sctp_nonpad_sndrcvinfo,
    pub pkt: *mut mbuf,
    pub pkt_last: *mut mbuf,
    pub control: *mut mbuf,
    pub inp_mtx: userland_mutex_t,
    pub inp_create_mtx: userland_mutex_t,
    pub inp_rdata_mtx: userland_mutex_t,
    pub refcount: int32_t,
    pub def_vrf_id: uint32_t,
    pub fibnum: uint16_t,
    pub total_sends: uint32_t,
    pub total_recvs: uint32_t,
    pub last_abort_code: uint32_t,
    pub total_nospaces: uint32_t,
    pub sctp_asocidhash: *mut sctpasochead,
    pub hashasocidmark: u_long,
    pub sctp_associd_counter: uint32_t,
    pub ulp_info: *mut libc::c_void,
    pub recv_callback: Option<
        unsafe extern "C" fn(
            _: *mut socket,
            _: sctp_sockstore,
            _: *mut libc::c_void,
            _: size_t,
            _: sctp_rcvinfo,
            _: libc::c_int,
            _: *mut libc::c_void,
        ) -> libc::c_int,
    >,
    pub send_sb_threshold: uint32_t,
    pub send_callback: Option<unsafe extern "C" fn(_: *mut socket, _: uint32_t) -> libc::c_int>,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_rcvinfo {
    pub rcv_sid: uint16_t,
    pub rcv_ssn: uint16_t,
    pub rcv_flags: uint16_t,
    pub rcv_ppid: uint32_t,
    pub rcv_tsn: uint32_t,
    pub rcv_cumtsn: uint32_t,
    pub rcv_context: uint32_t,
    pub rcv_assoc_id: sctp_assoc_t,
}
pub type sctp_assoc_t = uint32_t;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctpasochead {
    pub lh_first: *mut sctp_tcb,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_nonpad_sndrcvinfo {
    pub sinfo_stream: uint16_t,
    pub sinfo_ssn: uint16_t,
    pub sinfo_flags: uint16_t,
    pub sinfo_ppid: uint32_t,
    pub sinfo_context: uint32_t,
    pub sinfo_timetolive: uint32_t,
    pub sinfo_tsn: uint32_t,
    pub sinfo_cumtsn: uint32_t,
    pub sinfo_assoc_id: sctp_assoc_t,
    pub sinfo_keynumber: uint16_t,
    pub sinfo_keynumber_valid: uint16_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_iterator {
    pub sctp_nxt_itr: C2RustUnnamed_364,
    pub tmr: sctp_timer,
    pub inp: *mut sctp_inpcb,
    pub stcb: *mut sctp_tcb,
    pub next_inp: *mut sctp_inpcb,
    pub function_assoc: asoc_func,
    pub function_inp: inp_func,
    pub function_inp_end: inp_func,
    pub function_atend: end_func,
    pub pointer: *mut libc::c_void,
    pub val: uint32_t,
    pub pcb_flags: uint32_t,
    pub pcb_features: uint32_t,
    pub asoc_state: uint32_t,
    pub iterator_flags: uint32_t,
    pub no_chunk_output: uint8_t,
    pub done_current_ep: uint8_t,
}
pub type end_func = Option<unsafe extern "C" fn(_: *mut libc::c_void, _: uint32_t) -> ()>;
pub type inp_func = Option<
    unsafe extern "C" fn(_: *mut sctp_inpcb, _: *mut libc::c_void, _: uint32_t) -> libc::c_int,
>;
pub type asoc_func = Option<
    unsafe extern "C" fn(
        _: *mut sctp_inpcb,
        _: *mut sctp_tcb,
        _: *mut libc::c_void,
        _: uint32_t,
    ) -> (),
>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_364 {
    pub tqe_next: *mut sctp_iterator,
    pub tqe_prev: *mut *mut sctp_iterator,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_pcb {
    pub time_of_secret_change: libc::c_uint,
    pub secret_key: [[uint32_t; 8]; 2],
    pub size_of_a_cookie: libc::c_uint,
    pub sctp_timeoutticks: [libc::c_uint; 7],
    pub sctp_minrto: libc::c_uint,
    pub sctp_maxrto: libc::c_uint,
    pub initial_rto: libc::c_uint,
    pub initial_init_rto_max: libc::c_int,
    pub sctp_sack_freq: libc::c_uint,
    pub sctp_sws_sender: uint32_t,
    pub sctp_sws_receiver: uint32_t,
    pub sctp_default_cc_module: uint32_t,
    pub sctp_default_ss_module: uint32_t,
    pub shared_keys: sctp_keyhead,
    pub local_auth_chunks: *mut sctp_auth_chklist_t,
    pub local_hmacs: *mut sctp_hmaclist_t,
    pub default_keyid: uint16_t,
    pub default_mtu: uint32_t,
    pub max_init_times: uint16_t,
    pub max_send_times: uint16_t,
    pub def_net_failure: uint16_t,
    pub def_net_pf_threshold: uint16_t,
    pub pre_open_stream_count: uint16_t,
    pub max_open_streams_intome: uint16_t,
    pub random_counter: uint32_t,
    pub random_numbers: [uint8_t; 20],
    pub random_store: [uint8_t; 20],
    pub signature_change: sctp_timer,
    pub def_cookie_life: uint32_t,
    pub auto_close_time: libc::c_int,
    pub initial_sequence_debug: uint32_t,
    pub adaptation_layer_indicator: uint32_t,
    pub adaptation_layer_indicator_provided: uint8_t,
    pub store_at: uint32_t,
    pub max_burst: uint32_t,
    pub fr_max_burst: uint32_t,
    pub default_flowlabel: uint32_t,
    pub default_dscp: uint8_t,
    pub current_secret_number: libc::c_char,
    pub last_secret_number: libc::c_char,
    pub port: uint16_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_laddr {
    pub sctp_nxt_addr: C2RustUnnamed_365,
    pub ifa: *mut sctp_ifa,
    pub action: uint32_t,
    pub start_time: timeval,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_365 {
    pub le_next: *mut sctp_laddr,
    pub le_prev: *mut *mut sctp_laddr,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctpladdr {
    pub lh_first: *mut sctp_laddr,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_366 {
    pub le_next: *mut sctp_inpcb,
    pub le_prev: *mut *mut sctp_inpcb,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_367 {
    pub le_next: *mut sctp_inpcb,
    pub le_prev: *mut *mut sctp_inpcb,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_readhead {
    pub tqh_first: *mut sctp_queued_to_read,
    pub tqh_last: *mut *mut sctp_queued_to_read,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union C2RustUnnamed_368 {
    pub inp: inpcb,
    pub align: [libc::c_char; 256],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_ss_functions {
    pub sctp_ss_init: Option<
        unsafe extern "C" fn(_: *mut sctp_tcb, _: *mut sctp_association, _: libc::c_int) -> (),
    >,
    pub sctp_ss_clear: Option<
        unsafe extern "C" fn(
            _: *mut sctp_tcb,
            _: *mut sctp_association,
            _: libc::c_int,
            _: libc::c_int,
        ) -> (),
    >,
    pub sctp_ss_init_stream: Option<
        unsafe extern "C" fn(
            _: *mut sctp_tcb,
            _: *mut sctp_stream_out,
            _: *mut sctp_stream_out,
        ) -> (),
    >,
    pub sctp_ss_add_to_stream: Option<
        unsafe extern "C" fn(
            _: *mut sctp_tcb,
            _: *mut sctp_association,
            _: *mut sctp_stream_out,
            _: *mut sctp_stream_queue_pending,
            _: libc::c_int,
        ) -> (),
    >,
    pub sctp_ss_is_empty:
        Option<unsafe extern "C" fn(_: *mut sctp_tcb, _: *mut sctp_association) -> libc::c_int>,
    pub sctp_ss_remove_from_stream: Option<
        unsafe extern "C" fn(
            _: *mut sctp_tcb,
            _: *mut sctp_association,
            _: *mut sctp_stream_out,
            _: *mut sctp_stream_queue_pending,
            _: libc::c_int,
        ) -> (),
    >,
    pub sctp_ss_select_stream: Option<
        unsafe extern "C" fn(
            _: *mut sctp_tcb,
            _: *mut sctp_nets,
            _: *mut sctp_association,
        ) -> *mut sctp_stream_out,
    >,
    pub sctp_ss_scheduled: Option<
        unsafe extern "C" fn(
            _: *mut sctp_tcb,
            _: *mut sctp_nets,
            _: *mut sctp_association,
            _: *mut sctp_stream_out,
            _: libc::c_int,
        ) -> (),
    >,
    pub sctp_ss_packet_done: Option<
        unsafe extern "C" fn(_: *mut sctp_tcb, _: *mut sctp_nets, _: *mut sctp_association) -> (),
    >,
    pub sctp_ss_get_value: Option<
        unsafe extern "C" fn(
            _: *mut sctp_tcb,
            _: *mut sctp_association,
            _: *mut sctp_stream_out,
            _: *mut uint16_t,
        ) -> libc::c_int,
    >,
    pub sctp_ss_set_value: Option<
        unsafe extern "C" fn(
            _: *mut sctp_tcb,
            _: *mut sctp_association,
            _: *mut sctp_stream_out,
            _: uint16_t,
        ) -> libc::c_int,
    >,
    pub sctp_ss_is_user_msgs_incomplete:
        Option<unsafe extern "C" fn(_: *mut sctp_tcb, _: *mut sctp_association) -> libc::c_int>,
}
/* This struct is used to track the traffic on outbound streams */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_stream_out {
    pub outqueue: sctp_streamhead,
    pub ss_params: scheduling_parameters,
    pub chunks_on_queues: uint32_t,
    pub abandoned_unsent: [uint32_t; 1],
    pub abandoned_sent: [uint32_t; 1],
    pub next_mid_ordered: uint32_t,
    pub next_mid_unordered: uint32_t,
    pub sid: uint16_t,
    pub last_msg_incomplete: uint8_t,
    pub state: uint8_t,
}
/*
 * This union holds all parameters per stream
 * necessary for different stream schedulers.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub union scheduling_parameters {
    pub rr: ss_rr,
    pub prio: ss_prio,
    pub fb: ss_fb,
}
/* Fair Bandwidth scheduler */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ss_fb {
    pub next_spoke: C2RustUnnamed_369,
    pub rounds: int32_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_369 {
    pub tqe_next: *mut sctp_stream_out,
    pub tqe_prev: *mut *mut sctp_stream_out,
}
/* Priority scheduler */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ss_prio {
    pub next_spoke: C2RustUnnamed_370,
    pub priority: uint16_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_370 {
    pub tqe_next: *mut sctp_stream_out,
    pub tqe_prev: *mut *mut sctp_stream_out,
}
/* Round-robin schedulers */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ss_rr {
    pub next_spoke: C2RustUnnamed_371,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_371 {
    pub tqe_next: *mut sctp_stream_out,
    pub tqe_prev: *mut *mut sctp_stream_out,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_streamhead {
    pub tqh_first: *mut sctp_stream_queue_pending,
    pub tqh_last: *mut *mut sctp_stream_queue_pending,
}
/* This data structure will be on the outbound
 * stream queues. Data will be pulled off from
 * the front of the mbuf data and chunk-ified
 * by the output routines. We will custom
 * fit every chunk we pull to the send/sent
 * queue to make up the next full packet
 * if we can. An entry cannot be removed
 * from the stream_out queue until
 * the msg_is_complete flag is set. This
 * means at times data/tail_mbuf MIGHT
 * be NULL.. If that occurs it happens
 * for one of two reasons. Either the user
 * is blocked on a send() call and has not
 * awoken to copy more data down... OR
 * the user is in the explict MSG_EOR mode
 * and wrote some data, but has not completed
 * sending.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_stream_queue_pending {
    pub data: *mut mbuf,
    pub tail_mbuf: *mut mbuf,
    pub ts: timeval,
    pub net: *mut sctp_nets,
    pub next: C2RustUnnamed_373,
    pub ss_next: C2RustUnnamed_372,
    pub fsn: uint32_t,
    pub length: uint32_t,
    pub timetolive: uint32_t,
    pub ppid: uint32_t,
    pub context: uint32_t,
    pub sinfo_flags: uint16_t,
    pub sid: uint16_t,
    pub act_flags: uint16_t,
    pub auth_keyid: uint16_t,
    pub holds_key_ref: uint8_t,
    pub msg_is_complete: uint8_t,
    pub some_taken: uint8_t,
    pub sender_all_done: uint8_t,
    pub put_last_out: uint8_t,
    pub discard_rest: uint8_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_372 {
    pub tqe_next: *mut sctp_stream_queue_pending,
    pub tqe_prev: *mut *mut sctp_stream_queue_pending,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_373 {
    pub tqe_next: *mut sctp_stream_queue_pending,
    pub tqe_prev: *mut *mut sctp_stream_queue_pending,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_cc_functions {
    pub sctp_set_initial_cc_param:
        Option<unsafe extern "C" fn(_: *mut sctp_tcb, _: *mut sctp_nets) -> ()>,
    pub sctp_cwnd_update_after_sack: Option<
        unsafe extern "C" fn(
            _: *mut sctp_tcb,
            _: *mut sctp_association,
            _: libc::c_int,
            _: libc::c_int,
            _: libc::c_int,
        ) -> (),
    >,
    pub sctp_cwnd_update_exit_pf:
        Option<unsafe extern "C" fn(_: *mut sctp_tcb, _: *mut sctp_nets) -> ()>,
    pub sctp_cwnd_update_after_fr:
        Option<unsafe extern "C" fn(_: *mut sctp_tcb, _: *mut sctp_association) -> ()>,
    pub sctp_cwnd_update_after_timeout:
        Option<unsafe extern "C" fn(_: *mut sctp_tcb, _: *mut sctp_nets) -> ()>,
    pub sctp_cwnd_update_after_ecn_echo: Option<
        unsafe extern "C" fn(
            _: *mut sctp_tcb,
            _: *mut sctp_nets,
            _: libc::c_int,
            _: libc::c_int,
        ) -> (),
    >,
    pub sctp_cwnd_update_after_packet_dropped: Option<
        unsafe extern "C" fn(
            _: *mut sctp_tcb,
            _: *mut sctp_nets,
            _: *mut sctp_pktdrop_chunk,
            _: *mut uint32_t,
            _: *mut uint32_t,
        ) -> (),
    >,
    pub sctp_cwnd_update_after_output:
        Option<unsafe extern "C" fn(_: *mut sctp_tcb, _: *mut sctp_nets, _: libc::c_int) -> ()>,
    pub sctp_cwnd_update_packet_transmitted:
        Option<unsafe extern "C" fn(_: *mut sctp_tcb, _: *mut sctp_nets) -> ()>,
    pub sctp_cwnd_update_tsn_acknowledged:
        Option<unsafe extern "C" fn(_: *mut sctp_nets, _: *mut sctp_tmit_chunk) -> ()>,
    pub sctp_cwnd_new_transmission_begins:
        Option<unsafe extern "C" fn(_: *mut sctp_tcb, _: *mut sctp_nets) -> ()>,
    pub sctp_cwnd_prepare_net_for_sack:
        Option<unsafe extern "C" fn(_: *mut sctp_tcb, _: *mut sctp_nets) -> ()>,
    pub sctp_cwnd_socket_option: Option<
        unsafe extern "C" fn(
            _: *mut sctp_tcb,
            _: libc::c_int,
            _: *mut sctp_cc_option,
        ) -> libc::c_int,
    >,
    pub sctp_rtt_calculated:
        Option<unsafe extern "C" fn(_: *mut sctp_tcb, _: *mut sctp_nets, _: *mut timeval) -> ()>,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_cc_option {
    pub option: libc::c_int,
    pub aid_value: sctp_assoc_value,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_assoc_value {
    pub assoc_id: sctp_assoc_t,
    pub assoc_value: uint32_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_pktdrop_chunk {
    pub ch: sctp_chunkhdr,
    pub bottle_bw: uint32_t,
    pub current_onq: uint32_t,
    pub trunc_len: uint16_t,
    pub reserved: uint16_t,
    pub data: [uint8_t; 0],
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_chunkhdr {
    pub chunk_type: uint8_t,
    pub chunk_flags: uint8_t,
    pub chunk_length: uint16_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_resethead {
    pub tqh_first: *mut sctp_stream_reset_list,
    pub tqh_last: *mut *mut sctp_stream_reset_list,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_stream_reset_list {
    pub next_resp: C2RustUnnamed_374,
    pub seq: uint32_t,
    pub tsn: uint32_t,
    pub number_entries: uint32_t,
    pub list_of_streams: [uint16_t; 0],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_374 {
    pub tqe_next: *mut sctp_stream_reset_list,
    pub tqe_prev: *mut *mut sctp_stream_reset_list,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_stream_in {
    pub inqueue: sctp_readhead,
    pub uno_inqueue: sctp_readhead,
    pub last_mid_delivered: uint32_t,
    pub sid: uint16_t,
    pub delivery_started: uint8_t,
    pub pd_api_started: uint8_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_asconf_ackhead {
    pub tqh_first: *mut sctp_asconf_ack,
    pub tqh_last: *mut *mut sctp_asconf_ack,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_asconf_ack {
    pub next: C2RustUnnamed_375,
    pub serial_number: uint32_t,
    pub last_sent_to: *mut sctp_nets,
    pub data: *mut mbuf,
    pub len: uint16_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_375 {
    pub tqe_next: *mut sctp_asconf_ack,
    pub tqe_prev: *mut *mut sctp_asconf_ack,
}
/*
 * This union holds all data necessary for
 * different stream schedulers.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct scheduling_data {
    pub locked_on_sending: *mut sctp_stream_out,
    pub last_out_stream: *mut sctp_stream_out,
    pub out: C2RustUnnamed_376,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union C2RustUnnamed_376 {
    pub wheel: sctpwheel_listhead,
    pub list: sctplist_listhead,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctplist_listhead {
    pub tqh_first: *mut sctp_stream_queue_pending,
    pub tqh_last: *mut *mut sctp_stream_queue_pending,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctpwheel_listhead {
    pub tqh_first: *mut sctp_stream_out,
    pub tqh_last: *mut *mut sctp_stream_out,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctpnetlisthead {
    pub tqh_first: *mut sctp_nets,
    pub tqh_last: *mut *mut sctp_nets,
}
/* used to keep track of the addresses yet to try to add/delete */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_asconf_addrhead {
    pub tqh_first: *mut sctp_asconf_addr,
    pub tqh_last: *mut *mut sctp_asconf_addr,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_asconf_addr {
    pub next: C2RustUnnamed_377,
    pub ap: sctp_asconf_addr_param,
    pub ifa: *mut sctp_ifa,
    pub sent: uint8_t,
    pub special_del: uint8_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_asconf_addr_param {
    pub aph: sctp_asconf_paramhdr,
    pub addrp: sctp_ipv6addr_param,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_ipv6addr_param {
    pub ph: sctp_paramhdr,
    pub addr: [uint8_t; 16],
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_paramhdr {
    pub param_type: uint16_t,
    pub param_length: uint16_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_asconf_paramhdr {
    pub ph: sctp_paramhdr,
    pub correlation_id: uint32_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_377 {
    pub tqe_next: *mut sctp_asconf_addr,
    pub tqe_prev: *mut *mut sctp_asconf_addr,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union C2RustUnnamed_378 {
    pub data: sctp_data_chunkrec,
    pub chunk_id: chk_id,
}
/* The lower byte is used to enumerate PR_SCTP policies */
/* The upper byte is used as a bit mask */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct chk_id {
    pub id: uint8_t,
    pub can_take_data: uint8_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_data_chunkrec {
    pub tsn: uint32_t,
    pub mid: uint32_t,
    pub sid: uint16_t,
    pub ppid: uint32_t,
    pub context: uint32_t,
    pub cwnd_at_send: uint32_t,
    pub fast_retran_tsn: uint32_t,
    pub timetodrop: timeval,
    pub fsn: uint32_t,
    pub doing_fast_retransmit: uint8_t,
    pub rcv_flags: uint8_t,
    pub state_flags: uint8_t,
    pub chunk_was_revoked: uint8_t,
    pub fwd_tsn_cnt: uint8_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_init_chunk {
    pub ch: sctp_chunkhdr,
    pub init: sctp_init,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_init {
    pub initiate_tag: uint32_t,
    pub a_rwnd: uint32_t,
    pub num_outbound_streams: uint16_t,
    pub num_inbound_streams: uint16_t,
    pub initial_tsn: uint32_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: libc::c_int,
    pub tz_dsttime: libc::c_int,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_stream_reset_request {
    pub ph: sctp_paramhdr,
    pub request_seq: uint32_t,
}
/* type = 0x8004 */

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_auth_chunk {
    pub ch: sctp_chunkhdr,
    pub shared_key_id: uint16_t,
    pub hmac_id: uint16_t,
    pub hmac: [uint8_t; 0],
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_abort_chunk {
    pub ch: sctp_chunkhdr,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_stream_reset_response {
    pub ph: sctp_paramhdr,
    pub response_seq: uint32_t,
    pub result: uint32_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctphdr {
    pub src_port: uint16_t,
    pub dest_port: uint16_t,
    pub v_tag: uint32_t,
    pub checksum: uint32_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_gen_error_cause {
    pub code: uint16_t,
    pub length: uint16_t,
    pub info: [uint8_t; 0],
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_error_cause {
    pub code: uint16_t,
    pub length: uint16_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_error_missing_param {
    pub cause: sctp_error_cause,
    pub num_missing_params: uint32_t,
    pub type_0: [uint16_t; 0],
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_error_stale_cookie {
    pub cause: sctp_error_cause,
    pub stale_time: uint32_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_error_unrecognized_chunk {
    pub cause: sctp_error_cause,
    pub ch: sctp_chunkhdr,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_timeval {
    pub tv_sec: uint32_t,
    pub tv_usec: uint32_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctpstat {
    pub sctps_discontinuitytime: sctp_timeval,
    pub sctps_currestab: uint32_t,
    pub sctps_activeestab: uint32_t,
    pub sctps_restartestab: uint32_t,
    pub sctps_collisionestab: uint32_t,
    pub sctps_passiveestab: uint32_t,
    pub sctps_aborted: uint32_t,
    pub sctps_shutdown: uint32_t,
    pub sctps_outoftheblue: uint32_t,
    pub sctps_checksumerrors: uint32_t,
    pub sctps_outcontrolchunks: uint32_t,
    pub sctps_outorderchunks: uint32_t,
    pub sctps_outunorderchunks: uint32_t,
    pub sctps_incontrolchunks: uint32_t,
    pub sctps_inorderchunks: uint32_t,
    pub sctps_inunorderchunks: uint32_t,
    pub sctps_fragusrmsgs: uint32_t,
    pub sctps_reasmusrmsgs: uint32_t,
    pub sctps_outpackets: uint32_t,
    pub sctps_inpackets: uint32_t,
    pub sctps_recvpackets: uint32_t,
    pub sctps_recvdatagrams: uint32_t,
    pub sctps_recvpktwithdata: uint32_t,
    pub sctps_recvsacks: uint32_t,
    pub sctps_recvdata: uint32_t,
    pub sctps_recvdupdata: uint32_t,
    pub sctps_recvheartbeat: uint32_t,
    pub sctps_recvheartbeatack: uint32_t,
    pub sctps_recvecne: uint32_t,
    pub sctps_recvauth: uint32_t,
    pub sctps_recvauthmissing: uint32_t,
    pub sctps_recvivalhmacid: uint32_t,
    pub sctps_recvivalkeyid: uint32_t,
    pub sctps_recvauthfailed: uint32_t,
    pub sctps_recvexpress: uint32_t,
    pub sctps_recvexpressm: uint32_t,
    pub sctps_recv_spare: uint32_t,
    pub sctps_recvswcrc: uint32_t,
    pub sctps_recvhwcrc: uint32_t,
    pub sctps_sendpackets: uint32_t,
    pub sctps_sendsacks: uint32_t,
    pub sctps_senddata: uint32_t,
    pub sctps_sendretransdata: uint32_t,
    pub sctps_sendfastretrans: uint32_t,
    pub sctps_sendmultfastretrans: uint32_t,
    pub sctps_sendheartbeat: uint32_t,
    pub sctps_sendecne: uint32_t,
    pub sctps_sendauth: uint32_t,
    pub sctps_senderrors: uint32_t,
    pub sctps_send_spare: uint32_t,
    pub sctps_sendswcrc: uint32_t,
    pub sctps_sendhwcrc: uint32_t,
    pub sctps_pdrpfmbox: uint32_t,
    pub sctps_pdrpfehos: uint32_t,
    pub sctps_pdrpmbda: uint32_t,
    pub sctps_pdrpmbct: uint32_t,
    pub sctps_pdrpbwrpt: uint32_t,
    pub sctps_pdrpcrupt: uint32_t,
    pub sctps_pdrpnedat: uint32_t,
    pub sctps_pdrppdbrk: uint32_t,
    pub sctps_pdrptsnnf: uint32_t,
    pub sctps_pdrpdnfnd: uint32_t,
    pub sctps_pdrpdiwnp: uint32_t,
    pub sctps_pdrpdizrw: uint32_t,
    pub sctps_pdrpbadd: uint32_t,
    pub sctps_pdrpmark: uint32_t,
    pub sctps_timoiterator: uint32_t,
    pub sctps_timodata: uint32_t,
    pub sctps_timowindowprobe: uint32_t,
    pub sctps_timoinit: uint32_t,
    pub sctps_timosack: uint32_t,
    pub sctps_timoshutdown: uint32_t,
    pub sctps_timoheartbeat: uint32_t,
    pub sctps_timocookie: uint32_t,
    pub sctps_timosecret: uint32_t,
    pub sctps_timopathmtu: uint32_t,
    pub sctps_timoshutdownack: uint32_t,
    pub sctps_timoshutdownguard: uint32_t,
    pub sctps_timostrmrst: uint32_t,
    pub sctps_timoearlyfr: uint32_t,
    pub sctps_timoasconf: uint32_t,
    pub sctps_timodelprim: uint32_t,
    pub sctps_timoautoclose: uint32_t,
    pub sctps_timoassockill: uint32_t,
    pub sctps_timoinpkill: uint32_t,
    pub sctps_spare: [uint32_t; 11],
    pub sctps_hdrops: uint32_t,
    pub sctps_badsum: uint32_t,
    pub sctps_noport: uint32_t,
    pub sctps_badvtag: uint32_t,
    pub sctps_badsid: uint32_t,
    pub sctps_nomem: uint32_t,
    pub sctps_fastretransinrtt: uint32_t,
    pub sctps_markedretrans: uint32_t,
    pub sctps_naglesent: uint32_t,
    pub sctps_naglequeued: uint32_t,
    pub sctps_maxburstqueued: uint32_t,
    pub sctps_ifnomemqueued: uint32_t,
    pub sctps_windowprobed: uint32_t,
    pub sctps_lowlevelerr: uint32_t,
    pub sctps_lowlevelerrusr: uint32_t,
    pub sctps_datadropchklmt: uint32_t,
    pub sctps_datadroprwnd: uint32_t,
    pub sctps_ecnereducedcwnd: uint32_t,
    pub sctps_vtagexpress: uint32_t,
    pub sctps_vtagbogus: uint32_t,
    pub sctps_primary_randry: uint32_t,
    pub sctps_cmt_randry: uint32_t,
    pub sctps_slowpath_sack: uint32_t,
    pub sctps_wu_sacks_sent: uint32_t,
    pub sctps_sends_with_flags: uint32_t,
    pub sctps_sends_with_unord: uint32_t,
    pub sctps_sends_with_eof: uint32_t,
    pub sctps_sends_with_abort: uint32_t,
    pub sctps_protocol_drain_calls: uint32_t,
    pub sctps_protocol_drains_done: uint32_t,
    pub sctps_read_peeks: uint32_t,
    pub sctps_cached_chk: uint32_t,
    pub sctps_cached_strmoq: uint32_t,
    pub sctps_left_abandon: uint32_t,
    pub sctps_send_burst_avoid: uint32_t,
    pub sctps_send_cwnd_avoid: uint32_t,
    pub sctps_fwdtsn_map_over: uint32_t,
    pub sctps_queue_upd_ecne: uint32_t,
    pub sctps_reserved: [uint32_t; 31],
}
/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 2007, by Cisco Systems, Inc. All rights reserved.
 * Copyright (c) 2008-2012, by Randall Stewart. All rights reserved.
 * Copyright (c) 2008-2012, by Michael Tuexen. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * a) Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * b) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the distribution.
 *
 * c) Neither the name of Cisco Systems, Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_sysctl {
    pub sctp_sendspace: uint32_t,
    pub sctp_recvspace: uint32_t,
    pub sctp_auto_asconf: uint32_t,
    pub sctp_multiple_asconfs: uint32_t,
    pub sctp_ecn_enable: uint32_t,
    pub sctp_pr_enable: uint32_t,
    pub sctp_auth_enable: uint32_t,
    pub sctp_asconf_enable: uint32_t,
    pub sctp_reconfig_enable: uint32_t,
    pub sctp_nrsack_enable: uint32_t,
    pub sctp_pktdrop_enable: uint32_t,
    pub sctp_fr_max_burst_default: uint32_t,
    pub sctp_no_csum_on_loopback: uint32_t,
    pub sctp_peer_chunk_oh: uint32_t,
    pub sctp_max_burst_default: uint32_t,
    pub sctp_max_chunks_on_queue: uint32_t,
    pub sctp_hashtblsize: uint32_t,
    pub sctp_pcbtblsize: uint32_t,
    pub sctp_min_split_point: uint32_t,
    pub sctp_chunkscale: uint32_t,
    pub sctp_delayed_sack_time_default: uint32_t,
    pub sctp_sack_freq_default: uint32_t,
    pub sctp_system_free_resc_limit: uint32_t,
    pub sctp_asoc_free_resc_limit: uint32_t,
    pub sctp_heartbeat_interval_default: uint32_t,
    pub sctp_pmtu_raise_time_default: uint32_t,
    pub sctp_shutdown_guard_time_default: uint32_t,
    pub sctp_secret_lifetime_default: uint32_t,
    pub sctp_rto_max_default: uint32_t,
    pub sctp_rto_min_default: uint32_t,
    pub sctp_rto_initial_default: uint32_t,
    pub sctp_init_rto_max_default: uint32_t,
    pub sctp_valid_cookie_life_default: uint32_t,
    pub sctp_init_rtx_max_default: uint32_t,
    pub sctp_assoc_rtx_max_default: uint32_t,
    pub sctp_path_rtx_max_default: uint32_t,
    pub sctp_path_pf_threshold: uint32_t,
    pub sctp_add_more_threshold: uint32_t,
    pub sctp_nr_incoming_streams_default: uint32_t,
    pub sctp_nr_outgoing_streams_default: uint32_t,
    pub sctp_cmt_on_off: uint32_t,
    pub sctp_cmt_use_dac: uint32_t,
    pub sctp_use_cwnd_based_maxburst: uint32_t,
    pub sctp_nat_friendly: uint32_t,
    pub sctp_L2_abc_variable: uint32_t,
    pub sctp_mbuf_threshold_count: uint32_t,
    pub sctp_do_drain: uint32_t,
    pub sctp_hb_maxburst: uint32_t,
    pub sctp_abort_if_one_2_one_hits_limit: uint32_t,
    pub sctp_min_residual: uint32_t,
    pub sctp_max_retran_chunk: uint32_t,
    pub sctp_logging_level: uint32_t,
    pub sctp_default_cc_module: uint32_t,
    pub sctp_default_ss_module: uint32_t,
    pub sctp_default_frag_interleave: uint32_t,
    pub sctp_mobility_base: uint32_t,
    pub sctp_mobility_fasthandoff: uint32_t,
    pub sctp_inits_include_nat_friendly: uint32_t,
    pub sctp_rttvar_bw: uint32_t,
    pub sctp_rttvar_rtt: uint32_t,
    pub sctp_rttvar_eqret: uint32_t,
    pub sctp_steady_step: uint32_t,
    pub sctp_use_dccc_ecn: uint32_t,
    pub sctp_diag_info_code: uint32_t,
    pub sctp_udp_tunneling_port: uint32_t,
    pub sctp_enable_sack_immediately: uint32_t,
    pub sctp_vtag_time_wait: uint32_t,
    pub sctp_buffer_splitting: uint32_t,
    pub sctp_initial_cwnd: uint32_t,
    pub sctp_blackhole: uint32_t,
    pub sctp_sendall_limit: uint32_t,
    pub sctp_debug_on: uint32_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctppcbhead {
    pub lh_first: *mut sctp_inpcb,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctpvtaghead {
    pub lh_first: *mut sctp_tagblock,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_tagblock {
    pub sctp_nxt_tagblock: C2RustUnnamed_379,
    pub vtag_block: [sctp_timewait; 15],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_timewait {
    pub tv_sec_at_expire: uint32_t,
    pub v_tag: uint32_t,
    pub lport: uint16_t,
    pub rport: uint16_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_379 {
    pub le_next: *mut sctp_tagblock,
    pub le_prev: *mut *mut sctp_tagblock,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_vrflist {
    pub lh_first: *mut sctp_vrf,
}
pub type __timezone_ptr_t = *mut timezone;

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_heartbeat_info_param {
    pub ph: sctp_paramhdr,
    pub time_value_1: uint32_t,
    pub time_value_2: uint32_t,
    pub random_value1: uint32_t,
    pub random_value2: uint32_t,
    pub addr_family: uint8_t,
    pub addr_len: uint8_t,
    pub padding: [uint8_t; 2],
    pub address: [libc::c_char; 16],
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_data {
    pub tsn: uint32_t,
    pub sid: uint16_t,
    pub ssn: uint16_t,
    pub ppid: uint32_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_data_chunk {
    pub ch: sctp_chunkhdr,
    pub dp: sctp_data,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_state_cookie {
    pub identification: [uint8_t; 16],
    pub time_entered: timeval,
    pub cookie_life: uint32_t,
    pub tie_tag_my_vtag: uint32_t,
    pub tie_tag_peer_vtag: uint32_t,
    pub peers_vtag: uint32_t,
    pub my_vtag: uint32_t,
    pub address: [uint32_t; 4],
    pub addr_type: uint32_t,
    pub laddress: [uint32_t; 4],
    pub laddr_type: uint32_t,
    pub scope_id: uint32_t,
    pub peerport: uint16_t,
    pub myport: uint16_t,
    pub ipv4_addr_legal: uint8_t,
    pub ipv6_addr_legal: uint8_t,
    pub conn_addr_legal: uint8_t,
    pub local_scope: uint8_t,
    pub site_scope: uint8_t,
    pub ipv4_scope: uint8_t,
    pub loopback_scope: uint8_t,
    pub reserved: [uint8_t; 5],
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_gap_ack_block {
    pub start: uint16_t,
    pub end: uint16_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_sack {
    pub cum_tsn_ack: uint32_t,
    pub a_rwnd: uint32_t,
    pub num_gap_ack_blks: uint16_t,
    pub num_dup_tsns: uint16_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_sack_chunk {
    pub ch: sctp_chunkhdr,
    pub sack: sctp_sack,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_nr_sack {
    pub cum_tsn_ack: uint32_t,
    pub a_rwnd: uint32_t,
    pub num_gap_ack_blks: uint16_t,
    pub num_nr_gap_ack_blks: uint16_t,
    pub num_dup_tsns: uint16_t,
    pub reserved: uint16_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_nr_sack_chunk {
    pub ch: sctp_chunkhdr,
    pub nr_sack: sctp_nr_sack,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_heartbeat {
    pub hb_info: sctp_heartbeat_info_param,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_heartbeat_chunk {
    pub ch: sctp_chunkhdr,
    pub heartbeat: sctp_heartbeat,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_shutdown_chunk {
    pub ch: sctp_chunkhdr,
    pub cumulative_tsn_ack: uint32_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_shutdown_ack_chunk {
    pub ch: sctp_chunkhdr,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_cookie_echo_chunk {
    pub ch: sctp_chunkhdr,
    pub cookie: sctp_state_cookie,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_cookie_ack_chunk {
    pub ch: sctp_chunkhdr,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct old_sctp_ecne_chunk {
    pub ch: sctp_chunkhdr,
    pub tsn: uint32_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_ecne_chunk {
    pub ch: sctp_chunkhdr,
    pub tsn: uint32_t,
    pub num_pkts_since_cwr: uint32_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_cwr_chunk {
    pub ch: sctp_chunkhdr,
    pub tsn: uint32_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_shutdown_complete_chunk {
    pub ch: sctp_chunkhdr,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_asconf_chunk {
    pub ch: sctp_chunkhdr,
    pub serial_number: uint32_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_asconf_ack_chunk {
    pub ch: sctp_chunkhdr,
    pub serial_number: uint32_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_forward_tsn_chunk {
    pub ch: sctp_chunkhdr,
    pub new_cumulative_tsn: uint32_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_chunk_desc {
    pub chunk_type: uint8_t,
    pub data_bytes: [uint8_t; 31],
    pub tsn_ifany: uint32_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_stream_reset_out_request {
    pub ph: sctp_paramhdr,
    pub request_seq: uint32_t,
    pub response_seq: uint32_t,
    pub send_reset_at_tsn: uint32_t,
    pub list_of_streams: [uint16_t; 0],
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_stream_reset_in_request {
    pub ph: sctp_paramhdr,
    pub request_seq: uint32_t,
    pub list_of_streams: [uint16_t; 0],
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_stream_reset_tsn_request {
    pub ph: sctp_paramhdr,
    pub request_seq: uint32_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_stream_reset_response_tsn {
    pub ph: sctp_paramhdr,
    pub response_seq: uint32_t,
    pub result: uint32_t,
    pub senders_next_tsn: uint32_t,
    pub receivers_next_tsn: uint32_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_stream_reset_add_strm {
    pub ph: sctp_paramhdr,
    pub request_seq: uint32_t,
    pub number_of_streams: uint16_t,
    pub reserved: uint16_t,
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sctp_stream_reset_tsn_req {
    pub ch: sctp_chunkhdr,
    pub sr_req: sctp_stream_reset_tsn_request,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_epinfo {
    pub sctp_asochash: *mut sctpasochead,
    pub hashasocmark: u_long,
    pub sctp_ephash: *mut sctppcbhead,
    pub hashmark: u_long,
    pub sctp_tcpephash: *mut sctppcbhead,
    pub hashtcpmark: u_long,
    pub hashtblsize: uint32_t,
    pub sctp_vrfhash: *mut sctp_vrflist,
    pub hashvrfmark: u_long,
    pub vrf_ifn_hash: *mut sctp_ifnlist,
    pub vrf_ifn_hashmark: u_long,
    pub listhead: sctppcbhead,
    pub addr_wq: sctpladdr,
    pub ipi_zone_ep: sctp_zone_t,
    pub ipi_zone_asoc: sctp_zone_t,
    pub ipi_zone_laddr: sctp_zone_t,
    pub ipi_zone_net: sctp_zone_t,
    pub ipi_zone_chunk: sctp_zone_t,
    pub ipi_zone_readq: sctp_zone_t,
    pub ipi_zone_strmoq: sctp_zone_t,
    pub ipi_zone_asconf: sctp_zone_t,
    pub ipi_zone_asconf_ack: sctp_zone_t,
    pub ipi_ep_mtx: userland_mutex_t,
    pub ipi_addr_mtx: userland_mutex_t,
    pub ipi_count_mtx: userland_mutex_t,
    pub ipi_pktlog_mtx: userland_mutex_t,
    pub wq_addr_mtx: userland_mutex_t,
    pub ipi_count_ep: uint32_t,
    pub ipi_count_asoc: uint32_t,
    pub ipi_count_laddr: uint32_t,
    pub ipi_count_raddr: uint32_t,
    pub ipi_count_chunk: uint32_t,
    pub ipi_count_readq: uint32_t,
    pub ipi_count_strmoq: uint32_t,
    pub ipi_count_vrfs: uint32_t,
    pub ipi_count_ifns: uint32_t,
    pub ipi_count_ifas: uint32_t,
    pub ipi_free_chunks: uint32_t,
    pub ipi_free_strmoq: uint32_t,
    pub vtag_timewait: [sctpvtaghead; 32],
    pub addr_wq_timer: sctp_timer,
    pub callqueue: calloutlist,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_base_info {
    pub sctppcbinfo: sctp_epinfo,
    pub sctpstat: sctpstat,
    pub sctpsysctl: sctp_sysctl,
    pub first_time: uint8_t,
    pub sctp_pcb_initialized: libc::c_char,
    pub timer_mtx: userland_mutex_t,
    pub timer_thread: userland_thread_t,
    pub timer_thread_should_exit: libc::c_int,
    pub mtx_attr: pthread_mutexattr_t,
    pub userspace_route: libc::c_int,
    pub recvthreadroute: userland_thread_t,
    pub userspace_rawsctp: libc::c_int,
    pub userspace_udpsctp: libc::c_int,
    pub recvthreadraw: userland_thread_t,
    pub recvthreadudp: userland_thread_t,
    pub userspace_rawsctp6: libc::c_int,
    pub userspace_udpsctp6: libc::c_int,
    pub recvthreadraw6: userland_thread_t,
    pub recvthreadudp6: userland_thread_t,
    pub conn_output: Option<
        unsafe extern "C" fn(
            _: *mut libc::c_void,
            _: *mut libc::c_void,
            _: size_t,
            _: uint8_t,
            _: uint8_t,
        ) -> libc::c_int,
    >,
    pub debug_printf: Option<unsafe extern "C" fn(_: *const libc::c_char, _: ...) -> ()>,
    pub crc32c_offloaded: libc::c_int,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct udphdr {
    pub c2rust_unnamed: C2RustUnnamed_380,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union C2RustUnnamed_380 {
    pub c2rust_unnamed: C2RustUnnamed_382,
    pub c2rust_unnamed_0: C2RustUnnamed_381,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_381 {
    pub source: uint16_t,
    pub dest: uint16_t,
    pub len: uint16_t,
    pub check: uint16_t,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct C2RustUnnamed_382 {
    pub uh_sport: uint16_t,
    pub uh_dport: uint16_t,
    pub uh_ulen: uint16_t,
    pub uh_sum: uint16_t,
}
#[inline]
unsafe extern "C" fn sctp_userspace_rtfree(mut rt: *mut sctp_rtentry_t) {
    if rt.is_null() {
        return;
    }
    (*rt).rt_refcnt -= 1;
    if (*rt).rt_refcnt > 0i64 {
        return;
    }
    free(rt as *mut libc::c_void);
    rt = 0 as *mut sctp_rtentry_t;
}
/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 2001-2008, by Cisco Systems, Inc. All rights reserved.
 * Copyright (c) 2008-2012, by Randall Stewart. All rights reserved.
 * Copyright (c) 2008-2012, by Michael Tuexen. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * a) Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * b) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the distribution.
 *
 * c) Neither the name of Cisco Systems, Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
unsafe extern "C" fn sctp_stop_all_cookie_timers(mut stcb: *mut sctp_tcb) {
    let mut net = 0 as *mut sctp_nets;
    /* This now not only stops all cookie timers
     * it also stops any INIT timers as well. This
     * will make sure that the timers are stopped in
     * all collision cases.
     */
    net = (*stcb).asoc.nets.tqh_first;
    while !net.is_null() {
        if (*net).rxt_timer.type_0 == 6i32 {
            sctp_timer_stop(
                6i32,
                (*stcb).sctp_ep,
                stcb,
                net,
                (0x10000000i32 + 0x1i32) as uint32_t,
            );
        } else if (*net).rxt_timer.type_0 == 2i32 {
            sctp_timer_stop(
                2i32,
                (*stcb).sctp_ep,
                stcb,
                net,
                (0x10000000i32 + 0x2i32) as uint32_t,
            );
        }
        net = (*net).sctp_next.tqe_next
    }
}
/* INIT handler */
unsafe extern "C" fn sctp_handle_init(
    mut m: *mut mbuf,
    mut iphlen: libc::c_int,
    mut offset: libc::c_int,
    mut src: *mut sockaddr,
    mut dst: *mut sockaddr,
    mut sh: *mut sctphdr,
    mut cp: *mut sctp_init_chunk,
    mut inp: *mut sctp_inpcb,
    mut stcb: *mut sctp_tcb,
    mut net: *mut sctp_nets,
    mut abort_no_unlock: *mut libc::c_int,
    mut vrf_id: uint32_t,
    mut port: uint16_t,
) {
    let mut op_err = 0 as *mut mbuf;
    if system_base_info.sctpsysctl.sctp_debug_on & 0x2000u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"sctp_handle_init: handling INIT tcb:%p\n\x00" as *const u8 as *const libc::c_char,
                stcb as *mut libc::c_void,
            );
        }
    }
    if stcb.is_null() {
        pthread_mutex_lock(&mut (*inp).inp_mtx);
    }
    /* validate length */
    if (ntohs((*cp).ch.chunk_length) as libc::c_ulong)
        < ::std::mem::size_of::<sctp_init_chunk>() as libc::c_ulong
    {
        op_err = sctp_generate_cause(0x7u16, b"\x00" as *const u8 as *mut libc::c_char);
        sctp_abort_association(inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id, port);
        if !stcb.is_null() {
            *abort_no_unlock = 1i32
        }
    } else {
        let mut init = 0 as *mut sctp_init;
        init = &mut (*cp).init;
        if (*init).initiate_tag == 0u32 {
            /* protocol error... send abort */
            op_err = sctp_generate_cause(0x7u16, b"\x00" as *const u8 as *mut libc::c_char);
            sctp_abort_association(inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id, port);
            if !stcb.is_null() {
                *abort_no_unlock = 1i32
            }
        } else if ntohl((*init).a_rwnd) < 1500u32 {
            /* invalid parameter... send abort */
            op_err = sctp_generate_cause(0x7u16, b"\x00" as *const u8 as *mut libc::c_char);
            sctp_abort_association(inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id, port);
            if !stcb.is_null() {
                *abort_no_unlock = 1i32
            }
        } else if (*init).num_inbound_streams as libc::c_int == 0i32 {
            /* protocol error... send abort */
            op_err = sctp_generate_cause(0x7u16, b"\x00" as *const u8 as *mut libc::c_char);
            sctp_abort_association(inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id, port);
            if !stcb.is_null() {
                *abort_no_unlock = 1i32
            }
        } else if (*init).num_outbound_streams as libc::c_int == 0i32 {
            /* protocol error... send abort */
            op_err = sctp_generate_cause(0x7u16, b"\x00" as *const u8 as *mut libc::c_char);
            sctp_abort_association(inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id, port);
            if !stcb.is_null() {
                *abort_no_unlock = 1i32
            }
        } else if sctp_validate_init_auth_params(
            m,
            (offset as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<sctp_init_chunk>() as libc::c_ulong)
                as libc::c_int,
            offset + ntohs((*cp).ch.chunk_length) as libc::c_int,
        ) != 0
        {
            /* auth parameter(s) error... send abort */
            op_err = sctp_generate_cause(
                system_base_info.sctpsysctl.sctp_diag_info_code as uint16_t,
                b"Problem with AUTH parameters\x00" as *const u8 as *mut libc::c_char,
            );
            sctp_abort_association(inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id, port);
            if !stcb.is_null() {
                *abort_no_unlock = 1i32
            }
        } else if stcb.is_null()
            && ((*inp).sctp_flags & 0x10000000u32 != 0
                || (*inp).sctp_flags & 0x20000000u32 != 0
                || !((*inp).sctp_flags & 0x8u32 != 0u32))
        {
            /* We are only accepting if we have a listening socket.*/
            /*
             * FIX ME ?? What about TCP model and we have a
             * match/restart case? Actually no fix is needed.
             * the lookup will always find the existing assoc so stcb
             * would not be NULL. It may be questionable to do this
             * since we COULD just send back the INIT-ACK and hope that
             * the app did accept()'s by the time the COOKIE was sent. But
             * there is a price to pay for COOKIE generation and I don't
             * want to pay it on the chance that the app will actually do
             * some accepts(). The App just looses and should NOT be in
             * this state :-)
             */
            if system_base_info.sctpsysctl.sctp_blackhole == 0u32 {
                op_err = sctp_generate_cause(
                    system_base_info.sctpsysctl.sctp_diag_info_code as uint16_t,
                    b"No listener\x00" as *const u8 as *mut libc::c_char,
                );
                sctp_send_abort(m, iphlen, src, dst, sh, 0u32, op_err, vrf_id, port);
            }
        } else if !stcb.is_null() && (*stcb).asoc.state & 0x7fi32 == 0x40i32 {
            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"sctp_handle_init: sending SHUTDOWN-ACK\n\x00" as *const u8
                            as *const libc::c_char,
                    );
                }
            }
            sctp_send_shutdown_ack(stcb, 0 as *mut sctp_nets);
            sctp_chunk_output(inp, stcb, 3i32, 0i32);
        } else {
            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"sctp_handle_init: sending INIT-ACK\n\x00" as *const u8
                            as *const libc::c_char,
                    );
                }
            }
            sctp_send_initiate_ack(
                inp, stcb, net, m, iphlen, offset, src, dst, sh, cp, vrf_id, port,
            );
        }
    }
    if stcb.is_null() {
        pthread_mutex_unlock(&mut (*inp).inp_mtx);
    };
}
/*
 * process peer "INIT/INIT-ACK" chunk returns value < 0 on error
 */
#[no_mangle]
pub unsafe extern "C" fn sctp_is_there_unsent_data(
    mut stcb: *mut sctp_tcb,
    mut so_locked: libc::c_int,
) -> libc::c_int {
    let mut unsent_data = 0;
    let mut asoc = 0 as *mut sctp_association;
    /* This function returns if any stream has true unsent data on it.
     * Note that as it looks through it will clean up any places that
     * have old data that has been sent but left at top of stream queue.
     */
    asoc = &mut (*stcb).asoc;
    unsent_data = 0i32;
    pthread_mutex_lock(&mut (*stcb).tcb_send_mtx);
    if (*stcb)
        .asoc
        .ss_functions
        .sctp_ss_is_empty
        .expect("non-null function pointer")(stcb, asoc)
        == 0
    {
        let mut i = 0;
        i = 0u32;
        while i < (*stcb).asoc.streamoutcnt as libc::c_uint {
            let mut sp = 0 as *mut sctp_stream_queue_pending;
            sp = (*(*stcb).asoc.strmout.offset(i as isize))
                .outqueue
                .tqh_first;
            if !sp.is_null() {
                if (*sp).msg_is_complete as libc::c_int != 0
                    && (*sp).length == 0u32
                    && (*sp).sender_all_done as libc::c_int != 0
                {
                    /* We are doing differed cleanup. Last
                     * time through when we took all the data
                     * the sender_all_done was not set.
                     */
                    if (*sp).put_last_out as libc::c_int == 0i32 {
                        if system_base_info.debug_printf.is_some() {
                            system_base_info
                                .debug_printf
                                .expect("non-null function pointer")(
                                b"Gak, put out entire msg with NO end!-1\n\x00" as *const u8
                                    as *const libc::c_char,
                            );
                        }
                        if system_base_info.debug_printf.is_some() {
                            system_base_info
                                .debug_printf
                                .expect("non-null function pointer")(
                                b"sender_done:%d len:%d msg_comp:%d put_last_out:%d\n\x00"
                                    as *const u8
                                    as *const libc::c_char,
                                (*sp).sender_all_done as libc::c_int,
                                (*sp).length,
                                (*sp).msg_is_complete as libc::c_int,
                                (*sp).put_last_out as libc::c_int,
                            );
                        }
                    }
                    ::std::intrinsics::atomic_xsub(&mut (*stcb).asoc.stream_queue_cnt, 1u32);
                    if !(*sp).next.tqe_next.is_null() {
                        (*(*sp).next.tqe_next).next.tqe_prev = (*sp).next.tqe_prev
                    } else {
                        let ref mut fresh0 =
                            (*(*stcb).asoc.strmout.offset(i as isize)).outqueue.tqh_last;
                        *fresh0 = (*sp).next.tqe_prev
                    }
                    *(*sp).next.tqe_prev = (*sp).next.tqe_next;
                    (*stcb)
                        .asoc
                        .ss_functions
                        .sctp_ss_remove_from_stream
                        .expect("non-null function pointer")(
                        stcb,
                        asoc,
                        &mut *(*asoc).strmout.offset(i as isize),
                        sp,
                        1i32,
                    );
                    if !(*sp).net.is_null() {
                        if !(*sp).net.is_null() {
                            if ::std::intrinsics::atomic_xadd(
                                &mut (*(*sp).net).ref_count as *mut libc::c_int,
                                -(1i32),
                            ) == 1i32
                            {
                                sctp_os_timer_stop(&mut (*(*sp).net).rxt_timer.timer);
                                sctp_os_timer_stop(&mut (*(*sp).net).pmtu_timer.timer);
                                sctp_os_timer_stop(&mut (*(*sp).net).hb_timer.timer);
                                if !(*(*sp).net).ro.ro_rt.is_null() {
                                    if (*(*(*sp).net).ro.ro_rt).rt_refcnt <= 1i64 {
                                        sctp_userspace_rtfree((*(*sp).net).ro.ro_rt);
                                    } else {
                                        (*(*(*sp).net).ro.ro_rt).rt_refcnt -= 1
                                    }
                                    (*(*sp).net).ro.ro_rt = 0 as *mut sctp_rtentry_t;
                                    (*(*sp).net).ro.ro_rt = 0 as *mut sctp_rtentry_t
                                }
                                if (*(*sp).net).src_addr_selected != 0 {
                                    sctp_free_ifa((*(*sp).net).ro._s_addr);
                                    (*(*sp).net).ro._s_addr = 0 as *mut sctp_ifa
                                }
                                (*(*sp).net).src_addr_selected = 0u8;
                                (*(*sp).net).dest_state = ((*(*sp).net).dest_state as libc::c_int
                                    & !(0x1i32))
                                    as uint16_t;
                                free((*sp).net as *mut libc::c_void);
                                ::std::intrinsics::atomic_xsub(
                                    &mut system_base_info.sctppcbinfo.ipi_count_raddr,
                                    1u32,
                                );
                            }
                        }
                        (*sp).net = 0 as *mut sctp_nets
                    }
                    if !(*sp).data.is_null() {
                        m_freem((*sp).data);
                        (*sp).data = 0 as *mut mbuf
                    }
                    if (*sp).holds_key_ref != 0 {
                        sctp_auth_key_release(stcb, (*sp).auth_keyid, so_locked);
                        (*sp).holds_key_ref = 0u8
                    }
                    free(sp as *mut libc::c_void);
                    ::std::intrinsics::atomic_xsub(
                        &mut system_base_info.sctppcbinfo.ipi_count_strmoq,
                        1u32,
                    );
                    if !(*(*stcb).asoc.strmout.offset(i as isize))
                        .outqueue
                        .tqh_first
                        .is_null()
                    {
                        unsent_data += 1
                    }
                } else {
                    unsent_data += 1
                }
                if unsent_data > 0i32 {
                    break;
                }
            }
            i = i.wrapping_add(1)
        }
    }
    pthread_mutex_unlock(&mut (*stcb).tcb_send_mtx);
    return unsent_data;
}
unsafe extern "C" fn sctp_process_init(
    mut cp: *mut sctp_init_chunk,
    mut stcb: *mut sctp_tcb,
) -> libc::c_int {
    let mut init = 0 as *mut sctp_init;
    let mut asoc = 0 as *mut sctp_association;
    let mut i = 0;
    init = &mut (*cp).init;
    asoc = &mut (*stcb).asoc;
    /* save off parameters */
    (*asoc).peer_vtag = ntohl((*init).initiate_tag);
    (*asoc).peers_rwnd = ntohl((*init).a_rwnd);
    /* init tsn's */
    (*asoc).asconf_seq_in = ntohl((*init).initial_tsn).wrapping_sub(1u32);
    (*asoc).highest_tsn_inside_map = (*asoc).asconf_seq_in;
    if !(*asoc).nets.tqh_first.is_null() {
        let mut lnet = 0 as *mut sctp_nets;
        lnet = (*asoc).nets.tqh_first;
        while !lnet.is_null() {
            (*lnet).ssthresh = (*asoc).peers_rwnd;
            if system_base_info.sctpsysctl.sctp_logging_level & (0x2i32 | 0x4i32) as libc::c_uint
                != 0
            {
                sctp_log_cwnd(stcb, lnet, 0i32, 62u8);
            }
            lnet = (*lnet).sctp_next.tqe_next
        }
    }
    pthread_mutex_lock(&mut (*stcb).tcb_send_mtx);
    if (*asoc).pre_open_streams > ntohs((*init).num_inbound_streams) as libc::c_uint {
        let mut newcnt = 0;
        let mut chk = 0 as *mut sctp_tmit_chunk;
        let mut nchk = 0 as *mut sctp_tmit_chunk;
        /* abandon the upper streams */
        newcnt = ntohs((*init).num_inbound_streams) as libc::c_uint;
        chk = (*asoc).send_queue.tqh_first;
        while !chk.is_null() && {
            nchk = (*chk).sctp_next.tqe_next;
            (1i32) != 0
        } {
            if (*chk).rec.data.sid as libc::c_uint >= newcnt {
                if !(*chk).sctp_next.tqe_next.is_null() {
                    (*(*chk).sctp_next.tqe_next).sctp_next.tqe_prev = (*chk).sctp_next.tqe_prev
                } else {
                    (*asoc).send_queue.tqh_last = (*chk).sctp_next.tqe_prev
                }
                *(*chk).sctp_next.tqe_prev = (*chk).sctp_next.tqe_next;
                (*asoc).send_queue_cnt = (*asoc).send_queue_cnt.wrapping_sub(1);
                if (*(*asoc).strmout.offset((*chk).rec.data.sid as isize)).chunks_on_queues > 0u32 {
                    let ref mut fresh1 =
                        (*(*asoc).strmout.offset((*chk).rec.data.sid as isize)).chunks_on_queues;
                    *fresh1 = (*fresh1).wrapping_sub(1)
                }
                if !(*chk).data.is_null() {
                    if !(*chk).data.is_null() {
                        ::std::intrinsics::atomic_xsub(&mut (*asoc).chunks_on_out_queue, 1u32);
                        if (*asoc).total_output_queue_size >= (*chk).book_size as libc::c_uint {
                            ::std::intrinsics::atomic_xsub(
                                &mut (*asoc).total_output_queue_size,
                                (*chk).book_size as uint32_t,
                            );
                        } else {
                            (*asoc).total_output_queue_size = 0u32
                        }
                        if !(*stcb).sctp_socket.is_null()
                            && ((*(*stcb).sctp_ep).sctp_flags & 0x2u32 != 0
                                || (*(*stcb).sctp_ep).sctp_flags & 0x400000u32 != 0)
                        {
                            if (*(*stcb).sctp_socket).so_snd.sb_cc
                                >= (*chk).book_size as libc::c_uint
                            {
                                ::std::intrinsics::atomic_xsub(
                                    &mut (*(*stcb).sctp_socket).so_snd.sb_cc,
                                    (*chk).book_size as u_int,
                                );
                            } else {
                                (*(*stcb).sctp_socket).so_snd.sb_cc = 0u32
                            }
                        }
                    }
                    sctp_ulp_notify(6u32, stcb, 0u32, chk as *mut libc::c_void, 0i32);
                    if !(*chk).data.is_null() {
                        m_freem((*chk).data);
                        (*chk).data = 0 as *mut mbuf
                    }
                }
                if (*chk).holds_key_ref != 0 {
                    sctp_auth_key_release(stcb, (*chk).auth_keyid, 0i32);
                    (*chk).holds_key_ref = 0u8
                }
                if !stcb.is_null() {
                    if !(*chk).whoTo.is_null() {
                        if !(*chk).whoTo.is_null() {
                            if ::std::intrinsics::atomic_xadd(
                                &mut (*(*chk).whoTo).ref_count as *mut libc::c_int,
                                -(1i32),
                            ) == 1i32
                            {
                                sctp_os_timer_stop(&mut (*(*chk).whoTo).rxt_timer.timer);
                                sctp_os_timer_stop(&mut (*(*chk).whoTo).pmtu_timer.timer);
                                sctp_os_timer_stop(&mut (*(*chk).whoTo).hb_timer.timer);
                                if !(*(*chk).whoTo).ro.ro_rt.is_null() {
                                    if (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt <= 1i64 {
                                        sctp_userspace_rtfree((*(*chk).whoTo).ro.ro_rt);
                                    } else {
                                        (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt -= 1
                                    }
                                    (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t;
                                    (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t
                                }
                                if (*(*chk).whoTo).src_addr_selected != 0 {
                                    sctp_free_ifa((*(*chk).whoTo).ro._s_addr);
                                    (*(*chk).whoTo).ro._s_addr = 0 as *mut sctp_ifa
                                }
                                (*(*chk).whoTo).src_addr_selected = 0u8;
                                (*(*chk).whoTo).dest_state =
                                    ((*(*chk).whoTo).dest_state as libc::c_int & !(0x1i32))
                                        as uint16_t;
                                free((*chk).whoTo as *mut libc::c_void);
                                ::std::intrinsics::atomic_xsub(
                                    &mut system_base_info.sctppcbinfo.ipi_count_raddr,
                                    1u32,
                                );
                            }
                        }
                        (*chk).whoTo = 0 as *mut sctp_nets
                    }
                    if (*stcb).asoc.free_chunk_cnt as libc::c_uint
                        > system_base_info.sctpsysctl.sctp_asoc_free_resc_limit
                        || system_base_info.sctppcbinfo.ipi_free_chunks
                            > system_base_info.sctpsysctl.sctp_system_free_resc_limit
                    {
                        free(chk as *mut libc::c_void);
                        ::std::intrinsics::atomic_xsub(
                            &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                            1u32,
                        );
                    } else {
                        (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
                        (*chk).sctp_next.tqe_prev = (*stcb).asoc.free_chunks.tqh_last;
                        *(*stcb).asoc.free_chunks.tqh_last = chk;
                        (*stcb).asoc.free_chunks.tqh_last = &mut (*chk).sctp_next.tqe_next;
                        (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_add(1);
                        ::std::intrinsics::atomic_xadd(
                            &mut system_base_info.sctppcbinfo.ipi_free_chunks,
                            1u32,
                        );
                    }
                } else {
                    free(chk as *mut libc::c_void);
                    ::std::intrinsics::atomic_xsub(
                        &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                        1u32,
                    );
                }
                /*sa_ignore FREED_MEMORY*/
            }
            chk = nchk
        }
        if !(*asoc).strmout.is_null() {
            i = newcnt;
            while i < (*asoc).pre_open_streams {
                let mut outs = 0 as *mut sctp_stream_out;
                let mut sp = 0 as *mut sctp_stream_queue_pending;
                let mut nsp = 0 as *mut sctp_stream_queue_pending;
                outs = &mut *(*asoc).strmout.offset(i as isize) as *mut sctp_stream_out;
                sp = (*outs).outqueue.tqh_first;
                while !sp.is_null() && {
                    nsp = (*sp).next.tqe_next;
                    (1i32) != 0
                } {
                    ::std::intrinsics::atomic_xsub(&mut (*stcb).asoc.stream_queue_cnt, 1u32);
                    if !(*sp).next.tqe_next.is_null() {
                        (*(*sp).next.tqe_next).next.tqe_prev = (*sp).next.tqe_prev
                    } else {
                        (*outs).outqueue.tqh_last = (*sp).next.tqe_prev
                    }
                    *(*sp).next.tqe_prev = (*sp).next.tqe_next;
                    (*stcb)
                        .asoc
                        .ss_functions
                        .sctp_ss_remove_from_stream
                        .expect("non-null function pointer")(
                        stcb, asoc, outs, sp, 1i32
                    );
                    sctp_ulp_notify(7u32, stcb, 0u32, sp as *mut libc::c_void, 0i32);
                    if !(*sp).data.is_null() {
                        m_freem((*sp).data);
                        (*sp).data = 0 as *mut mbuf
                    }
                    if !(*sp).net.is_null() {
                        if !(*sp).net.is_null() {
                            if ::std::intrinsics::atomic_xadd(
                                &mut (*(*sp).net).ref_count as *mut libc::c_int,
                                -(1i32),
                            ) == 1i32
                            {
                                sctp_os_timer_stop(&mut (*(*sp).net).rxt_timer.timer);
                                sctp_os_timer_stop(&mut (*(*sp).net).pmtu_timer.timer);
                                sctp_os_timer_stop(&mut (*(*sp).net).hb_timer.timer);
                                if !(*(*sp).net).ro.ro_rt.is_null() {
                                    if (*(*(*sp).net).ro.ro_rt).rt_refcnt <= 1i64 {
                                        sctp_userspace_rtfree((*(*sp).net).ro.ro_rt);
                                    } else {
                                        (*(*(*sp).net).ro.ro_rt).rt_refcnt -= 1
                                    }
                                    (*(*sp).net).ro.ro_rt = 0 as *mut sctp_rtentry_t;
                                    (*(*sp).net).ro.ro_rt = 0 as *mut sctp_rtentry_t
                                }
                                if (*(*sp).net).src_addr_selected != 0 {
                                    sctp_free_ifa((*(*sp).net).ro._s_addr);
                                    (*(*sp).net).ro._s_addr = 0 as *mut sctp_ifa
                                }
                                (*(*sp).net).src_addr_selected = 0u8;
                                (*(*sp).net).dest_state = ((*(*sp).net).dest_state as libc::c_int
                                    & !(0x1i32))
                                    as uint16_t;
                                free((*sp).net as *mut libc::c_void);
                                ::std::intrinsics::atomic_xsub(
                                    &mut system_base_info.sctppcbinfo.ipi_count_raddr,
                                    1u32,
                                );
                            }
                        }
                        (*sp).net = 0 as *mut sctp_nets
                    }
                    /*sa_ignore FREED_MEMORY*/
                    if (*sp).holds_key_ref != 0 {
                        sctp_auth_key_release(stcb, (*sp).auth_keyid, 0i32);
                        (*sp).holds_key_ref = 0u8
                    }
                    free(sp as *mut libc::c_void);
                    ::std::intrinsics::atomic_xsub(
                        &mut system_base_info.sctppcbinfo.ipi_count_strmoq,
                        1u32,
                    );
                    sp = nsp
                }
                (*outs).state = 0u8;
                i = i.wrapping_add(1)
            }
        }
        /* Free the chunk */
        /* cut back the count */
        (*asoc).pre_open_streams = newcnt
    }
    pthread_mutex_unlock(&mut (*stcb).tcb_send_mtx);
    (*asoc).streamoutcnt = (*asoc).pre_open_streams as uint16_t;
    if !(*asoc).strmout.is_null() {
        i = 0u32;
        while i < (*asoc).streamoutcnt as libc::c_uint {
            (*(*asoc).strmout.offset(i as isize)).state = 0x2u8;
            i = i.wrapping_add(1)
        }
    }
    /* EY - nr_sack: initialize highest tsn in nr_mapping_array */
    (*asoc).highest_tsn_inside_nr_map = (*asoc).highest_tsn_inside_map;
    if system_base_info.sctpsysctl.sctp_logging_level & 0x100u32 != 0 {
        sctp_log_map(0u32, 5u32, (*asoc).highest_tsn_inside_map, 23i32);
    }
    /* This is the next one we expect */
    (*asoc).str_reset_seq_in = (*asoc).asconf_seq_in.wrapping_add(1u32);
    (*asoc).mapping_array_base_tsn = ntohl((*init).initial_tsn);
    (*asoc).cumulative_tsn = (*asoc).asconf_seq_in;
    (*asoc).tsn_last_delivered = (*asoc).cumulative_tsn;
    (*asoc).advanced_peer_ack_point = (*asoc).last_acked_seq;
    /* open the requested streams */
    if !(*asoc).strmin.is_null() {
        /* Free the old ones */
        i = 0u32;
        while i < (*asoc).streamincnt as libc::c_uint {
            sctp_clean_up_stream(stcb, &mut (*(*asoc).strmin.offset(i as isize)).inqueue);
            sctp_clean_up_stream(stcb, &mut (*(*asoc).strmin.offset(i as isize)).uno_inqueue);
            i = i.wrapping_add(1)
        }
        free((*asoc).strmin as *mut libc::c_void);
    }
    if (*asoc).max_inbound_streams > ntohs((*init).num_outbound_streams) as libc::c_uint {
        (*asoc).streamincnt = ntohs((*init).num_outbound_streams)
    } else {
        (*asoc).streamincnt = (*asoc).max_inbound_streams as uint16_t
    }
    (*asoc).strmin = malloc(
        ((*asoc).streamincnt as libc::c_ulong)
            .wrapping_mul(::std::mem::size_of::<sctp_stream_in>() as libc::c_ulong),
    ) as *mut sctp_stream_in;
    if 0x1i32 & 0x100i32 != 0 {
        memset(
            (*asoc).strmin as *mut libc::c_void,
            0i32,
            ((*asoc).streamincnt as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<sctp_stream_in>() as libc::c_ulong),
        );
    }
    if (*asoc).strmin.is_null() {
        /* we didn't get memory for the streams! */
        if system_base_info.sctpsysctl.sctp_debug_on & 0x2000u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"process_init: couldn\'t get memory for the streams!\n\x00" as *const u8
                        as *const libc::c_char,
                );
            }
        }
        return -(1i32);
    }
    i = 0u32;
    while i < (*asoc).streamincnt as libc::c_uint {
        (*(*asoc).strmin.offset(i as isize)).sid = i as uint16_t;
        (*(*asoc).strmin.offset(i as isize)).last_mid_delivered = 0xffffffffu32;
        let ref mut fresh2 = (*(*asoc).strmin.offset(i as isize)).inqueue.tqh_first;
        *fresh2 = 0 as *mut sctp_queued_to_read;
        let ref mut fresh3 = (*(*asoc).strmin.offset(i as isize)).inqueue.tqh_last;
        *fresh3 = &mut (*(*asoc).strmin.offset(i as isize)).inqueue.tqh_first;
        let ref mut fresh4 = (*(*asoc).strmin.offset(i as isize)).uno_inqueue.tqh_first;
        *fresh4 = 0 as *mut sctp_queued_to_read;
        let ref mut fresh5 = (*(*asoc).strmin.offset(i as isize)).uno_inqueue.tqh_last;
        *fresh5 = &mut (*(*asoc).strmin.offset(i as isize)).uno_inqueue.tqh_first;
        (*(*asoc).strmin.offset(i as isize)).pd_api_started = 0u8;
        (*(*asoc).strmin.offset(i as isize)).delivery_started = 0u8;
        i = i.wrapping_add(1)
    }
    /*
     * load_address_from_init will put the addresses into the
     * association when the COOKIE is processed or the INIT-ACK is
     * processed. Both types of COOKIE's existing and new call this
     * routine. It will remove addresses that are no longer in the
     * association (for the restarting case where addresses are
     * removed). Up front when the INIT arrives we will discard it if it
     * is a restart and new addresses have been added.
     */
    /* sa_ignore MEMLEAK */
    return 0i32;
}
/*
 * INIT-ACK message processing/consumption returns value < 0 on error
 */
unsafe extern "C" fn sctp_process_init_ack(
    mut m: *mut mbuf,
    mut iphlen: libc::c_int,
    mut offset: libc::c_int,
    mut src: *mut sockaddr,
    mut dst: *mut sockaddr,
    mut sh: *mut sctphdr,
    mut cp: *mut sctp_init_chunk,
    mut stcb: *mut sctp_tcb,
    mut net: *mut sctp_nets,
    mut abort_no_unlock: *mut libc::c_int,
    mut vrf_id: uint32_t,
) -> libc::c_int {
    let mut asoc = 0 as *mut sctp_association;
    let mut op_err = 0 as *mut mbuf;
    let mut retval = 0;
    let mut abort_flag = 0;
    let mut cookie_found = 0;
    let mut initack_limit = 0;
    let mut nat_friendly = 0i32;
    /* First verify that we have no illegal param's */
    abort_flag = 0i32;
    cookie_found = 0i32;
    op_err = sctp_arethere_unrecognized_parameters(
        m,
        (offset as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<sctp_init_chunk>() as libc::c_ulong)
            as libc::c_int,
        &mut abort_flag,
        cp as *mut sctp_chunkhdr,
        &mut nat_friendly,
        &mut cookie_found,
    );
    if abort_flag != 0 {
        /* Send an abort and notify peer */
        sctp_abort_an_association((*stcb).sctp_ep, stcb, op_err, 0i32);
        *abort_no_unlock = 1i32;
        return -(1i32);
    }
    if cookie_found == 0 {
        let mut len = 0;
        /* Only report the missing cookie parameter */
        if !op_err.is_null() {
            m_freem(op_err);
        }
        len = (::std::mem::size_of::<sctp_error_missing_param>() as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<uint16_t>() as libc::c_ulong)
            as uint16_t;
        /* We abort with an error of missing mandatory param */
        op_err = sctp_get_mbuf_for_msg(len as libc::c_uint, 0i32, 0x1i32, 1i32, 1i32);
        if !op_err.is_null() {
            let mut cause = 0 as *mut sctp_error_missing_param;
            (*op_err).m_hdr.mh_len = len as libc::c_int;
            cause = (*op_err).m_hdr.mh_data as *mut sctp_error_missing_param;
            /* Subtract the reserved param */
            (*cause).cause.code = htons(0x2u16);
            (*cause).cause.length = htons(len);
            (*cause).num_missing_params = htonl(1u32);
            *(*cause).type_0.as_mut_ptr().offset(0isize) = htons(0x7u16)
        }
        sctp_abort_association(
            (*stcb).sctp_ep,
            stcb,
            m,
            iphlen,
            src,
            dst,
            sh,
            op_err,
            vrf_id,
            (*net).port,
        );
        *abort_no_unlock = 1i32;
        return -(3i32);
    }
    asoc = &mut (*stcb).asoc;
    (*asoc).peer_supports_nat = nat_friendly as uint8_t;
    /* process the peer's parameters in the INIT-ACK */
    retval = sctp_process_init(cp, stcb);
    if retval < 0i32 {
        if !op_err.is_null() {
            m_freem(op_err);
        }
        return retval;
    }
    initack_limit = offset + ntohs((*cp).ch.chunk_length) as libc::c_int;
    /* load all addresses */
    retval = sctp_load_addresses_from_init(
        stcb,
        m,
        (offset as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<sctp_init_chunk>() as libc::c_ulong)
            as libc::c_int,
        initack_limit,
        src,
        dst,
        0 as *mut sockaddr,
        (*stcb).asoc.port,
    );
    if retval != 0 {
        if !op_err.is_null() {
            m_freem(op_err);
        }
        op_err = sctp_generate_cause(
            system_base_info.sctpsysctl.sctp_diag_info_code as uint16_t,
            b"Problem with address parameters\x00" as *const u8 as *mut libc::c_char,
        );
        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"Load addresses from INIT causes an abort %d\n\x00" as *const u8
                        as *const libc::c_char,
                    retval,
                );
            }
        }
        sctp_abort_association(
            (*stcb).sctp_ep,
            stcb,
            m,
            iphlen,
            src,
            dst,
            sh,
            op_err,
            vrf_id,
            (*net).port,
        );
        *abort_no_unlock = 1i32;
        return -(1i32);
    }
    /* if the peer doesn't support asconf, flush the asconf queue */
    if (*asoc).asconf_supported as libc::c_int == 0i32 {
        let mut param = 0 as *mut sctp_asconf_addr;
        let mut nparam = 0 as *mut sctp_asconf_addr;
        param = (*asoc).asconf_queue.tqh_first;
        while !param.is_null() && {
            nparam = (*param).next.tqe_next;
            (1i32) != 0
        } {
            if !(*param).next.tqe_next.is_null() {
                (*(*param).next.tqe_next).next.tqe_prev = (*param).next.tqe_prev
            } else {
                (*asoc).asconf_queue.tqh_last = (*param).next.tqe_prev
            }
            *(*param).next.tqe_prev = (*param).next.tqe_next;
            free(param as *mut libc::c_void);
            param = nparam
        }
    }
    (*stcb).asoc.peer_hmac_id =
        sctp_negotiate_hmacid((*stcb).asoc.peer_hmacs, (*stcb).asoc.local_hmacs);
    if !op_err.is_null() {
        sctp_queue_op_err(stcb, op_err);
        /* queuing will steal away the mbuf chain to the out queue */
        op_err = 0 as *mut mbuf
    }
    /* extract the cookie and queue it to "echo" it back... */
    if system_base_info.sctpsysctl.sctp_logging_level & 0x2000000u32 != 0 {
        sctp_misc_ints(
            120u8,
            (*stcb).asoc.overall_error_count,
            0u32,
            0x10000000u32,
            579u32,
        );
    }
    (*stcb).asoc.overall_error_count = 0u32;
    (*net).error_count = 0u16;
    /*
     * Cancel the INIT timer, We do this first before queueing the
     * cookie. We always cancel at the primary to assue that we are
     * canceling the timer started by the INIT which always goes to the
     * primary.
     */
    sctp_timer_stop(
        2i32,
        (*stcb).sctp_ep,
        stcb,
        (*asoc).primary_destination,
        (0x10000000i32 + 0x3i32) as uint32_t,
    );
    /* calculate the RTO */
    sctp_calculate_rto(stcb, asoc, net, &mut (*asoc).time_entered, 0i32);
    if (*(*stcb).sctp_ep).recv_callback.is_some() {
        if !(*stcb).sctp_socket.is_null() {
            let mut inqueue_bytes = 0;
            let mut sb_free_now = 0;
            let mut inp = 0 as *mut sctp_inpcb;
            inp = (*stcb).sctp_ep;
            inqueue_bytes = ((*stcb).asoc.total_output_queue_size as libc::c_ulong).wrapping_sub(
                ((*stcb).asoc.chunks_on_out_queue as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<sctp_data_chunk>() as libc::c_ulong),
            ) as uint32_t;
            sb_free_now = (*(*stcb).sctp_socket)
                .so_snd
                .sb_hiwat
                .wrapping_sub(inqueue_bytes.wrapping_add((*stcb).asoc.sb_send_resv));
            /* check if the amount free in the send socket buffer crossed the threshold */
            if (*inp).send_callback.is_some()
                && ((*inp).send_sb_threshold > 0u32
                    && sb_free_now >= (*inp).send_sb_threshold
                    && (*stcb).asoc.chunks_on_out_queue
                        <= system_base_info.sctpsysctl.sctp_max_chunks_on_queue
                    || (*inp).send_sb_threshold == 0u32)
            {
                ::std::intrinsics::atomic_xadd(&mut (*stcb).asoc.refcnt, 1u32);
                pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                (*inp).send_callback.expect("non-null function pointer")(
                    (*stcb).sctp_socket,
                    sb_free_now,
                );
                pthread_mutex_lock(&mut (*stcb).tcb_mtx);
                ::std::intrinsics::atomic_xsub(&mut (*stcb).asoc.refcnt, 1u32);
            }
        }
    }
    retval = sctp_send_cookie_echo(m, offset, initack_limit, stcb, net);
    return retval;
}
unsafe extern "C" fn sctp_handle_heartbeat_ack(
    mut cp: *mut sctp_heartbeat_chunk,
    mut stcb: *mut sctp_tcb,
    mut net: *mut sctp_nets,
) {
    let mut store = sctp_sockstore {
        sin: sockaddr_in {
            sin_family: 0,
            sin_port: 0,
            sin_addr: in_addr { s_addr: 0 },
            sin_zero: [0; 8],
        },
    };
    let mut r_net = 0 as *mut sctp_nets;
    let mut tv = timeval {
        tv_sec: 0,
        tv_usec: 0,
    };
    let mut req_prim = 0i32;
    let mut old_error_counter = 0;
    if ntohs((*cp).ch.chunk_length) as libc::c_ulong
        != ::std::mem::size_of::<sctp_heartbeat_chunk>() as libc::c_ulong
    {
        /* Invalid length */
        return;
    }
    memset(
        &mut store as *mut sctp_sockstore as *mut libc::c_void,
        0i32,
        ::std::mem::size_of::<sctp_sockstore>() as libc::c_ulong,
    );
    match (*cp).heartbeat.hb_info.addr_family as libc::c_int {
        2 => {
            if (*cp).heartbeat.hb_info.addr_len as libc::c_ulong
                == ::std::mem::size_of::<sockaddr_in>() as libc::c_ulong
            {
                store.sin.sin_family = (*cp).heartbeat.hb_info.addr_family as sa_family_t;
                store.sin.sin_port = (*stcb).rport;
                memcpy(
                    &mut store.sin.sin_addr as *mut in_addr as *mut libc::c_void,
                    (*cp).heartbeat.hb_info.address.as_mut_ptr() as *const libc::c_void,
                    ::std::mem::size_of::<in_addr>() as libc::c_ulong,
                );
            } else {
                return;
            }
        }
        10 => {
            if (*cp).heartbeat.hb_info.addr_len as libc::c_ulong
                == ::std::mem::size_of::<sockaddr_in6>() as libc::c_ulong
            {
                store.sin6.sin6_family = (*cp).heartbeat.hb_info.addr_family as sa_family_t;
                store.sin6.sin6_port = (*stcb).rport;
                memcpy(
                    &mut store.sin6.sin6_addr as *mut in6_addr as *mut libc::c_void,
                    (*cp).heartbeat.hb_info.address.as_mut_ptr() as *const libc::c_void,
                    ::std::mem::size_of::<in6_addr>() as libc::c_ulong,
                );
            } else {
                return;
            }
        }
        123 => {
            if (*cp).heartbeat.hb_info.addr_len as libc::c_ulong
                == ::std::mem::size_of::<sockaddr_conn>() as libc::c_ulong
            {
                store.sconn.sconn_family = (*cp).heartbeat.hb_info.addr_family as uint16_t;
                store.sconn.sconn_port = (*stcb).rport;
                memcpy(
                    &mut store.sconn.sconn_addr as *mut *mut libc::c_void as *mut libc::c_void,
                    (*cp).heartbeat.hb_info.address.as_mut_ptr() as *const libc::c_void,
                    ::std::mem::size_of::<*mut libc::c_void>() as libc::c_ulong,
                );
            } else {
                return;
            }
        }
        _ => return,
    }
    r_net = sctp_findnet(stcb, &mut store.sa);
    if r_net.is_null() {
        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"Huh? I can\'t find the address I sent it to, discard\n\x00" as *const u8
                        as *const libc::c_char,
                );
            }
        }
        return;
    }
    if !r_net.is_null()
        && (*r_net).dest_state as libc::c_int & 0x200i32 != 0
        && (*r_net).heartbeat_random1 == (*cp).heartbeat.hb_info.random_value1
        && (*r_net).heartbeat_random2 == (*cp).heartbeat.hb_info.random_value2
    {
        /*
         * If the its a HB and it's random value is correct when can
         * confirm the destination.
         */
        (*r_net).dest_state = ((*r_net).dest_state as libc::c_int & !(0x200i32)) as uint16_t;
        if (*r_net).dest_state as libc::c_int & 0x400i32 != 0 {
            let mut f_net = 0 as *mut sctp_nets;
            (*stcb).asoc.primary_destination = r_net;
            (*r_net).dest_state = ((*r_net).dest_state as libc::c_int & !(0x400i32)) as uint16_t;
            f_net = (*stcb).asoc.nets.tqh_first;
            if f_net != r_net {
                /* first one on the list is NOT the primary
                 * sctp_cmpaddr() is much more efficient if
                 * the primary is the first on the list, make it
                 * so.
                 */
                if !(*r_net).sctp_next.tqe_next.is_null() {
                    (*(*r_net).sctp_next.tqe_next).sctp_next.tqe_prev = (*r_net).sctp_next.tqe_prev
                } else {
                    (*stcb).asoc.nets.tqh_last = (*r_net).sctp_next.tqe_prev
                }
                *(*r_net).sctp_next.tqe_prev = (*r_net).sctp_next.tqe_next;
                (*r_net).sctp_next.tqe_next = (*stcb).asoc.nets.tqh_first;
                if !(*r_net).sctp_next.tqe_next.is_null() {
                    (*(*stcb).asoc.nets.tqh_first).sctp_next.tqe_prev =
                        &mut (*r_net).sctp_next.tqe_next
                } else {
                    (*stcb).asoc.nets.tqh_last = &mut (*r_net).sctp_next.tqe_next
                }
                (*stcb).asoc.nets.tqh_first = r_net;
                (*r_net).sctp_next.tqe_prev = &mut (*stcb).asoc.nets.tqh_first
            }
            req_prim = 1i32
        }
        sctp_ulp_notify(16u32, stcb, 0u32, r_net as *mut libc::c_void, 0i32);
        sctp_timer_stop(
            5i32,
            (*stcb).sctp_ep,
            stcb,
            r_net,
            (0x10000000i32 + 0x4i32) as uint32_t,
        );
        sctp_timer_start(5i32, (*stcb).sctp_ep, stcb, r_net);
    }
    if system_base_info.sctpsysctl.sctp_logging_level & 0x2000000u32 != 0 {
        sctp_misc_ints(
            120u8,
            (*stcb).asoc.overall_error_count,
            0u32,
            0x10000000u32,
            727u32,
        );
    }
    (*stcb).asoc.overall_error_count = 0u32;
    old_error_counter = (*r_net).error_count;
    (*r_net).error_count = 0u16;
    (*r_net).hb_responded = 1u8;
    tv.tv_sec = (*cp).heartbeat.hb_info.time_value_1 as __time_t;
    tv.tv_usec = (*cp).heartbeat.hb_info.time_value_2 as __suseconds_t;
    /* Now lets do a RTO with this */
    sctp_calculate_rto(stcb, &mut (*stcb).asoc, r_net, &mut tv, 0i32);
    if (*r_net).dest_state as libc::c_int & 0x1i32 == 0 {
        (*r_net).dest_state = ((*r_net).dest_state as libc::c_int | 0x1i32) as uint16_t;
        sctp_ulp_notify(4u32, stcb, 0u32, r_net as *mut libc::c_void, 0i32);
    }
    if (*r_net).dest_state as libc::c_int & 0x800i32 != 0 {
        (*r_net).dest_state = ((*r_net).dest_state as libc::c_int & !(0x800i32)) as uint16_t;
        (*stcb)
            .asoc
            .cc_functions
            .sctp_cwnd_update_exit_pf
            .expect("non-null function pointer")(stcb, net);
    }
    if old_error_counter as libc::c_int > 0i32 {
        sctp_timer_stop(
            5i32,
            (*stcb).sctp_ep,
            stcb,
            r_net,
            (0x10000000i32 + 0x5i32) as uint32_t,
        );
        sctp_timer_start(5i32, (*stcb).sctp_ep, stcb, r_net);
    }
    if r_net == (*stcb).asoc.primary_destination {
        if !(*stcb).asoc.alternate.is_null() {
            /* release the alternate, primary is good */
            if !(*stcb).asoc.alternate.is_null() {
                if ::std::intrinsics::atomic_xadd(
                    &mut (*(*stcb).asoc.alternate).ref_count as *mut libc::c_int,
                    -(1i32),
                ) == 1i32
                {
                    sctp_os_timer_stop(&mut (*(*stcb).asoc.alternate).rxt_timer.timer);
                    sctp_os_timer_stop(&mut (*(*stcb).asoc.alternate).pmtu_timer.timer);
                    sctp_os_timer_stop(&mut (*(*stcb).asoc.alternate).hb_timer.timer);
                    if !(*(*stcb).asoc.alternate).ro.ro_rt.is_null() {
                        if (*(*(*stcb).asoc.alternate).ro.ro_rt).rt_refcnt <= 1i64 {
                            sctp_userspace_rtfree((*(*stcb).asoc.alternate).ro.ro_rt);
                        } else {
                            (*(*(*stcb).asoc.alternate).ro.ro_rt).rt_refcnt -= 1
                        }
                        (*(*stcb).asoc.alternate).ro.ro_rt = 0 as *mut sctp_rtentry_t;
                        (*(*stcb).asoc.alternate).ro.ro_rt = 0 as *mut sctp_rtentry_t
                    }
                    if (*(*stcb).asoc.alternate).src_addr_selected != 0 {
                        sctp_free_ifa((*(*stcb).asoc.alternate).ro._s_addr);
                        (*(*stcb).asoc.alternate).ro._s_addr = 0 as *mut sctp_ifa
                    }
                    (*(*stcb).asoc.alternate).src_addr_selected = 0u8;
                    (*(*stcb).asoc.alternate).dest_state =
                        ((*(*stcb).asoc.alternate).dest_state as libc::c_int & !(0x1i32))
                            as uint16_t;
                    free((*stcb).asoc.alternate as *mut libc::c_void);
                    ::std::intrinsics::atomic_xsub(
                        &mut system_base_info.sctppcbinfo.ipi_count_raddr,
                        1u32,
                    );
                }
            }
            (*stcb).asoc.alternate = 0 as *mut sctp_nets
        }
    }
    /* Mobility adaptation */
    if req_prim != 0 {
        if ((*(*stcb).sctp_ep).sctp_mobility_features & 0x1u32 != 0
            || (*(*stcb).sctp_ep).sctp_mobility_features & 0x2u32 != 0)
            && (*(*stcb).sctp_ep).sctp_mobility_features & 0x4u32 != 0
        {
            sctp_timer_stop(
                18i32,
                (*stcb).sctp_ep,
                stcb,
                0 as *mut sctp_nets,
                (0x10000000i32 + 0x6i32) as uint32_t,
            );
            if (*(*stcb).sctp_ep).sctp_mobility_features & 0x2u32 != 0 {
                sctp_assoc_immediate_retrans(stcb, (*stcb).asoc.primary_destination);
            }
            if (*(*stcb).sctp_ep).sctp_mobility_features & 0x1u32 != 0 {
                sctp_move_chunks_from_net(stcb, (*stcb).asoc.deleted_primary);
            }
            sctp_delete_prim_timer((*stcb).sctp_ep, stcb, (*stcb).asoc.deleted_primary);
        }
    };
}
unsafe extern "C" fn sctp_handle_nat_colliding_state(mut stcb: *mut sctp_tcb) -> libc::c_int {
    let mut new_vtag = 0;
    let mut head = 0 as *mut sctpasochead;
    if (*stcb).asoc.state & 0x7fi32 == 0x2i32 || (*stcb).asoc.state & 0x7fi32 == 0x4i32 {
        new_vtag = sctp_select_a_tag(
            (*stcb).sctp_ep,
            (*(*stcb).sctp_ep).ip_inp.inp.inp_inc.inc_ie.ie_lport,
            (*stcb).rport,
            1i32,
        );
        ::std::intrinsics::atomic_xadd(&mut (*stcb).asoc.refcnt, 1u32);
        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
        pthread_mutex_lock(&mut system_base_info.sctppcbinfo.ipi_ep_mtx);
        pthread_mutex_lock(&mut (*stcb).tcb_mtx);
        ::std::intrinsics::atomic_xsub(&mut (*stcb).asoc.refcnt, 1u32);
    } else {
        return 0i32;
    }
    if (*stcb).asoc.state & 0x7fi32 == 0x2i32 {
        /* generate a new vtag and send init */
        if !(*stcb).sctp_asocs.le_next.is_null() {
            (*(*stcb).sctp_asocs.le_next).sctp_asocs.le_prev = (*stcb).sctp_asocs.le_prev
        }
        *(*stcb).sctp_asocs.le_prev = (*stcb).sctp_asocs.le_next;
        (*stcb).asoc.my_vtag = new_vtag;
        head = &mut *system_base_info.sctppcbinfo.sctp_asochash.offset(
            ((*stcb).asoc.my_vtag as libc::c_ulong & system_base_info.sctppcbinfo.hashasocmark)
                as isize,
        ) as *mut sctpasochead;
        /* put it in the bucket in the vtag hash of assoc's for the system */
        (*stcb).sctp_asocs.le_next = (*head).lh_first;
        if !(*stcb).sctp_asocs.le_next.is_null() {
            (*(*head).lh_first).sctp_asocs.le_prev = &mut (*stcb).sctp_asocs.le_next
        }
        (*head).lh_first = stcb;
        (*stcb).sctp_asocs.le_prev = &mut (*head).lh_first;
        pthread_mutex_unlock(&mut system_base_info.sctppcbinfo.ipi_ep_mtx);
        sctp_send_initiate((*stcb).sctp_ep, stcb, 0i32);
        return 1i32;
    } else {
        /* treat like a case where the cookie expired i.e.:
        	* - dump current cookie.
        	* - generate a new vtag.
        	* - resend init.
        	*/
        /* generate a new vtag and send init */
        if !(*stcb).sctp_asocs.le_next.is_null() {
            (*(*stcb).sctp_asocs.le_next).sctp_asocs.le_prev = (*stcb).sctp_asocs.le_prev
        }
        *(*stcb).sctp_asocs.le_prev = (*stcb).sctp_asocs.le_next;
        sctp_set_state(stcb, 0x2i32);
        sctp_stop_all_cookie_timers(stcb);
        sctp_toss_old_cookies(stcb, &mut (*stcb).asoc);
        (*stcb).asoc.my_vtag = new_vtag;
        head = &mut *system_base_info.sctppcbinfo.sctp_asochash.offset(
            ((*stcb).asoc.my_vtag as libc::c_ulong & system_base_info.sctppcbinfo.hashasocmark)
                as isize,
        ) as *mut sctpasochead;
        /* put it in the bucket in the vtag hash of assoc's for the system */
        (*stcb).sctp_asocs.le_next = (*head).lh_first;
        if !(*stcb).sctp_asocs.le_next.is_null() {
            (*(*head).lh_first).sctp_asocs.le_prev = &mut (*stcb).sctp_asocs.le_next
        }
        (*head).lh_first = stcb;
        (*stcb).sctp_asocs.le_prev = &mut (*head).lh_first;
        pthread_mutex_unlock(&mut system_base_info.sctppcbinfo.ipi_ep_mtx);
        sctp_send_initiate((*stcb).sctp_ep, stcb, 0i32);
        return 1i32;
    };
}
unsafe extern "C" fn sctp_handle_nat_missing_state(
    mut stcb: *mut sctp_tcb,
    mut net: *mut sctp_nets,
) -> libc::c_int {
    /* return 0 means we want you to proceed with the abort
     * non-zero means no abort processing
     */
    if (*stcb).asoc.auth_supported as libc::c_int == 0i32 {
        if system_base_info.sctpsysctl.sctp_debug_on & 0x2000u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info.debug_printf.expect("non-null function pointer")(b"sctp_handle_nat_missing_state: Peer does not support AUTH, cannot send an asconf\n\x00"
                                                                                      as
                                                                                      *const u8
                                                                                      as
                                                                                      *const libc::c_char);
            }
        }
        return 0i32;
    }
    sctp_asconf_send_nat_state_update(stcb, net);
    return 1i32;
}
/* Returns 1 if the stcb was aborted, 0 otherwise */
unsafe extern "C" fn sctp_handle_abort(
    mut abort: *mut sctp_abort_chunk,
    mut stcb: *mut sctp_tcb,
    mut net: *mut sctp_nets,
) -> libc::c_int {
    let mut len = 0;
    let mut error = 0;
    if system_base_info.sctpsysctl.sctp_debug_on & 0x2000u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"sctp_handle_abort: handling ABORT\n\x00" as *const u8 as *const libc::c_char,
            );
        }
    }
    if stcb.is_null() {
        return 0i32;
    }
    len = ntohs((*abort).ch.chunk_length);
    if len as libc::c_ulong
        >= (::std::mem::size_of::<sctp_chunkhdr>() as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<sctp_error_cause>() as libc::c_ulong)
    {
        let mut cause = 0 as *mut sctp_error_cause;
        cause = abort.offset(1isize) as *mut sctp_error_cause;
        error = ntohs((*cause).code);
        if error as libc::c_int == 0xb0i32 {
            if system_base_info.sctpsysctl.sctp_debug_on & 0x2000u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"Received Colliding state abort flags:%x\n\x00" as *const u8
                            as *const libc::c_char,
                        (*abort).ch.chunk_flags as libc::c_int,
                    );
                }
            }
            if sctp_handle_nat_colliding_state(stcb) != 0 {
                return 0i32;
            }
        } else if error as libc::c_int == 0xb1i32 {
            if system_base_info.sctpsysctl.sctp_debug_on & 0x2000u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"Received missing state abort flags:%x\n\x00" as *const u8
                            as *const libc::c_char,
                        (*abort).ch.chunk_flags as libc::c_int,
                    );
                }
            }
            if sctp_handle_nat_missing_state(stcb, net) != 0 {
                return 0i32;
            }
        }
    } else {
        error = 0u16
    }
    /* stop any receive timers */
    sctp_timer_stop(
        3i32,
        (*stcb).sctp_ep,
        stcb,
        net,
        (0x10000000i32 + 0x7i32) as uint32_t,
    );
    /* notify user of the abort and clean up... */
    sctp_abort_notification(stcb, 1u8, error, abort, 0i32);
    /* free the tcb */
    ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_aborted, 1u32);
    if (*stcb).asoc.state & 0x7fi32 == 0x8i32 || (*stcb).asoc.state & 0x7fi32 == 0x20i32 {
        ::std::intrinsics::atomic_xsub(&mut system_base_info.sctpstat.sctps_currestab, 1u32);
    }
    sctp_add_substate(stcb, 0x800i32);
    sctp_free_assoc((*stcb).sctp_ep, stcb, 0i32, 0x10000000i32 + 0x8i32);
    if system_base_info.sctpsysctl.sctp_debug_on & 0x2000u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"sctp_handle_abort: finished\n\x00" as *const u8 as *const libc::c_char,
            );
        }
    }
    return 1i32;
}
unsafe extern "C" fn sctp_start_net_timers(mut stcb: *mut sctp_tcb) {
    let mut cnt_hb_sent = 0;
    let mut net = 0 as *mut sctp_nets;
    cnt_hb_sent = 0u32;
    net = (*stcb).asoc.nets.tqh_first;
    while !net.is_null() {
        /* For each network start:
         * 1) A pmtu timer.
         * 2) A HB timer
         * 3) If the dest in unconfirmed send
         *    a hb as well if under max_hb_burst have
         *    been sent.
         */
        sctp_timer_start(8i32, (*stcb).sctp_ep, stcb, net);
        sctp_timer_start(5i32, (*stcb).sctp_ep, stcb, net);
        if (*net).dest_state as libc::c_int & 0x200i32 != 0
            && cnt_hb_sent < system_base_info.sctpsysctl.sctp_hb_maxburst
        {
            sctp_send_hb(stcb, net, 0i32);
            cnt_hb_sent = cnt_hb_sent.wrapping_add(1)
        }
        net = (*net).sctp_next.tqe_next
    }
    if cnt_hb_sent != 0 {
        sctp_chunk_output((*stcb).sctp_ep, stcb, 14i32, 0i32);
    };
}
unsafe extern "C" fn sctp_handle_shutdown(
    mut cp: *mut sctp_shutdown_chunk,
    mut stcb: *mut sctp_tcb,
    mut net: *mut sctp_nets,
    mut abort_flag: *mut libc::c_int,
) {
    let mut asoc = 0 as *mut sctp_association;
    let mut some_on_streamwheel = 0;
    let mut old_state = 0;
    if system_base_info.sctpsysctl.sctp_debug_on & 0x2000u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"sctp_handle_shutdown: handling SHUTDOWN\n\x00" as *const u8
                    as *const libc::c_char,
            );
        }
    }
    if stcb.is_null() {
        return;
    }
    asoc = &mut (*stcb).asoc;
    if (*stcb).asoc.state & 0x7fi32 == 0x2i32 || (*stcb).asoc.state & 0x7fi32 == 0x4i32 {
        return;
    }
    if ntohs((*cp).ch.chunk_length) as libc::c_ulong
        != ::std::mem::size_of::<sctp_shutdown_chunk>() as libc::c_ulong
    {
        /* Shutdown NOT the expected size */
        return;
    }
    old_state = (*stcb).asoc.state & 0x7fi32;
    sctp_update_acked(stcb, cp, abort_flag);
    if *abort_flag != 0 {
        return;
    }
    if !(*asoc).control_pdapi.is_null() {
        /* With a normal shutdown
         * we assume the end of last record.
         */
        pthread_mutex_lock(&mut (*(*stcb).sctp_ep).inp_rdata_mtx);
        if (*(*asoc).control_pdapi).on_strm_q != 0 {
            let mut strm = 0 as *mut sctp_stream_in;
            strm = &mut *(*asoc)
                .strmin
                .offset((*(*asoc).control_pdapi).sinfo_stream as isize)
                as *mut sctp_stream_in;
            if (*(*asoc).control_pdapi).on_strm_q as libc::c_int == 2i32 {
                /* Unordered */
                if !(*(*asoc).control_pdapi).next_instrm.tqe_next.is_null() {
                    (*(*(*asoc).control_pdapi).next_instrm.tqe_next)
                        .next_instrm
                        .tqe_prev = (*(*asoc).control_pdapi).next_instrm.tqe_prev
                } else {
                    (*strm).uno_inqueue.tqh_last = (*(*asoc).control_pdapi).next_instrm.tqe_prev
                }
                *(*(*asoc).control_pdapi).next_instrm.tqe_prev =
                    (*(*asoc).control_pdapi).next_instrm.tqe_next;
                (*(*asoc).control_pdapi).on_strm_q = 0u8
            } else if (*(*asoc).control_pdapi).on_strm_q as libc::c_int == 1i32 {
                /* Ordered */
                if !(*(*asoc).control_pdapi).next_instrm.tqe_next.is_null() {
                    (*(*(*asoc).control_pdapi).next_instrm.tqe_next)
                        .next_instrm
                        .tqe_prev = (*(*asoc).control_pdapi).next_instrm.tqe_prev
                } else {
                    (*strm).inqueue.tqh_last = (*(*asoc).control_pdapi).next_instrm.tqe_prev
                }
                *(*(*asoc).control_pdapi).next_instrm.tqe_prev =
                    (*(*asoc).control_pdapi).next_instrm.tqe_next;
                (*(*asoc).control_pdapi).on_strm_q = 0u8
            }
        }
        (*(*asoc).control_pdapi).end_added = 1u8;
        (*(*asoc).control_pdapi).pdapi_aborted = 1u8;
        (*asoc).control_pdapi = 0 as *mut sctp_queued_to_read;
        pthread_mutex_unlock(&mut (*(*stcb).sctp_ep).inp_rdata_mtx);
        if !(*stcb).sctp_socket.is_null() {
            if (*(*stcb).sctp_ep).sctp_flags & 0x800000u32 != 0 {
                (*(*stcb).sctp_ep).sctp_flags |= 0x2000000u32
            } else {
                pthread_mutex_lock(&mut (*(*stcb).sctp_socket).so_rcv.sb_mtx);
                if (*(*stcb).sctp_socket).so_rcv.sb_flags as libc::c_int
                    & (0x4i32 | 0x8i32 | 0x10i32 | 0x20i32 | 0x80i32 | 0x100i32)
                    != 0i32
                {
                    sowakeup((*stcb).sctp_socket, &mut (*(*stcb).sctp_socket).so_rcv);
                } else {
                    pthread_mutex_unlock(&mut (*(*stcb).sctp_socket).so_rcv.sb_mtx);
                }
            }
        }
    }
    /* goto SHUTDOWN_RECEIVED state to block new requests */
    if !(*stcb).sctp_socket.is_null() {
        if (*stcb).asoc.state & 0x7fi32 != 0x20i32
            && (*stcb).asoc.state & 0x7fi32 != 0x40i32
            && (*stcb).asoc.state & 0x7fi32 != 0x10i32
        {
            sctp_set_state(stcb, 0x20i32);
            /* notify upper layer that peer has initiated a shutdown */
            sctp_ulp_notify(11u32, stcb, 0u32, 0 as *mut libc::c_void, 0i32);
            /* reset time */
            gettimeofday(&mut (*asoc).time_entered, 0 as *mut timezone);
        }
    }
    if (*stcb).asoc.state & 0x7fi32 == 0x10i32 {
        /*
         * stop the shutdown timer, since we WILL move to
         * SHUTDOWN-ACK-SENT.
         */
        sctp_timer_stop(
            4i32,
            (*stcb).sctp_ep,
            stcb,
            net,
            (0x10000000i32 + 0x9i32) as uint32_t,
        );
    }
    /* Now is there unsent data on a stream somewhere? */
    some_on_streamwheel = sctp_is_there_unsent_data(stcb, 0i32);
    if !(*asoc).send_queue.tqh_first.is_null()
        || !(*asoc).sent_queue.tqh_first.is_null()
        || some_on_streamwheel != 0
    {
        /* By returning we will push more data out */
        return;
    } else {
        /* no outstanding data to send, so move on... */
        /* send SHUTDOWN-ACK */
        /* move to SHUTDOWN-ACK-SENT state */
        if (*stcb).asoc.state & 0x7fi32 == 0x8i32 || (*stcb).asoc.state & 0x7fi32 == 0x20i32 {
            ::std::intrinsics::atomic_xsub(&mut system_base_info.sctpstat.sctps_currestab, 1u32);
        }
        if (*stcb).asoc.state & 0x7fi32 != 0x40i32 {
            sctp_set_state(stcb, 0x40i32);
            sctp_stop_timers_for_shutdown(stcb);
            sctp_send_shutdown_ack(stcb, net);
            sctp_timer_start(9i32, (*stcb).sctp_ep, stcb, net);
        } else if old_state == 0x40i32 {
            sctp_send_shutdown_ack(stcb, net);
        }
    };
}
unsafe extern "C" fn sctp_handle_shutdown_ack(
    mut cp: *mut sctp_shutdown_ack_chunk,
    mut stcb: *mut sctp_tcb,
    mut net: *mut sctp_nets,
) {
    let mut asoc = 0 as *mut sctp_association;
    if system_base_info.sctpsysctl.sctp_debug_on & 0x2000u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"sctp_handle_shutdown_ack: handling SHUTDOWN ACK\n\x00" as *const u8
                    as *const libc::c_char,
            );
        }
    }
    if stcb.is_null() {
        return;
    }
    asoc = &mut (*stcb).asoc;
    /* process according to association state */
    if (*stcb).asoc.state & 0x7fi32 == 0x2i32 || (*stcb).asoc.state & 0x7fi32 == 0x4i32 {
        /* unexpected SHUTDOWN-ACK... do OOTB handling... */
        sctp_send_shutdown_complete(stcb, net, 1i32);
        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
        return;
    }
    if (*stcb).asoc.state & 0x7fi32 != 0x10i32 && (*stcb).asoc.state & 0x7fi32 != 0x40i32 {
        /* unexpected SHUTDOWN-ACK... so ignore... */
        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
        return;
    }
    if !(*asoc).control_pdapi.is_null() {
        /* With a normal shutdown
         * we assume the end of last record.
         */
        pthread_mutex_lock(&mut (*(*stcb).sctp_ep).inp_rdata_mtx);
        (*(*asoc).control_pdapi).end_added = 1u8;
        (*(*asoc).control_pdapi).pdapi_aborted = 1u8;
        (*asoc).control_pdapi = 0 as *mut sctp_queued_to_read;
        pthread_mutex_unlock(&mut (*(*stcb).sctp_ep).inp_rdata_mtx);
        if (*(*stcb).sctp_ep).sctp_flags & 0x800000u32 != 0 {
            (*(*stcb).sctp_ep).sctp_flags |= 0x2000000u32
        } else {
            pthread_mutex_lock(&mut (*(*stcb).sctp_socket).so_rcv.sb_mtx);
            if (*(*stcb).sctp_socket).so_rcv.sb_flags as libc::c_int
                & (0x4i32 | 0x8i32 | 0x10i32 | 0x20i32 | 0x80i32 | 0x100i32)
                != 0i32
            {
                sowakeup((*stcb).sctp_socket, &mut (*(*stcb).sctp_socket).so_rcv);
            } else {
                pthread_mutex_unlock(&mut (*(*stcb).sctp_socket).so_rcv.sb_mtx);
            }
        }
    }
    /* stop the timer */
    sctp_timer_stop(
        4i32,
        (*stcb).sctp_ep,
        stcb,
        net,
        (0x10000000i32 + 0xai32) as uint32_t,
    );
    /* send SHUTDOWN-COMPLETE */
    sctp_send_shutdown_complete(stcb, net, 0i32);
    /* notify upper layer protocol */
    if !(*stcb).sctp_socket.is_null() {
        if (*(*stcb).sctp_ep).sctp_flags & 0x2u32 != 0
            || (*(*stcb).sctp_ep).sctp_flags & 0x400000u32 != 0
        {
            (*(*stcb).sctp_socket).so_snd.sb_cc = 0u32
        }
        sctp_ulp_notify(2u32, stcb, 0u32, 0 as *mut libc::c_void, 0i32);
    }
    ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_shutdown, 1u32);
    /* free the TCB but first save off the ep */
    sctp_free_assoc((*stcb).sctp_ep, stcb, 0i32, 0x10000000i32 + 0xbi32);
}
unsafe extern "C" fn sctp_process_unrecog_chunk(
    mut stcb: *mut sctp_tcb,
    mut chunk_type: uint8_t,
    mut net: *mut sctp_nets,
) {
    match chunk_type as libc::c_int {
        128 | 193 => {
            sctp_asconf_cleanup(stcb, net);
        }
        194 | 192 => (*stcb).asoc.prsctp_supported = 0u8,
        _ => {
            if system_base_info.sctpsysctl.sctp_debug_on & 0x2000u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"Peer does not support chunk type %d (0x%x).\n\x00" as *const u8
                            as *const libc::c_char,
                        chunk_type as libc::c_int,
                        chunk_type as libc::c_int,
                    );
                }
            }
        }
    };
}
/*
 * Skip past the param header and then we will find the param that caused the
 * problem.  There are a number of param's in a ASCONF OR the prsctp param
 * these will turn of specific features.
 * XXX: Is this the right thing to do?
 */
unsafe extern "C" fn sctp_process_unrecog_param(
    mut stcb: *mut sctp_tcb,
    mut parameter_type: uint16_t,
) {
    match parameter_type as libc::c_int {
        49152 => {
            /* pr-sctp draft */
            (*stcb).asoc.prsctp_supported = 0u8
        }
        32776 => {}
        49159 => {
            /* draft-ietf-tsvwg-addip-sctp */
            (*stcb).asoc.peer_supports_nat = 0u8
        }
        49153 | 49154 | 49156 => (*stcb).asoc.asconf_supported = 0u8,
        49157 | 49155 => {
            if system_base_info.sctpsysctl.sctp_debug_on & 0x2000u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"Huh, the peer does not support success? or error cause?\n\x00"
                            as *const u8 as *const libc::c_char,
                    );
                }
            }
            if system_base_info.sctpsysctl.sctp_debug_on & 0x2000u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"Turning off ASCONF to this strange peer\n\x00" as *const u8
                            as *const libc::c_char,
                    );
                }
            }
            (*stcb).asoc.asconf_supported = 0u8
        }
        _ => {
            if system_base_info.sctpsysctl.sctp_debug_on & 0x2000u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"Peer does not support param type %d (0x%x)??\n\x00" as *const u8
                            as *const libc::c_char,
                        parameter_type as libc::c_int,
                        parameter_type as libc::c_int,
                    );
                }
            }
        }
    };
}
unsafe extern "C" fn sctp_handle_error(
    mut ch: *mut sctp_chunkhdr,
    mut stcb: *mut sctp_tcb,
    mut net: *mut sctp_nets,
    mut limit: uint32_t,
) -> libc::c_int {
    let mut cause = 0 as *mut sctp_error_cause;
    let mut asoc = 0 as *mut sctp_association;
    let mut remaining_length = 0;
    let mut code = 0;
    /* parse through all of the errors and process */
    asoc = &mut (*stcb).asoc;
    cause = (ch as caddr_t).offset(::std::mem::size_of::<sctp_chunkhdr>() as isize)
        as *mut sctp_error_cause;
    remaining_length = ntohs((*ch).chunk_length) as uint32_t;
    if remaining_length > limit {
        remaining_length = limit
    }
    if remaining_length as libc::c_ulong >= ::std::mem::size_of::<sctp_chunkhdr>() as libc::c_ulong
    {
        remaining_length = (remaining_length as libc::c_ulong)
            .wrapping_sub(::std::mem::size_of::<sctp_chunkhdr>() as libc::c_ulong)
            as uint32_t
    } else {
        remaining_length = 0u32
    }
    code = 0u16;
    while remaining_length as libc::c_ulong
        >= ::std::mem::size_of::<sctp_error_cause>() as libc::c_ulong
    {
        let mut adjust = 0;
        let mut cause_code = 0;
        let mut cause_length = 0;
        cause_code = ntohs((*cause).code);
        cause_length = ntohs((*cause).length);
        if cause_length as libc::c_uint > remaining_length || cause_length as libc::c_int == 0i32 {
            /* Invalid cause length, possibly due to truncation. */
            if system_base_info.sctpsysctl.sctp_debug_on & 0x1000u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"Bogus length in cause - bytes left: %u cause length: %u\n\x00"
                            as *const u8 as *const libc::c_char,
                        remaining_length,
                        cause_length as libc::c_int,
                    );
                }
            }
            return 0i32;
        }
        if code as libc::c_int == 0i32 {
            /* report the first error cause */
            code = cause_code
        }
        match cause_code as libc::c_int {
            1 | 2 | 7 | 9 => {
                if system_base_info.sctpsysctl.sctp_debug_on & 0x1000u32 != 0 {
                    if system_base_info.debug_printf.is_some() {
                        system_base_info
                            .debug_printf
                            .expect("non-null function pointer")(
                            b"Software error we got a %u back? We have a bug :/ (or do they?)\n\x00"
                                as *const u8 as *const libc::c_char,
                            cause_code as libc::c_int,
                        );
                    }
                }
            }
            176 => {
                if system_base_info.sctpsysctl.sctp_debug_on & 0x2000u32 != 0 {
                    if system_base_info.debug_printf.is_some() {
                        system_base_info
                            .debug_printf
                            .expect("non-null function pointer")(
                            b"Received Colliding state abort flags: %x\n\x00" as *const u8
                                as *const libc::c_char,
                            (*ch).chunk_flags as libc::c_int,
                        );
                    }
                }
                if sctp_handle_nat_colliding_state(stcb) != 0 {
                    return 0i32;
                }
            }
            177 => {
                if system_base_info.sctpsysctl.sctp_debug_on & 0x2000u32 != 0 {
                    if system_base_info.debug_printf.is_some() {
                        system_base_info
                            .debug_printf
                            .expect("non-null function pointer")(
                            b"Received missing state abort flags: %x\n\x00" as *const u8
                                as *const libc::c_char,
                            (*ch).chunk_flags as libc::c_int,
                        );
                    }
                }
                if sctp_handle_nat_missing_state(stcb, net) != 0 {
                    return 0i32;
                }
            }
            3 => {
                /*
                 * We only act if we have echoed a cookie and are
                 * waiting.
                 */
                if cause_length as libc::c_ulong
                    >= ::std::mem::size_of::<sctp_error_stale_cookie>() as libc::c_ulong
                    && (*stcb).asoc.state & 0x7fi32 == 0x4i32
                {
                    let mut stale_cookie = 0 as *mut sctp_error_stale_cookie;
                    stale_cookie = cause as *mut sctp_error_stale_cookie;
                    (*asoc).cookie_preserve_req = ntohl((*stale_cookie).stale_time);
                    /* Double it to be more robust on RTX */
                    if (*asoc).cookie_preserve_req <= (4294967295u32).wrapping_div(2u32) {
                        (*asoc).cookie_preserve_req =
                            ((*asoc).cookie_preserve_req).wrapping_mul(2u32)
                    } else {
                        (*asoc).cookie_preserve_req = 4294967295u32
                    }
                    (*asoc).stale_cookie_count = (*asoc).stale_cookie_count.wrapping_add(1);
                    if (*asoc).stale_cookie_count as libc::c_int
                        > (*asoc).max_init_times as libc::c_int
                    {
                        sctp_abort_notification(stcb, 0u8, 0u16, 0 as *mut sctp_abort_chunk, 0i32);
                        /* now free the asoc */
                        sctp_free_assoc((*stcb).sctp_ep, stcb, 0i32, 0x10000000i32 + 0xci32);
                        return -(1i32);
                    }
                    /* blast back to INIT state */
                    sctp_toss_old_cookies(stcb, &mut (*stcb).asoc);
                    sctp_set_state(stcb, 0x2i32);
                    sctp_stop_all_cookie_timers(stcb);
                    sctp_send_initiate((*stcb).sctp_ep, stcb, 0i32);
                }
            }
            5 => {}
            6 => {
                if cause_length as libc::c_ulong
                    >= ::std::mem::size_of::<sctp_error_unrecognized_chunk>() as libc::c_ulong
                {
                    let mut unrec_chunk = 0 as *mut sctp_error_unrecognized_chunk;
                    unrec_chunk = cause as *mut sctp_error_unrecognized_chunk;
                    sctp_process_unrecog_chunk(stcb, (*unrec_chunk).ch.chunk_type, net);
                }
            }
            8 => {
                /* XXX: We only consider the first parameter */
                if cause_length as libc::c_ulong
                    >= (::std::mem::size_of::<sctp_error_cause>() as libc::c_ulong)
                        .wrapping_add(::std::mem::size_of::<sctp_paramhdr>() as libc::c_ulong)
                {
                    let mut unrec_parameter = 0 as *mut sctp_paramhdr;
                    unrec_parameter = cause.offset(1isize) as *mut sctp_paramhdr;
                    sctp_process_unrecog_param(stcb, ntohs((*unrec_parameter).param_type));
                }
            }
            10 => {}
            160 | 161 | 162 => {
                /*
                 * We should NOT get these here, but in a
                 * ASCONF-ACK.
                 */
                if system_base_info.sctpsysctl.sctp_debug_on & 0x2000u32 != 0 {
                    if system_base_info.debug_printf.is_some() {
                        system_base_info
                            .debug_printf
                            .expect("non-null function pointer")(
                            b"Peer sends ASCONF errors in a error cause with code %u.\n\x00"
                                as *const u8 as *const libc::c_char,
                            cause_code as libc::c_int,
                        );
                    }
                }
            }
            4 => {}
            _ => {
                if system_base_info.sctpsysctl.sctp_debug_on & 0x1000u32 != 0 {
                    if system_base_info.debug_printf.is_some() {
                        system_base_info
                            .debug_printf
                            .expect("non-null function pointer")(
                            b"sctp_handle_error: unknown code 0x%x\n\x00" as *const u8
                                as *const libc::c_char,
                            cause_code as libc::c_int,
                        );
                    }
                }
            }
        }
        adjust = ((cause_length as libc::c_int + 3i32 >> 2i32) << 2i32) as uint32_t;
        if remaining_length >= adjust {
            remaining_length = (remaining_length).wrapping_sub(adjust)
        } else {
            remaining_length = 0u32
        }
        cause = (cause as caddr_t).offset(adjust as isize) as *mut sctp_error_cause
    }
    sctp_ulp_notify(27u32, stcb, code as uint32_t, ch as *mut libc::c_void, 0i32);
    return 0i32;
}
unsafe extern "C" fn sctp_handle_init_ack(
    mut m: *mut mbuf,
    mut iphlen: libc::c_int,
    mut offset: libc::c_int,
    mut src: *mut sockaddr,
    mut dst: *mut sockaddr,
    mut sh: *mut sctphdr,
    mut cp: *mut sctp_init_chunk,
    mut stcb: *mut sctp_tcb,
    mut net: *mut sctp_nets,
    mut abort_no_unlock: *mut libc::c_int,
    mut vrf_id: uint32_t,
) -> libc::c_int {
    let mut init_ack = 0 as *mut sctp_init;
    let mut op_err = 0 as *mut mbuf;
    if system_base_info.sctpsysctl.sctp_debug_on & 0x2000u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"sctp_handle_init_ack: handling INIT-ACK\n\x00" as *const u8
                    as *const libc::c_char,
            );
        }
    }
    if stcb.is_null() {
        if system_base_info.sctpsysctl.sctp_debug_on & 0x2000u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"sctp_handle_init_ack: TCB is null\n\x00" as *const u8 as *const libc::c_char,
                );
            }
        }
        return -(1i32);
    }
    if (ntohs((*cp).ch.chunk_length) as libc::c_ulong)
        < ::std::mem::size_of::<sctp_init_chunk>() as libc::c_ulong
    {
        /* Invalid length */
        op_err = sctp_generate_cause(0x7u16, b"\x00" as *const u8 as *mut libc::c_char);
        sctp_abort_association(
            (*stcb).sctp_ep,
            stcb,
            m,
            iphlen,
            src,
            dst,
            sh,
            op_err,
            vrf_id,
            (*net).port,
        );
        *abort_no_unlock = 1i32;
        return -(1i32);
    }
    init_ack = &mut (*cp).init;
    /* validate parameters */
    if (*init_ack).initiate_tag == 0u32 {
        /* protocol error... send an abort */
        op_err = sctp_generate_cause(0x7u16, b"\x00" as *const u8 as *mut libc::c_char);
        sctp_abort_association(
            (*stcb).sctp_ep,
            stcb,
            m,
            iphlen,
            src,
            dst,
            sh,
            op_err,
            vrf_id,
            (*net).port,
        );
        *abort_no_unlock = 1i32;
        return -(1i32);
    }
    if ntohl((*init_ack).a_rwnd) < 1500u32 {
        /* protocol error... send an abort */
        op_err = sctp_generate_cause(0x7u16, b"\x00" as *const u8 as *mut libc::c_char);
        sctp_abort_association(
            (*stcb).sctp_ep,
            stcb,
            m,
            iphlen,
            src,
            dst,
            sh,
            op_err,
            vrf_id,
            (*net).port,
        );
        *abort_no_unlock = 1i32;
        return -(1i32);
    }
    if (*init_ack).num_inbound_streams as libc::c_int == 0i32 {
        /* protocol error... send an abort */
        op_err = sctp_generate_cause(0x7u16, b"\x00" as *const u8 as *mut libc::c_char);
        sctp_abort_association(
            (*stcb).sctp_ep,
            stcb,
            m,
            iphlen,
            src,
            dst,
            sh,
            op_err,
            vrf_id,
            (*net).port,
        );
        *abort_no_unlock = 1i32;
        return -(1i32);
    }
    if (*init_ack).num_outbound_streams as libc::c_int == 0i32 {
        /* protocol error... send an abort */
        op_err = sctp_generate_cause(0x7u16, b"\x00" as *const u8 as *mut libc::c_char);
        sctp_abort_association(
            (*stcb).sctp_ep,
            stcb,
            m,
            iphlen,
            src,
            dst,
            sh,
            op_err,
            vrf_id,
            (*net).port,
        );
        *abort_no_unlock = 1i32;
        return -(1i32);
    }
    /* process according to association state... */
    match (*stcb).asoc.state & 0x7fi32 {
        2 => {
            /* this is the expected state for this chunk */
            /* process the INIT-ACK parameters */
            if (*(*stcb).asoc.primary_destination).dest_state as libc::c_int & 0x200i32 != 0 {
                /*
                 * The primary is where we sent the INIT, we can
                 * always consider it confirmed when the INIT-ACK is
                 * returned. Do this before we load addresses
                 * though.
                 */
                (*(*stcb).asoc.primary_destination).dest_state =
                    ((*(*stcb).asoc.primary_destination).dest_state as libc::c_int & !(0x200i32))
                        as uint16_t;
                sctp_ulp_notify(
                    16u32,
                    stcb,
                    0u32,
                    (*stcb).asoc.primary_destination as *mut libc::c_void,
                    0i32,
                );
            }
            if sctp_process_init_ack(
                m,
                iphlen,
                offset,
                src,
                dst,
                sh,
                cp,
                stcb,
                net,
                abort_no_unlock,
                vrf_id,
            ) < 0i32
            {
                /* error in parsing parameters */
                return -(1i32);
            }
            /* update our state */
            if system_base_info.sctpsysctl.sctp_debug_on & 0x2000u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"moving to COOKIE-ECHOED state\n\x00" as *const u8 as *const libc::c_char,
                    );
                }
            }
            sctp_set_state(stcb, 0x4i32);
            /* reset the RTO calc */
            if system_base_info.sctpsysctl.sctp_logging_level & 0x2000000u32 != 0 {
                sctp_misc_ints(
                    120u8,
                    (*stcb).asoc.overall_error_count,
                    0u32,
                    0x10000000u32,
                    1541u32,
                );
            }
            (*stcb).asoc.overall_error_count = 0u32;
            gettimeofday(&mut (*stcb).asoc.time_entered, 0 as *mut timezone);
            /*
             * collapse the init timer back in case of a exponential
             * backoff
             */
            sctp_timer_start(6i32, (*stcb).sctp_ep, stcb, net);
        }
        16 => {}
        4 => {}
        8 => {}
        0 | 1 | _ => {
            /* incorrect state... discard */
            return -(1i32);
        }
    }
    if system_base_info.sctpsysctl.sctp_debug_on & 0x1000u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"Leaving handle-init-ack end\n\x00" as *const u8 as *const libc::c_char,
            );
        }
    }
    return 0i32;
}
/*
 * handle a state cookie for an existing association m: input packet mbuf
 * chain-- assumes a pullup on IP/SCTP/COOKIE-ECHO chunk note: this is a
 * "split" mbuf and the cookie signature does not exist offset: offset into
 * mbuf to the cookie-echo chunk
 */
unsafe extern "C" fn sctp_process_cookie_existing(
    mut m: *mut mbuf,
    mut iphlen: libc::c_int,
    mut offset: libc::c_int,
    mut src: *mut sockaddr,
    mut dst: *mut sockaddr,
    mut sh: *mut sctphdr,
    mut cookie: *mut sctp_state_cookie,
    mut cookie_len: libc::c_int,
    mut inp: *mut sctp_inpcb,
    mut stcb: *mut sctp_tcb,
    mut netp: *mut *mut sctp_nets,
    mut init_src: *mut sockaddr,
    mut notification: *mut libc::c_int,
    mut auth_skipped: libc::c_int,
    mut auth_offset: uint32_t,
    mut auth_len: uint32_t,
    mut vrf_id: uint32_t,
    mut port: uint16_t,
) -> *mut sctp_tcb {
    let mut asoc = 0 as *mut sctp_association;
    let mut init_cp = 0 as *mut sctp_init_chunk;
    let mut init_buf = sctp_init_chunk {
        ch: sctp_chunkhdr {
            chunk_type: 0,
            chunk_flags: 0,
            chunk_length: 0,
        },
        init: sctp_init {
            initiate_tag: 0,
            a_rwnd: 0,
            num_outbound_streams: 0,
            num_inbound_streams: 0,
            initial_tsn: 0,
        },
    };
    let mut initack_cp = 0 as *mut sctp_init_chunk;
    let mut initack_buf = sctp_init_chunk {
        ch: sctp_chunkhdr {
            chunk_type: 0,
            chunk_flags: 0,
            chunk_length: 0,
        },
        init: sctp_init {
            initiate_tag: 0,
            a_rwnd: 0,
            num_outbound_streams: 0,
            num_inbound_streams: 0,
            initial_tsn: 0,
        },
    };
    let mut net = 0 as *mut sctp_nets;
    let mut op_err = 0 as *mut mbuf;
    let mut init_offset = 0;
    let mut initack_offset = 0;
    let mut retval = 0;
    let mut how_indx = 0;
    net = *netp;
    /* I know that the TCB is non-NULL from the caller */
    asoc = &mut (*stcb).asoc;
    how_indx = 0u32;
    while (how_indx as libc::c_ulong) < ::std::mem::size_of::<[uint8_t; 8]>() as libc::c_ulong {
        if (*asoc).cookie_how[how_indx as usize] as libc::c_int == 0i32 {
            break;
        }
        how_indx = how_indx.wrapping_add(1)
    }
    if (how_indx as libc::c_ulong) < ::std::mem::size_of::<[uint8_t; 8]>() as libc::c_ulong {
        (*asoc).cookie_how[how_indx as usize] = 1u8
    }
    if (*stcb).asoc.state & 0x7fi32 == 0x40i32 {
        /* SHUTDOWN came in after sending INIT-ACK */
        sctp_send_shutdown_ack(stcb, (*stcb).asoc.primary_destination);
        op_err = sctp_generate_cause(0xau16, b"\x00" as *const u8 as *mut libc::c_char);
        sctp_send_operr_to(
            src,
            dst,
            sh,
            (*cookie).peers_vtag,
            op_err,
            vrf_id,
            (*net).port,
        );
        if (how_indx as libc::c_ulong) < ::std::mem::size_of::<[uint8_t; 8]>() as libc::c_ulong {
            (*asoc).cookie_how[how_indx as usize] = 2u8
        }
        return 0 as *mut sctp_tcb;
    }
    /*
     * find and validate the INIT chunk in the cookie (peer's info) the
     * INIT should start after the cookie-echo header struct (chunk
     * header, state cookie header struct)
     */
    offset = (offset as libc::c_ulong)
        .wrapping_add(::std::mem::size_of::<sctp_cookie_echo_chunk>() as libc::c_ulong)
        as libc::c_int;
    init_offset = offset;
    init_cp = sctp_m_getptr(
        m,
        init_offset,
        ::std::mem::size_of::<sctp_init_chunk>() as libc::c_int,
        &mut init_buf as *mut sctp_init_chunk as *mut uint8_t,
    ) as *mut sctp_init_chunk;
    if init_cp.is_null() {
        /* could not pull a INIT chunk in cookie */
        return 0 as *mut sctp_tcb;
    }
    if (*init_cp).ch.chunk_type as libc::c_int != 0x1i32 {
        return 0 as *mut sctp_tcb;
    }
    /*
     * find and validate the INIT-ACK chunk in the cookie (my info) the
     * INIT-ACK follows the INIT chunk
     */
    initack_offset =
        init_offset + ((ntohs((*init_cp).ch.chunk_length) as libc::c_int + 3i32 >> 2i32) << 2i32);
    initack_cp = sctp_m_getptr(
        m,
        initack_offset,
        ::std::mem::size_of::<sctp_init_chunk>() as libc::c_int,
        &mut initack_buf as *mut sctp_init_chunk as *mut uint8_t,
    ) as *mut sctp_init_chunk;
    if initack_cp.is_null() {
        /* could not pull INIT-ACK chunk in cookie */
        return 0 as *mut sctp_tcb;
    }
    if (*initack_cp).ch.chunk_type as libc::c_int != 0x2i32 {
        return 0 as *mut sctp_tcb;
    }
    if ntohl((*initack_cp).init.initiate_tag) == (*asoc).my_vtag
        && ntohl((*init_cp).init.initiate_tag) == (*asoc).peer_vtag
    {
        /*
         * case D in Section 5.2.4 Table 2: MMAA process accordingly
         * to get into the OPEN state
         */
        if ntohl((*initack_cp).init.initial_tsn) != (*asoc).init_seq_number {
            /*-
             * Opps, this means that we somehow generated two vtag's
             * the same. I.e. we did:
             *  Us               Peer
             *   <---INIT(tag=a)------
             *   ----INIT-ACK(tag=t)-->
             *   ----INIT(tag=t)------> *1
             *   <---INIT-ACK(tag=a)---
             *   <----CE(tag=t)------------- *2
             *
             * At point *1 we should be generating a different
             * tag t'. Which means we would throw away the CE and send
             * ours instead. Basically this is case C (throw away side).
             */
            if (how_indx as libc::c_ulong) < ::std::mem::size_of::<[uint8_t; 8]>() as libc::c_ulong
            {
                (*asoc).cookie_how[how_indx as usize] = 17u8
            } /* end switch */
            return 0 as *mut sctp_tcb;
        }
        match (*stcb).asoc.state & 0x7fi32 {
            2 | 4 => {
                let mut old = timeval {
                    tv_sec: 0,
                    tv_usec: 0,
                };
                retval = sctp_process_init(init_cp, stcb);
                if retval < 0i32 {
                    if (how_indx as libc::c_ulong)
                        < ::std::mem::size_of::<[uint8_t; 8]>() as libc::c_ulong
                    {
                        (*asoc).cookie_how[how_indx as usize] = 3u8
                    }
                    return 0 as *mut sctp_tcb;
                }
                /* we have already processed the INIT so no problem */
                sctp_timer_stop(5i32, inp, stcb, net, (0x10000000i32 + 0xdi32) as uint32_t);
                sctp_timer_stop(2i32, inp, stcb, net, (0x10000000i32 + 0xei32) as uint32_t);
                /* update current state */
                if (*stcb).asoc.state & 0x7fi32 == 0x4i32 {
                    ::std::intrinsics::atomic_xadd(
                        &mut system_base_info.sctpstat.sctps_activeestab,
                        1u32,
                    );
                } else {
                    ::std::intrinsics::atomic_xadd(
                        &mut system_base_info.sctpstat.sctps_collisionestab,
                        1u32,
                    );
                }
                sctp_set_state(stcb, 0x8i32);
                if (*asoc).state & 0x80i32 != 0 {
                    sctp_timer_start(11i32, (*stcb).sctp_ep, stcb, (*asoc).primary_destination);
                }
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctpstat.sctps_currestab,
                    1u32,
                );
                sctp_stop_all_cookie_timers(stcb);
                if ((*(*stcb).sctp_ep).sctp_flags & 0x2u32 != 0
                    || (*(*stcb).sctp_ep).sctp_flags & 0x400000u32 != 0)
                    && !((*inp).sctp_flags & 0x8u32 != 0u32)
                {
                    /*
                     * Here is where collision would go if we
                     * did a connect() and instead got a
                     * init/init-ack/cookie done before the
                     * init-ack came back..
                     */
                    (*(*stcb).sctp_ep).sctp_flags |= 0x200000u32;
                    soisconnected((*stcb).sctp_socket);
                }
                /* notify upper layer */
                *notification = 1i32;
                /*
                 * since we did not send a HB make sure we
                 * don't double things
                 */
                old.tv_sec = (*cookie).time_entered.tv_sec;
                old.tv_usec = (*cookie).time_entered.tv_usec;
                (*net).hb_responded = 1u8;
                sctp_calculate_rto(stcb, asoc, net, &mut old, 0i32);
                if (*stcb).asoc.sctp_autoclose_ticks != 0
                    && (*inp).sctp_features & 0x200u64 == 0x200u64
                {
                    sctp_timer_start(12i32, inp, stcb, 0 as *mut sctp_nets);
                }
            }
            _ => {}
        }
        sctp_stop_all_cookie_timers(stcb);
        /*
         * We ignore the return code here.. not sure if we should
         * somehow abort.. but we do have an existing asoc. This
         * really should not fail.
         */
        if sctp_load_addresses_from_init(
            stcb,
            m,
            (init_offset as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<sctp_init_chunk>() as libc::c_ulong)
                as libc::c_int,
            initack_offset,
            src,
            dst,
            init_src,
            (*stcb).asoc.port,
        ) != 0
        {
            if (how_indx as libc::c_ulong) < ::std::mem::size_of::<[uint8_t; 8]>() as libc::c_ulong
            {
                (*asoc).cookie_how[how_indx as usize] = 4u8
            }
            return 0 as *mut sctp_tcb;
        }
        /* respond with a COOKIE-ACK */
        sctp_toss_old_cookies(stcb, asoc);
        sctp_send_cookie_ack(stcb);
        if (how_indx as libc::c_ulong) < ::std::mem::size_of::<[uint8_t; 8]>() as libc::c_ulong {
            (*asoc).cookie_how[how_indx as usize] = 5u8
        }
        return stcb;
    }
    if ntohl((*initack_cp).init.initiate_tag) != (*asoc).my_vtag
        && ntohl((*init_cp).init.initiate_tag) == (*asoc).peer_vtag
        && (*cookie).tie_tag_my_vtag == 0u32
        && (*cookie).tie_tag_peer_vtag == 0u32
    {
        /*
         * case C in Section 5.2.4 Table 2: XMOO silently discard
         */
        if (how_indx as libc::c_ulong) < ::std::mem::size_of::<[uint8_t; 8]>() as libc::c_ulong {
            (*asoc).cookie_how[how_indx as usize] = 6u8
        }
        return 0 as *mut sctp_tcb;
    }
    /* If nat support, and the below and stcb is established,
     * send back a ABORT(colliding state) if we are established.
     */
    if (*stcb).asoc.state & 0x7fi32 == 0x8i32
        && (*asoc).peer_supports_nat as libc::c_int != 0
        && (ntohl((*initack_cp).init.initiate_tag) == (*asoc).my_vtag
            && (ntohl((*init_cp).init.initiate_tag) != (*asoc).peer_vtag
                || (*asoc).peer_vtag == 0u32))
    {
        /* Special case - Peer's support nat. We may have
         * two init's that we gave out the same tag on since
         * one was not established.. i.e. we get INIT from host-1
         * behind the nat and we respond tag-a, we get a INIT from
         * host-2 behind the nat and we get tag-a again. Then we
         * bring up host-1 (or 2's) assoc, Then comes the cookie
         * from hsot-2 (or 1). Now we have colliding state. We must
         * send an abort here with colliding state indication.
         */
        op_err = sctp_generate_cause(0xb0u16, b"\x00" as *const u8 as *mut libc::c_char);
        sctp_send_abort(m, iphlen, src, dst, sh, 0u32, op_err, vrf_id, port);
        return 0 as *mut sctp_tcb;
    }
    if ntohl((*initack_cp).init.initiate_tag) == (*asoc).my_vtag
        && (ntohl((*init_cp).init.initiate_tag) != (*asoc).peer_vtag || (*asoc).peer_vtag == 0u32)
    {
        let mut spec_flag = 0i32;
        if ntohl((*initack_cp).init.initial_tsn) != (*asoc).init_seq_number {
            /* Extension of case C.
             * If we hit this, then the random number
             * generator returned the same vtag when we
             * first sent our INIT-ACK and when we later sent
             * our INIT. The side with the seq numbers that are
             * different will be the one that normnally would
             * have hit case C. This in effect "extends" our vtags
             * in this collision case to be 64 bits. The same collision
             * could occur aka you get both vtag and seq number the
             * same twice in a row.. but is much less likely. If it
             * did happen then we would proceed through and bring
             * up the assoc.. we may end up with the wrong stream
             * setup however.. which would be bad.. but there is
             * no way to tell.. until we send on a stream that does
             * not exist :-)
             */
            if (how_indx as libc::c_ulong) < ::std::mem::size_of::<[uint8_t; 8]>() as libc::c_ulong
            {
                (*asoc).cookie_how[how_indx as usize] = 7u8
            }
            return 0 as *mut sctp_tcb;
        }
        if (how_indx as libc::c_ulong) < ::std::mem::size_of::<[uint8_t; 8]>() as libc::c_ulong {
            (*asoc).cookie_how[how_indx as usize] = 8u8
        }
        sctp_timer_stop(5i32, inp, stcb, net, (0x10000000i32 + 0xfi32) as uint32_t);
        sctp_stop_all_cookie_timers(stcb);
        /*
         * since we did not send a HB make sure we don't double
         * things
         */
        (*net).hb_responded = 1u8;
        if (*stcb).asoc.sctp_autoclose_ticks != 0 && (*inp).sctp_features & 0x200u64 == 0x200u64 {
            sctp_timer_start(12i32, inp, stcb, 0 as *mut sctp_nets);
        }
        (*asoc).my_rwnd = ntohl((*initack_cp).init.a_rwnd);
        (*asoc).pre_open_streams = ntohs((*initack_cp).init.num_outbound_streams) as libc::c_uint;
        if ntohl((*init_cp).init.initiate_tag) != (*asoc).peer_vtag {
            let mut chk = 0 as *mut sctp_tmit_chunk;
            chk = (*stcb).asoc.sent_queue.tqh_first;
            while !chk.is_null() {
                if (*chk).sent < 4i32 {
                    (*chk).sent = 4i32;
                    if (*(*chk).whoTo).flight_size >= (*chk).book_size as libc::c_uint {
                        (*(*chk).whoTo).flight_size = ((*(*chk).whoTo).flight_size)
                            .wrapping_sub((*chk).book_size as libc::c_uint)
                    } else {
                        (*(*chk).whoTo).flight_size = 0u32
                    }
                    (*chk).window_probe = 0u8;
                    if (*stcb).asoc.total_flight >= (*chk).book_size as libc::c_uint {
                        (*stcb).asoc.total_flight = (*stcb)
                            .asoc
                            .total_flight
                            .wrapping_sub((*chk).book_size as libc::c_uint);
                        if (*stcb).asoc.total_flight_count > 0u32 {
                            (*stcb).asoc.total_flight_count =
                                (*stcb).asoc.total_flight_count.wrapping_sub(1)
                        }
                    } else {
                        (*stcb).asoc.total_flight = 0u32;
                        (*stcb).asoc.total_flight_count = 0u32
                    }
                    (*stcb).asoc.sent_queue_retran_cnt =
                        (*stcb).asoc.sent_queue_retran_cnt.wrapping_add(1);
                    spec_flag += 1
                }
                chk = (*chk).sctp_next.tqe_next
            }
        }
        /* process the INIT info (peer's info) */
        retval = sctp_process_init(init_cp, stcb);
        if retval < 0i32 {
            if (how_indx as libc::c_ulong) < ::std::mem::size_of::<[uint8_t; 8]>() as libc::c_ulong
            {
                (*asoc).cookie_how[how_indx as usize] = 9u8
            }
            return 0 as *mut sctp_tcb;
        }
        if sctp_load_addresses_from_init(
            stcb,
            m,
            (init_offset as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<sctp_init_chunk>() as libc::c_ulong)
                as libc::c_int,
            initack_offset,
            src,
            dst,
            init_src,
            (*stcb).asoc.port,
        ) != 0
        {
            if (how_indx as libc::c_ulong) < ::std::mem::size_of::<[uint8_t; 8]>() as libc::c_ulong
            {
                (*asoc).cookie_how[how_indx as usize] = 10u8
            }
            return 0 as *mut sctp_tcb;
        }
        if (*stcb).asoc.state & 0x7fi32 == 0x2i32 || (*stcb).asoc.state & 0x7fi32 == 0x4i32 {
            *notification = 1i32;
            if ((*(*stcb).sctp_ep).sctp_flags & 0x2u32 != 0
                || (*(*stcb).sctp_ep).sctp_flags & 0x400000u32 != 0)
                && !((*inp).sctp_flags & 0x8u32 != 0u32)
            {
                (*(*stcb).sctp_ep).sctp_flags |= 0x200000u32;
                soisconnected((*stcb).sctp_socket);
            }
            if (*stcb).asoc.state & 0x7fi32 == 0x4i32 {
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctpstat.sctps_activeestab,
                    1u32,
                );
            } else {
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctpstat.sctps_collisionestab,
                    1u32,
                );
            }
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_currestab, 1u32);
        } else if (*stcb).asoc.state & 0x7fi32 == 0x8i32 {
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_restartestab, 1u32);
        } else {
            ::std::intrinsics::atomic_xadd(
                &mut system_base_info.sctpstat.sctps_collisionestab,
                1u32,
            );
        }
        sctp_set_state(stcb, 0x8i32);
        if (*asoc).state & 0x80i32 != 0 {
            sctp_timer_start(11i32, (*stcb).sctp_ep, stcb, (*asoc).primary_destination);
        }
        sctp_stop_all_cookie_timers(stcb);
        sctp_toss_old_cookies(stcb, asoc);
        sctp_send_cookie_ack(stcb);
        if spec_flag != 0 {
            /* only if we have retrans set do we do this. What
             * this call does is get only the COOKIE-ACK out
             * and then when we return the normal call to
             * sctp_chunk_output will get the retrans out
             * behind this.
             */
            sctp_chunk_output(inp, stcb, 14i32, 0i32);
        }
        if (how_indx as libc::c_ulong) < ::std::mem::size_of::<[uint8_t; 8]>() as libc::c_ulong {
            (*asoc).cookie_how[how_indx as usize] = 11u8
        }
        return stcb;
    }
    if ntohl((*initack_cp).init.initiate_tag) != (*asoc).my_vtag
        && ntohl((*init_cp).init.initiate_tag) != (*asoc).peer_vtag
        && (*cookie).tie_tag_my_vtag == (*asoc).my_vtag_nonce
        && (*cookie).tie_tag_peer_vtag == (*asoc).peer_vtag_nonce
        && (*cookie).tie_tag_peer_vtag != 0u32
    {
        let mut head = 0 as *mut sctpasochead;
        if (*asoc).peer_supports_nat != 0 {
            /* This is a gross gross hack.
             * Just call the cookie_new code since we
             * are allowing a duplicate association.
             * I hope this works...
             */
            return sctp_process_cookie_new(
                m,
                iphlen,
                offset,
                src,
                dst,
                sh,
                cookie,
                cookie_len,
                inp,
                netp,
                init_src,
                notification,
                auth_skipped,
                auth_offset,
                auth_len,
                vrf_id,
                port,
            );
        }
        /*
         * case A in Section 5.2.4 Table 2: XXMM (peer restarted)
         */
        /* temp code */
        if (how_indx as libc::c_ulong) < ::std::mem::size_of::<[uint8_t; 8]>() as libc::c_ulong {
            (*asoc).cookie_how[how_indx as usize] = 12u8
        }
        sctp_timer_stop(2i32, inp, stcb, net, (0x10000000i32 + 0x10i32) as uint32_t);
        sctp_timer_stop(5i32, inp, stcb, net, (0x10000000i32 + 0x11i32) as uint32_t);
        /* notify upper layer */
        *notification = 10i32;
        ::std::intrinsics::atomic_xadd(&mut (*stcb).asoc.refcnt, 1u32);
        if (*stcb).asoc.state & 0x7fi32 != 0x8i32
            && (*stcb).asoc.state & 0x7fi32 != 0x20i32
            && (*stcb).asoc.state & 0x7fi32 != 0x10i32
        {
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_currestab, 1u32);
        }
        if (*stcb).asoc.state & 0x7fi32 == 0x8i32 {
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_restartestab, 1u32);
        } else if (*stcb).asoc.state & 0x7fi32 != 0x10i32 {
            ::std::intrinsics::atomic_xadd(
                &mut system_base_info.sctpstat.sctps_collisionestab,
                1u32,
            );
        }
        if (*asoc).state & 0x80i32 != 0 {
            sctp_set_state(stcb, 0x8i32);
            sctp_timer_start(11i32, (*stcb).sctp_ep, stcb, (*asoc).primary_destination);
        } else if (*stcb).asoc.state & 0x7fi32 != 0x10i32 {
            /* move to OPEN state, if not in SHUTDOWN_SENT */
            sctp_set_state(stcb, 0x8i32);
        }
        (*asoc).pre_open_streams = ntohs((*initack_cp).init.num_outbound_streams) as libc::c_uint;
        (*asoc).init_seq_number = ntohl((*initack_cp).init.initial_tsn);
        (*asoc).str_reset_seq_out = (*asoc).init_seq_number;
        (*asoc).asconf_seq_out = (*asoc).str_reset_seq_out;
        (*asoc).sending_seq = (*asoc).asconf_seq_out;
        (*asoc).asconf_seq_out_acked = (*asoc).asconf_seq_out.wrapping_sub(1u32);
        (*asoc).last_acked_seq = (*asoc).init_seq_number.wrapping_sub(1u32);
        (*asoc).asconf_seq_in = (*asoc).last_acked_seq;
        (*asoc).str_reset_seq_in = (*asoc).init_seq_number;
        (*asoc).advanced_peer_ack_point = (*asoc).last_acked_seq;
        if !(*asoc).mapping_array.is_null() {
            memset(
                (*asoc).mapping_array as *mut libc::c_void,
                0i32,
                (*asoc).mapping_array_size as libc::c_ulong,
            );
        }
        if !(*asoc).nr_mapping_array.is_null() {
            memset(
                (*asoc).nr_mapping_array as *mut libc::c_void,
                0i32,
                (*asoc).mapping_array_size as libc::c_ulong,
            );
        }
        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
        pthread_mutex_lock(&mut system_base_info.sctppcbinfo.ipi_ep_mtx);
        pthread_mutex_lock(&mut (*(*stcb).sctp_ep).inp_mtx);
        pthread_mutex_lock(&mut (*stcb).tcb_mtx);
        ::std::intrinsics::atomic_xadd(&mut (*stcb).asoc.refcnt, -(1i32) as uint32_t);
        /* send up all the data */
        pthread_mutex_lock(&mut (*stcb).tcb_send_mtx);
        sctp_report_all_outbound(stcb, 0u16, 1i32, 1i32);

        for i in 0i32..(*stcb).asoc.streamoutcnt as libc::c_int {
            (*(*stcb).asoc.strmout.offset(i as isize)).chunks_on_queues = 0u32;

            (*(*asoc).strmout.offset(i as isize)).abandoned_sent[0usize] = 0u32;

            (*(*asoc).strmout.offset(i as isize)).abandoned_unsent[0usize] = 0u32;

            (*(*stcb).asoc.strmout.offset(i as isize)).sid = i as uint16_t;

            (*(*stcb).asoc.strmout.offset(i as isize)).next_mid_ordered = 0u32;

            (*(*stcb).asoc.strmout.offset(i as isize)).next_mid_unordered = 0u32;

            (*(*stcb).asoc.strmout.offset(i as isize)).last_msg_incomplete = 0u8;
        }
        /* process the INIT-ACK info (my info) */
        (*asoc).my_vtag = ntohl((*initack_cp).init.initiate_tag);
        (*asoc).my_rwnd = ntohl((*initack_cp).init.a_rwnd);
        /* pull from vtag hash */
        if !(*stcb).sctp_asocs.le_next.is_null() {
            (*(*stcb).sctp_asocs.le_next).sctp_asocs.le_prev = (*stcb).sctp_asocs.le_prev
        }
        *(*stcb).sctp_asocs.le_prev = (*stcb).sctp_asocs.le_next;
        /* re-insert to new vtag position */
        head = &mut *system_base_info.sctppcbinfo.sctp_asochash.offset(
            ((*stcb).asoc.my_vtag as libc::c_ulong & system_base_info.sctppcbinfo.hashasocmark)
                as isize,
        ) as *mut sctpasochead;
        /*
         * put it in the bucket in the vtag hash of assoc's for the
         * system
         */
        (*stcb).sctp_asocs.le_next = (*head).lh_first;
        if !(*stcb).sctp_asocs.le_next.is_null() {
            (*(*head).lh_first).sctp_asocs.le_prev = &mut (*stcb).sctp_asocs.le_next
        }
        (*head).lh_first = stcb;
        (*stcb).sctp_asocs.le_prev = &mut (*head).lh_first;
        pthread_mutex_unlock(&mut (*stcb).tcb_send_mtx);
        pthread_mutex_unlock(&mut (*(*stcb).sctp_ep).inp_mtx);
        pthread_mutex_unlock(&mut system_base_info.sctppcbinfo.ipi_ep_mtx);
        (*asoc).total_flight = 0u32;
        (*asoc).total_flight_count = 0u32;
        /* process the INIT info (peer's info) */
        retval = sctp_process_init(init_cp, stcb);
        if retval < 0i32 {
            if (how_indx as libc::c_ulong) < ::std::mem::size_of::<[uint8_t; 8]>() as libc::c_ulong
            {
                (*asoc).cookie_how[how_indx as usize] = 13u8
            }
            return 0 as *mut sctp_tcb;
        }
        /*
         * since we did not send a HB make sure we don't double
         * things
         */
        (*net).hb_responded = 1u8;
        if sctp_load_addresses_from_init(
            stcb,
            m,
            (init_offset as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<sctp_init_chunk>() as libc::c_ulong)
                as libc::c_int,
            initack_offset,
            src,
            dst,
            init_src,
            (*stcb).asoc.port,
        ) != 0
        {
            if (how_indx as libc::c_ulong) < ::std::mem::size_of::<[uint8_t; 8]>() as libc::c_ulong
            {
                (*asoc).cookie_how[how_indx as usize] = 14u8
            }
            return 0 as *mut sctp_tcb;
        }
        /* respond with a COOKIE-ACK */
        sctp_stop_all_cookie_timers(stcb);
        sctp_toss_old_cookies(stcb, asoc);
        sctp_send_cookie_ack(stcb);
        if (how_indx as libc::c_ulong) < ::std::mem::size_of::<[uint8_t; 8]>() as libc::c_ulong {
            (*asoc).cookie_how[how_indx as usize] = 15u8
        }
        return stcb;
    }
    if (how_indx as libc::c_ulong) < ::std::mem::size_of::<[uint8_t; 8]>() as libc::c_ulong {
        (*asoc).cookie_how[how_indx as usize] = 16u8
    }
    /* all other cases... */
    return 0 as *mut sctp_tcb;
}
/*
 * handle a state cookie for a new association m: input packet mbuf chain--
 * assumes a pullup on IP/SCTP/COOKIE-ECHO chunk note: this is a "split" mbuf
 * and the cookie signature does not exist offset: offset into mbuf to the
 * cookie-echo chunk length: length of the cookie chunk to: where the init
 * was from returns a new TCB
 */
unsafe extern "C" fn sctp_process_cookie_new(
    mut m: *mut mbuf,
    mut iphlen: libc::c_int,
    mut offset: libc::c_int,
    mut src: *mut sockaddr,
    mut dst: *mut sockaddr,
    mut sh: *mut sctphdr,
    mut cookie: *mut sctp_state_cookie,
    mut cookie_len: libc::c_int,
    mut inp: *mut sctp_inpcb,
    mut netp: *mut *mut sctp_nets,
    mut init_src: *mut sockaddr,
    mut notification: *mut libc::c_int,
    mut auth_skipped: libc::c_int,
    mut auth_offset: uint32_t,
    mut auth_len: uint32_t,
    mut vrf_id: uint32_t,
    mut port: uint16_t,
) -> *mut sctp_tcb {
    let mut stcb = 0 as *mut sctp_tcb;
    let mut init_cp = 0 as *mut sctp_init_chunk;
    let mut init_buf = sctp_init_chunk {
        ch: sctp_chunkhdr {
            chunk_type: 0,
            chunk_flags: 0,
            chunk_length: 0,
        },
        init: sctp_init {
            initiate_tag: 0,
            a_rwnd: 0,
            num_outbound_streams: 0,
            num_inbound_streams: 0,
            initial_tsn: 0,
        },
    };
    let mut initack_cp = 0 as *mut sctp_init_chunk;
    let mut initack_buf = sctp_init_chunk {
        ch: sctp_chunkhdr {
            chunk_type: 0,
            chunk_flags: 0,
            chunk_length: 0,
        },
        init: sctp_init {
            initiate_tag: 0,
            a_rwnd: 0,
            num_outbound_streams: 0,
            num_inbound_streams: 0,
            initial_tsn: 0,
        },
    };
    let mut store = sctp_sockstore {
        sin: sockaddr_in {
            sin_family: 0,
            sin_port: 0,
            sin_addr: in_addr { s_addr: 0 },
            sin_zero: [0; 8],
        },
    };
    let mut asoc = 0 as *mut sctp_association;
    let mut init_offset = 0;
    let mut initack_offset = 0;
    let mut initack_limit = 0;
    let mut retval = 0;
    let mut error = 0i32;
    /*
     * find and validate the INIT chunk in the cookie (peer's info) the
     * INIT should start after the cookie-echo header struct (chunk
     * header, state cookie header struct)
     */
    init_offset = (offset as libc::c_ulong)
        .wrapping_add(::std::mem::size_of::<sctp_cookie_echo_chunk>() as libc::c_ulong)
        as libc::c_int;
    init_cp = sctp_m_getptr(
        m,
        init_offset,
        ::std::mem::size_of::<sctp_init_chunk>() as libc::c_int,
        &mut init_buf as *mut sctp_init_chunk as *mut uint8_t,
    ) as *mut sctp_init_chunk;
    if init_cp.is_null() {
        /* could not pull a INIT chunk in cookie */
        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"process_cookie_new: could not pull INIT chunk hdr\n\x00" as *const u8
                        as *const libc::c_char,
                );
            }
        }
        return 0 as *mut sctp_tcb;
    }
    if (*init_cp).ch.chunk_type as libc::c_int != 0x1i32 {
        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"HUH? process_cookie_new: could not find INIT chunk!\n\x00" as *const u8
                        as *const libc::c_char,
                );
            }
        }
        return 0 as *mut sctp_tcb;
    }
    initack_offset =
        init_offset + ((ntohs((*init_cp).ch.chunk_length) as libc::c_int + 3i32 >> 2i32) << 2i32);
    /*
     * find and validate the INIT-ACK chunk in the cookie (my info) the
     * INIT-ACK follows the INIT chunk
     */
    initack_cp = sctp_m_getptr(
        m,
        initack_offset,
        ::std::mem::size_of::<sctp_init_chunk>() as libc::c_int,
        &mut initack_buf as *mut sctp_init_chunk as *mut uint8_t,
    ) as *mut sctp_init_chunk;
    if initack_cp.is_null() {
        /* could not pull INIT-ACK chunk in cookie */
        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"process_cookie_new: could not pull INIT-ACK chunk hdr\n\x00" as *const u8
                        as *const libc::c_char,
                );
            }
        }
        return 0 as *mut sctp_tcb;
    }
    if (*initack_cp).ch.chunk_type as libc::c_int != 0x2i32 {
        return 0 as *mut sctp_tcb;
    }
    /*
     * NOTE: We can't use the INIT_ACK's chk_length to determine the
     * "initack_limit" value.  This is because the chk_length field
     * includes the length of the cookie, but the cookie is omitted when
     * the INIT and INIT_ACK are tacked onto the cookie...
     */
    initack_limit = offset + cookie_len;
    /*
     * now that we know the INIT/INIT-ACK are in place, create a new TCB
     * and popluate
     */
    /*
     * Here we do a trick, we set in NULL for the proc/thread argument. We
     * do this since in effect we only use the p argument when
     * the socket is unbound and we must do an implicit bind.
     * Since we are getting a cookie, we cannot be unbound.
     */
    stcb = sctp_aloc_assoc(
        inp,
        init_src,
        &mut error,
        ntohl((*initack_cp).init.initiate_tag),
        vrf_id,
        ntohs((*initack_cp).init.num_outbound_streams),
        port,
        0 as *mut proc_0,
        0i32,
    );
    if stcb.is_null() {
        let mut op_err = 0 as *mut mbuf;
        /* memory problem? */
        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"process_cookie_new: no room for another TCB!\n\x00" as *const u8
                        as *const libc::c_char,
                );
            }
        }
        op_err = sctp_generate_cause(0x4u16, b"\x00" as *const u8 as *mut libc::c_char);
        sctp_abort_association(
            inp,
            0 as *mut sctp_tcb,
            m,
            iphlen,
            src,
            dst,
            sh,
            op_err,
            vrf_id,
            port,
        );
        return 0 as *mut sctp_tcb;
    }
    /* get the correct sctp_nets */
    if !netp.is_null() {
        *netp = sctp_findnet(stcb, init_src)
    }
    asoc = &mut (*stcb).asoc;
    /* get scope variables out of cookie */
    (*asoc).scope.ipv4_local_scope = (*cookie).ipv4_scope;
    (*asoc).scope.site_scope = (*cookie).site_scope;
    (*asoc).scope.local_scope = (*cookie).local_scope;
    (*asoc).scope.loopback_scope = (*cookie).loopback_scope;
    if (*asoc).scope.ipv4_addr_legal as libc::c_int != (*cookie).ipv4_addr_legal as libc::c_int
        || (*asoc).scope.ipv6_addr_legal as libc::c_int != (*cookie).ipv6_addr_legal as libc::c_int
        || (*asoc).scope.conn_addr_legal as libc::c_int != (*cookie).conn_addr_legal as libc::c_int
    {
        let mut op_err_0 = 0 as *mut mbuf;
        /*
         * Houston we have a problem. The EP changed while the
         * cookie was in flight. Only recourse is to abort the
         * association.
         */
        op_err_0 = sctp_generate_cause(0x4u16, b"\x00" as *const u8 as *mut libc::c_char);
        sctp_abort_association(
            inp,
            0 as *mut sctp_tcb,
            m,
            iphlen,
            src,
            dst,
            sh,
            op_err_0,
            vrf_id,
            port,
        );
        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x12i32);
        return 0 as *mut sctp_tcb;
    }
    /* process the INIT-ACK info (my info) */
    (*asoc).my_vtag = ntohl((*initack_cp).init.initiate_tag);
    (*asoc).my_rwnd = ntohl((*initack_cp).init.a_rwnd);
    (*asoc).pre_open_streams = ntohs((*initack_cp).init.num_outbound_streams) as libc::c_uint;
    (*asoc).init_seq_number = ntohl((*initack_cp).init.initial_tsn);
    (*asoc).str_reset_seq_out = (*asoc).init_seq_number;
    (*asoc).asconf_seq_out = (*asoc).str_reset_seq_out;
    (*asoc).sending_seq = (*asoc).asconf_seq_out;
    (*asoc).asconf_seq_out_acked = (*asoc).asconf_seq_out.wrapping_sub(1u32);
    (*asoc).last_acked_seq = (*asoc).init_seq_number.wrapping_sub(1u32);
    (*asoc).asconf_seq_in = (*asoc).last_acked_seq;
    (*asoc).str_reset_seq_in = (*asoc).init_seq_number;
    (*asoc).advanced_peer_ack_point = (*asoc).last_acked_seq;
    /* process the INIT info (peer's info) */
    if !netp.is_null() {
        retval = sctp_process_init(init_cp, stcb)
    } else {
        retval = 0i32
    }
    if retval < 0i32 {
        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x13i32);
        return 0 as *mut sctp_tcb;
    }
    /* load all addresses */
    if sctp_load_addresses_from_init(
        stcb,
        m,
        (init_offset as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<sctp_init_chunk>() as libc::c_ulong)
            as libc::c_int,
        initack_offset,
        src,
        dst,
        init_src,
        port,
    ) != 0
    {
        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x14i32);
        return 0 as *mut sctp_tcb;
    }
    /*
     * verify any preceding AUTH chunk that was skipped
     */
    /* pull the local authentication parameters from the cookie/init-ack */
    sctp_auth_get_cookie_params(
        stcb,
        m,
        (initack_offset as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<sctp_init_chunk>() as libc::c_ulong)
            as uint32_t,
        (initack_limit as libc::c_ulong).wrapping_sub(
            (initack_offset as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<sctp_init_chunk>() as libc::c_ulong),
        ) as uint32_t,
    );
    if auth_skipped != 0 {
        let mut auth = 0 as *mut sctp_auth_chunk;
        if auth_len <= 512u32 {
            let mut auth_chunk_buf = [0; 512];
            auth = sctp_m_getptr(
                m,
                auth_offset as libc::c_int,
                auth_len as libc::c_int,
                auth_chunk_buf.as_mut_ptr(),
            ) as *mut sctp_auth_chunk
        } else {
            auth = 0 as *mut sctp_auth_chunk
        }
        if auth.is_null() || sctp_handle_auth(stcb, auth, m, auth_offset) != 0 {
            /* auth HMAC failed, dump the assoc and packet */
            if system_base_info.sctpsysctl.sctp_debug_on & 0x400u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"COOKIE-ECHO: AUTH failed\n\x00" as *const u8 as *const libc::c_char,
                    );
                }
            }
            sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x15i32);
            return 0 as *mut sctp_tcb;
        } else {
            /* remaining chunks checked... good to go */
            (*stcb).asoc.authenticated = 1u8
        }
    }
    /*
     * if we're doing ASCONFs, check to see if we have any new local
     * addresses that need to get added to the peer (eg. addresses
     * changed while cookie echo in flight).  This needs to be done
     * after we go to the OPEN state to do the correct asconf
     * processing. else, make sure we have the correct addresses in our
     * lists
     */
    /* warning, we re-use sin, sin6, sa_store here! */
    /* pull in local_address (our "from" address) */
    match (*cookie).laddr_type {
        5 => {
            /* source addr is IPv4 */
            memset(
                &mut store.sin as *mut sockaddr_in as *mut libc::c_void,
                0i32,
                ::std::mem::size_of::<sockaddr_in>() as libc::c_ulong,
            );
            store.sin.sin_family = 2u16;
            store.sin.sin_addr.s_addr = (*cookie).laddress[0usize]
        }
        6 => {
            /* source addr is IPv6 */
            memset(
                &mut store.sin6 as *mut sockaddr_in6 as *mut libc::c_void,
                0i32,
                ::std::mem::size_of::<sockaddr_in6>() as libc::c_ulong,
            );
            store.sin6.sin6_family = 10u16;
            store.sin6.sin6_scope_id = (*cookie).scope_id;
            memcpy(
                &mut store.sin6.sin6_addr as *mut in6_addr as *mut libc::c_void,
                (*cookie).laddress.as_mut_ptr() as *const libc::c_void,
                ::std::mem::size_of::<in6_addr>() as libc::c_ulong,
            );
        }
        4 => {
            /* source addr is conn */
            memset(
                &mut store.sconn as *mut sockaddr_conn as *mut libc::c_void,
                0i32,
                ::std::mem::size_of::<sockaddr_conn>() as libc::c_ulong,
            );
            store.sconn.sconn_family = 123u16;
            memcpy(
                &mut store.sconn.sconn_addr as *mut *mut libc::c_void as *mut libc::c_void,
                (*cookie).laddress.as_mut_ptr() as *const libc::c_void,
                ::std::mem::size_of::<*mut libc::c_void>() as libc::c_ulong,
            );
        }
        _ => {
            sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x16i32);
            return 0 as *mut sctp_tcb;
        }
    }
    /* update current state */
    if system_base_info.sctpsysctl.sctp_debug_on & 0x2000u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"moving to OPEN state\n\x00" as *const u8 as *const libc::c_char,
            );
        }
    }
    sctp_set_state(stcb, 0x8i32);
    if (*asoc).state & 0x80i32 != 0 {
        sctp_timer_start(11i32, (*stcb).sctp_ep, stcb, (*asoc).primary_destination);
    }
    sctp_stop_all_cookie_timers(stcb);
    ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_passiveestab, 1u32);
    ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_currestab, 1u32);
    /* set up to notify upper layer */
    *notification = 1i32;
    if ((*(*stcb).sctp_ep).sctp_flags & 0x2u32 != 0
        || (*(*stcb).sctp_ep).sctp_flags & 0x400000u32 != 0)
        && !((*inp).sctp_flags & 0x8u32 != 0u32)
    {
        /*
         * This is an endpoint that called connect() how it got a
         * cookie that is NEW is a bit of a mystery. It must be that
         * the INIT was sent, but before it got there.. a complete
         * INIT/INIT-ACK/COOKIE arrived. But of course then it
         * should have went to the other code.. not here.. oh well..
         * a bit of protection is worth having..
         */
        (*(*stcb).sctp_ep).sctp_flags |= 0x200000u32;
        soisconnected((*stcb).sctp_socket);
    } else {
        ((*(*stcb).sctp_ep).sctp_flags & 0x2u32 != 0) && (*inp).sctp_flags & 0x8u32 != 0u32;
    }
    /* since we did not send a HB make sure we don't double things */
    if !netp.is_null() && !(*netp).is_null() {
        (**netp).hb_responded = 1u8
    }
    if (*stcb).asoc.sctp_autoclose_ticks != 0 && (*inp).sctp_features & 0x200u64 == 0x200u64 {
        sctp_timer_start(12i32, inp, stcb, 0 as *mut sctp_nets);
    }
    gettimeofday(&mut (*stcb).asoc.time_entered, 0 as *mut timezone);
    if !netp.is_null() && !(*netp).is_null() {
        let mut old = timeval {
            tv_sec: 0,
            tv_usec: 0,
        };
        /* calculate the RTT and set the encaps port */
        old.tv_sec = (*cookie).time_entered.tv_sec;
        old.tv_usec = (*cookie).time_entered.tv_usec;
        sctp_calculate_rto(stcb, asoc, *netp, &mut old, 0i32);
    }
    /* respond with a COOKIE-ACK */
    sctp_send_cookie_ack(stcb);
    /*
     * check the address lists for any ASCONFs that need to be sent
     * AFTER the cookie-ack is sent
     */
    sctp_check_address_list(
        stcb,
        m,
        (initack_offset as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<sctp_init_chunk>() as libc::c_ulong)
            as libc::c_int,
        (initack_limit as libc::c_ulong).wrapping_sub(
            (initack_offset as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<sctp_init_chunk>() as libc::c_ulong),
        ) as libc::c_int,
        &mut store.sa,
        (*cookie).local_scope as uint16_t,
        (*cookie).site_scope as uint16_t,
        (*cookie).ipv4_scope as uint16_t,
        (*cookie).loopback_scope as uint16_t,
    );
    return stcb;
}
/*
 * CODE LIKE THIS NEEDS TO RUN IF the peer supports the NAT extension, i.e
 * we NEED to make sure we are not already using the vtag. If so we
 * need to send back an ABORT-TRY-AGAIN-WITH-NEW-TAG No middle box bit!
    head = &SCTP_BASE_INFO(sctp_asochash)[SCTP_PCBHASH_ASOC(tag,
                                SCTP_BASE_INFO(hashasocmark))];
    LIST_FOREACH(stcb, head, sctp_asocs) {
            if ((stcb->asoc.my_vtag == tag) && (stcb->rport == rport) && (inp == stcb->sctp_ep))  {
               -- SEND ABORT - TRY AGAIN --
        }
    }
*/
/*
 * handles a COOKIE-ECHO message stcb: modified to either a new or left as
 * existing (non-NULL) TCB
 */
unsafe extern "C" fn sctp_handle_cookie_echo(
    mut m: *mut mbuf,
    mut iphlen: libc::c_int,
    mut offset: libc::c_int,
    mut src: *mut sockaddr,
    mut dst: *mut sockaddr,
    mut sh: *mut sctphdr,
    mut cp: *mut sctp_cookie_echo_chunk,
    mut inp_p: *mut *mut sctp_inpcb,
    mut stcb: *mut *mut sctp_tcb,
    mut netp: *mut *mut sctp_nets,
    mut auth_skipped: libc::c_int,
    mut auth_offset: uint32_t,
    mut auth_len: uint32_t,
    mut locked_tcb: *mut *mut sctp_tcb,
    mut vrf_id: uint32_t,
    mut port: uint16_t,
) -> *mut mbuf {
    let mut cookie = 0 as *mut sctp_state_cookie;
    let mut l_inp = 0 as *mut sctp_inpcb;
    let mut to = 0 as *mut sockaddr;
    let mut ep = 0 as *mut sctp_pcb;
    let mut m_sig = 0 as *mut mbuf;
    let mut calc_sig = [0; 20];
    let mut tmp_sig = [0u8; 20];
    let mut sig = 0 as *mut uint8_t;
    let mut cookie_ok = 0u8;
    let mut sig_offset = 0;
    let mut cookie_offset = 0;
    let mut cookie_len = 0;
    let mut now = timeval {
        tv_sec: 0,
        tv_usec: 0,
    };
    let mut time_expires = timeval {
        tv_sec: 0,
        tv_usec: 0,
    };
    let mut notification = 0i32;
    let mut netl = 0 as *mut sctp_nets;
    let mut had_a_existing_tcb = 0i32;
    let mut send_int_conf = 0i32;
    let mut m_at = 0 as *mut mbuf;
    let mut l_stcb = *stcb;

    if system_base_info.sctpsysctl.sctp_debug_on & 0x2000u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"sctp_handle_cookie: handling COOKIE-ECHO\n\x00" as *const u8
                    as *const libc::c_char,
            );
        }
    }
    if inp_p.is_null() {
        return 0 as *mut mbuf;
    }
    cookie = &mut (*cp).cookie;
    cookie_offset = (offset as libc::c_ulong)
        .wrapping_add(::std::mem::size_of::<sctp_chunkhdr>() as libc::c_ulong)
        as libc::c_uint;
    cookie_len = ntohs((*cp).ch.chunk_length) as libc::c_uint;
    if (cookie_len as libc::c_ulong)
        < (::std::mem::size_of::<sctp_cookie_echo_chunk>() as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<sctp_init_chunk>() as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<sctp_init_chunk>() as libc::c_ulong)
            .wrapping_add(20u64)
    {
        /* cookie too small */
        return 0 as *mut mbuf;
    }
    if (*cookie).peerport as libc::c_int != (*sh).src_port as libc::c_int
        || (*cookie).myport as libc::c_int != (*sh).dest_port as libc::c_int
        || (*cookie).my_vtag != (*sh).v_tag
    {
        /*
         * invalid ports or bad tag.  Note that we always leave the
         * v_tag in the header in network order and when we stored
         * it in the my_vtag slot we also left it in network order.
         * This maintains the match even though it may be in the
         * opposite byte order of the machine :->
         */
        return 0 as *mut mbuf;
    }
    /*
     * split off the signature into its own mbuf (since it should not be
     * calculated in the sctp_hmac_m() call).
     */
    sig_offset = (offset as libc::c_uint)
        .wrapping_add(cookie_len)
        .wrapping_sub(20u32);
    m_sig = m_split(m, sig_offset as libc::c_int, 0x1i32);
    if m_sig.is_null() {
        /* out of memory or ?? */
        return 0 as *mut mbuf;
    }
    /*
     * compute the signature/digest for the cookie
     */
    ep = &mut (**inp_p).sctp_ep;
    l_inp = *inp_p;
    if !l_stcb.is_null() {
        pthread_mutex_unlock(&mut (*l_stcb).tcb_mtx);
    }
    pthread_mutex_lock(&mut (*l_inp).inp_mtx);
    if !l_stcb.is_null() {
        pthread_mutex_lock(&mut (*l_stcb).tcb_mtx);
    }
    /* which cookie is it? */
    if (*cookie).time_entered.tv_sec < (*ep).time_of_secret_change as libc::c_long
        && (*ep).current_secret_number as libc::c_int != (*ep).last_secret_number as libc::c_int
    {
        /* it's the old cookie */
        sctp_hmac_m(
            0x1u16,
            (*ep).secret_key[(*ep).last_secret_number as libc::c_int as usize].as_mut_ptr()
                as *mut uint8_t,
            32u32,
            m,
            cookie_offset,
            calc_sig.as_mut_ptr(),
            0u32,
        );
    } else {
        /* it's the current cookie */
        sctp_hmac_m(
            0x1u16,
            (*ep).secret_key[(*ep).current_secret_number as libc::c_int as usize].as_mut_ptr()
                as *mut uint8_t,
            32u32,
            m,
            cookie_offset,
            calc_sig.as_mut_ptr(),
            0u32,
        );
    }
    /* get the signature */
    pthread_mutex_unlock(&mut (*l_inp).inp_mtx);
    sig = sctp_m_getptr(
        m_sig,
        0i32,
        20i32,
        &mut tmp_sig as *mut [uint8_t; 20] as *mut uint8_t,
    ) as *mut uint8_t;
    if sig.is_null() {
        /* couldn't find signature */
        m_freem(m_sig);
        return 0 as *mut mbuf;
    }
    /* compare the received digest with the computed digest */
    if timingsafe_bcmp(
        calc_sig.as_mut_ptr() as *const libc::c_void,
        sig as *const libc::c_void,
        20u64,
    ) != 0i32
    {
        /* try the old cookie? */
        if (*cookie).time_entered.tv_sec == (*ep).time_of_secret_change as libc::c_long
            && (*ep).current_secret_number as libc::c_int != (*ep).last_secret_number as libc::c_int
        {
            /* compute digest with old */
            sctp_hmac_m(
                0x1u16,
                (*ep).secret_key[(*ep).last_secret_number as libc::c_int as usize].as_mut_ptr()
                    as *mut uint8_t,
                32u32,
                m,
                cookie_offset,
                calc_sig.as_mut_ptr(),
                0u32,
            );
            /* compare */
            if timingsafe_bcmp(
                calc_sig.as_mut_ptr() as *const libc::c_void,
                sig as *const libc::c_void,
                20u64,
            ) == 0i32
            {
                cookie_ok = 1u8
            }
        }
    } else {
        cookie_ok = 1u8
    }

    m_at = m;
    while !(*m_at).m_hdr.mh_next.is_null() {
        m_at = (*m_at).m_hdr.mh_next
    }
    (*m_at).m_hdr.mh_next = m_sig;
    if cookie_ok as libc::c_int == 0i32 {
        if system_base_info.sctpsysctl.sctp_debug_on & 0x2000u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"handle_cookie_echo: cookie signature validation failed!\n\x00" as *const u8
                        as *const libc::c_char,
                );
            }
        }
        if system_base_info.sctpsysctl.sctp_debug_on & 0x2000u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"offset = %u, cookie_offset = %u, sig_offset = %u\n\x00" as *const u8
                        as *const libc::c_char,
                    offset as uint32_t,
                    cookie_offset,
                    sig_offset,
                );
            }
        }
        return 0 as *mut mbuf;
    }
    /*
     * check the cookie timestamps to be sure it's not stale
     */
    gettimeofday(&mut now, 0 as *mut timezone);
    /* Expire time is in Ticks, so we convert to seconds */
    time_expires.tv_sec = (*cookie).time_entered.tv_sec
        + (*cookie)
            .cookie_life
            .wrapping_add((hz - 1i32) as libc::c_uint)
            .wrapping_div(hz as libc::c_uint) as libc::c_long;
    time_expires.tv_usec = (*cookie).time_entered.tv_usec;
    if if now.tv_sec == time_expires.tv_sec {
        (now.tv_usec > time_expires.tv_usec) as libc::c_int
    } else {
        (now.tv_sec > time_expires.tv_sec) as libc::c_int
    } != 0
    {
        let mut op_err = 0 as *mut mbuf;
        let mut cause = 0 as *mut sctp_error_stale_cookie;
        let mut diff = timeval {
            tv_sec: 0,
            tv_usec: 0,
        };
        let mut staleness = 0;
        op_err = sctp_get_mbuf_for_msg(
            ::std::mem::size_of::<sctp_error_stale_cookie>() as libc::c_uint,
            0i32,
            0x1i32,
            1i32,
            1i32,
        );
        if op_err.is_null() {
            /* FOOBAR */
            return 0 as *mut mbuf;
        }
        /* Set the len */
        (*op_err).m_hdr.mh_len = ::std::mem::size_of::<sctp_error_stale_cookie>() as libc::c_int;
        cause = (*op_err).m_hdr.mh_data as *mut sctp_error_stale_cookie;
        (*cause).cause.code = htons(0x3u16);
        (*cause).cause.length = htons(
            (::std::mem::size_of::<sctp_paramhdr>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<uint32_t>() as libc::c_ulong)
                as uint16_t,
        );
        diff.tv_sec = now.tv_sec - time_expires.tv_sec;
        diff.tv_usec = now.tv_usec - time_expires.tv_usec;
        if diff.tv_usec < 0i64 {
            diff.tv_sec -= 1;
            diff.tv_usec += 1000000i64
        }
        if diff.tv_sec as uint32_t > (4294967295u32).wrapping_div(1000000u32) {
            staleness = 4294967295u32
        } else {
            staleness = (diff.tv_sec * 1000000i64) as uint32_t
        }
        if (4294967295u32).wrapping_sub(staleness) >= diff.tv_usec as uint32_t {
            staleness = (staleness as libc::c_long + diff.tv_usec) as uint32_t
        } else {
            staleness = 4294967295u32
        }
        (*cause).stale_time = htonl(staleness);
        sctp_send_operr_to(src, dst, sh, (*cookie).peers_vtag, op_err, vrf_id, port);
        return 0 as *mut mbuf;
    }
    /*
     * Now we must see with the lookup address if we have an existing
     * asoc. This will only happen if we were in the COOKIE-WAIT state
     * and a INIT collided with us and somewhere the peer sent the
     * cookie on another address besides the single address our assoc
     * had for him. In this case we will have one of the tie-tags set at
     * least AND the address field in the cookie can be used to look it
     * up.
     */
    to = 0 as *mut sockaddr;
    match (*cookie).addr_type {
        6 => {
            let mut sin6 = sockaddr_in6 {
                sin6_family: 0,
                sin6_port: 0,
                sin6_flowinfo: 0,
                sin6_addr: in6_addr {
                    __in6_u: C2RustUnnamed_330 {
                        __u6_addr8: [0; 16],
                    },
                },
                sin6_scope_id: 0,
            };
            memset(
                &mut sin6 as *mut sockaddr_in6 as *mut libc::c_void,
                0i32,
                ::std::mem::size_of::<sockaddr_in6>() as libc::c_ulong,
            );
            sin6.sin6_family = 10u16;
            sin6.sin6_port = (*sh).src_port;
            sin6.sin6_scope_id = (*cookie).scope_id;
            memcpy(
                &mut sin6.sin6_addr.__in6_u.__u6_addr8 as *mut [uint8_t; 16] as *mut libc::c_void,
                (*cookie).address.as_mut_ptr() as *const libc::c_void,
                ::std::mem::size_of::<[uint8_t; 16]>() as libc::c_ulong,
            );
            to = &mut sin6 as *mut sockaddr_in6 as *mut sockaddr
        }
        5 => {
            let mut sin = sockaddr_in {
                sin_family: 0,
                sin_port: 0,
                sin_addr: in_addr { s_addr: 0 },
                sin_zero: [0; 8],
            };
            memset(
                &mut sin as *mut sockaddr_in as *mut libc::c_void,
                0i32,
                ::std::mem::size_of::<sockaddr_in>() as libc::c_ulong,
            );
            sin.sin_family = 2u16;
            sin.sin_port = (*sh).src_port;
            sin.sin_addr.s_addr = (*cookie).address[0usize];
            to = &mut sin as *mut sockaddr_in as *mut sockaddr
        }
        4 => {
            let mut sconn = sockaddr_conn {
                sconn_family: 0,
                sconn_port: 0,
                sconn_addr: 0 as *mut libc::c_void,
            };
            memset(
                &mut sconn as *mut sockaddr_conn as *mut libc::c_void,
                0i32,
                ::std::mem::size_of::<sockaddr_conn>() as libc::c_ulong,
            );
            sconn.sconn_family = 123u16;
            sconn.sconn_port = (*sh).src_port;
            memcpy(
                &mut sconn.sconn_addr as *mut *mut libc::c_void as *mut libc::c_void,
                (*cookie).address.as_mut_ptr() as *const libc::c_void,
                ::std::mem::size_of::<*mut libc::c_void>() as libc::c_ulong,
            );
            to = &mut sconn as *mut sockaddr_conn as *mut sockaddr
        }
        _ => {
            /* This should not happen */
            return 0 as *mut mbuf;
        }
    }
    if (*stcb).is_null() {
        /* Yep, lets check */
        *stcb = sctp_findassociation_ep_addr(inp_p, to, netp, dst, 0 as *mut sctp_tcb);
        if (*stcb).is_null() {
            /*
             * We should have only got back the same inp. If we
             * got back a different ep we have a problem. The
             * original findep got back l_inp and now
             */
            if l_inp != *inp_p {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"Bad problem find_ep got a diff inp then special_locate?\n\x00"
                            as *const u8 as *const libc::c_char,
                    );
                }
            }
        } else if (*locked_tcb).is_null() {
            /* In this case we found the assoc only
             * after we locked the create lock. This means
             * we are in a colliding case and we must make
             * sure that we unlock the tcb if its one of the
             * cases where we throw away the incoming packets.
             */
            *locked_tcb = *stcb;
            /* We must also increment the inp ref count
             * since the ref_count flags was set when we
             * did not find the TCB, now we found it which
             * reduces the refcount.. we must raise it back
             * out to balance it all :-)
             */
            ::std::intrinsics::atomic_xadd(&mut (*(**stcb).sctp_ep).refcount, 1i32);
            if (**stcb).sctp_ep != l_inp {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"Huh? ep:%p diff then l_inp:%p?\n\x00" as *const u8 as *const libc::c_char,
                        (**stcb).sctp_ep as *mut libc::c_void,
                        l_inp as *mut libc::c_void,
                    );
                }
            }
        }
    }
    cookie_len = cookie_len.wrapping_sub(20u32);
    if (*stcb).is_null() {
        /* this is the "normal" case... get a new TCB */
        *stcb = sctp_process_cookie_new(
            m,
            iphlen,
            offset,
            src,
            dst,
            sh,
            cookie,
            cookie_len as libc::c_int,
            *inp_p,
            netp,
            to,
            &mut notification,
            auth_skipped,
            auth_offset,
            auth_len,
            vrf_id,
            port,
        )
    } else {
        /* this is abnormal... cookie-echo on existing TCB */
        had_a_existing_tcb = 1i32;
        *stcb = sctp_process_cookie_existing(
            m,
            iphlen,
            offset,
            src,
            dst,
            sh,
            cookie,
            cookie_len as libc::c_int,
            *inp_p,
            *stcb,
            netp,
            to,
            &mut notification,
            auth_skipped,
            auth_offset,
            auth_len,
            vrf_id,
            port,
        )
    }
    if (*stcb).is_null() {
        /* still no TCB... must be bad cookie-echo */
        return 0 as *mut mbuf;
    }
    /*
     * Ok, we built an association so confirm the address we sent the
     * INIT-ACK to.
     */
    netl = sctp_findnet(*stcb, to);
    /*
     * This code should in theory NOT run but
     */
    if netl.is_null() {
        /* TSNH! Huh, why do I need to add this address here? */
        if sctp_add_remote_addr(*stcb, to, 0 as *mut *mut sctp_nets, port, 0i32, 100i32) != 0 {
            return 0 as *mut mbuf;
        }
        netl = sctp_findnet(*stcb, to)
    }
    if !netl.is_null() {
        if (*netl).dest_state as libc::c_int & 0x200i32 != 0 {
            (*netl).dest_state = ((*netl).dest_state as libc::c_int & !(0x200i32)) as uint16_t;
            sctp_set_primary_addr(*stcb, 0 as *mut sockaddr, netl);
            send_int_conf = 1i32
        }
    }
    sctp_start_net_timers(*stcb);
    if (**inp_p).sctp_flags & 0x2u32 != 0 {
        if had_a_existing_tcb == 0 || (**inp_p).sctp_flags & 0x200000u32 == 0u32 {
            let mut so = 0 as *mut socket;
            let mut oso = 0 as *mut socket;
            let mut inp = 0 as *mut sctp_inpcb;
            if notification == 10i32 {
                /*
                 * For a restart we will keep the same
                 * socket, no need to do anything. I THINK!!
                 */
                sctp_ulp_notify(
                    notification as uint32_t,
                    *stcb,
                    0u32,
                    0 as *mut libc::c_void,
                    0i32,
                );
                if send_int_conf != 0 {
                    sctp_ulp_notify(16u32, *stcb, 0u32, netl as *mut libc::c_void, 0i32);
                }
                return m;
            }
            oso = (**inp_p).sctp_socket;
            ::std::intrinsics::atomic_xadd(&mut (**stcb).asoc.refcnt, 1u32);
            pthread_mutex_unlock(&mut (**stcb).tcb_mtx);
            so = sonewconn(oso, 0i32);
            pthread_mutex_lock(&mut (**stcb).tcb_mtx);
            ::std::intrinsics::atomic_xsub(&mut (**stcb).asoc.refcnt, 1u32);
            if so.is_null() {
                let mut op_err_0 = 0 as *mut mbuf;
                /* Too many sockets */
                if system_base_info.sctpsysctl.sctp_debug_on & 0x1000u32 != 0 {
                    if system_base_info.debug_printf.is_some() {
                        system_base_info
                            .debug_printf
                            .expect("non-null function pointer")(
                            b"process_cookie_new: no room for another socket!\n\x00" as *const u8
                                as *const libc::c_char,
                        );
                    }
                }
                op_err_0 = sctp_generate_cause(0x4u16, b"\x00" as *const u8 as *mut libc::c_char);
                sctp_abort_association(
                    *inp_p,
                    0 as *mut sctp_tcb,
                    m,
                    iphlen,
                    src,
                    dst,
                    sh,
                    op_err_0,
                    vrf_id,
                    port,
                );
                sctp_free_assoc(*inp_p, *stcb, 0i32, 0x10000000i32 + 0x17i32);
                return 0 as *mut mbuf;
            }
            inp = (*so).so_pcb as *mut sctp_inpcb;
            ::std::intrinsics::atomic_xadd(&mut (*inp).refcount, 1i32);
            /*
             * We add the unbound flag here so that
             * if we get an soabort() before we get the
             * move_pcb done, we will properly cleanup.
             */
            (*inp).sctp_flags = (0x2i32 | 0x200000i32 | 0x400000i32 | 0x10i32) as libc::c_uint
                | ((0x4i32 | 0x2000000i32 | 0x4000000i32) as libc::c_uint | 0x80000000u32)
                    & (**inp_p).sctp_flags
                | 0x800000u32;
            (*inp).sctp_features = (**inp_p).sctp_features;
            (*inp).sctp_mobility_features = (**inp_p).sctp_mobility_features;
            (*inp).sctp_socket = so;
            (*inp).sctp_frag_point = (**inp_p).sctp_frag_point;
            (*inp).max_cwnd = (**inp_p).max_cwnd;
            (*inp).sctp_cmt_on_off = (**inp_p).sctp_cmt_on_off;
            (*inp).ecn_supported = (**inp_p).ecn_supported;
            (*inp).prsctp_supported = (**inp_p).prsctp_supported;
            (*inp).auth_supported = (**inp_p).auth_supported;
            (*inp).asconf_supported = (**inp_p).asconf_supported;
            (*inp).reconfig_supported = (**inp_p).reconfig_supported;
            (*inp).nrsack_supported = (**inp_p).nrsack_supported;
            (*inp).pktdrop_supported = (**inp_p).pktdrop_supported;
            (*inp).partial_delivery_point = (**inp_p).partial_delivery_point;
            (*inp).sctp_context = (**inp_p).sctp_context;
            (*inp).local_strreset_support = (**inp_p).local_strreset_support;
            (*inp).fibnum = (**inp_p).fibnum;
            (*inp).inp_starting_point_for_iterator = 0 as *mut sctp_iterator;
            (*inp).ulp_info = (**inp_p).ulp_info;
            (*inp).recv_callback = (**inp_p).recv_callback;
            (*inp).send_callback = (**inp_p).send_callback;
            (*inp).send_sb_threshold = (**inp_p).send_sb_threshold;
            /*
             * copy in the authentication parameters from the
             * original endpoint
             */
            if !(*inp).sctp_ep.local_hmacs.is_null() {
                sctp_free_hmaclist((*inp).sctp_ep.local_hmacs);
            }
            (*inp).sctp_ep.local_hmacs = sctp_copy_hmaclist((**inp_p).sctp_ep.local_hmacs);
            if !(*inp).sctp_ep.local_auth_chunks.is_null() {
                sctp_free_chunklist((*inp).sctp_ep.local_auth_chunks);
            }
            (*inp).sctp_ep.local_auth_chunks =
                sctp_copy_chunklist((**inp_p).sctp_ep.local_auth_chunks);
            /*
             * Now we must move it from one hash table to
             * another and get the tcb in the right place.
             */
            /* This is where the one-2-one socket is put into
             * the accept state waiting for the accept!
             */
            if !(*stcb).is_null() {
                sctp_add_substate(*stcb, 0x1000i32);
            }
            sctp_move_pcb_and_assoc(*inp_p, inp, *stcb);
            ::std::intrinsics::atomic_xadd(&mut (**stcb).asoc.refcnt, 1u32);
            pthread_mutex_unlock(&mut (**stcb).tcb_mtx);
            sctp_pull_off_control_to_new_inp(*inp_p, inp, *stcb, 0x1i32);
            pthread_mutex_lock(&mut (**stcb).tcb_mtx);
            ::std::intrinsics::atomic_xsub(&mut (**stcb).asoc.refcnt, 1u32);
            /* now we must check to see if we were aborted while
             * the move was going on and the lock/unlock happened.
             */
            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                /* yep it was, we leave the
                 * assoc attached to the socket since
                 * the sctp_inpcb_free() call will send
                 * an abort for us.
                 */
                ::std::intrinsics::atomic_xadd(&mut (*inp).refcount, -(1i32));
                return 0 as *mut mbuf;
            }
            ::std::intrinsics::atomic_xadd(&mut (*inp).refcount, -(1i32));
            /* Switch over to the new guy */
            *inp_p = inp;
            sctp_ulp_notify(
                notification as uint32_t,
                *stcb,
                0u32,
                0 as *mut libc::c_void,
                0i32,
            );
            if send_int_conf != 0 {
                sctp_ulp_notify(16u32, *stcb, 0u32, netl as *mut libc::c_void, 0i32);
            }
            /* Pull it from the incomplete queue and wake the guy */
            soisconnected(so);
            return m;
        }
    }
    if notification != 0 {
        sctp_ulp_notify(
            notification as uint32_t,
            *stcb,
            0u32,
            0 as *mut libc::c_void,
            0i32,
        );
    }
    if send_int_conf != 0 {
        sctp_ulp_notify(16u32, *stcb, 0u32, netl as *mut libc::c_void, 0i32);
    }
    return m;
}
unsafe extern "C" fn sctp_handle_cookie_ack(
    mut cp: *mut sctp_cookie_ack_chunk,
    mut stcb: *mut sctp_tcb,
    mut net: *mut sctp_nets,
) {
    let mut asoc = 0 as *mut sctp_association;
    if system_base_info.sctpsysctl.sctp_debug_on & 0x2000u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"sctp_handle_cookie_ack: handling COOKIE-ACK\n\x00" as *const u8
                    as *const libc::c_char,
            );
        }
    }
    if stcb.is_null() || net.is_null() {
        return;
    }
    asoc = &mut (*stcb).asoc;
    if system_base_info.sctpsysctl.sctp_logging_level & 0x2000000u32 != 0 {
        sctp_misc_ints(
            120u8,
            (*asoc).overall_error_count,
            0u32,
            0x10000000u32,
            3160u32,
        );
    }
    (*asoc).overall_error_count = 0u32;
    sctp_stop_all_cookie_timers(stcb);
    /* process according to association state */
    if (*stcb).asoc.state & 0x7fi32 == 0x4i32 {
        /* state change only needed when I am in right state */
        if system_base_info.sctpsysctl.sctp_debug_on & 0x2000u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"moving to OPEN state\n\x00" as *const u8 as *const libc::c_char,
                );
            }
        }
        sctp_set_state(stcb, 0x8i32);
        sctp_start_net_timers(stcb);
        if (*asoc).state & 0x80i32 != 0 {
            sctp_timer_start(11i32, (*stcb).sctp_ep, stcb, (*asoc).primary_destination);
        }
        /* update RTO */
        ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_activeestab, 1u32);
        ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_currestab, 1u32);
        if (*asoc).overall_error_count == 0u32 {
            sctp_calculate_rto(stcb, asoc, net, &mut (*asoc).time_entered, 0i32);
        }
        gettimeofday(&mut (*asoc).time_entered, 0 as *mut timezone);
        sctp_ulp_notify(1u32, stcb, 0u32, 0 as *mut libc::c_void, 0i32);
        if (*(*stcb).sctp_ep).sctp_flags & 0x2u32 != 0
            || (*(*stcb).sctp_ep).sctp_flags & 0x400000u32 != 0
        {
            (*(*stcb).sctp_ep).sctp_flags |= 0x200000u32;
            if (*stcb).asoc.state & 0x100i32 == 0i32 {
                soisconnected((*stcb).sctp_socket);
            }
        }
        /*
         * since we did not send a HB make sure we don't double
         * things
         */
        (*net).hb_responded = 1u8;
        if !((*stcb).asoc.state & 0x100i32 != 0) {
            sctp_timer_start(5i32, (*stcb).sctp_ep, stcb, net);
            if (*stcb).asoc.sctp_autoclose_ticks != 0
                && (*(*stcb).sctp_ep).sctp_features & 0x200u64 == 0x200u64
            {
                sctp_timer_start(12i32, (*stcb).sctp_ep, stcb, 0 as *mut sctp_nets);
            }
            /*
             * send ASCONF if parameters are pending and ASCONFs are
             * allowed (eg. addresses changed when init/cookie echo were
             * in flight)
             */
            if (*(*stcb).sctp_ep).sctp_features & 0x20u64 == 0x20u64
                && (*stcb).asoc.asconf_supported as libc::c_int == 1i32
                && !(*stcb).asoc.asconf_queue.tqh_first.is_null()
            {
                sctp_send_asconf(stcb, (*stcb).asoc.primary_destination, 0i32);
            }
        }
    }
    /* We don't need to do the asconf thing,
     * nor hb or autoclose if the socket is closed.
     */
    /* Toss the cookie if I can */
    sctp_toss_old_cookies(stcb, asoc);
    if !(*asoc).sent_queue.tqh_first.is_null() {
        let mut chk = 0 as *mut sctp_tmit_chunk;
        chk = (*asoc).sent_queue.tqh_first;
        sctp_timer_start(1i32, (*stcb).sctp_ep, stcb, (*chk).whoTo);
    };
}
unsafe extern "C" fn sctp_handle_ecn_echo(mut cp: *mut sctp_ecne_chunk, mut stcb: *mut sctp_tcb) {
    let mut net = 0 as *mut sctp_nets;
    let mut lchk = 0 as *mut sctp_tmit_chunk;
    let mut override_bit = 0;
    let mut tsn = 0;
    let mut window_data_tsn = 0;
    let mut len = 0;
    let mut pkt_cnt = 0;
    len = ntohs((*cp).ch.chunk_length) as libc::c_int;
    if len as libc::c_ulong != ::std::mem::size_of::<sctp_ecne_chunk>() as libc::c_ulong
        && len as libc::c_ulong != ::std::mem::size_of::<old_sctp_ecne_chunk>() as libc::c_ulong
    {
        return;
    }
    if len as libc::c_ulong == ::std::mem::size_of::<old_sctp_ecne_chunk>() as libc::c_ulong {
        let mut bkup = sctp_ecne_chunk {
            ch: sctp_chunkhdr {
                chunk_type: 0,
                chunk_flags: 0,
                chunk_length: 0,
            },
            tsn: 0,
            num_pkts_since_cwr: 0,
        };
        memcpy(
            &mut bkup as *mut sctp_ecne_chunk as *mut libc::c_void,
            cp as *const libc::c_void,
            ::std::mem::size_of::<old_sctp_ecne_chunk>() as libc::c_ulong,
        );
        bkup.num_pkts_since_cwr = htonl(1u32);
        cp = &mut bkup
    }
    ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_recvecne, 1u32);
    tsn = ntohl((*cp).tsn);
    pkt_cnt = ntohl((*cp).num_pkts_since_cwr);
    lchk = *(*((*stcb).asoc.send_queue.tqh_last as *mut sctpchunk_listhead)).tqh_last;
    if lchk.is_null() {
        window_data_tsn = (*stcb).asoc.sending_seq.wrapping_sub(1u32)
    } else {
        window_data_tsn = (*lchk).rec.data.tsn
    }
    /* Find where it was sent to if possible. */
    net = 0 as *mut sctp_nets;
    lchk = (*stcb).asoc.sent_queue.tqh_first;
    while !lchk.is_null() {
        if (*lchk).rec.data.tsn == tsn {
            net = (*lchk).whoTo;
            (*net).ecn_prev_cwnd = (*lchk).rec.data.cwnd_at_send;
            break;
        } else {
            if (*lchk).rec.data.tsn < tsn
                && tsn.wrapping_sub((*lchk).rec.data.tsn) > (1u32) << 31i32
                || (*lchk).rec.data.tsn > tsn
                    && (*lchk).rec.data.tsn.wrapping_sub(tsn) < (1u32) << 31i32
            {
                break;
            }
            lchk = (*lchk).sctp_next.tqe_next
        }
    }
    if net.is_null() {
        /*
         * What to do. A previous send of a
         * CWR was possibly lost. See how old it is, we
         * may have it marked on the actual net.
         */
        net = (*stcb).asoc.nets.tqh_first;
        while !net.is_null() {
            if tsn == (*net).last_cwr_tsn {
                break;
            }
            net = (*net).sctp_next.tqe_next
        }
        if net.is_null() {
            /*
             * If we reach here, we need to send a special
             * CWR that says hey, we did this a long time
             * ago and you lost the response.
             */
            net = (*stcb).asoc.nets.tqh_first;
            if net.is_null() {
                /* TSNH */
                return;
            }
            override_bit = 0x1u8
        } else {
            override_bit = 0u8
        }
    } else {
        override_bit = 0u8
    }
    if (tsn < (*net).cwr_window_tsn && (*net).cwr_window_tsn.wrapping_sub(tsn) > (1u32) << 31i32
        || tsn > (*net).cwr_window_tsn && tsn.wrapping_sub((*net).cwr_window_tsn) < (1u32) << 31i32)
        && override_bit as libc::c_int & 0x1i32 == 0i32
    {
        /* JRS - Use the congestion control given in the pluggable CC module */
        (*stcb)
            .asoc
            .cc_functions
            .sctp_cwnd_update_after_ecn_echo
            .expect("non-null function pointer")(stcb, net, 0i32, pkt_cnt as libc::c_int);
        /*
         * We reduce once every RTT. So we will only lower cwnd at
         * the next sending seq i.e. the window_data_tsn
         */
        (*net).cwr_window_tsn = window_data_tsn;
        (*net).ecn_ce_pkt_cnt = ((*net).ecn_ce_pkt_cnt).wrapping_add(pkt_cnt);
        (*net).lost_cnt = pkt_cnt;
        (*net).last_cwr_tsn = tsn
    } else {
        override_bit = (override_bit as libc::c_int | 0x2i32) as uint8_t;
        if (tsn < (*net).last_cwr_tsn && (*net).last_cwr_tsn.wrapping_sub(tsn) > (1u32) << 31i32
            || tsn > (*net).last_cwr_tsn && tsn.wrapping_sub((*net).last_cwr_tsn) < (1u32) << 31i32)
            && override_bit as libc::c_int & 0x1i32 == 0i32
        {
            let mut cnt = 1i32;
            if pkt_cnt > (*net).lost_cnt {
                /* Should be the case */
                cnt = pkt_cnt.wrapping_sub((*net).lost_cnt) as libc::c_int;
                (*net).ecn_ce_pkt_cnt = ((*net).ecn_ce_pkt_cnt).wrapping_add(cnt as libc::c_uint)
            }
            (*net).lost_cnt = pkt_cnt;
            (*net).last_cwr_tsn = tsn;
            /*
             * Most CC functions will ignore this call, since we are in-window
             * yet of the initial CE the peer saw.
             */
            (*stcb)
                .asoc
                .cc_functions
                .sctp_cwnd_update_after_ecn_echo
                .expect("non-null function pointer")(stcb, net, 1i32, cnt);
        }
    }
    /*
     * We always send a CWR this way if our previous one was lost our
     * peer will get an update, or if it is not time again to reduce we
     * still get the cwr to the peer. Note we set the override when we
     * could not find the TSN on the chunk or the destination network.
     */
    sctp_send_cwr(stcb, net, (*net).last_cwr_tsn, override_bit);
}
unsafe extern "C" fn sctp_handle_ecn_cwr(
    mut cp: *mut sctp_cwr_chunk,
    mut stcb: *mut sctp_tcb,
    mut net: *mut sctp_nets,
) {
    let mut chk = 0 as *mut sctp_tmit_chunk;
    let mut nchk = 0 as *mut sctp_tmit_chunk;
    let mut override_0 = 0;
    let mut cwr_tsn = 0;
    cwr_tsn = ntohl((*cp).tsn);
    override_0 = (*cp).ch.chunk_flags as libc::c_int & 0x1i32;
    chk = (*stcb).asoc.control_send_queue.tqh_first;
    while !chk.is_null() && {
        nchk = (*chk).sctp_next.tqe_next;
        (1i32) != 0
    } {
        if !((*chk).rec.chunk_id.id as libc::c_int != 0xci32) {
            if !(override_0 == 0i32 && (*chk).whoTo != net) {
                let mut ecne = 0 as *mut sctp_ecne_chunk;
                ecne = (*(*chk).data).m_hdr.mh_data as *mut sctp_ecne_chunk;
                if cwr_tsn < ntohl((*ecne).tsn)
                    && ntohl((*ecne).tsn).wrapping_sub(cwr_tsn) > (1u32) << 31i32
                    || cwr_tsn > ntohl((*ecne).tsn)
                        && cwr_tsn.wrapping_sub(ntohl((*ecne).tsn)) < (1u32) << 31i32
                    || cwr_tsn == ntohl((*ecne).tsn)
                {
                    /* this covers this ECNE, we can remove it */
                    (*stcb).asoc.ecn_echo_cnt_onq = (*stcb).asoc.ecn_echo_cnt_onq.wrapping_sub(1);
                    if !(*chk).sctp_next.tqe_next.is_null() {
                        (*(*chk).sctp_next.tqe_next).sctp_next.tqe_prev = (*chk).sctp_next.tqe_prev
                    } else {
                        (*stcb).asoc.control_send_queue.tqh_last = (*chk).sctp_next.tqe_prev
                    }
                    *(*chk).sctp_next.tqe_prev = (*chk).sctp_next.tqe_next;
                    (*stcb).asoc.ctrl_queue_cnt -= 1;
                    m_freem((*chk).data);
                    (*chk).data = 0 as *mut mbuf;
                    if (*chk).holds_key_ref != 0 {
                        sctp_auth_key_release(stcb, (*chk).auth_keyid, 0i32);
                        (*chk).holds_key_ref = 0u8
                    }
                    if !stcb.is_null() {
                        if !(*chk).whoTo.is_null() {
                            if !(*chk).whoTo.is_null() {
                                if ::std::intrinsics::atomic_xadd(
                                    &mut (*(*chk).whoTo).ref_count as *mut libc::c_int,
                                    -(1i32),
                                ) == 1i32
                                {
                                    sctp_os_timer_stop(&mut (*(*chk).whoTo).rxt_timer.timer);
                                    sctp_os_timer_stop(&mut (*(*chk).whoTo).pmtu_timer.timer);
                                    sctp_os_timer_stop(&mut (*(*chk).whoTo).hb_timer.timer);
                                    if !(*(*chk).whoTo).ro.ro_rt.is_null() {
                                        if (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt <= 1i64 {
                                            sctp_userspace_rtfree((*(*chk).whoTo).ro.ro_rt);
                                        } else {
                                            (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt -= 1
                                        }
                                        (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t;
                                        (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t
                                    }
                                    if (*(*chk).whoTo).src_addr_selected != 0 {
                                        sctp_free_ifa((*(*chk).whoTo).ro._s_addr);
                                        (*(*chk).whoTo).ro._s_addr = 0 as *mut sctp_ifa
                                    }
                                    (*(*chk).whoTo).src_addr_selected = 0u8;
                                    (*(*chk).whoTo).dest_state =
                                        ((*(*chk).whoTo).dest_state as libc::c_int & !(0x1i32))
                                            as uint16_t;
                                    free((*chk).whoTo as *mut libc::c_void);
                                    ::std::intrinsics::atomic_xsub(
                                        &mut system_base_info.sctppcbinfo.ipi_count_raddr,
                                        1u32,
                                    );
                                }
                            }
                            (*chk).whoTo = 0 as *mut sctp_nets
                        }
                        if (*stcb).asoc.free_chunk_cnt as libc::c_uint
                            > system_base_info.sctpsysctl.sctp_asoc_free_resc_limit
                            || system_base_info.sctppcbinfo.ipi_free_chunks
                                > system_base_info.sctpsysctl.sctp_system_free_resc_limit
                        {
                            free(chk as *mut libc::c_void);
                            ::std::intrinsics::atomic_xsub(
                                &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                                1u32,
                            );
                        } else {
                            (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
                            (*chk).sctp_next.tqe_prev = (*stcb).asoc.free_chunks.tqh_last;
                            *(*stcb).asoc.free_chunks.tqh_last = chk;
                            (*stcb).asoc.free_chunks.tqh_last = &mut (*chk).sctp_next.tqe_next;
                            (*stcb).asoc.free_chunk_cnt =
                                (*stcb).asoc.free_chunk_cnt.wrapping_add(1);
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctppcbinfo.ipi_free_chunks,
                                1u32,
                            );
                        }
                    } else {
                        free(chk as *mut libc::c_void);
                        ::std::intrinsics::atomic_xsub(
                            &mut system_base_info.sctppcbinfo.ipi_count_chunk,
                            1u32,
                        );
                    }
                    if override_0 == 0i32 {
                        break;
                    }
                }
            }
        }
        /* Must be from the right src unless override is set */
        chk = nchk
    }
}
unsafe extern "C" fn sctp_handle_shutdown_complete(
    mut cp: *mut sctp_shutdown_complete_chunk,
    mut stcb: *mut sctp_tcb,
    mut net: *mut sctp_nets,
) {
    if system_base_info.sctpsysctl.sctp_debug_on & 0x2000u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"sctp_handle_shutdown_complete: handling SHUTDOWN-COMPLETE\n\x00" as *const u8
                    as *const libc::c_char,
            );
        }
    }
    if stcb.is_null() {
        return;
    }
    /* process according to association state */
    if (*stcb).asoc.state & 0x7fi32 != 0x40i32 {
        /* unexpected SHUTDOWN-COMPLETE... so ignore... */
        if system_base_info.sctpsysctl.sctp_debug_on & 0x2000u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info.debug_printf.expect("non-null function pointer")(b"sctp_handle_shutdown_complete: not in SCTP_STATE_SHUTDOWN_ACK_SENT --- ignore\n\x00"
                                                                                      as
                                                                                      *const u8
                                                                                      as
                                                                                      *const libc::c_char);
            }
        }
        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
        return;
    }
    /* notify upper layer protocol */
    if !(*stcb).sctp_socket.is_null() {
        sctp_ulp_notify(2u32, stcb, 0u32, 0 as *mut libc::c_void, 0i32);
    }
    /* stop the timer */
    sctp_timer_stop(
        9i32,
        (*stcb).sctp_ep,
        stcb,
        net,
        (0x10000000i32 + 0x18i32) as uint32_t,
    );
    ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_shutdown, 1u32);
    /* free the TCB */
    if system_base_info.sctpsysctl.sctp_debug_on & 0x2000u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"sctp_handle_shutdown_complete: calls free-asoc\n\x00" as *const u8
                    as *const libc::c_char,
            );
        }
    }
    sctp_free_assoc((*stcb).sctp_ep, stcb, 0i32, 0x10000000i32 + 0x19i32);
}
unsafe extern "C" fn process_chunk_drop(
    mut stcb: *mut sctp_tcb,
    mut desc: *mut sctp_chunk_desc,
    mut net: *mut sctp_nets,
    mut flg: uint8_t,
) -> libc::c_int {
    match (*desc).chunk_type as libc::c_int {
        0 => {
            let mut tsn = 0;
            let mut tp1 = 0 as *mut sctp_tmit_chunk;
            let mut audit = 0;
            tsn = ntohl((*desc).tsn_ifany);
            tp1 = (*stcb).asoc.sent_queue.tqh_first;
            while !tp1.is_null() {
                if (*tp1).rec.data.tsn == tsn {
                    break;
                }
                if (*tp1).rec.data.tsn < tsn
                    && tsn.wrapping_sub((*tp1).rec.data.tsn) > (1u32) << 31i32
                    || (*tp1).rec.data.tsn > tsn
                        && (*tp1).rec.data.tsn.wrapping_sub(tsn) < (1u32) << 31i32
                {
                    /* not found */
                    tp1 = 0 as *mut sctp_tmit_chunk;
                    break;
                } else {
                    tp1 = (*tp1).sctp_next.tqe_next
                }
            }
            if tp1.is_null() {
                /*
                 * Do it the other way , aka without paying
                 * attention to queue seq order.
                 */
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctpstat.sctps_pdrpdnfnd,
                    1u32,
                );
                tp1 = (*stcb).asoc.sent_queue.tqh_first;
                while !tp1.is_null() {
                    if (*tp1).rec.data.tsn == tsn {
                        break;
                    }
                    tp1 = (*tp1).sctp_next.tqe_next
                }
            }
            if tp1.is_null() {
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctpstat.sctps_pdrptsnnf,
                    1u32,
                );
            }
            if !tp1.is_null() && (*tp1).sent < 10010i32 {
                let mut ddp = 0 as *mut uint8_t;
                let mut iii = 0;
                if flg as libc::c_int & 0x2i32 == 0i32 && flg as libc::c_int & 0x1i32 == 0i32 {
                    return 0i32;
                }
                if (*stcb).asoc.peers_rwnd == 0u32 && flg as libc::c_int & 0x1i32 == 0i32 {
                    ::std::intrinsics::atomic_xadd(
                        &mut system_base_info.sctpstat.sctps_pdrpdiwnp,
                        1u32,
                    );
                    return 0i32;
                }
                if (*stcb).asoc.peers_rwnd == 0u32 && flg as libc::c_int & 0x1i32 != 0 {
                    ::std::intrinsics::atomic_xadd(
                        &mut system_base_info.sctpstat.sctps_pdrpdizrw,
                        1u32,
                    );
                    return 0i32;
                }
                ddp = (*(*tp1).data)
                    .m_hdr
                    .mh_data
                    .offset(::std::mem::size_of::<sctp_data_chunk>() as isize)
                    as *mut uint8_t;

                iii = 0u32;
                while (iii as libc::c_ulong)
                    < ::std::mem::size_of::<[uint8_t; 31]>() as libc::c_ulong
                {
                    if *ddp.offset(iii as isize) as libc::c_int
                        != (*desc).data_bytes[iii as usize] as libc::c_int
                    {
                        ::std::intrinsics::atomic_xadd(
                            &mut system_base_info.sctpstat.sctps_pdrpbadd,
                            1u32,
                        );
                        return -(1i32);
                    }
                    iii = iii.wrapping_add(1)
                }
                if (*tp1).do_rtt != 0 {
                    /*
                     * this guy had a RTO calculation
                     * pending on it, cancel it
                     */
                    if (*(*tp1).whoTo).rto_needed as libc::c_int == 0i32 {
                        (*(*tp1).whoTo).rto_needed = 1u8
                    }
                    (*tp1).do_rtt = 0u8
                }
                ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_pdrpmark, 1u32);
                if (*tp1).sent != 4i32 {
                    (*stcb).asoc.sent_queue_retran_cnt =
                        (*stcb).asoc.sent_queue_retran_cnt.wrapping_add(1)
                }
                /*
                 * mark it as if we were doing a FR, since
                 * we will be getting gap ack reports behind
                 * the info from the router.
                 */
                (*tp1).rec.data.doing_fast_retransmit = 1u8;
                /*
                 * mark the tsn with what sequences can
                 * cause a new FR.
                 */
                if (*stcb).asoc.send_queue.tqh_first.is_null() {
                    (*tp1).rec.data.fast_retran_tsn = (*stcb).asoc.sending_seq
                } else {
                    (*tp1).rec.data.fast_retran_tsn =
                        (*(*stcb).asoc.send_queue.tqh_first).rec.data.tsn
                }
                /* restart the timer */
                sctp_timer_stop(
                    1i32,
                    (*stcb).sctp_ep,
                    stcb,
                    (*tp1).whoTo,
                    (0x10000000i32 + 0x1ai32) as uint32_t,
                );
                sctp_timer_start(1i32, (*stcb).sctp_ep, stcb, (*tp1).whoTo);
                /* fix counts and things */
                if system_base_info.sctpsysctl.sctp_logging_level & 0x20u32 != 0 {
                    sctp_misc_ints(
                        115u8,
                        (*(*tp1).whoTo).flight_size,
                        (*tp1).book_size as uint32_t,
                        stcb as uint32_t,
                        (*tp1).rec.data.tsn,
                    );
                }
                if (*tp1).sent < 4i32 {
                    if (*(*tp1).whoTo).flight_size >= (*tp1).book_size as libc::c_uint {
                        (*(*tp1).whoTo).flight_size = ((*(*tp1).whoTo).flight_size)
                            .wrapping_sub((*tp1).book_size as libc::c_uint)
                    } else {
                        (*(*tp1).whoTo).flight_size = 0u32
                    }
                    (*tp1).window_probe = 0u8;
                    if (*stcb).asoc.total_flight >= (*tp1).book_size as libc::c_uint {
                        (*stcb).asoc.total_flight = (*stcb)
                            .asoc
                            .total_flight
                            .wrapping_sub((*tp1).book_size as libc::c_uint);
                        if (*stcb).asoc.total_flight_count > 0u32 {
                            (*stcb).asoc.total_flight_count =
                                (*stcb).asoc.total_flight_count.wrapping_sub(1)
                        }
                    } else {
                        (*stcb).asoc.total_flight = 0u32;
                        (*stcb).asoc.total_flight_count = 0u32
                    }
                }
                (*tp1).sent = 4i32
            }

            audit = 0u32;
            tp1 = (*stcb).asoc.sent_queue.tqh_first;
            while !tp1.is_null() {
                if (*tp1).sent == 4i32 {
                    audit = audit.wrapping_add(1)
                }
                tp1 = (*tp1).sctp_next.tqe_next
            }
            tp1 = (*stcb).asoc.control_send_queue.tqh_first;
            while !tp1.is_null() {
                if (*tp1).sent == 4i32 {
                    audit = audit.wrapping_add(1)
                }
                tp1 = (*tp1).sctp_next.tqe_next
            }
            if audit != (*stcb).asoc.sent_queue_retran_cnt {
                if system_base_info.debug_printf.is_some() {
                    system_base_info
                        .debug_printf
                        .expect("non-null function pointer")(
                        b"**Local Audit finds cnt:%d asoc cnt:%d\n\x00" as *const u8
                            as *const libc::c_char,
                        audit,
                        (*stcb).asoc.sent_queue_retran_cnt,
                    );
                }
                (*stcb).asoc.sent_queue_retran_cnt = audit
            }
        }
        193 => {
            let mut asconf = 0 as *mut sctp_tmit_chunk;
            asconf = (*stcb).asoc.control_send_queue.tqh_first;
            while !asconf.is_null() {
                if (*asconf).rec.chunk_id.id as libc::c_int == 0xc1i32 {
                    break;
                }
                asconf = (*asconf).sctp_next.tqe_next
            }
            if !asconf.is_null() {
                if (*asconf).sent != 4i32 {
                    (*stcb).asoc.sent_queue_retran_cnt =
                        (*stcb).asoc.sent_queue_retran_cnt.wrapping_add(1)
                }
                (*asconf).sent = 4i32;
                (*asconf).snd_count = (*asconf).snd_count.wrapping_sub(1)
            }
        }
        1 => {
            /* resend the INIT */
            (*stcb).asoc.dropped_special_cnt = (*stcb).asoc.dropped_special_cnt.wrapping_add(1);
            if ((*stcb).asoc.dropped_special_cnt as libc::c_int) < 4i32 {
                /*
                 * If we can get it in, in a few attempts we do
                 * this, otherwise we let the timer fire.
                 */
                sctp_timer_stop(
                    2i32,
                    (*stcb).sctp_ep,
                    stcb,
                    net,
                    (0x10000000i32 + 0x1bi32) as uint32_t,
                );
                sctp_send_initiate((*stcb).sctp_ep, stcb, 0i32);
            }
        }
        3 | 16 => {
            /* resend the sack */
            sctp_send_sack(stcb, 0i32);
        }
        4 => {
            /* resend a demand HB */
            if (*stcb).asoc.overall_error_count.wrapping_add(3u32)
                < (*stcb).asoc.max_send_times as libc::c_uint
            {
                /* Only retransmit if we KNOW we wont destroy the tcb */
                sctp_send_hb(stcb, net, 0i32);
            }
        }
        7 => {
            sctp_send_shutdown(stcb, net);
        }
        8 => {
            sctp_send_shutdown_ack(stcb, net);
        }
        10 => {
            let mut cookie = 0 as *mut sctp_tmit_chunk;
            cookie = 0 as *mut sctp_tmit_chunk;
            cookie = (*stcb).asoc.control_send_queue.tqh_first;
            while !cookie.is_null() {
                if (*cookie).rec.chunk_id.id as libc::c_int == 0xai32 {
                    break;
                }
                cookie = (*cookie).sctp_next.tqe_next
            }
            if !cookie.is_null() {
                if (*cookie).sent != 4i32 {
                    (*stcb).asoc.sent_queue_retran_cnt =
                        (*stcb).asoc.sent_queue_retran_cnt.wrapping_add(1)
                }
                (*cookie).sent = 4i32;
                sctp_stop_all_cookie_timers(stcb);
            }
        }
        11 => {
            sctp_send_cookie_ack(stcb);
        }
        128 => {
            /* resend last asconf ack */
            sctp_send_asconf_ack(stcb);
        }
        194 | 192 => {
            send_forward_tsn(stcb, &mut (*stcb).asoc);
        }
        129 | 2 | 5 | 6 | 9 | 14 | 12 | 13 | _ => {}
    }
    return 0i32;
}
#[no_mangle]
pub unsafe extern "C" fn sctp_reset_in_stream(
    mut stcb: *mut sctp_tcb,
    mut number_entries: uint32_t,
    mut list: *mut uint16_t,
) {
    let mut i = 0;
    /*
     * We set things to 0xffffffff since this is the last delivered sequence
     * and we will be sending in 0 after the reset.
     */
    if number_entries != 0 {
        i = 0u32;
        while i < number_entries {
            let mut temp = 0;
            temp = ntohs(*list.offset(i as isize));
            if !(temp as libc::c_int >= (*stcb).asoc.streamincnt as libc::c_int) {
                (*(*stcb).asoc.strmin.offset(temp as isize)).last_mid_delivered = 0xffffffffu32
            }
            i = i.wrapping_add(1)
        }
    } else {
        list = 0 as *mut uint16_t;
        i = 0u32;
        while i < (*stcb).asoc.streamincnt as libc::c_uint {
            (*(*stcb).asoc.strmin.offset(i as isize)).last_mid_delivered = 0xffffffffu32;
            i = i.wrapping_add(1)
        }
    }
    sctp_ulp_notify(17u32, stcb, number_entries, list as *mut libc::c_void, 0i32);
}
unsafe extern "C" fn sctp_reset_out_streams(
    mut stcb: *mut sctp_tcb,
    mut number_entries: uint32_t,
    mut list: *mut uint16_t,
) {
    let mut i = 0;
    if number_entries > 0u32 {
        i = 0u32;
        while i < number_entries {
            let mut temp = 0;
            temp = ntohs(*list.offset(i as isize));
            if !(temp as libc::c_int >= (*stcb).asoc.streamoutcnt as libc::c_int) {
                (*(*stcb).asoc.strmout.offset(temp as isize)).next_mid_ordered = 0u32;
                (*(*stcb).asoc.strmout.offset(temp as isize)).next_mid_unordered = 0u32
            }
            /* no such stream */
            i = i.wrapping_add(1)
        }
    } else {
        i = 0u32;
        while i < (*stcb).asoc.streamoutcnt as libc::c_uint {
            (*(*stcb).asoc.strmout.offset(i as isize)).next_mid_ordered = 0u32;
            (*(*stcb).asoc.strmout.offset(i as isize)).next_mid_unordered = 0u32;
            i = i.wrapping_add(1)
        }
    }
    sctp_ulp_notify(18u32, stcb, number_entries, list as *mut libc::c_void, 0i32);
}
unsafe extern "C" fn sctp_reset_clear_pending(
    mut stcb: *mut sctp_tcb,
    mut number_entries: uint32_t,
    mut list: *mut uint16_t,
) {
    let mut i = 0;
    if number_entries > 0u32 {
        i = 0u32;
        while i < number_entries {
            let mut temp = 0;
            temp = ntohs(*list.offset(i as isize));
            if !(temp as libc::c_int >= (*stcb).asoc.streamoutcnt as libc::c_int) {
                (*(*stcb).asoc.strmout.offset(temp as isize)).state = 0x2u8
            }
            /* no such stream */
            i = i.wrapping_add(1)
        }
    } else {
        i = 0u32;
        while i < (*stcb).asoc.streamoutcnt as libc::c_uint {
            (*(*stcb).asoc.strmout.offset(i as isize)).state = 0x2u8;
            i = i.wrapping_add(1)
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn sctp_find_stream_reset(
    mut stcb: *mut sctp_tcb,
    mut seq: uint32_t,
    mut bchk: *mut *mut sctp_tmit_chunk,
) -> *mut sctp_stream_reset_request {
    let mut asoc = 0 as *mut sctp_association;
    let mut ch = 0 as *mut sctp_chunkhdr;
    let mut r = 0 as *mut sctp_stream_reset_request;
    let mut chk = 0 as *mut sctp_tmit_chunk;
    let mut len = 0;
    let mut clen = 0;
    asoc = &mut (*stcb).asoc;
    if (*stcb).asoc.control_send_queue.tqh_first.is_null() {
        (*asoc).stream_reset_outstanding = 0u8;
        return 0 as *mut sctp_stream_reset_request;
    }
    if (*stcb).asoc.str_reset.is_null() {
        (*asoc).stream_reset_outstanding = 0u8;
        return 0 as *mut sctp_stream_reset_request;
    }
    chk = (*stcb).asoc.str_reset;
    if (*chk).data.is_null() {
        return 0 as *mut sctp_stream_reset_request;
    }
    if !bchk.is_null() {
        /* he wants a copy of the chk pointer */
        *bchk = chk
    }
    clen = (*chk).send_size as libc::c_int;
    ch = (*(*chk).data).m_hdr.mh_data as *mut sctp_chunkhdr;
    r = ch.offset(1isize) as *mut sctp_stream_reset_request;
    if ntohl((*r).request_seq) == seq {
        /* found it */
        return r;
    }
    len = (ntohs((*r).ph.param_length) as libc::c_int + 3i32 >> 2i32) << 2i32;
    if clen > len + ::std::mem::size_of::<sctp_chunkhdr>() as libc::c_int {
        /* move to the next one, there can only be a max of two */
        r = (r as caddr_t).offset(len as isize) as *mut sctp_stream_reset_request;
        if ntohl((*r).request_seq) == seq {
            return r;
        }
    }
    /* that seq is not here */
    return 0 as *mut sctp_stream_reset_request;
}
unsafe extern "C" fn sctp_clean_up_stream_reset(mut stcb: *mut sctp_tcb) {
    let mut asoc = 0 as *mut sctp_association;
    let mut chk = 0 as *mut sctp_tmit_chunk;
    asoc = &mut (*stcb).asoc;
    chk = (*asoc).str_reset;
    if chk.is_null() {
        return;
    }
    (*asoc).str_reset = 0 as *mut sctp_tmit_chunk;
    sctp_timer_stop(
        14i32,
        (*stcb).sctp_ep,
        stcb,
        (*chk).whoTo,
        (0x10000000i32 + 0x1ci32) as uint32_t,
    );
    if !(*chk).sctp_next.tqe_next.is_null() {
        (*(*chk).sctp_next.tqe_next).sctp_next.tqe_prev = (*chk).sctp_next.tqe_prev
    } else {
        (*asoc).control_send_queue.tqh_last = (*chk).sctp_next.tqe_prev
    }
    *(*chk).sctp_next.tqe_prev = (*chk).sctp_next.tqe_next;
    (*asoc).ctrl_queue_cnt -= 1;
    if !(*chk).data.is_null() {
        m_freem((*chk).data);
        (*chk).data = 0 as *mut mbuf
    }
    if (*chk).holds_key_ref != 0 {
        sctp_auth_key_release(stcb, (*chk).auth_keyid, 0i32);
        (*chk).holds_key_ref = 0u8
    }
    if !stcb.is_null() {
        if !(*chk).whoTo.is_null() {
            if !(*chk).whoTo.is_null() {
                if ::std::intrinsics::atomic_xadd(
                    &mut (*(*chk).whoTo).ref_count as *mut libc::c_int,
                    -(1i32),
                ) == 1i32
                {
                    sctp_os_timer_stop(&mut (*(*chk).whoTo).rxt_timer.timer);
                    sctp_os_timer_stop(&mut (*(*chk).whoTo).pmtu_timer.timer);
                    sctp_os_timer_stop(&mut (*(*chk).whoTo).hb_timer.timer);
                    if !(*(*chk).whoTo).ro.ro_rt.is_null() {
                        if (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt <= 1i64 {
                            sctp_userspace_rtfree((*(*chk).whoTo).ro.ro_rt);
                        } else {
                            (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt -= 1
                        }
                        (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t;
                        (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t
                    }
                    if (*(*chk).whoTo).src_addr_selected != 0 {
                        sctp_free_ifa((*(*chk).whoTo).ro._s_addr);
                        (*(*chk).whoTo).ro._s_addr = 0 as *mut sctp_ifa
                    }
                    (*(*chk).whoTo).src_addr_selected = 0u8;
                    (*(*chk).whoTo).dest_state =
                        ((*(*chk).whoTo).dest_state as libc::c_int & !(0x1i32)) as uint16_t;
                    free((*chk).whoTo as *mut libc::c_void);
                    ::std::intrinsics::atomic_xsub(
                        &mut system_base_info.sctppcbinfo.ipi_count_raddr,
                        1u32,
                    );
                }
            }
            (*chk).whoTo = 0 as *mut sctp_nets
        }
        if (*stcb).asoc.free_chunk_cnt as libc::c_uint
            > system_base_info.sctpsysctl.sctp_asoc_free_resc_limit
            || system_base_info.sctppcbinfo.ipi_free_chunks
                > system_base_info.sctpsysctl.sctp_system_free_resc_limit
        {
            free(chk as *mut libc::c_void);
            ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_count_chunk, 1u32);
        } else {
            (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
            (*chk).sctp_next.tqe_prev = (*stcb).asoc.free_chunks.tqh_last;
            *(*stcb).asoc.free_chunks.tqh_last = chk;
            (*stcb).asoc.free_chunks.tqh_last = &mut (*chk).sctp_next.tqe_next;
            (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_add(1);
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctppcbinfo.ipi_free_chunks, 1u32);
        }
    } else {
        free(chk as *mut libc::c_void);
        ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_count_chunk, 1u32);
    };
}
unsafe extern "C" fn sctp_handle_stream_reset_response(
    mut stcb: *mut sctp_tcb,
    mut seq: uint32_t,
    mut action: uint32_t,
    mut respin: *mut sctp_stream_reset_response,
) -> libc::c_int {
    let mut asoc = &mut (*stcb).asoc;

    if (*asoc).stream_reset_outstanding as libc::c_int == 0i32 {
        /* duplicate */
        return 0i32;
    }
    if seq == (*stcb).asoc.str_reset_seq_out {
        let mut chk = 0 as *mut sctp_tmit_chunk;
        let mut req_param = 0 as *mut sctp_stream_reset_request;
        req_param = sctp_find_stream_reset(stcb, seq, &mut chk);
        if !req_param.is_null() {
            let mut type_0 = 0;
            let mut lparam_len = 0;
            let mut number_entries = 0;
            (*stcb).asoc.str_reset_seq_out = (*stcb).asoc.str_reset_seq_out.wrapping_add(1);
            type_0 = ntohs((*req_param).ph.param_type);
            lparam_len = ntohs((*req_param).ph.param_length) as libc::c_int;
            if type_0 as libc::c_int == 0xdi32 {
                let mut req_out_param = 0 as *mut sctp_stream_reset_out_request;
                let mut no_clear = 0i32;
                req_out_param = req_param as *mut sctp_stream_reset_out_request;
                number_entries = (lparam_len as libc::c_ulong)
                    .wrapping_sub(
                        ::std::mem::size_of::<sctp_stream_reset_out_request>() as libc::c_ulong
                    )
                    .wrapping_div(::std::mem::size_of::<uint16_t>() as libc::c_ulong)
                    as uint32_t;
                (*asoc).stream_reset_out_is_outstanding = 0u8;
                if (*asoc).stream_reset_outstanding != 0 {
                    (*asoc).stream_reset_outstanding =
                        (*asoc).stream_reset_outstanding.wrapping_sub(1)
                }
                if action == 0x1u32 {
                    /* do it */
                    sctp_reset_out_streams(
                        stcb,
                        number_entries,
                        (*req_out_param).list_of_streams.as_mut_ptr(),
                    );
                } else if action == 0x2u32 {
                    sctp_ulp_notify(
                        21u32,
                        stcb,
                        number_entries,
                        (*req_out_param).list_of_streams.as_mut_ptr() as *mut libc::c_void,
                        0i32,
                    );
                } else if action == 0x6u32 {
                    /* Set it up so we don't stop retransmitting */
                    (*asoc).stream_reset_outstanding =
                        (*asoc).stream_reset_outstanding.wrapping_add(1);
                    (*stcb).asoc.str_reset_seq_out = (*stcb).asoc.str_reset_seq_out.wrapping_sub(1);
                    (*asoc).stream_reset_out_is_outstanding = 1u8;
                    no_clear = 1i32
                } else {
                    sctp_ulp_notify(
                        19u32,
                        stcb,
                        number_entries,
                        (*req_out_param).list_of_streams.as_mut_ptr() as *mut libc::c_void,
                        0i32,
                    );
                }
                if no_clear == 0i32 {
                    sctp_reset_clear_pending(
                        stcb,
                        number_entries,
                        (*req_out_param).list_of_streams.as_mut_ptr(),
                    );
                }
            } else if type_0 as libc::c_int == 0xei32 {
                let mut req_in_param = 0 as *mut sctp_stream_reset_in_request;
                req_in_param = req_param as *mut sctp_stream_reset_in_request;
                number_entries = (lparam_len as libc::c_ulong)
                    .wrapping_sub(
                        ::std::mem::size_of::<sctp_stream_reset_in_request>() as libc::c_ulong
                    )
                    .wrapping_div(::std::mem::size_of::<uint16_t>() as libc::c_ulong)
                    as uint32_t;
                if (*asoc).stream_reset_outstanding != 0 {
                    (*asoc).stream_reset_outstanding =
                        (*asoc).stream_reset_outstanding.wrapping_sub(1)
                }
                if action == 0x2u32 {
                    sctp_ulp_notify(
                        22u32,
                        stcb,
                        number_entries,
                        (*req_in_param).list_of_streams.as_mut_ptr() as *mut libc::c_void,
                        0i32,
                    );
                } else if action != 0x1u32 {
                    sctp_ulp_notify(
                        20u32,
                        stcb,
                        number_entries,
                        (*req_in_param).list_of_streams.as_mut_ptr() as *mut libc::c_void,
                        0i32,
                    );
                }
            } else if type_0 as libc::c_int == 0x11i32 {
                let mut num_stream = 0;
                num_stream = (*stcb).asoc.strm_pending_add_size as libc::c_int;
                if num_stream
                    > (*stcb).asoc.strm_realoutsize as libc::c_int
                        - (*stcb).asoc.streamoutcnt as libc::c_int
                {
                    /* TSNH */
                    num_stream = (*stcb).asoc.strm_realoutsize as libc::c_int
                        - (*stcb).asoc.streamoutcnt as libc::c_int
                }
                (*stcb).asoc.strm_pending_add_size = 0u16;
                if (*asoc).stream_reset_outstanding != 0 {
                    (*asoc).stream_reset_outstanding =
                        (*asoc).stream_reset_outstanding.wrapping_sub(1)
                }
                if action == 0x1u32 {
                    for i in (*asoc).streamoutcnt as libc::c_int
                        ..(*asoc).streamoutcnt as libc::c_int + num_stream
                    {
                        (*(*asoc).strmout.offset(i as isize)).state = 0x2u8;
                    }
                    (*asoc).streamoutcnt =
                        ((*asoc).streamoutcnt as libc::c_int + num_stream) as uint16_t;
                    sctp_notify_stream_reset_add(
                        stcb,
                        (*stcb).asoc.streamincnt,
                        (*stcb).asoc.streamoutcnt,
                        0i32,
                    );
                } else if action == 0x2u32 {
                    sctp_notify_stream_reset_add(
                        stcb,
                        (*stcb).asoc.streamincnt,
                        (*stcb).asoc.streamoutcnt,
                        0x4i32,
                    );
                } else {
                    sctp_notify_stream_reset_add(
                        stcb,
                        (*stcb).asoc.streamincnt,
                        (*stcb).asoc.streamoutcnt,
                        0x8i32,
                    );
                }
            } else if type_0 as libc::c_int == 0x12i32 {
                if (*asoc).stream_reset_outstanding != 0 {
                    (*asoc).stream_reset_outstanding =
                        (*asoc).stream_reset_outstanding.wrapping_sub(1)
                }
                if action == 0x2u32 {
                    sctp_notify_stream_reset_add(
                        stcb,
                        (*stcb).asoc.streamincnt,
                        (*stcb).asoc.streamoutcnt,
                        0x4i32,
                    );
                } else if action != 0x1u32 {
                    sctp_notify_stream_reset_add(
                        stcb,
                        (*stcb).asoc.streamincnt,
                        (*stcb).asoc.streamoutcnt,
                        0x8i32,
                    );
                }
            } else if type_0 as libc::c_int == 0xfi32 {
                if respin.is_null() {
                    /* huh ? */
                    return 0i32;
                }
                if (ntohs((*respin).ph.param_length) as libc::c_ulong)
                    < ::std::mem::size_of::<sctp_stream_reset_response_tsn>() as libc::c_ulong
                {
                    return 0i32;
                }
                if action == 0x1u32 {
                    let mut resp = 0 as *mut sctp_stream_reset_response_tsn;
                    let mut fwdtsn = sctp_forward_tsn_chunk {
                        ch: sctp_chunkhdr {
                            chunk_type: 0,
                            chunk_flags: 0,
                            chunk_length: 0,
                        },
                        new_cumulative_tsn: 0,
                    };
                    let mut abort_flag = 0i32;
                    resp = respin as *mut sctp_stream_reset_response_tsn;
                    (*asoc).stream_reset_outstanding =
                        (*asoc).stream_reset_outstanding.wrapping_sub(1);
                    fwdtsn.ch.chunk_length =
                        htons(::std::mem::size_of::<sctp_forward_tsn_chunk>() as uint16_t);
                    fwdtsn.ch.chunk_type = 0xc0u8;
                    fwdtsn.new_cumulative_tsn =
                        htonl(ntohl((*resp).senders_next_tsn).wrapping_sub(1u32));
                    sctp_handle_forward_tsn(
                        stcb,
                        &mut fwdtsn,
                        &mut abort_flag,
                        0 as *mut mbuf,
                        0i32,
                    );
                    if abort_flag != 0 {
                        return 1i32;
                    }
                    (*stcb).asoc.highest_tsn_inside_map =
                        ntohl((*resp).senders_next_tsn).wrapping_sub(1u32);
                    if system_base_info.sctpsysctl.sctp_logging_level & 0x100u32 != 0 {
                        sctp_log_map(0u32, 7u32, (*asoc).highest_tsn_inside_map, 23i32);
                    }
                    (*stcb).asoc.cumulative_tsn = (*stcb).asoc.highest_tsn_inside_map;
                    (*stcb).asoc.tsn_last_delivered = (*stcb).asoc.cumulative_tsn;
                    (*stcb).asoc.mapping_array_base_tsn = ntohl((*resp).senders_next_tsn);
                    memset(
                        (*stcb).asoc.mapping_array as *mut libc::c_void,
                        0i32,
                        (*stcb).asoc.mapping_array_size as libc::c_ulong,
                    );
                    (*stcb).asoc.highest_tsn_inside_nr_map = (*stcb).asoc.highest_tsn_inside_map;
                    memset(
                        (*stcb).asoc.nr_mapping_array as *mut libc::c_void,
                        0i32,
                        (*stcb).asoc.mapping_array_size as libc::c_ulong,
                    );
                    (*stcb).asoc.sending_seq = ntohl((*resp).receivers_next_tsn);
                    (*stcb).asoc.last_acked_seq = (*stcb).asoc.cumulative_tsn;
                    sctp_reset_out_streams(stcb, 0u32, 0 as *mut uint16_t);
                    sctp_reset_in_stream(stcb, 0u32, 0 as *mut uint16_t);
                    sctp_notify_stream_reset_tsn(
                        stcb,
                        (*stcb).asoc.sending_seq,
                        (*stcb).asoc.mapping_array_base_tsn.wrapping_add(1u32),
                        0i32,
                    );
                } else if action == 0x2u32 {
                    sctp_notify_stream_reset_tsn(
                        stcb,
                        (*stcb).asoc.sending_seq,
                        (*stcb).asoc.mapping_array_base_tsn.wrapping_add(1u32),
                        0x4i32,
                    );
                } else {
                    sctp_notify_stream_reset_tsn(
                        stcb,
                        (*stcb).asoc.sending_seq,
                        (*stcb).asoc.mapping_array_base_tsn.wrapping_add(1u32),
                        0x8i32,
                    );
                }
            }
            /* get rid of the request and get the request flags */
            if (*asoc).stream_reset_outstanding as libc::c_int == 0i32 {
                sctp_clean_up_stream_reset(stcb);
            }
        }
    }
    if (*asoc).stream_reset_outstanding as libc::c_int == 0i32 {
        sctp_send_stream_reset_out_if_possible(stcb, 0i32);
    }
    return 0i32;
}
unsafe extern "C" fn sctp_handle_str_reset_request_in(
    mut stcb: *mut sctp_tcb,
    mut chk: *mut sctp_tmit_chunk,
    mut req: *mut sctp_stream_reset_in_request,
    mut trunc: libc::c_int,
) {
    let mut seq = 0;
    let mut asoc = &mut (*stcb).asoc;
    seq = ntohl((*req).request_seq);
    if (*asoc).str_reset_seq_in == seq {
        (*asoc).last_reset_action[1usize] = (*asoc).last_reset_action[0usize];
        if (*asoc).local_strreset_support as libc::c_int & 0x1i32 == 0 {
            (*asoc).last_reset_action[0usize] = 0x2u32
        } else if trunc != 0 {
            /* Can't do it, since they exceeded our buffer size  */
            (*asoc).last_reset_action[0usize] = 0x2u32
        } else if (*stcb).asoc.stream_reset_out_is_outstanding as libc::c_int == 0i32 {
            let mut len = 0;
            let mut number_entries = 0;
            let mut current_block_28: u64;
            len = ntohs((*req).ph.param_length) as libc::c_int;
            number_entries =
                (len as libc::c_ulong)
                    .wrapping_sub(
                        ::std::mem::size_of::<sctp_stream_reset_in_request>() as libc::c_ulong
                    )
                    .wrapping_div(::std::mem::size_of::<uint16_t>() as libc::c_ulong)
                    as libc::c_int;
            if number_entries != 0 {
                let mut i = 0;
                i = 0i32;
                loop {
                    let mut temp = 0;
                    if !(i < number_entries) {
                        current_block_28 = 26972500619410423;
                        break;
                    }
                    temp = ntohs(*(*req).list_of_streams.as_mut_ptr().offset(i as isize));
                    if temp as libc::c_int >= (*stcb).asoc.streamoutcnt as libc::c_int {
                        (*asoc).last_reset_action[0usize] = 0x2u32;
                        current_block_28 = 8412958105456932190;
                        break;
                    } else {
                        *(*req).list_of_streams.as_mut_ptr().offset(i as isize) = temp;
                        i += 1
                    }
                }
                match current_block_28 {
                    8412958105456932190 => {}
                    _ => {
                        for i in 0i32..number_entries {
                            if (*(*stcb)
                                .asoc
                                .strmout
                                .offset(*(*req).list_of_streams.as_mut_ptr().offset(i as isize)
                                    as isize))
                            .state as libc::c_int
                                == 0x2i32
                            {
                                (*(*stcb).asoc.strmout.offset(
                                    *(*req).list_of_streams.as_mut_ptr().offset(i as isize)
                                        as isize,
                                ))
                                .state = 0x3u8
                            }
                        }
                        current_block_28 = 11913429853522160501;
                    }
                }
            } else {
                for i in 0i32..(*stcb).asoc.streamoutcnt as libc::c_int {
                    if (*(*stcb).asoc.strmout.offset(i as isize)).state as libc::c_int == 0x2i32 {
                        (*(*stcb).asoc.strmout.offset(i as isize)).state = 0x3u8
                    }
                }
                current_block_28 = 11913429853522160501;
            }
            match current_block_28 {
                8412958105456932190 => {}
                _ => (*asoc).last_reset_action[0usize] = 0x1u32,
            }
        } else {
            /* Can't do it, since we have sent one out */
            (*asoc).last_reset_action[0usize] = 0x4u32
        }
        sctp_add_stream_reset_result(chk, seq, (*asoc).last_reset_action[0usize]);
        (*asoc).str_reset_seq_in = (*asoc).str_reset_seq_in.wrapping_add(1)
    } else if (*asoc).str_reset_seq_in.wrapping_sub(1u32) == seq {
        sctp_add_stream_reset_result(chk, seq, (*asoc).last_reset_action[0usize]);
    } else if (*asoc).str_reset_seq_in.wrapping_sub(2u32) == seq {
        sctp_add_stream_reset_result(chk, seq, (*asoc).last_reset_action[1usize]);
    } else {
        sctp_add_stream_reset_result(chk, seq, 0x5u32);
    }
    sctp_send_stream_reset_out_if_possible(stcb, 0i32);
}
unsafe extern "C" fn sctp_handle_str_reset_request_tsn(
    mut stcb: *mut sctp_tcb,
    mut chk: *mut sctp_tmit_chunk,
    mut req: *mut sctp_stream_reset_tsn_request,
) -> libc::c_int {
    /* reset all in and out and update the tsn */
    /*
     * A) reset my str-seq's on in and out. B) Select a receive next,
     * and set cum-ack to it. Also process this selected number as a
     * fwd-tsn as well. C) set in the response my next sending seq.
     */

    let mut seq = 0;
    let mut asoc = &mut (*stcb).asoc;

    seq = ntohl((*req).request_seq);
    if (*asoc).str_reset_seq_in == seq {
        (*asoc).last_reset_action[1usize] = (*stcb).asoc.last_reset_action[0usize];
        if (*asoc).local_strreset_support as libc::c_int & 0x4i32 == 0 {
            (*asoc).last_reset_action[0usize] = 0x2u32
        } else {
            let mut fwdtsn = sctp_forward_tsn_chunk {
                ch: sctp_chunkhdr {
                    chunk_type: 0,
                    chunk_flags: 0,
                    chunk_length: 0,
                },
                new_cumulative_tsn: 0,
            };
            let mut abort_flag = 0i32;
            fwdtsn.ch.chunk_length =
                htons(::std::mem::size_of::<sctp_forward_tsn_chunk>() as uint16_t);
            fwdtsn.ch.chunk_type = 0xc0u8;
            fwdtsn.ch.chunk_flags = 0u8;
            fwdtsn.new_cumulative_tsn =
                htonl((*stcb).asoc.highest_tsn_inside_map.wrapping_add(1u32));
            sctp_handle_forward_tsn(stcb, &mut fwdtsn, &mut abort_flag, 0 as *mut mbuf, 0i32);
            if abort_flag != 0 {
                return 1i32;
            }
            (*asoc).highest_tsn_inside_map =
                ((*asoc).highest_tsn_inside_map).wrapping_add(0x1000u32);
            if system_base_info.sctpsysctl.sctp_logging_level & 0x100u32 != 0 {
                sctp_log_map(0u32, 10u32, (*asoc).highest_tsn_inside_map, 23i32);
            }
            (*asoc).cumulative_tsn = (*asoc).highest_tsn_inside_map;
            (*asoc).tsn_last_delivered = (*asoc).cumulative_tsn;
            (*asoc).mapping_array_base_tsn = (*asoc).highest_tsn_inside_map.wrapping_add(1u32);
            memset(
                (*asoc).mapping_array as *mut libc::c_void,
                0i32,
                (*asoc).mapping_array_size as libc::c_ulong,
            );
            (*asoc).highest_tsn_inside_nr_map = (*asoc).highest_tsn_inside_map;
            memset(
                (*asoc).nr_mapping_array as *mut libc::c_void,
                0i32,
                (*asoc).mapping_array_size as libc::c_ulong,
            );
            ::std::intrinsics::atomic_xadd(&mut (*asoc).sending_seq, 1u32);
            /* save off historical data for retrans */
            (*asoc).last_sending_seq[1usize] = (*asoc).last_sending_seq[0usize];
            (*asoc).last_sending_seq[0usize] = (*asoc).sending_seq;
            (*asoc).last_base_tsnsent[1usize] = (*asoc).last_base_tsnsent[0usize];
            (*asoc).last_base_tsnsent[0usize] = (*asoc).mapping_array_base_tsn;
            sctp_reset_out_streams(stcb, 0u32, 0 as *mut uint16_t);
            sctp_reset_in_stream(stcb, 0u32, 0 as *mut uint16_t);
            (*asoc).last_reset_action[0usize] = 0x1u32;
            sctp_notify_stream_reset_tsn(
                stcb,
                (*asoc).sending_seq,
                (*asoc).mapping_array_base_tsn.wrapping_add(1u32),
                0i32,
            );
        }
        sctp_add_stream_reset_result_tsn(
            chk,
            seq,
            (*asoc).last_reset_action[0usize],
            (*asoc).last_sending_seq[0usize],
            (*asoc).last_base_tsnsent[0usize],
        );
        (*asoc).str_reset_seq_in = (*asoc).str_reset_seq_in.wrapping_add(1)
    } else if (*asoc).str_reset_seq_in.wrapping_sub(1u32) == seq {
        sctp_add_stream_reset_result_tsn(
            chk,
            seq,
            (*asoc).last_reset_action[0usize],
            (*asoc).last_sending_seq[0usize],
            (*asoc).last_base_tsnsent[0usize],
        );
    } else if (*asoc).str_reset_seq_in.wrapping_sub(2u32) == seq {
        sctp_add_stream_reset_result_tsn(
            chk,
            seq,
            (*asoc).last_reset_action[1usize],
            (*asoc).last_sending_seq[1usize],
            (*asoc).last_base_tsnsent[1usize],
        );
    } else {
        sctp_add_stream_reset_result(chk, seq, 0x5u32);
    }
    return 0i32;
}
unsafe extern "C" fn sctp_handle_str_reset_request_out(
    mut stcb: *mut sctp_tcb,
    mut chk: *mut sctp_tmit_chunk,
    mut req: *mut sctp_stream_reset_out_request,
    mut trunc: libc::c_int,
) {
    let mut seq = 0;
    let mut asoc = &mut (*stcb).asoc;
    seq = ntohl((*req).request_seq);
    /* now if its not a duplicate we process it */
    if (*asoc).str_reset_seq_in == seq {
        let mut tsn = 0;
        let mut number_entries = 0;
        let mut len = 0;
        len = ntohs((*req).ph.param_length) as libc::c_int;
        number_entries = (len as libc::c_ulong)
            .wrapping_sub(::std::mem::size_of::<sctp_stream_reset_out_request>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<uint16_t>() as libc::c_ulong)
            as libc::c_int;
        /*
         * the sender is resetting, handle the list issue.. we must
         * a) verify if we can do the reset, if so no problem b) If
         * we can't do the reset we must copy the request. c) queue
         * it, and setup the data in processor to trigger it off
         * when needed and dequeue all the queued data.
         */
        tsn = ntohl((*req).send_reset_at_tsn);
        /* move the reset action back one */
        (*asoc).last_reset_action[1usize] = (*asoc).last_reset_action[0usize];
        if (*asoc).local_strreset_support as libc::c_int & 0x1i32 == 0 {
            (*asoc).last_reset_action[0usize] = 0x2u32
        } else if trunc != 0 {
            (*asoc).last_reset_action[0usize] = 0x2u32
        } else if (*asoc).cumulative_tsn < tsn
            && tsn.wrapping_sub((*asoc).cumulative_tsn) > (1u32) << 31i32
            || (*asoc).cumulative_tsn > tsn
                && (*asoc).cumulative_tsn.wrapping_sub(tsn) < (1u32) << 31i32
            || (*asoc).cumulative_tsn == tsn
        {
            /* we can do it now */
            sctp_reset_in_stream(
                stcb,
                number_entries as uint32_t,
                (*req).list_of_streams.as_mut_ptr(),
            );
            (*asoc).last_reset_action[0usize] = 0x1u32
        } else {
            let mut liste = 0 as *mut sctp_stream_reset_list;
            let mut siz = 0;
            siz = (::std::mem::size_of::<sctp_stream_reset_list>() as libc::c_ulong).wrapping_add(
                (number_entries as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<uint16_t>() as libc::c_ulong),
            ) as libc::c_int;
            liste = malloc(siz as u_long) as *mut sctp_stream_reset_list;
            if 0x1i32 & 0x100i32 != 0 {
                memset(liste as *mut libc::c_void, 0i32, siz as libc::c_ulong);
            }
            if liste.is_null() {
                /* gak out of memory */
                (*asoc).last_reset_action[0usize] = 0x2u32;
                sctp_add_stream_reset_result(chk, seq, (*asoc).last_reset_action[0usize]);
                return;
            }
            (*liste).seq = seq;
            (*liste).tsn = tsn;
            (*liste).number_entries = number_entries as uint32_t;
            memcpy(
                &mut (*liste).list_of_streams as *mut [uint16_t; 0] as *mut libc::c_void,
                (*req).list_of_streams.as_mut_ptr() as *const libc::c_void,
                (number_entries as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<uint16_t>() as libc::c_ulong),
            );
            (*liste).next_resp.tqe_next = 0 as *mut sctp_stream_reset_list;
            (*liste).next_resp.tqe_prev = (*asoc).resetHead.tqh_last;
            *(*asoc).resetHead.tqh_last = liste;
            (*asoc).resetHead.tqh_last = &mut (*liste).next_resp.tqe_next;
            (*asoc).last_reset_action[0usize] = 0x6u32
        }
        sctp_add_stream_reset_result(chk, seq, (*asoc).last_reset_action[0usize]);
        (*asoc).str_reset_seq_in = (*asoc).str_reset_seq_in.wrapping_add(1)
    } else if (*asoc).str_reset_seq_in.wrapping_sub(1u32) == seq {
        /*
         * one seq back, just echo back last action since my
         * response was lost.
         */
        sctp_add_stream_reset_result(chk, seq, (*asoc).last_reset_action[0usize]);
    } else if (*asoc).str_reset_seq_in.wrapping_sub(2u32) == seq {
        /*
         * two seq back, just echo back last action since my
         * response was lost.
         */
        sctp_add_stream_reset_result(chk, seq, (*asoc).last_reset_action[1usize]);
    } else {
        sctp_add_stream_reset_result(chk, seq, 0x5u32);
    };
}
unsafe extern "C" fn sctp_handle_str_reset_add_strm(
    mut stcb: *mut sctp_tcb,
    mut chk: *mut sctp_tmit_chunk,
    mut str_add: *mut sctp_stream_reset_add_strm,
) {
    let mut num_stream = 0;
    let mut seq = 0;
    let mut asoc = &mut (*stcb).asoc;

    /* Get the number. */
    seq = ntohl((*str_add).request_seq);
    num_stream = ntohs((*str_add).number_of_streams) as uint32_t;
    /* Now what would be the new total? */
    if (*asoc).str_reset_seq_in == seq {
        num_stream = (num_stream).wrapping_add((*stcb).asoc.streamincnt as libc::c_uint);
        (*stcb).asoc.last_reset_action[1usize] = (*stcb).asoc.last_reset_action[0usize];
        if (*asoc).local_strreset_support as libc::c_int & 0x4i32 == 0 {
            (*asoc).last_reset_action[0usize] = 0x2u32
        } else {
            let mut current_block_81: u64;
            if num_stream > (*stcb).asoc.max_inbound_streams || num_stream > 0xffffu32 {
                current_block_81 = 2327973299195853457;
            } else {
                let mut oldstrm = 0 as *mut sctp_stream_in;
                /* save off the old */
                oldstrm = (*stcb).asoc.strmin;
                (*stcb).asoc.strmin = malloc(
                    (num_stream as libc::c_ulong)
                        .wrapping_mul(::std::mem::size_of::<sctp_stream_in>() as libc::c_ulong),
                ) as *mut sctp_stream_in;
                if 0x1i32 & 0x100i32 != 0 {
                    memset(
                        (*stcb).asoc.strmin as *mut libc::c_void,
                        0i32,
                        (num_stream as libc::c_ulong)
                            .wrapping_mul(::std::mem::size_of::<sctp_stream_in>() as libc::c_ulong),
                    );
                }
                if (*stcb).asoc.strmin.is_null() {
                    (*stcb).asoc.strmin = oldstrm;
                    current_block_81 = 2327973299195853457;
                } else {
                    let mut i = 0;
                    i = 0u32;
                    while i < (*stcb).asoc.streamincnt as libc::c_uint {
                        let mut ctl = 0 as *mut sctp_queued_to_read;
                        let mut nctl = 0 as *mut sctp_queued_to_read;
                        let ref mut fresh6 =
                            (*(*stcb).asoc.strmin.offset(i as isize)).inqueue.tqh_first;
                        *fresh6 = 0 as *mut sctp_queued_to_read;
                        let ref mut fresh7 =
                            (*(*stcb).asoc.strmin.offset(i as isize)).inqueue.tqh_last;
                        *fresh7 = &mut (*(*stcb).asoc.strmin.offset(i as isize)).inqueue.tqh_first;
                        let ref mut fresh8 = (*(*stcb).asoc.strmin.offset(i as isize))
                            .uno_inqueue
                            .tqh_first;
                        *fresh8 = 0 as *mut sctp_queued_to_read;
                        let ref mut fresh9 = (*(*stcb).asoc.strmin.offset(i as isize))
                            .uno_inqueue
                            .tqh_last;
                        *fresh9 = &mut (*(*stcb).asoc.strmin.offset(i as isize))
                            .uno_inqueue
                            .tqh_first;
                        (*(*stcb).asoc.strmin.offset(i as isize)).sid = i as uint16_t;
                        (*(*stcb).asoc.strmin.offset(i as isize)).last_mid_delivered =
                            (*oldstrm.offset(i as isize)).last_mid_delivered;
                        (*(*stcb).asoc.strmin.offset(i as isize)).delivery_started =
                            (*oldstrm.offset(i as isize)).delivery_started;
                        (*(*stcb).asoc.strmin.offset(i as isize)).pd_api_started =
                            (*oldstrm.offset(i as isize)).pd_api_started;
                        /* now anything on those queues? */
                        ctl = (*oldstrm.offset(i as isize)).inqueue.tqh_first;
                        while !ctl.is_null() && {
                            nctl = (*ctl).next_instrm.tqe_next;
                            (1i32) != 0
                        } {
                            if !(*ctl).next_instrm.tqe_next.is_null() {
                                (*(*ctl).next_instrm.tqe_next).next_instrm.tqe_prev =
                                    (*ctl).next_instrm.tqe_prev
                            } else {
                                let ref mut fresh10 =
                                    (*oldstrm.offset(i as isize)).inqueue.tqh_last;
                                *fresh10 = (*ctl).next_instrm.tqe_prev
                            }
                            *(*ctl).next_instrm.tqe_prev = (*ctl).next_instrm.tqe_next;
                            (*ctl).next_instrm.tqe_next = 0 as *mut sctp_queued_to_read;
                            (*ctl).next_instrm.tqe_prev =
                                (*(*stcb).asoc.strmin.offset(i as isize)).inqueue.tqh_last;
                            let ref mut fresh11 =
                                *(*(*stcb).asoc.strmin.offset(i as isize)).inqueue.tqh_last;
                            *fresh11 = ctl;
                            let ref mut fresh12 =
                                (*(*stcb).asoc.strmin.offset(i as isize)).inqueue.tqh_last;
                            *fresh12 = &mut (*ctl).next_instrm.tqe_next;
                            ctl = nctl
                        }
                        ctl = (*oldstrm.offset(i as isize)).uno_inqueue.tqh_first;
                        while !ctl.is_null() && {
                            nctl = (*ctl).next_instrm.tqe_next;
                            (1i32) != 0
                        } {
                            if !(*ctl).next_instrm.tqe_next.is_null() {
                                (*(*ctl).next_instrm.tqe_next).next_instrm.tqe_prev =
                                    (*ctl).next_instrm.tqe_prev
                            } else {
                                let ref mut fresh13 =
                                    (*oldstrm.offset(i as isize)).uno_inqueue.tqh_last;
                                *fresh13 = (*ctl).next_instrm.tqe_prev
                            }
                            *(*ctl).next_instrm.tqe_prev = (*ctl).next_instrm.tqe_next;
                            (*ctl).next_instrm.tqe_next = 0 as *mut sctp_queued_to_read;
                            (*ctl).next_instrm.tqe_prev = (*(*stcb).asoc.strmin.offset(i as isize))
                                .uno_inqueue
                                .tqh_last;
                            let ref mut fresh14 = *(*(*stcb).asoc.strmin.offset(i as isize))
                                .uno_inqueue
                                .tqh_last;
                            *fresh14 = ctl;
                            let ref mut fresh15 = (*(*stcb).asoc.strmin.offset(i as isize))
                                .uno_inqueue
                                .tqh_last;
                            *fresh15 = &mut (*ctl).next_instrm.tqe_next;
                            ctl = nctl
                        }
                        i = i.wrapping_add(1)
                    }
                    /* Init the new streams */
                    i = (*stcb).asoc.streamincnt as uint32_t;
                    while i < num_stream {
                        let ref mut fresh16 =
                            (*(*stcb).asoc.strmin.offset(i as isize)).inqueue.tqh_first;
                        *fresh16 = 0 as *mut sctp_queued_to_read;
                        let ref mut fresh17 =
                            (*(*stcb).asoc.strmin.offset(i as isize)).inqueue.tqh_last;
                        *fresh17 = &mut (*(*stcb).asoc.strmin.offset(i as isize)).inqueue.tqh_first;
                        let ref mut fresh18 = (*(*stcb).asoc.strmin.offset(i as isize))
                            .uno_inqueue
                            .tqh_first;
                        *fresh18 = 0 as *mut sctp_queued_to_read;
                        let ref mut fresh19 = (*(*stcb).asoc.strmin.offset(i as isize))
                            .uno_inqueue
                            .tqh_last;
                        *fresh19 = &mut (*(*stcb).asoc.strmin.offset(i as isize))
                            .uno_inqueue
                            .tqh_first;
                        (*(*stcb).asoc.strmin.offset(i as isize)).sid = i as uint16_t;
                        (*(*stcb).asoc.strmin.offset(i as isize)).last_mid_delivered =
                            0xffffffffu32;
                        (*(*stcb).asoc.strmin.offset(i as isize)).pd_api_started = 0u8;
                        (*(*stcb).asoc.strmin.offset(i as isize)).delivery_started = 0u8;
                        i = i.wrapping_add(1)
                    }
                    free(oldstrm as *mut libc::c_void);
                    /* update the size */
                    (*stcb).asoc.streamincnt = num_stream as uint16_t;
                    (*stcb).asoc.last_reset_action[0usize] = 0x1u32;
                    sctp_notify_stream_reset_add(
                        stcb,
                        (*stcb).asoc.streamincnt,
                        (*stcb).asoc.streamoutcnt,
                        0i32,
                    );
                    current_block_81 = 6838274324784804404;
                }
            }
            match current_block_81 {
                2327973299195853457 =>
                /* We must reject it they ask for to many */
                {
                    (*stcb).asoc.last_reset_action[0usize] = 0x2u32
                }
                _ => {}
            }
        }
        sctp_add_stream_reset_result(chk, seq, (*asoc).last_reset_action[0usize]);
        (*asoc).str_reset_seq_in = (*asoc).str_reset_seq_in.wrapping_add(1)
    } else if (*asoc).str_reset_seq_in.wrapping_sub(1u32) == seq {
        /*
         * one seq back, just echo back last action since my
         * response was lost.
         */
        sctp_add_stream_reset_result(chk, seq, (*asoc).last_reset_action[0usize]);
    } else if (*asoc).str_reset_seq_in.wrapping_sub(2u32) == seq {
        /*
         * two seq back, just echo back last action since my
         * response was lost.
         */
        sctp_add_stream_reset_result(chk, seq, (*asoc).last_reset_action[1usize]);
    } else {
        sctp_add_stream_reset_result(chk, seq, 0x5u32);
    };
}
unsafe extern "C" fn sctp_handle_str_reset_add_out_strm(
    mut stcb: *mut sctp_tcb,
    mut chk: *mut sctp_tmit_chunk,
    mut str_add: *mut sctp_stream_reset_add_strm,
) {
    let mut num_stream = 0;
    let mut seq = 0;
    let mut asoc = &mut (*stcb).asoc;
    /* Get the number. */
    seq = ntohl((*str_add).request_seq);
    num_stream = ntohs((*str_add).number_of_streams);
    /* Now what would be the new total? */
    if (*asoc).str_reset_seq_in == seq {
        (*stcb).asoc.last_reset_action[1usize] = (*stcb).asoc.last_reset_action[0usize];
        if (*asoc).local_strreset_support as libc::c_int & 0x4i32 == 0 {
            (*asoc).last_reset_action[0usize] = 0x2u32
        } else if (*stcb).asoc.stream_reset_outstanding != 0 {
            /* We must reject it we have something pending */
            (*stcb).asoc.last_reset_action[0usize] = 0x4u32
        } else {
            let mut mychk = 0;
            mychk = (*stcb).asoc.streamoutcnt as libc::c_int;
            mychk += num_stream as libc::c_int;
            if mychk < 0x10000i32 {
                (*stcb).asoc.last_reset_action[0usize] = 0x1u32;
                if sctp_send_str_reset_req(
                    stcb,
                    0u16,
                    0 as *mut uint16_t,
                    0u8,
                    0u8,
                    1u8,
                    num_stream,
                    0u16,
                    1u8,
                ) != 0
                {
                    (*stcb).asoc.last_reset_action[0usize] = 0x2u32
                }
            } else {
                (*stcb).asoc.last_reset_action[0usize] = 0x2u32
            }
        }
        sctp_add_stream_reset_result(chk, seq, (*stcb).asoc.last_reset_action[0usize]);
        (*asoc).str_reset_seq_in = (*asoc).str_reset_seq_in.wrapping_add(1)
    } else if (*asoc).str_reset_seq_in.wrapping_sub(1u32) == seq {
        /*
         * one seq back, just echo back last action since my
         * response was lost.
         */
        sctp_add_stream_reset_result(chk, seq, (*asoc).last_reset_action[0usize]);
    } else if (*asoc).str_reset_seq_in.wrapping_sub(2u32) == seq {
        /*
         * two seq back, just echo back last action since my
         * response was lost.
         */
        sctp_add_stream_reset_result(chk, seq, (*asoc).last_reset_action[1usize]);
    } else {
        sctp_add_stream_reset_result(chk, seq, 0x5u32);
    };
}
#[inline(never)]
unsafe extern "C" fn sctp_handle_stream_reset(
    mut stcb: *mut sctp_tcb,
    mut m: *mut mbuf,
    mut offset: libc::c_int,
    mut ch_req: *mut sctp_chunkhdr,
) -> libc::c_int {
    let mut remaining_length = 0;
    let mut chk = 0 as *mut sctp_tmit_chunk;
    let mut ret_code = 0i32;
    /* now it may be a reset or a reset-response */
    remaining_length = (ntohs((*ch_req).chunk_length) as libc::c_ulong)
        .wrapping_sub(::std::mem::size_of::<sctp_chunkhdr>() as libc::c_ulong)
        as uint16_t;
    /* setup for adding the response */
    if (*stcb).asoc.free_chunks.tqh_first.is_null() {
        chk = malloc(system_base_info.sctppcbinfo.ipi_zone_chunk) as *mut sctp_tmit_chunk;
        if !chk.is_null() {
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctppcbinfo.ipi_count_chunk, 1u32);
            (*chk).whoTo = 0 as *mut sctp_nets;
            (*chk).holds_key_ref = 0u8
        }
    } else {
        chk = (*stcb).asoc.free_chunks.tqh_first;
        if !(*chk).sctp_next.tqe_next.is_null() {
            (*(*chk).sctp_next.tqe_next).sctp_next.tqe_prev = (*chk).sctp_next.tqe_prev
        } else {
            (*stcb).asoc.free_chunks.tqh_last = (*chk).sctp_next.tqe_prev
        }
        *(*chk).sctp_next.tqe_prev = (*chk).sctp_next.tqe_next;
        ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_free_chunks, 1u32);
        (*chk).holds_key_ref = 0u8;
        ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_cached_chk, 1u32);
        (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_sub(1)
    }
    if chk.is_null() {
        return ret_code;
    }
    (*chk).copy_by_ref = 0u8;
    (*chk).rec.chunk_id.id = 0x82u8;
    (*chk).rec.chunk_id.can_take_data = 0u8;
    (*chk).flags = 0u16;
    (*chk).asoc = &mut (*stcb).asoc;
    (*chk).no_fr_allowed = 0u8;
    (*chk).send_size = ::std::mem::size_of::<sctp_chunkhdr>() as uint16_t;
    (*chk).book_size = (*chk).send_size;
    (*chk).book_size_scale = 0u8;
    (*chk).data = sctp_get_mbuf_for_msg(2048u32, 0i32, 0x1i32, 1i32, 1i32);
    if !(*chk).data.is_null() {
        let mut current_block: u64;
        let mut num_req = 0i32;
        let mut ch = 0 as *mut sctp_chunkhdr;
        (*(*chk).data).m_hdr.mh_data = (*(*chk).data).m_hdr.mh_data.offset(
            (::std::mem::size_of::<ip6_hdr>() as libc::c_ulong)
                .wrapping_add(::std::mem::size_of::<sctphdr>() as libc::c_ulong)
                as isize,
        );
        /* setup chunk parameters */
        (*chk).sent = 0i32;
        (*chk).snd_count = 0u16;
        (*chk).whoTo = 0 as *mut sctp_nets;
        ch = (*(*chk).data).m_hdr.mh_data as *mut sctp_chunkhdr;
        (*ch).chunk_type = 0x82u8;
        (*ch).chunk_flags = 0u8;
        (*ch).chunk_length = htons((*chk).send_size);
        (*(*chk).data).m_hdr.mh_len = ((*chk).send_size as libc::c_int + 3i32 >> 2i32) << 2i32;
        offset = (offset as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<sctp_chunkhdr>() as libc::c_ulong)
            as libc::c_int;
        loop {
            let mut pstore = sctp_paramhdr {
                param_type: 0,
                param_length: 0,
            };
            let mut ph = 0 as *mut sctp_paramhdr;
            if !(remaining_length as libc::c_ulong
                >= ::std::mem::size_of::<sctp_paramhdr>() as libc::c_ulong)
            {
                current_block = 2167674248514145403;
                break;
            }
            ph = sctp_m_getptr(
                m,
                offset,
                ::std::mem::size_of::<sctp_paramhdr>() as libc::c_int,
                &mut pstore as *mut sctp_paramhdr as *mut uint8_t,
            ) as *mut sctp_paramhdr;
            if ph.is_null() {
                /* TSNH */
                current_block = 2167674248514145403;
                break;
            } else {
                let mut param_len = 0;
                param_len = ntohs((*ph).param_length);
                if param_len as libc::c_int > remaining_length as libc::c_int
                    || (param_len as libc::c_ulong)
                        < (::std::mem::size_of::<sctp_paramhdr>() as libc::c_ulong)
                            .wrapping_add(::std::mem::size_of::<uint32_t>() as libc::c_ulong)
                {
                    /* bad parameter length */
                    current_block = 2167674248514145403;
                    break;
                } else {
                    let mut cstore = [0u8; 512];
                    ph = sctp_m_getptr(
                        m,
                        offset,
                        if param_len as libc::c_ulong
                            > ::std::mem::size_of::<[uint8_t; 512]>() as libc::c_ulong
                        {
                            ::std::mem::size_of::<[uint8_t; 512]>() as libc::c_ulong
                        } else {
                            param_len as libc::c_ulong
                        } as libc::c_int,
                        &mut cstore as *mut [uint8_t; 512] as *mut uint8_t,
                    ) as *mut sctp_paramhdr;
                    if ph.is_null() {
                        /* TSNH */
                        current_block = 2167674248514145403;
                        break;
                    } else {
                        let mut ptype = 0;
                        let mut trunc = 0i32;
                        let mut num_param = 0i32;
                        ptype = ntohs((*ph).param_type);
                        num_param += 1;
                        if param_len as libc::c_ulong
                            > ::std::mem::size_of::<[uint8_t; 512]>() as libc::c_ulong
                        {
                            trunc = 1i32
                        } else {
                            trunc = 0i32
                        }
                        if num_param > 2i32 {
                            /* hit the max of parameters already sorry.. */
                            current_block = 2167674248514145403;
                            break;
                        } else {
                            let mut seq = 0u32;
                            if ptype as libc::c_int == 0xdi32 {
                                let mut req_out = 0 as *mut sctp_stream_reset_out_request;
                                if (param_len as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_stream_reset_out_request>()
                                        as libc::c_ulong
                                {
                                    current_block = 2167674248514145403;
                                    break;
                                }
                                req_out = ph as *mut sctp_stream_reset_out_request;
                                num_req += 1;
                                if (*stcb).asoc.stream_reset_outstanding != 0 {
                                    seq = ntohl((*req_out).response_seq);
                                    if seq == (*stcb).asoc.str_reset_seq_out {
                                        /* implicit ack */
                                        sctp_handle_stream_reset_response(
                                            stcb,
                                            seq,
                                            0x1u32,
                                            0 as *mut sctp_stream_reset_response,
                                        );
                                    }
                                }
                                sctp_handle_str_reset_request_out(stcb, chk, req_out, trunc);
                            } else if ptype as libc::c_int == 0x11i32 {
                                let mut str_add = 0 as *mut sctp_stream_reset_add_strm;
                                if (param_len as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_stream_reset_add_strm>()
                                        as libc::c_ulong
                                {
                                    current_block = 2167674248514145403;
                                    break;
                                }
                                str_add = ph as *mut sctp_stream_reset_add_strm;
                                num_req += 1;
                                sctp_handle_str_reset_add_strm(stcb, chk, str_add);
                            } else if ptype as libc::c_int == 0x12i32 {
                                let mut str_add_0 = 0 as *mut sctp_stream_reset_add_strm;
                                if (param_len as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_stream_reset_add_strm>()
                                        as libc::c_ulong
                                {
                                    current_block = 2167674248514145403;
                                    break;
                                }
                                str_add_0 = ph as *mut sctp_stream_reset_add_strm;
                                num_req += 1;
                                sctp_handle_str_reset_add_out_strm(stcb, chk, str_add_0);
                            } else if ptype as libc::c_int == 0xei32 {
                                let mut req_in = 0 as *mut sctp_stream_reset_in_request;
                                num_req += 1;
                                req_in = ph as *mut sctp_stream_reset_in_request;
                                sctp_handle_str_reset_request_in(stcb, chk, req_in, trunc);
                            } else if ptype as libc::c_int == 0xfi32 {
                                let mut req_tsn = 0 as *mut sctp_stream_reset_tsn_request;
                                num_req += 1;
                                req_tsn = ph as *mut sctp_stream_reset_tsn_request;
                                if !(sctp_handle_str_reset_request_tsn(stcb, chk, req_tsn) != 0) {
                                    current_block = 2167674248514145403;
                                    break;
                                }
                                ret_code = 1i32;
                                current_block = 14974733831175737844;
                                break;
                            } else {
                                let mut resp = 0 as *mut sctp_stream_reset_response;
                                let mut result = 0;
                                if !(ptype as libc::c_int == 0x10i32) {
                                    current_block = 2167674248514145403;
                                    break;
                                }

                                if (param_len as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_stream_reset_response>()
                                        as libc::c_ulong
                                {
                                    current_block = 2167674248514145403;
                                    break;
                                }
                                resp = ph as *mut sctp_stream_reset_response;
                                seq = ntohl((*resp).response_seq);
                                result = ntohl((*resp).result);
                                if sctp_handle_stream_reset_response(stcb, seq, result, resp) != 0 {
                                    ret_code = 1i32;
                                    current_block = 14974733831175737844;
                                    break;
                                }
                            }
                            offset += (param_len as libc::c_int + 3i32 >> 2i32) << 2i32;
                            if remaining_length as libc::c_int
                                >= (param_len as libc::c_int + 3i32 >> 2i32) << 2i32
                            {
                                remaining_length = (remaining_length as libc::c_int
                                    - ((param_len as libc::c_int + 3i32 >> 2i32) << 2i32))
                                    as uint16_t
                            } else {
                                remaining_length = 0u16
                            }
                        }
                    }
                }
            }
        }
        match current_block {
            14974733831175737844 => {}
            _ =>
            /* no more */
            {
                if !(num_req == 0i32) {
                    /* ok we have a chunk to link in */
                    (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
                    (*chk).sctp_next.tqe_prev = (*stcb).asoc.control_send_queue.tqh_last;
                    *(*stcb).asoc.control_send_queue.tqh_last = chk;
                    (*stcb).asoc.control_send_queue.tqh_last = &mut (*chk).sctp_next.tqe_next;
                    (*stcb).asoc.ctrl_queue_cnt += 1;
                    return ret_code;
                }
            }
        }
    }
    /* we have no response free the stuff */
    if !(*chk).data.is_null() {
        m_freem((*chk).data);
        (*chk).data = 0 as *mut mbuf
    }
    if (*chk).holds_key_ref != 0 {
        sctp_auth_key_release(stcb, (*chk).auth_keyid, 0i32);
        (*chk).holds_key_ref = 0u8
    }
    if !stcb.is_null() {
        if !(*chk).whoTo.is_null() {
            if !(*chk).whoTo.is_null() {
                if ::std::intrinsics::atomic_xadd(
                    &mut (*(*chk).whoTo).ref_count as *mut libc::c_int,
                    -(1i32),
                ) == 1i32
                {
                    sctp_os_timer_stop(&mut (*(*chk).whoTo).rxt_timer.timer);
                    sctp_os_timer_stop(&mut (*(*chk).whoTo).pmtu_timer.timer);
                    sctp_os_timer_stop(&mut (*(*chk).whoTo).hb_timer.timer);
                    if !(*(*chk).whoTo).ro.ro_rt.is_null() {
                        if (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt <= 1i64 {
                            sctp_userspace_rtfree((*(*chk).whoTo).ro.ro_rt);
                        } else {
                            (*(*(*chk).whoTo).ro.ro_rt).rt_refcnt -= 1
                        }
                        (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t;
                        (*(*chk).whoTo).ro.ro_rt = 0 as *mut sctp_rtentry_t
                    }
                    if (*(*chk).whoTo).src_addr_selected != 0 {
                        sctp_free_ifa((*(*chk).whoTo).ro._s_addr);
                        (*(*chk).whoTo).ro._s_addr = 0 as *mut sctp_ifa
                    }
                    (*(*chk).whoTo).src_addr_selected = 0u8;
                    (*(*chk).whoTo).dest_state =
                        ((*(*chk).whoTo).dest_state as libc::c_int & !(0x1i32)) as uint16_t;
                    free((*chk).whoTo as *mut libc::c_void);
                    ::std::intrinsics::atomic_xsub(
                        &mut system_base_info.sctppcbinfo.ipi_count_raddr,
                        1u32,
                    );
                }
            }
            (*chk).whoTo = 0 as *mut sctp_nets
        }
        if (*stcb).asoc.free_chunk_cnt as libc::c_uint
            > system_base_info.sctpsysctl.sctp_asoc_free_resc_limit
            || system_base_info.sctppcbinfo.ipi_free_chunks
                > system_base_info.sctpsysctl.sctp_system_free_resc_limit
        {
            free(chk as *mut libc::c_void);
            ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_count_chunk, 1u32);
        } else {
            (*chk).sctp_next.tqe_next = 0 as *mut sctp_tmit_chunk;
            (*chk).sctp_next.tqe_prev = (*stcb).asoc.free_chunks.tqh_last;
            *(*stcb).asoc.free_chunks.tqh_last = chk;
            (*stcb).asoc.free_chunks.tqh_last = &mut (*chk).sctp_next.tqe_next;
            (*stcb).asoc.free_chunk_cnt = (*stcb).asoc.free_chunk_cnt.wrapping_add(1);
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctppcbinfo.ipi_free_chunks, 1u32);
        }
    } else {
        free(chk as *mut libc::c_void);
        ::std::intrinsics::atomic_xsub(&mut system_base_info.sctppcbinfo.ipi_count_chunk, 1u32);
    }
    return ret_code;
}
/*
 * Handle a router or endpoints report of a packet loss, there are two ways
 * to handle this, either we get the whole packet and must disect it
 * ourselves (possibly with truncation and or corruption) or it is a summary
 * from a middle box that did the disectting for us.
 */
unsafe extern "C" fn sctp_handle_packet_dropped(
    mut cp: *mut sctp_pktdrop_chunk,
    mut stcb: *mut sctp_tcb,
    mut net: *mut sctp_nets,
    mut limit: uint32_t,
) {
    let mut bottle_bw = 0;
    let mut on_queue = 0;
    let mut trunc_len = 0;
    let mut chlen = 0;
    let mut desc = sctp_chunk_desc {
        chunk_type: 0,
        data_bytes: [0; 31],
        tsn_ifany: 0,
    };
    let mut ch = 0 as *mut sctp_chunkhdr;
    chlen = ntohs((*cp).ch.chunk_length) as libc::c_uint;
    chlen = (chlen as libc::c_ulong)
        .wrapping_sub(::std::mem::size_of::<sctp_pktdrop_chunk>() as libc::c_ulong)
        as libc::c_uint;
    /* XXX possible chlen underflow */
    if chlen == 0u32 {
        ch = 0 as *mut sctp_chunkhdr;
        if (*cp).ch.chunk_flags as libc::c_int & 0x1i32 != 0 {
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_pdrpbwrpt, 1u32);
        }
    } else {
        ch = (*cp)
            .data
            .as_mut_ptr()
            .offset(::std::mem::size_of::<sctphdr>() as isize) as *mut sctp_chunkhdr;
        chlen = (chlen as libc::c_ulong)
            .wrapping_sub(::std::mem::size_of::<sctphdr>() as libc::c_ulong)
            as libc::c_uint;
        /* XXX possible chlen underflow */
        memset(
            &mut desc as *mut sctp_chunk_desc as *mut libc::c_void,
            0i32,
            ::std::mem::size_of::<sctp_chunk_desc>() as libc::c_ulong,
        );
    }
    trunc_len = ntohs((*cp).trunc_len);
    if trunc_len as libc::c_uint > limit {
        trunc_len = limit as uint16_t
    }
    /* now the chunks themselves */
    while !ch.is_null()
        && chlen as libc::c_ulong >= ::std::mem::size_of::<sctp_chunkhdr>() as libc::c_ulong
    {
        let mut at = 0;
        desc.chunk_type = (*ch).chunk_type;
        /* get amount we need to move */
        at = ntohs((*ch).chunk_length) as libc::c_uint;
        if (at as libc::c_ulong) < ::std::mem::size_of::<sctp_chunkhdr>() as libc::c_ulong {
            /* corrupt chunk, maybe at the end? */
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_pdrpcrupt, 1u32);
            break;
        } else {
            if trunc_len as libc::c_int == 0i32 {
                /* we are supposed to have all of it */
                if at > chlen {
                    /* corrupt skip it */
                    ::std::intrinsics::atomic_xadd(
                        &mut system_base_info.sctpstat.sctps_pdrpcrupt,
                        1u32,
                    );
                    break;
                }
            } else if desc.chunk_type as libc::c_int == 0i32 {
                if (chlen as libc::c_ulong)
                    < (::std::mem::size_of::<sctp_data_chunk>() as libc::c_ulong)
                        .wrapping_add(::std::mem::size_of::<[uint8_t; 31]>() as libc::c_ulong)
                {
                    break;
                }
            } else if (chlen as libc::c_ulong)
                < ::std::mem::size_of::<sctp_chunkhdr>() as libc::c_ulong
            {
                break;
            }
            if desc.chunk_type as libc::c_int == 0i32 {
                /* is there enough of it left ? */
                /* can we get out the tsn? */
                if (*cp).ch.chunk_flags as libc::c_int & 0x1i32 != 0 {
                    ::std::intrinsics::atomic_xadd(
                        &mut system_base_info.sctpstat.sctps_pdrpmbda,
                        1u32,
                    );
                }
                if chlen as libc::c_ulong
                    >= (::std::mem::size_of::<sctp_data_chunk>() as libc::c_ulong)
                        .wrapping_add(::std::mem::size_of::<uint32_t>() as libc::c_ulong)
                {
                    let mut dcp = 0 as *mut sctp_data_chunk;
                    let mut ddp = 0 as *mut uint8_t;
                    let mut iii = 0;
                    dcp = ch as *mut sctp_data_chunk;
                    ddp = dcp.offset(1isize) as *mut uint8_t;
                    iii = 0u32;
                    while (iii as libc::c_ulong)
                        < ::std::mem::size_of::<[uint8_t; 31]>() as libc::c_ulong
                    {
                        desc.data_bytes[iii as usize] = *ddp.offset(iii as isize);
                        iii = iii.wrapping_add(1)
                    }
                    desc.tsn_ifany = (*dcp).dp.tsn
                } else {
                    /* nope we are done. */
                    ::std::intrinsics::atomic_xadd(
                        &mut system_base_info.sctpstat.sctps_pdrpnedat,
                        1u32,
                    );
                    break;
                }
            } else if (*cp).ch.chunk_flags as libc::c_int & 0x1i32 != 0 {
                ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_pdrpmbct, 1u32);
            }
            if process_chunk_drop(stcb, &mut desc, net, (*cp).ch.chunk_flags) != 0 {
                ::std::intrinsics::atomic_xadd(
                    &mut system_base_info.sctpstat.sctps_pdrppdbrk,
                    1u32,
                );
                break;
            } else {
                if (at.wrapping_add(3u32) >> 2i32) << 2i32 > chlen {
                    break;
                }
                chlen = chlen.wrapping_sub((at.wrapping_add(3u32) >> 2i32) << 2i32);
                if (chlen as libc::c_ulong)
                    < ::std::mem::size_of::<sctp_chunkhdr>() as libc::c_ulong
                {
                    break;
                }
                ch = (ch as caddr_t).offset(((at.wrapping_add(3u32) >> 2i32) << 2i32) as isize)
                    as *mut sctp_chunkhdr
            }
        }
    }
    /* Now update any rwnd --- possibly */
    if (*cp).ch.chunk_flags as libc::c_int & 0x1i32 == 0i32 {
        ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_pdrpfehos, 1u32);
        bottle_bw = ntohl((*cp).bottle_bw);
        on_queue = ntohl((*cp).current_onq);
        if bottle_bw != 0 && on_queue != 0 {
            let mut a_rwnd = 0;
            if bottle_bw > on_queue {
                a_rwnd = bottle_bw.wrapping_sub(on_queue)
            } else {
                a_rwnd = 0u32
            }
            if a_rwnd == 0u32 {
                (*stcb).asoc.peers_rwnd = 0u32
            } else {
                if a_rwnd > (*stcb).asoc.total_flight {
                    (*stcb).asoc.peers_rwnd = a_rwnd.wrapping_sub((*stcb).asoc.total_flight)
                } else {
                    (*stcb).asoc.peers_rwnd = 0u32
                }
                if (*stcb).asoc.peers_rwnd < (*(*stcb).sctp_ep).sctp_ep.sctp_sws_sender {
                    /* SWS sender side engages */
                    (*stcb).asoc.peers_rwnd = 0u32
                }
            }
        }
    } else {
        ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_pdrpfmbox, 1u32);
    }
    /* now middle boxes in sat networks get a cwnd bump */
    if (*cp).ch.chunk_flags as libc::c_int & 0x1i32 != 0
        && (*stcb).asoc.sat_t3_loss_recovery as libc::c_int == 0i32
        && (*stcb).asoc.sat_network as libc::c_int != 0
    {
        /*
         * This is debatable but for sat networks it makes sense
         * Note if a T3 timer has went off, we will prohibit any
         * changes to cwnd until we exit the t3 loss recovery.
         */
        (*stcb)
            .asoc
            .cc_functions
            .sctp_cwnd_update_after_packet_dropped
            .expect("non-null function pointer")(
            stcb, net, cp, &mut bottle_bw, &mut on_queue
        );
    };
}
/*
 * handles all control chunks in a packet inputs: - m: mbuf chain, assumed to
 * still contain IP/SCTP header - stcb: is the tcb found for this packet -
 * offset: offset into the mbuf chain to first chunkhdr - length: is the
 * length of the complete packet outputs: - length: modified to remaining
 * length after control processing - netp: modified to new sctp_nets after
 * cookie-echo processing - return NULL to discard the packet (ie. no asoc,
 * bad packet,...) otherwise return the tcb for this packet
 */
#[inline(never)]
unsafe extern "C" fn sctp_process_control(
    mut m: *mut mbuf,
    mut iphlen: libc::c_int,
    mut offset: *mut libc::c_int,
    mut length: libc::c_int,
    mut src: *mut sockaddr,
    mut dst: *mut sockaddr,
    mut sh: *mut sctphdr,
    mut ch: *mut sctp_chunkhdr,
    mut inp: *mut sctp_inpcb,
    mut stcb: *mut sctp_tcb,
    mut netp: *mut *mut sctp_nets,
    mut fwd_tsn_seen: *mut libc::c_int,
    mut vrf_id: uint32_t,
    mut port: uint16_t,
) -> *mut sctp_tcb {
    let mut current_block: u64;
    let mut op_err = 0 as *mut mbuf;
    let mut vtag_in = 0;
    let mut chunk_buf = [0; 512];
    let mut got_auth = 0i32;
    let mut auth_offset = 0u32;
    let mut auth_len = 0u32;
    let mut auth_skipped = 0i32;
    let mut asconf_cnt = 0i32;
    if system_base_info.sctpsysctl.sctp_debug_on & 0x1000u32 != 0 {
        if system_base_info.debug_printf.is_some() {
            system_base_info
                .debug_printf
                .expect("non-null function pointer")(
                b"sctp_process_control: iphlen=%u, offset=%u, length=%u stcb:%p\n\x00" as *const u8
                    as *const libc::c_char,
                iphlen,
                *offset,
                length,
                stcb as *mut libc::c_void,
            );
        }
    }
    !stcb.is_null();
    /* validate chunk header length... */
    if (ntohs((*ch).chunk_length) as libc::c_ulong)
        < ::std::mem::size_of::<sctp_chunkhdr>() as libc::c_ulong
    {
        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"Invalid header length %d\n\x00" as *const u8 as *const libc::c_char,
                    ntohs((*ch).chunk_length) as libc::c_int,
                );
            }
        }
        *offset = length;
        return stcb;
    }
    /*
     * validate the verification tag
     */
    vtag_in = ntohl((*sh).v_tag); /* end if !SCTP_COOKIE_ECHO */
    if (*ch).chunk_type as libc::c_int == 0x1i32 {
        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"Its an INIT of len:%d vtag:%x\n\x00" as *const u8 as *const libc::c_char,
                    ntohs((*ch).chunk_length) as libc::c_int,
                    vtag_in,
                );
            }
        }
        if vtag_in != 0u32 {
            /* protocol error- silently discard... */
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_badvtag, 1u32);
            if !stcb.is_null() {
                pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
            }
            return 0 as *mut sctp_tcb;
        }
        current_block = 15650704408606443395;
    } else if (*ch).chunk_type as libc::c_int != 0xai32 {
        /*
         * If there is no stcb, skip the AUTH chunk and process
         * later after a stcb is found (to validate the lookup was
         * valid.
         */
        if (*ch).chunk_type as libc::c_int == 0xfi32
            && stcb.is_null()
            && (*inp).auth_supported as libc::c_int == 1i32
        {
            /* save this chunk for later processing */
            auth_skipped = 1i32;
            auth_offset = *offset as uint32_t;
            auth_len = ntohs((*ch).chunk_length) as uint32_t;
            /* (temporarily) move past this chunk */
            *offset = (*offset as libc::c_uint)
                .wrapping_add((auth_len.wrapping_add(3u32) >> 2i32) << 2i32)
                as libc::c_int;
            if *offset >= length {
                /* no more data left in the mbuf chain */
                *offset = length;
                return 0 as *mut sctp_tcb;
            }
            ch = sctp_m_getptr(
                m,
                *offset,
                ::std::mem::size_of::<sctp_chunkhdr>() as libc::c_int,
                chunk_buf.as_mut_ptr(),
            ) as *mut sctp_chunkhdr
        }
        if ch.is_null() {
            /* Help */
            *offset = length;
            return stcb;
        }
        if (*ch).chunk_type as libc::c_int == 0xai32 {
            current_block = 16974974966130203269;
        } else {
            let mut asoc = 0 as *mut sctp_association;
            let mut msg = [0; 128];
            if (*ch).chunk_type as libc::c_int == 0xc1i32 && stcb.is_null() {
                let mut asconf_offset = 0u32;
                let mut asconf_ch = ch;

                /* inp's refcount may be reduced */
                ::std::intrinsics::atomic_xadd(&mut (*inp).refcount, 1i32);
                asconf_offset = *offset as uint32_t;
                loop {
                    let mut asconf_len = 0u32;
                    asconf_len = ntohs((*asconf_ch).chunk_length) as uint32_t;
                    if (asconf_len as libc::c_ulong)
                        < ::std::mem::size_of::<sctp_asconf_paramhdr>() as libc::c_ulong
                    {
                        break;
                    }
                    stcb =
                        sctp_findassociation_ep_asconf(m, *offset, dst, sh, &mut inp, netp, vrf_id);
                    if !stcb.is_null() {
                        break;
                    }
                    asconf_offset = (asconf_offset)
                        .wrapping_add((asconf_len.wrapping_add(3u32) >> 2i32) << 2i32);
                    asconf_ch = sctp_m_getptr(
                        m,
                        asconf_offset as libc::c_int,
                        ::std::mem::size_of::<sctp_chunkhdr>() as libc::c_int,
                        chunk_buf.as_mut_ptr(),
                    ) as *mut sctp_chunkhdr;
                    if !(!asconf_ch.is_null() && (*asconf_ch).chunk_type as libc::c_int == 0xc1i32)
                    {
                        break;
                    }
                }
                if stcb.is_null() {
                    /*
                     * reduce inp's refcount if not reduced in
                     * sctp_findassociation_ep_asconf().
                     */
                    ::std::intrinsics::atomic_xadd(&mut (*inp).refcount, -(1i32));
                }
                /* now go back and verify any auth chunk to be sure */
                if auth_skipped != 0 && !stcb.is_null() {
                    let mut auth = 0 as *mut sctp_auth_chunk;
                    if auth_len <= 512u32 {
                        auth = sctp_m_getptr(
                            m,
                            auth_offset as libc::c_int,
                            auth_len as libc::c_int,
                            chunk_buf.as_mut_ptr(),
                        ) as *mut sctp_auth_chunk;
                        got_auth = 1i32;
                        auth_skipped = 0i32
                    } else {
                        auth = 0 as *mut sctp_auth_chunk
                    }
                    if auth.is_null() || sctp_handle_auth(stcb, auth, m, auth_offset) != 0 {
                        /* auth HMAC failed so dump it */
                        *offset = length;
                        return stcb;
                    } else {
                        /* remaining chunks are HMAC checked */
                        (*stcb).asoc.authenticated = 1u8
                    }
                }
            }
            if stcb.is_null() {
                snprintf(msg.as_mut_ptr(),
                         ::std::mem::size_of::<[libc::c_char; 128]>() as
                             libc::c_ulong,
                         b"OOTB, %s:%d at %s\x00" as *const u8 as
                             *const libc::c_char,
                         b"/usr/local/google/home/winniexiao/chromium/src/third_party/usrsctp/usrsctplib/usrsctplib/netinet/sctp_input.c\x00"
                             as *const u8 as *const libc::c_char,
                         4873i32,
                         (*::std::mem::transmute::<&[u8; 21],
                                                   &[libc::c_char; 21]>(b"sctp_process_control\x00")).as_ptr());
                op_err = sctp_generate_cause(
                    system_base_info.sctpsysctl.sctp_diag_info_code as uint16_t,
                    msg.as_mut_ptr(),
                );
                /* no association, so it's out of the blue... */
                sctp_handle_ootb(m, iphlen, *offset, src, dst, sh, inp, op_err, vrf_id, port);
                *offset = length;
                return 0 as *mut sctp_tcb;
            }
            asoc = &mut (*stcb).asoc;
            /* ABORT and SHUTDOWN can use either v_tag... */
            if (*ch).chunk_type as libc::c_int == 0x6i32
                || (*ch).chunk_type as libc::c_int == 0xei32
                || (*ch).chunk_type as libc::c_int == 0x81i32
            {
                /* Take the T-bit always into account. */
                if (*ch).chunk_flags as libc::c_int & 0x1i32 == 0i32 && vtag_in == (*asoc).my_vtag
                    || (*ch).chunk_flags as libc::c_int & 0x1i32 == 0x1i32
                        && (*asoc).peer_vtag != htonl(0u32)
                        && vtag_in == (*asoc).peer_vtag
                {
                } else {
                    /* drop this packet... */
                    ::std::intrinsics::atomic_xadd(
                        &mut system_base_info.sctpstat.sctps_badvtag,
                        1u32,
                    );
                    if !stcb.is_null() {
                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                    }
                    return 0 as *mut sctp_tcb;
                }
            } else if (*ch).chunk_type as libc::c_int == 0x8i32 {
                if vtag_in != (*asoc).my_vtag {
                    /*
                     * this could be a stale SHUTDOWN-ACK or the
                     * peer never got the SHUTDOWN-COMPLETE and
                     * is still hung; we have started a new asoc
                     * but it won't complete until the shutdown
                     * is completed
                     */
                    if !stcb.is_null() {
                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                    }
                    snprintf(msg.as_mut_ptr(),
                             ::std::mem::size_of::<[libc::c_char; 128]>() as
                                 libc::c_ulong,
                             b"OOTB, %s:%d at %s\x00" as *const u8 as
                                 *const libc::c_char,
                             b"/usr/local/google/home/winniexiao/chromium/src/third_party/usrsctp/usrsctplib/usrsctplib/netinet/sctp_input.c\x00"
                                 as *const u8 as *const libc::c_char,
                             4917i32,
                             (*::std::mem::transmute::<&[u8; 21],
                                                       &[libc::c_char; 21]>(b"sctp_process_control\x00")).as_ptr());
                    op_err = sctp_generate_cause(
                        system_base_info.sctpsysctl.sctp_diag_info_code as uint16_t,
                        msg.as_mut_ptr(),
                    );
                    sctp_handle_ootb(m, iphlen, *offset, src, dst, sh, inp, op_err, vrf_id, port);
                    return 0 as *mut sctp_tcb;
                }
            } else if vtag_in != (*asoc).my_vtag {
                /* for all other chunks, vtag must match */
                /* invalid vtag... */
                if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                    if system_base_info.debug_printf.is_some() {
                        system_base_info
                            .debug_printf
                            .expect("non-null function pointer")(
                            b"invalid vtag: %xh, expect %xh\n\x00" as *const u8
                                as *const libc::c_char,
                            vtag_in,
                            (*asoc).my_vtag,
                        );
                    }
                }
                ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_badvtag, 1u32);
                if !stcb.is_null() {
                    pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                }
                *offset = length;
                return 0 as *mut sctp_tcb;
            }
            current_block = 15650704408606443395;
        }
    } else {
        current_block = 15650704408606443395;
    }
    match current_block {
        15650704408606443395 => {
            /*
             * process all control chunks...
             */
            if ((*ch).chunk_type as libc::c_int == 0x3i32
                || (*ch).chunk_type as libc::c_int == 0x10i32
                || (*ch).chunk_type as libc::c_int == 0x4i32)
                && (*stcb).asoc.state & 0x7fi32 == 0x4i32
            {
                /* implied cookie-ack.. we must have lost the ack */
                sctp_handle_cookie_ack(ch as *mut sctp_cookie_ack_chunk, stcb, *netp);
                /* while */
            }
        }
        _ => {}
    }
    while (*ch).chunk_type as libc::c_int != 0i32 && (*ch).chunk_type as libc::c_int != 0x40i32 {
        let mut num_chunks = 0i32;
        let mut chk_length = 0;
        let mut contiguous = 0;
        chk_length = ntohs((*ch).chunk_length) as uint32_t;
        if system_base_info.sctpsysctl.sctp_debug_on & 0x2000u32 != 0 {
            if system_base_info.debug_printf.is_some() {
                system_base_info
                    .debug_printf
                    .expect("non-null function pointer")(
                    b"sctp_process_control: processing a chunk type=%u, len=%u\n\x00" as *const u8
                        as *const libc::c_char,
                    (*ch).chunk_type as libc::c_int,
                    chk_length,
                );
            }
        }
        if (chk_length as libc::c_ulong) < ::std::mem::size_of::<sctp_chunkhdr>() as libc::c_ulong
            || *offset + chk_length as libc::c_int > length
        {
            *offset = length;
            return stcb;
        }
        ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_incontrolchunks, 1u32);
        /*
         * INIT and INIT-ACK only gets the init ack "header" portion
         * only because we don't have to process the peer's COOKIE.
         * All others get a complete chunk.
         */
        match (*ch).chunk_type as libc::c_int {
            1 => contiguous = ::std::mem::size_of::<sctp_init_chunk>() as uint32_t,
            2 => contiguous = ::std::mem::size_of::<sctp_init_chunk>() as uint32_t,
            _ => {
                contiguous = if chk_length as libc::c_ulong
                    > ::std::mem::size_of::<[uint8_t; 512]>() as libc::c_ulong
                {
                    ::std::mem::size_of::<[uint8_t; 512]>() as libc::c_ulong
                } else {
                    chk_length as libc::c_ulong
                } as uint32_t
            }
        }
        ch = sctp_m_getptr(
            m,
            *offset,
            contiguous as libc::c_int,
            chunk_buf.as_mut_ptr(),
        ) as *mut sctp_chunkhdr;
        if ch.is_null() {
            *offset = length;
            if !stcb.is_null() {
                pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
            }
            return 0 as *mut sctp_tcb;
        }
        num_chunks += 1;
        /* Save off the last place we got a control from */
        if !stcb.is_null() {
            if !netp.is_null() && !(*netp).is_null() || (*ch).chunk_type as libc::c_int == 0xc1i32 {
                /*
                 * allow last_control to be NULL if
                 * ASCONF... ASCONF processing will find the
                 * right net later
                 */
                if !netp.is_null() && !(*netp).is_null() {
                    (*stcb).asoc.last_control_chunk_from = *netp
                }
            }
        }
        /* check to see if this chunk required auth, but isn't */
        if !stcb.is_null()
            && (if (*stcb).asoc.local_auth_chunks.is_null() {
                0i32
            } else {
                ((*(*stcb).asoc.local_auth_chunks).chunks[(*ch).chunk_type as usize] as libc::c_int
                    != 0i32) as libc::c_int
            }) != 0
            && (*stcb).asoc.authenticated == 0
        {
            /* "silently" ignore */
            ::std::intrinsics::atomic_xadd(
                &mut system_base_info.sctpstat.sctps_recvauthmissing,
                1u32,
            ); /* switch (ch->chunk_type) */
        } else {
            let mut ret = 0;
            let mut abort_no_unlock = 0i32;
            let mut ecne_seen = 0i32;
            match (*ch).chunk_type as libc::c_int {
                1 => {
                    current_block = 16195856799229720522;
                    match current_block {
                        17766256343850198083 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_COMPLETE, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            /* must be first and only chunk */
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_complete(
                                    ch as *mut sctp_shutdown_complete_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        12601157616349825580 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT_ACK\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                /* We are not interested anymore */
                                if !stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0 {
                                } else {
                                    *offset = length;
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1di32);
                                    }
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            /* The INIT-ACK chunk must be the only chunk. */
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                ret = sctp_handle_init_ack(
                                    m,
                                    iphlen,
                                    *offset,
                                    src,
                                    dst,
                                    sh,
                                    ch as *mut sctp_init_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_no_unlock,
                                    vrf_id,
                                )
                            } else {
                                ret = -(1i32)
                            }
                            *offset = length;
                            if abort_no_unlock != 0 {
                                return 0 as *mut sctp_tcb;
                            }
                            /*
                             * Special case, I must call the output routine to
                             * get the cookie echoed
                             */
                            if !stcb.is_null() && ret == 0i32 {
                                sctp_chunk_output((*stcb).sctp_ep, stcb, 3i32, 0i32);
                            }
                            return stcb;
                        }
                        16195856799229720522 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            /* The INIT chunk must be the only chunk. */
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                /* RFC 4960 requires that no ABORT is sent */
                                *offset = length;
                                if !stcb.is_null() {
                                    pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                }
                                return 0 as *mut sctp_tcb;
                            }
                            /* Honor our resource limit. */
                            if chk_length > (65535i32 - 2048i32) as libc::c_uint {
                                op_err = sctp_generate_cause(
                                    0x4u16,
                                    b"\x00" as *const u8 as *mut libc::c_char,
                                );
                                sctp_abort_association(
                                    inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id, port,
                                );
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            sctp_handle_init(
                                m,
                                iphlen,
                                *offset,
                                src,
                                dst,
                                sh,
                                ch as *mut sctp_init_chunk,
                                inp,
                                stcb,
                                *netp,
                                &mut abort_no_unlock,
                                vrf_id,
                                port,
                            );
                            *offset = length;
                            if abort_no_unlock == 0 && !stcb.is_null() {
                                pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                            }
                            return 0 as *mut sctp_tcb;
                        }
                        6246479402878884953 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_ack(
                                    ch as *mut sctp_shutdown_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        4558417918157925232 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ABORT, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            *offset = length;
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if sctp_handle_abort(ch as *mut sctp_abort_chunk, stcb, *netp) != 0
                                {
                                    return 0 as *mut sctp_tcb;
                                } else {
                                    return stcb;
                                }
                            } else {
                                return 0 as *mut sctp_tcb;
                            }
                        }
                        9379646460352968115 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ECHO, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && (*stcb).asoc.total_output_queue_size > 0u32 {
                                current_block = 15201865807353435331;
                            } else if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                current_block = 15767785092075175044;
                            } else {
                                current_block = 15201865807353435331;
                            }
                            match current_block {
                                15201865807353435331 =>
                                /*-
                                 * First are we accepting? We do this again here
                                 * since it is possible that a previous endpoint WAS
                                 * listening responded to a INIT-ACK and then
                                 * closed. We opened and bound.. and are now no
                                 * longer listening.
                                 *
                                 * XXXGL: notes on checking listen queue length.
                                 * 1) SCTP_IS_LISTENING() doesn't necessarily mean
                                 *    SOLISTENING(), because a listening "UDP type"
                                 *    socket isn't listening in terms of the socket
                                 *    layer.  It is a normal data flow socket, that
                                 *    can fork off new connections.  Thus, we should
                                 *    look into sol_qlen only in case we are !UDP.
                                 * 2) Checking sol_qlen in general requires locking
                                 *    the socket, and this code lacks that.
                                 */
                                {
                                    if stcb.is_null()
                                        && (!((*inp).sctp_flags & 0x8u32 != 0u32)
                                            || (*inp).sctp_flags & 0x1u32 == 0
                                                && (*(*inp).sctp_socket).so_qlen as libc::c_int
                                                    >= (*(*inp).sctp_socket).so_qlimit
                                                        as libc::c_int)
                                    {
                                        if (*inp).sctp_flags & 0x2u32 != 0
                                            && system_base_info
                                                .sctpsysctl
                                                .sctp_abort_if_one_2_one_hits_limit
                                                != 0
                                        {
                                            op_err = sctp_generate_cause(
                                                0x4u16,
                                                b"\x00" as *const u8 as *mut libc::c_char,
                                            );
                                            sctp_abort_association(
                                                inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id,
                                                port,
                                            );
                                        }
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    } else {
                                        let mut linp = 0 as *mut sctp_inpcb;
                                        if !stcb.is_null() {
                                            linp = 0 as *mut sctp_inpcb
                                        } else {
                                            linp = inp
                                        }
                                        if !linp.is_null() {
                                            pthread_mutex_lock(&mut (*linp).inp_create_mtx);
                                            if (*inp).sctp_flags & 0x10000000u32 != 0
                                                || (*inp).sctp_flags & 0x20000000u32 != 0
                                            {
                                                pthread_mutex_unlock(&mut (*linp).inp_create_mtx);
                                                current_block = 15767785092075175044;
                                            } else {
                                                current_block = 2358125959230175008;
                                            }
                                        } else {
                                            current_block = 2358125959230175008;
                                        }
                                        match current_block {
                                            15767785092075175044 => {}
                                            _ => {
                                                let mut ret_buf = 0 as *mut mbuf;
                                                if !netp.is_null() {
                                                    let mut locked_stcb = 0 as *mut sctp_tcb;
                                                    locked_stcb = stcb;
                                                    ret_buf = sctp_handle_cookie_echo(
                                                        m,
                                                        iphlen,
                                                        *offset,
                                                        src,
                                                        dst,
                                                        sh,
                                                        ch as *mut sctp_cookie_echo_chunk,
                                                        &mut inp,
                                                        &mut stcb,
                                                        netp,
                                                        auth_skipped,
                                                        auth_offset,
                                                        auth_len,
                                                        &mut locked_stcb,
                                                        vrf_id,
                                                        port,
                                                    );
                                                    if !locked_stcb.is_null() && locked_stcb != stcb
                                                    {
                                                        pthread_mutex_unlock(
                                                            &mut (*locked_stcb).tcb_mtx,
                                                        );
                                                    }
                                                    !stcb.is_null();
                                                } else {
                                                    ret_buf = 0 as *mut mbuf
                                                }
                                                if !linp.is_null() {
                                                    pthread_mutex_unlock(
                                                        &mut (*linp).inp_create_mtx,
                                                    );
                                                }
                                                if ret_buf.is_null() {
                                                    if !stcb.is_null() {
                                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                                    }
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"GAK, null buffer\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    *offset = length;
                                                    return 0 as *mut sctp_tcb;
                                                }
                                                /* if AUTH skipped, see if it verified... */
                                                if auth_skipped != 0 {
                                                    got_auth = 1i32;
                                                    auth_skipped = 0i32
                                                }
                                                if !(*stcb).asoc.sent_queue.tqh_first.is_null() {
                                                    let mut chk = 0 as *mut sctp_tmit_chunk;
                                                    chk = (*stcb).asoc.sent_queue.tqh_first;
                                                    sctp_timer_start(
                                                        1i32,
                                                        (*stcb).sctp_ep,
                                                        stcb,
                                                        (*chk).whoTo,
                                                    );
                                                }
                                                current_block = 13422570431586403309;
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                            match current_block {
                                13422570431586403309 => {}
                                _ =>
                                /* We are not interested anymore */
                                {
                                    if !stcb.is_null() {
                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                    }
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                        }
                        10582330624169799780 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_PACKET_DROPPED\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            /* re-get it all please */
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_pktdrop_chunk>() as libc::c_ulong
                            {
                                /* Its not ours */
                                *offset = length;
                                return stcb;
                            }
                            if !ch.is_null()
                                && !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                            {
                                if (*stcb).asoc.pktdrop_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_packet_dropped(
                                        ch as *mut sctp_pktdrop_chunk,
                                        stcb,
                                        *netp,
                                        if chk_length > contiguous {
                                            contiguous
                                        } else {
                                            chk_length
                                        },
                                    );
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13268550889959046632 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_STREAM_RESET\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || ch.is_null()
                                || (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_stream_reset_tsn_req>()
                                        as libc::c_ulong
                            {
                                /* Its not ours */
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.reconfig_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if sctp_handle_stream_reset(stcb, m, *offset, ch) != 0 {
                                    /* stop processing */
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                                current_block = 13422570431586403309;
                            }
                        }
                        13497718421940148126 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_FWD_TSN\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_forward_tsn_chunk>() as libc::c_ulong
                            {
                                /* Its not ours */
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.prsctp_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    let mut abort_flag_0 = 0i32;
                                    *fwd_tsn_seen = 1i32;
                                    if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                        /* We are not interested anymore */
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1fi32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    /*
                                     * For sending a SACK this looks like DATA
                                     * chunks.
                                     */
                                    (*stcb).asoc.last_data_chunk_from =
                                        (*stcb).asoc.last_control_chunk_from;
                                    sctp_handle_forward_tsn(
                                        stcb,
                                        ch as *mut sctp_forward_tsn_chunk,
                                        &mut abort_flag_0,
                                        m,
                                        *offset,
                                    );
                                    if abort_flag_0 != 0 {
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13226217046118304493 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_asconf_ack_chunk>() as libc::c_ulong
                            {
                                /* Its not ours */
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    /* He's alive so give him credit */
                                    if system_base_info.sctpsysctl.sctp_logging_level & 0x2000000u32
                                        != 0
                                    {
                                        sctp_misc_ints(
                                            120u8,
                                            (*stcb).asoc.overall_error_count,
                                            0u32,
                                            0x10000000u32,
                                            5531u32,
                                        );
                                    }
                                    (*stcb).asoc.overall_error_count = 0u32;
                                    sctp_handle_asconf_ack(
                                        m,
                                        *offset,
                                        ch as *mut sctp_asconf_ack_chunk,
                                        stcb,
                                        *netp,
                                        &mut abort_no_unlock,
                                    );
                                    if abort_no_unlock != 0 {
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        11399179239179359665 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_asconf(
                                        m,
                                        *offset as libc::c_uint,
                                        src,
                                        ch as *mut sctp_asconf_chunk,
                                        stcb,
                                        (asconf_cnt == 0i32) as libc::c_int,
                                    );
                                    asconf_cnt += 1;
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        3371148184269687219 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_CWR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cwr_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_cwr(ch as *mut sctp_cwr_chunk, stcb, *netp);
                                current_block = 13422570431586403309;
                            }
                        }
                        13594799726619700391 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_ECHO\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_ecne_chunk>() as libc::c_ulong
                            {
                                /* Its not ours */
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_echo(ch as *mut sctp_ecne_chunk, stcb);
                                ecne_seen = 1i32;
                                current_block = 13422570431586403309;
                            }
                        }
                        2781125740367032387 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cookie_ack_chunk>()
                                        as libc::c_ulong
                            {
                                return stcb;
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                /* We are not interested anymore */
                                if !(!stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0) {
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1ei32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                }
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_cookie_ack(
                                    ch as *mut sctp_cookie_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        17092723434217905016 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_OP_ERR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                                && sctp_handle_error(ch, stcb, *netp, contiguous) < 0i32
                            {
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            current_block = 13422570431586403309;
                        }
                        6770586402544785651 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_shutdown_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                let mut abort_flag = 0i32;
                                sctp_handle_shutdown(
                                    ch as *mut sctp_shutdown_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_flag,
                                );
                                if abort_flag != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            current_block = 13422570431586403309;
                        }
                        12945290292467802513 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_heartbeat_chunk>()
                                        as libc::c_ulong
                            {
                                /* Its not ours */
                                *offset = length;
                                return stcb;
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvheartbeatack,
                                1u32,
                            );
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_heartbeat_ack(
                                    ch as *mut sctp_heartbeat_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        5491205026464363454 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                ::std::intrinsics::atomic_xadd(
                                    &mut system_base_info.sctpstat.sctps_recvheartbeat,
                                    1u32,
                                );
                                sctp_send_heartbeat_ack(
                                    stcb,
                                    m,
                                    *offset,
                                    chk_length as libc::c_int,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        7940804887512848672 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"%s\n\x00" as *const u8 as *const libc::c_char,
                                        if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                            b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                        } else {
                                            b"SCTP_NR_SACK\x00" as *const u8 as *const libc::c_char
                                        },
                                    );
                                }
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvsacks,
                                1u32,
                            );
                            if stcb.is_null() {
                                if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0 {
                                    if system_base_info.debug_printf.is_some() {
                                        system_base_info
                                            .debug_printf
                                            .expect("non-null function pointer")(
                                            b"No stcb when processing %s chunk\n\x00" as *const u8
                                                as *const libc::c_char,
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                            } else {
                                                b"SCTP_NR_SACK\x00" as *const u8
                                                    as *const libc::c_char
                                            },
                                        );
                                    }
                                }
                                current_block = 13422570431586403309;
                            } else {
                                if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                    if (chk_length as libc::c_ulong)
                                        < ::std::mem::size_of::<sctp_sack_chunk>() as libc::c_ulong
                                    {
                                        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32
                                            != 0
                                        {
                                            if system_base_info.debug_printf.is_some() {
                                                system_base_info
                                                    .debug_printf
                                                    .expect("non-null function pointer")(
                                                    b"Bad size on SACK chunk, too small\n\x00"
                                                        as *const u8
                                                        as *const libc::c_char,
                                                );
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    } else {
                                        current_block = 17937968408868551711;
                                    }
                                } else if (*stcb).asoc.nrsack_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_nr_sack_chunk>() as libc::c_ulong
                                {
                                    if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0
                                    {
                                        if system_base_info.debug_printf.is_some() {
                                            system_base_info
                                                .debug_printf
                                                .expect("non-null function pointer")(
                                                b"Bad size on NR_SACK chunk, too small\n\x00"
                                                    as *const u8
                                                    as *const libc::c_char,
                                            );
                                        }
                                    }
                                    current_block = 13422570431586403309;
                                } else {
                                    current_block = 17937968408868551711;
                                }
                                match current_block {
                                    6765806975593869225 => {}
                                    13422570431586403309 => {}
                                    _ => {
                                        if !((*stcb).asoc.state & 0x7fi32 == 0x40i32) {
                                            let mut a_rwnd = 0;
                                            let mut cum_ack = 0;
                                            let mut num_seg = 0;
                                            let mut num_nr_seg = 0;
                                            let mut num_dup = 0;
                                            let mut flags = 0;
                                            let mut offset_seg = 0;
                                            let mut offset_dup = 0;
                                            flags = (*ch).chunk_flags;
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                let mut sack = 0 as *mut sctp_sack_chunk;
                                                sack = ch as *mut sctp_sack_chunk;
                                                cum_ack = ntohl((*sack).sack.cum_tsn_ack);
                                                num_seg = ntohs((*sack).sack.num_gap_ack_blks);
                                                num_nr_seg = 0u16;
                                                num_dup = ntohs((*sack).sack.num_dup_tsns);
                                                a_rwnd = ntohl((*sack).sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_sack_chunk>()
                                                        as
                                                        libc::c_ulong).wrapping_add((num_seg
                                                                                         as
                                                                                         libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                         as
                                                                                                                         libc::c_ulong)).wrapping_add((num_dup
                                                                                                                                                           as
                                                                                                                                                           libc::c_ulong).wrapping_mul(::std::mem::size_of::<uint32_t>()
                                                                                                                                                                                           as
                                                                                                                                                                                           libc::c_ulong))
                                                       !=
                                                       chk_length as
                                                           libc::c_ulong {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                           &
                                                           0x1000000u32 !=
                                                           0 {
                                                        if system_base_info.debug_printf.is_some()
                                                           {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"Bad size of SACK chunk\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char);
                                                        }
                                                    }
                                                    current_block =
                                                        13422570431586403309;
                                                } else {
                                                    offset_seg =
                                                        (*offset as
                                                             libc::c_ulong).wrapping_add(::std::mem::size_of::<sctp_sack_chunk>()
                                                                                             as
                                                                                             libc::c_ulong)
                                                            as libc::c_int;
                                                    offset_dup =
                                                        (offset_seg as
                                                             libc::c_ulong).wrapping_add((num_seg
                                                                                              as
                                                                                              libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                              as
                                                                                                                              libc::c_ulong))
                                                            as libc::c_int;
                                                    current_block =
                                                        8752412851861032177;
                                                }
                                            } else {
                                                let mut nr_sack = 0 as *mut sctp_nr_sack_chunk;
                                                nr_sack = ch as *mut sctp_nr_sack_chunk;
                                                cum_ack = ntohl((*nr_sack).nr_sack.cum_tsn_ack);
                                                num_seg =
                                                    ntohs((*nr_sack).nr_sack.num_gap_ack_blks);
                                                num_nr_seg =
                                                    ntohs((*nr_sack).nr_sack.num_nr_gap_ack_blks);
                                                num_dup = ntohs((*nr_sack).nr_sack.num_dup_tsns);
                                                a_rwnd = ntohl((*nr_sack).nr_sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_nr_sack_chunk>()
                                                    as libc::c_ulong)
                                                    .wrapping_add(
                                                        ((num_seg as libc::c_int
                                                            + num_nr_seg as libc::c_int)
                                                            as libc::c_ulong)
                                                            .wrapping_mul(::std::mem::size_of::<
                                                                sctp_gap_ack_block,
                                                            >(
                                                            )
                                                                as libc::c_ulong),
                                                    )
                                                    .wrapping_add(
                                                        (num_dup as libc::c_ulong).wrapping_mul(
                                                            ::std::mem::size_of::<uint32_t>()
                                                                as libc::c_ulong,
                                                        ),
                                                    )
                                                    != chk_length as libc::c_ulong
                                                {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x1000000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"Bad size of NR_SACK chunk\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    current_block = 13422570431586403309;
                                                } else {
                                                    offset_seg = (*offset as libc::c_ulong)
                                                        .wrapping_add(::std::mem::size_of::<
                                                            sctp_nr_sack_chunk,
                                                        >(
                                                        )
                                                            as libc::c_ulong)
                                                        as libc::c_int;
                                                    offset_dup = (offset_seg as libc::c_ulong)
                                                        .wrapping_add(
                                                            ((num_seg as libc::c_int
                                                                + num_nr_seg as libc::c_int)
                                                                as libc::c_ulong)
                                                                .wrapping_mul(
                                                                    ::std::mem::size_of::<
                                                                        sctp_gap_ack_block,
                                                                    >(
                                                                    )
                                                                        as libc::c_ulong,
                                                                ),
                                                        )
                                                        as libc::c_int;
                                                    current_block = 8752412851861032177;
                                                }
                                            }
                                            match current_block {
                                                13422570431586403309 => {}
                                                _ => {
                                                    let mut abort_now = 0i32;
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"%s process cum_ack:%x num_seg:%d a_rwnd:%d\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char,
                                                                                                                              if (*ch).chunk_type
                                                                                                                                     as
                                                                                                                                     libc::c_int
                                                                                                                                     ==
                                                                                                                                     0x3i32
                                                                                                                                 {
                                                                                                                                  b"SCTP_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              } else {
                                                                                                                                  b"SCTP_NR_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              },
                                                                                                                              cum_ack,
                                                                                                                              num_seg
                                                                                                                                  as
                                                                                                                                  libc::c_int,
                                                                                                                              a_rwnd);
                                                        }
                                                    }
                                                    (*stcb).asoc.seen_a_sack_this_pkt = 1u8;
                                                    if (*stcb).asoc.pr_sctp_cnt == 0u32
                                                        && num_seg as libc::c_int == 0i32
                                                        && num_nr_seg as libc::c_int == 0i32
                                                        && (cum_ack < (*stcb).asoc.last_acked_seq
                                                            && (*stcb)
                                                                .asoc
                                                                .last_acked_seq
                                                                .wrapping_sub(cum_ack)
                                                                > (1u32) << 31i32
                                                            || cum_ack
                                                                > (*stcb).asoc.last_acked_seq
                                                                && cum_ack.wrapping_sub(
                                                                    (*stcb).asoc.last_acked_seq,
                                                                ) < (1u32) << 31i32
                                                            || cum_ack
                                                                == (*stcb).asoc.last_acked_seq)
                                                        && (*stcb).asoc.saw_sack_with_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && (*stcb).asoc.saw_sack_with_nr_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && !(*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                    {
                                                        /*
                                                         * We have a SIMPLE sack having no
                                                         * prior segments and data on sent
                                                         * queue to be acked. Use the
                                                         * faster path sack processing. We
                                                         * also allow window update sacks
                                                         * with no missing segments to go
                                                         * this way too.
                                                         */
                                                        sctp_express_handle_sack(
                                                            stcb,
                                                            cum_ack,
                                                            a_rwnd,
                                                            &mut abort_now,
                                                            ecne_seen,
                                                        );
                                                    } else if !netp.is_null() && !(*netp).is_null()
                                                    {
                                                        sctp_handle_sack(
                                                            m,
                                                            offset_seg,
                                                            offset_dup,
                                                            stcb,
                                                            num_seg,
                                                            num_nr_seg,
                                                            num_dup,
                                                            &mut abort_now,
                                                            flags,
                                                            cum_ack,
                                                            a_rwnd,
                                                            ecne_seen,
                                                        );
                                                    }
                                                    if abort_now != 0 {
                                                        /* ABORT signal from sack processing */
                                                        *offset = length;
                                                        return 0 as *mut sctp_tcb;
                                                    }
                                                    if (*stcb).asoc.send_queue.tqh_first.is_null()
                                                        && (*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                        && (*stcb).asoc.stream_queue_cnt == 0u32
                                                    {
                                                        sctp_ulp_notify(
                                                            26u32,
                                                            stcb,
                                                            0u32,
                                                            0 as *mut libc::c_void,
                                                            0i32,
                                                        );
                                                    }
                                                }
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    }
                                }
                            }
                        }
                        2349180396633407496 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_AUTHENTICATION\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null() {
                                /* save the first AUTH for later processing */
                                if auth_skipped == 0i32 {
                                    auth_offset = *offset as uint32_t;
                                    auth_len = chk_length;
                                    auth_skipped = 1i32
                                }
                                /* skip this chunk (temporarily) */
                                current_block = 13422570431586403309;
                            } else if (*stcb).asoc.auth_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_auth_chunk>() as libc::c_ulong
                                    || chk_length as libc::c_ulong
                                        > (::std::mem::size_of::<sctp_auth_chunk>()
                                            as libc::c_ulong)
                                            .wrapping_add(32u64)
                                {
                                    /* Its not ours */
                                    *offset = length;
                                    return stcb;
                                }
                                if got_auth == 1i32 {
                                    current_block = 13422570431586403309;
                                } else {
                                    got_auth = 1i32;
                                    if ch.is_null()
                                        || sctp_handle_auth(
                                            stcb,
                                            ch as *mut sctp_auth_chunk,
                                            m,
                                            *offset as uint32_t,
                                        ) != 0
                                    {
                                        /* auth HMAC failed so dump the packet */
                                        *offset = length;
                                        return stcb;
                                    } else {
                                        /* remaining chunks are HMAC checked */
                                        (*stcb).asoc.authenticated = 1u8
                                    }
                                    current_block = 13422570431586403309;
                                }
                            }
                        }
                        _ => {}
                    }
                    match current_block {
                        13422570431586403309 => {}
                        _ => {
                            /* it's an unknown chunk! */
                            if (*ch).chunk_type as libc::c_int & 0x40i32 != 0 && !stcb.is_null() {
                                /* else skip this bad chunk and continue... */

                                op_err = sctp_get_mbuf_for_msg(
                                    ::std::mem::size_of::<sctp_gen_error_cause>() as libc::c_uint,
                                    0i32,
                                    0x1i32,
                                    1i32,
                                    1i32,
                                );
                                if !op_err.is_null() {
                                    let mut cause = 0 as *mut sctp_gen_error_cause;
                                    let mut len = 0;
                                    len = if (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                        > (length - *offset) as uint32_t
                                    {
                                        (length - *offset) as uint32_t
                                    } else {
                                        (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                    } as libc::c_int;
                                    cause = (*op_err).m_hdr.mh_data as *mut sctp_gen_error_cause;
                                    (*cause).code = htons(0x6u16);
                                    (*cause).length =
                                        htons((len as libc::c_ulong).wrapping_add(
                                            ::std::mem::size_of::<sctp_gen_error_cause>()
                                                as libc::c_ulong,
                                        )
                                            as uint16_t);
                                    (*op_err).m_hdr.mh_len =
                                        ::std::mem::size_of::<sctp_gen_error_cause>()
                                            as libc::c_int;
                                    (*op_err).m_hdr.mh_next = m_copym(m, *offset, len, 0x1i32);
                                    if !(*op_err).m_hdr.mh_next.is_null() {
                                        sctp_queue_op_err(stcb, op_err);
                                    } else {
                                        m_freem(op_err);
                                    }
                                }
                            }
                            if (*ch).chunk_type as libc::c_int & 0x80i32 == 0i32 {
                                /* discard this packet */
                                *offset = length;
                                return stcb;
                            }
                        }
                    }
                }
                132 => {}
                2 => {
                    current_block = 12601157616349825580;
                    match current_block {
                        17766256343850198083 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_COMPLETE, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_complete(
                                    ch as *mut sctp_shutdown_complete_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        12601157616349825580 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT_ACK\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0 {
                                } else {
                                    *offset = length;
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1di32);
                                    }
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                ret = sctp_handle_init_ack(
                                    m,
                                    iphlen,
                                    *offset,
                                    src,
                                    dst,
                                    sh,
                                    ch as *mut sctp_init_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_no_unlock,
                                    vrf_id,
                                )
                            } else {
                                ret = -(1i32)
                            }
                            *offset = length;
                            if abort_no_unlock != 0 {
                                return 0 as *mut sctp_tcb;
                            }
                            if !stcb.is_null() && ret == 0i32 {
                                sctp_chunk_output((*stcb).sctp_ep, stcb, 3i32, 0i32);
                            }
                            return stcb;
                        }
                        16195856799229720522 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                if !stcb.is_null() {
                                    pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                }
                                return 0 as *mut sctp_tcb;
                            }
                            if chk_length > (65535i32 - 2048i32) as libc::c_uint {
                                op_err = sctp_generate_cause(
                                    0x4u16,
                                    b"\x00" as *const u8 as *mut libc::c_char,
                                );
                                sctp_abort_association(
                                    inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id, port,
                                );
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            sctp_handle_init(
                                m,
                                iphlen,
                                *offset,
                                src,
                                dst,
                                sh,
                                ch as *mut sctp_init_chunk,
                                inp,
                                stcb,
                                *netp,
                                &mut abort_no_unlock,
                                vrf_id,
                                port,
                            );
                            *offset = length;
                            if abort_no_unlock == 0 && !stcb.is_null() {
                                pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                            }
                            return 0 as *mut sctp_tcb;
                        }
                        6246479402878884953 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_ack(
                                    ch as *mut sctp_shutdown_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        4558417918157925232 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ABORT, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            *offset = length;
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if sctp_handle_abort(ch as *mut sctp_abort_chunk, stcb, *netp) != 0
                                {
                                    return 0 as *mut sctp_tcb;
                                } else {
                                    return stcb;
                                }
                            } else {
                                return 0 as *mut sctp_tcb;
                            }
                        }
                        9379646460352968115 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ECHO, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && (*stcb).asoc.total_output_queue_size > 0u32 {
                                current_block = 15201865807353435331;
                            } else if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                current_block = 15767785092075175044;
                            } else {
                                current_block = 15201865807353435331;
                            }
                            match current_block {
                                15201865807353435331 => {
                                    if stcb.is_null()
                                        && (!((*inp).sctp_flags & 0x8u32 != 0u32)
                                            || (*inp).sctp_flags & 0x1u32 == 0
                                                && (*(*inp).sctp_socket).so_qlen as libc::c_int
                                                    >= (*(*inp).sctp_socket).so_qlimit
                                                        as libc::c_int)
                                    {
                                        if (*inp).sctp_flags & 0x2u32 != 0
                                            && system_base_info
                                                .sctpsysctl
                                                .sctp_abort_if_one_2_one_hits_limit
                                                != 0
                                        {
                                            op_err = sctp_generate_cause(
                                                0x4u16,
                                                b"\x00" as *const u8 as *mut libc::c_char,
                                            );
                                            sctp_abort_association(
                                                inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id,
                                                port,
                                            );
                                        }
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    } else {
                                        let mut linp = 0 as *mut sctp_inpcb;
                                        if !stcb.is_null() {
                                            linp = 0 as *mut sctp_inpcb
                                        } else {
                                            linp = inp
                                        }
                                        if !linp.is_null() {
                                            pthread_mutex_lock(&mut (*linp).inp_create_mtx);
                                            if (*inp).sctp_flags & 0x10000000u32 != 0
                                                || (*inp).sctp_flags & 0x20000000u32 != 0
                                            {
                                                pthread_mutex_unlock(&mut (*linp).inp_create_mtx);
                                                current_block = 15767785092075175044;
                                            } else {
                                                current_block = 2358125959230175008;
                                            }
                                        } else {
                                            current_block = 2358125959230175008;
                                        }
                                        match current_block {
                                            15767785092075175044 => {}
                                            _ => {
                                                let mut ret_buf = 0 as *mut mbuf;
                                                if !netp.is_null() {
                                                    let mut locked_stcb = 0 as *mut sctp_tcb;
                                                    locked_stcb = stcb;
                                                    ret_buf = sctp_handle_cookie_echo(
                                                        m,
                                                        iphlen,
                                                        *offset,
                                                        src,
                                                        dst,
                                                        sh,
                                                        ch as *mut sctp_cookie_echo_chunk,
                                                        &mut inp,
                                                        &mut stcb,
                                                        netp,
                                                        auth_skipped,
                                                        auth_offset,
                                                        auth_len,
                                                        &mut locked_stcb,
                                                        vrf_id,
                                                        port,
                                                    );
                                                    if !locked_stcb.is_null() && locked_stcb != stcb
                                                    {
                                                        pthread_mutex_unlock(
                                                            &mut (*locked_stcb).tcb_mtx,
                                                        );
                                                    }
                                                    !stcb.is_null();
                                                } else {
                                                    ret_buf = 0 as *mut mbuf
                                                }
                                                if !linp.is_null() {
                                                    pthread_mutex_unlock(
                                                        &mut (*linp).inp_create_mtx,
                                                    );
                                                }
                                                if ret_buf.is_null() {
                                                    if !stcb.is_null() {
                                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                                    }
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"GAK, null buffer\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    *offset = length;
                                                    return 0 as *mut sctp_tcb;
                                                }
                                                if auth_skipped != 0 {
                                                    got_auth = 1i32;
                                                    auth_skipped = 0i32
                                                }
                                                if !(*stcb).asoc.sent_queue.tqh_first.is_null() {
                                                    let mut chk = 0 as *mut sctp_tmit_chunk;
                                                    chk = (*stcb).asoc.sent_queue.tqh_first;
                                                    sctp_timer_start(
                                                        1i32,
                                                        (*stcb).sctp_ep,
                                                        stcb,
                                                        (*chk).whoTo,
                                                    );
                                                }
                                                current_block = 13422570431586403309;
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                            match current_block {
                                13422570431586403309 => {}
                                _ => {
                                    if !stcb.is_null() {
                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                    }
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                        }
                        10582330624169799780 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_PACKET_DROPPED\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_pktdrop_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !ch.is_null()
                                && !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                            {
                                if (*stcb).asoc.pktdrop_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_packet_dropped(
                                        ch as *mut sctp_pktdrop_chunk,
                                        stcb,
                                        *netp,
                                        if chk_length > contiguous {
                                            contiguous
                                        } else {
                                            chk_length
                                        },
                                    );
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13268550889959046632 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_STREAM_RESET\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || ch.is_null()
                                || (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_stream_reset_tsn_req>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.reconfig_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if sctp_handle_stream_reset(stcb, m, *offset, ch) != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                                current_block = 13422570431586403309;
                            }
                        }
                        13497718421940148126 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_FWD_TSN\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_forward_tsn_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.prsctp_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    let mut abort_flag_0 = 0i32;
                                    *fwd_tsn_seen = 1i32;
                                    if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1fi32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    (*stcb).asoc.last_data_chunk_from =
                                        (*stcb).asoc.last_control_chunk_from;
                                    sctp_handle_forward_tsn(
                                        stcb,
                                        ch as *mut sctp_forward_tsn_chunk,
                                        &mut abort_flag_0,
                                        m,
                                        *offset,
                                    );
                                    if abort_flag_0 != 0 {
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13226217046118304493 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_asconf_ack_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    if system_base_info.sctpsysctl.sctp_logging_level & 0x2000000u32
                                        != 0
                                    {
                                        sctp_misc_ints(
                                            120u8,
                                            (*stcb).asoc.overall_error_count,
                                            0u32,
                                            0x10000000u32,
                                            5531u32,
                                        );
                                    }
                                    (*stcb).asoc.overall_error_count = 0u32;
                                    sctp_handle_asconf_ack(
                                        m,
                                        *offset,
                                        ch as *mut sctp_asconf_ack_chunk,
                                        stcb,
                                        *netp,
                                        &mut abort_no_unlock,
                                    );
                                    if abort_no_unlock != 0 {
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        11399179239179359665 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_asconf(
                                        m,
                                        *offset as libc::c_uint,
                                        src,
                                        ch as *mut sctp_asconf_chunk,
                                        stcb,
                                        (asconf_cnt == 0i32) as libc::c_int,
                                    );
                                    asconf_cnt += 1;
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        3371148184269687219 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_CWR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cwr_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_cwr(ch as *mut sctp_cwr_chunk, stcb, *netp);
                                current_block = 13422570431586403309;
                            }
                        }
                        13594799726619700391 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_ECHO\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_ecne_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_echo(ch as *mut sctp_ecne_chunk, stcb);
                                ecne_seen = 1i32;
                                current_block = 13422570431586403309;
                            }
                        }
                        2781125740367032387 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cookie_ack_chunk>()
                                        as libc::c_ulong
                            {
                                return stcb;
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !(!stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0) {
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1ei32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                }
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_cookie_ack(
                                    ch as *mut sctp_cookie_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        17092723434217905016 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_OP_ERR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                                && sctp_handle_error(ch, stcb, *netp, contiguous) < 0i32
                            {
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            current_block = 13422570431586403309;
                        }
                        6770586402544785651 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_shutdown_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                let mut abort_flag = 0i32;
                                sctp_handle_shutdown(
                                    ch as *mut sctp_shutdown_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_flag,
                                );
                                if abort_flag != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            current_block = 13422570431586403309;
                        }
                        12945290292467802513 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_heartbeat_chunk>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvheartbeatack,
                                1u32,
                            );
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_heartbeat_ack(
                                    ch as *mut sctp_heartbeat_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        5491205026464363454 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                ::std::intrinsics::atomic_xadd(
                                    &mut system_base_info.sctpstat.sctps_recvheartbeat,
                                    1u32,
                                );
                                sctp_send_heartbeat_ack(
                                    stcb,
                                    m,
                                    *offset,
                                    chk_length as libc::c_int,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        7940804887512848672 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"%s\n\x00" as *const u8 as *const libc::c_char,
                                        if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                            b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                        } else {
                                            b"SCTP_NR_SACK\x00" as *const u8 as *const libc::c_char
                                        },
                                    );
                                }
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvsacks,
                                1u32,
                            );
                            if stcb.is_null() {
                                if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0 {
                                    if system_base_info.debug_printf.is_some() {
                                        system_base_info
                                            .debug_printf
                                            .expect("non-null function pointer")(
                                            b"No stcb when processing %s chunk\n\x00" as *const u8
                                                as *const libc::c_char,
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                            } else {
                                                b"SCTP_NR_SACK\x00" as *const u8
                                                    as *const libc::c_char
                                            },
                                        );
                                    }
                                }
                                current_block = 13422570431586403309;
                            } else {
                                if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                    if (chk_length as libc::c_ulong)
                                        < ::std::mem::size_of::<sctp_sack_chunk>() as libc::c_ulong
                                    {
                                        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32
                                            != 0
                                        {
                                            if system_base_info.debug_printf.is_some() {
                                                system_base_info
                                                    .debug_printf
                                                    .expect("non-null function pointer")(
                                                    b"Bad size on SACK chunk, too small\n\x00"
                                                        as *const u8
                                                        as *const libc::c_char,
                                                );
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    } else {
                                        current_block = 17937968408868551711;
                                    }
                                } else if (*stcb).asoc.nrsack_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_nr_sack_chunk>() as libc::c_ulong
                                {
                                    if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0
                                    {
                                        if system_base_info.debug_printf.is_some() {
                                            system_base_info
                                                .debug_printf
                                                .expect("non-null function pointer")(
                                                b"Bad size on NR_SACK chunk, too small\n\x00"
                                                    as *const u8
                                                    as *const libc::c_char,
                                            );
                                        }
                                    }
                                    current_block = 13422570431586403309;
                                } else {
                                    current_block = 17937968408868551711;
                                }
                                match current_block {
                                    6765806975593869225 => {}
                                    13422570431586403309 => {}
                                    _ => {
                                        if !((*stcb).asoc.state & 0x7fi32 == 0x40i32) {
                                            let mut a_rwnd = 0;
                                            let mut cum_ack = 0;
                                            let mut num_seg = 0;
                                            let mut num_nr_seg = 0;
                                            let mut num_dup = 0;
                                            let mut flags = 0;
                                            let mut offset_seg = 0;
                                            let mut offset_dup = 0;
                                            flags = (*ch).chunk_flags;
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                let mut sack = 0 as *mut sctp_sack_chunk;
                                                sack = ch as *mut sctp_sack_chunk;
                                                cum_ack = ntohl((*sack).sack.cum_tsn_ack);
                                                num_seg = ntohs((*sack).sack.num_gap_ack_blks);
                                                num_nr_seg = 0u16;
                                                num_dup = ntohs((*sack).sack.num_dup_tsns);
                                                a_rwnd = ntohl((*sack).sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_sack_chunk>()
                                                        as
                                                        libc::c_ulong).wrapping_add((num_seg
                                                                                         as
                                                                                         libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                         as
                                                                                                                         libc::c_ulong)).wrapping_add((num_dup
                                                                                                                                                           as
                                                                                                                                                           libc::c_ulong).wrapping_mul(::std::mem::size_of::<uint32_t>()
                                                                                                                                                                                           as
                                                                                                                                                                                           libc::c_ulong))
                                                       !=
                                                       chk_length as
                                                           libc::c_ulong {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                           &
                                                           0x1000000u32 !=
                                                           0 {
                                                        if system_base_info.debug_printf.is_some()
                                                           {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"Bad size of SACK chunk\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char);
                                                        }
                                                    }
                                                    current_block =
                                                        13422570431586403309;
                                                } else {
                                                    offset_seg =
                                                        (*offset as
                                                             libc::c_ulong).wrapping_add(::std::mem::size_of::<sctp_sack_chunk>()
                                                                                             as
                                                                                             libc::c_ulong)
                                                            as libc::c_int;
                                                    offset_dup =
                                                        (offset_seg as
                                                             libc::c_ulong).wrapping_add((num_seg
                                                                                              as
                                                                                              libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                              as
                                                                                                                              libc::c_ulong))
                                                            as libc::c_int;
                                                    current_block =
                                                        8752412851861032177;
                                                }
                                            } else {
                                                let mut nr_sack = 0 as *mut sctp_nr_sack_chunk;
                                                nr_sack = ch as *mut sctp_nr_sack_chunk;
                                                cum_ack = ntohl((*nr_sack).nr_sack.cum_tsn_ack);
                                                num_seg =
                                                    ntohs((*nr_sack).nr_sack.num_gap_ack_blks);
                                                num_nr_seg =
                                                    ntohs((*nr_sack).nr_sack.num_nr_gap_ack_blks);
                                                num_dup = ntohs((*nr_sack).nr_sack.num_dup_tsns);
                                                a_rwnd = ntohl((*nr_sack).nr_sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_nr_sack_chunk>()
                                                    as libc::c_ulong)
                                                    .wrapping_add(
                                                        ((num_seg as libc::c_int
                                                            + num_nr_seg as libc::c_int)
                                                            as libc::c_ulong)
                                                            .wrapping_mul(::std::mem::size_of::<
                                                                sctp_gap_ack_block,
                                                            >(
                                                            )
                                                                as libc::c_ulong),
                                                    )
                                                    .wrapping_add(
                                                        (num_dup as libc::c_ulong).wrapping_mul(
                                                            ::std::mem::size_of::<uint32_t>()
                                                                as libc::c_ulong,
                                                        ),
                                                    )
                                                    != chk_length as libc::c_ulong
                                                {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x1000000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"Bad size of NR_SACK chunk\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    current_block = 13422570431586403309;
                                                } else {
                                                    offset_seg = (*offset as libc::c_ulong)
                                                        .wrapping_add(::std::mem::size_of::<
                                                            sctp_nr_sack_chunk,
                                                        >(
                                                        )
                                                            as libc::c_ulong)
                                                        as libc::c_int;
                                                    offset_dup = (offset_seg as libc::c_ulong)
                                                        .wrapping_add(
                                                            ((num_seg as libc::c_int
                                                                + num_nr_seg as libc::c_int)
                                                                as libc::c_ulong)
                                                                .wrapping_mul(
                                                                    ::std::mem::size_of::<
                                                                        sctp_gap_ack_block,
                                                                    >(
                                                                    )
                                                                        as libc::c_ulong,
                                                                ),
                                                        )
                                                        as libc::c_int;
                                                    current_block = 8752412851861032177;
                                                }
                                            }
                                            match current_block {
                                                13422570431586403309 => {}
                                                _ => {
                                                    let mut abort_now = 0i32;
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"%s process cum_ack:%x num_seg:%d a_rwnd:%d\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char,
                                                                                                                              if (*ch).chunk_type
                                                                                                                                     as
                                                                                                                                     libc::c_int
                                                                                                                                     ==
                                                                                                                                     0x3i32
                                                                                                                                 {
                                                                                                                                  b"SCTP_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              } else {
                                                                                                                                  b"SCTP_NR_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              },
                                                                                                                              cum_ack,
                                                                                                                              num_seg
                                                                                                                                  as
                                                                                                                                  libc::c_int,
                                                                                                                              a_rwnd);
                                                        }
                                                    }
                                                    (*stcb).asoc.seen_a_sack_this_pkt = 1u8;
                                                    if (*stcb).asoc.pr_sctp_cnt == 0u32
                                                        && num_seg as libc::c_int == 0i32
                                                        && num_nr_seg as libc::c_int == 0i32
                                                        && (cum_ack < (*stcb).asoc.last_acked_seq
                                                            && (*stcb)
                                                                .asoc
                                                                .last_acked_seq
                                                                .wrapping_sub(cum_ack)
                                                                > (1u32) << 31i32
                                                            || cum_ack
                                                                > (*stcb).asoc.last_acked_seq
                                                                && cum_ack.wrapping_sub(
                                                                    (*stcb).asoc.last_acked_seq,
                                                                ) < (1u32) << 31i32
                                                            || cum_ack
                                                                == (*stcb).asoc.last_acked_seq)
                                                        && (*stcb).asoc.saw_sack_with_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && (*stcb).asoc.saw_sack_with_nr_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && !(*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                    {
                                                        sctp_express_handle_sack(
                                                            stcb,
                                                            cum_ack,
                                                            a_rwnd,
                                                            &mut abort_now,
                                                            ecne_seen,
                                                        );
                                                    } else if !netp.is_null() && !(*netp).is_null()
                                                    {
                                                        sctp_handle_sack(
                                                            m,
                                                            offset_seg,
                                                            offset_dup,
                                                            stcb,
                                                            num_seg,
                                                            num_nr_seg,
                                                            num_dup,
                                                            &mut abort_now,
                                                            flags,
                                                            cum_ack,
                                                            a_rwnd,
                                                            ecne_seen,
                                                        );
                                                    }
                                                    if abort_now != 0 {
                                                        *offset = length;
                                                        return 0 as *mut sctp_tcb;
                                                    }
                                                    if (*stcb).asoc.send_queue.tqh_first.is_null()
                                                        && (*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                        && (*stcb).asoc.stream_queue_cnt == 0u32
                                                    {
                                                        sctp_ulp_notify(
                                                            26u32,
                                                            stcb,
                                                            0u32,
                                                            0 as *mut libc::c_void,
                                                            0i32,
                                                        );
                                                    }
                                                }
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    }
                                }
                            }
                        }
                        2349180396633407496 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_AUTHENTICATION\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null() {
                                if auth_skipped == 0i32 {
                                    auth_offset = *offset as uint32_t;
                                    auth_len = chk_length;
                                    auth_skipped = 1i32
                                }
                                current_block = 13422570431586403309;
                            } else if (*stcb).asoc.auth_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_auth_chunk>() as libc::c_ulong
                                    || chk_length as libc::c_ulong
                                        > (::std::mem::size_of::<sctp_auth_chunk>()
                                            as libc::c_ulong)
                                            .wrapping_add(32u64)
                                {
                                    *offset = length;
                                    return stcb;
                                }
                                if got_auth == 1i32 {
                                    current_block = 13422570431586403309;
                                } else {
                                    got_auth = 1i32;
                                    if ch.is_null()
                                        || sctp_handle_auth(
                                            stcb,
                                            ch as *mut sctp_auth_chunk,
                                            m,
                                            *offset as uint32_t,
                                        ) != 0
                                    {
                                        *offset = length;
                                        return stcb;
                                    } else {
                                        (*stcb).asoc.authenticated = 1u8
                                    }
                                    current_block = 13422570431586403309;
                                }
                            }
                        }
                        _ => {}
                    }
                    match current_block {
                        13422570431586403309 => {}
                        _ => {
                            if (*ch).chunk_type as libc::c_int & 0x40i32 != 0 && !stcb.is_null() {
                                op_err = sctp_get_mbuf_for_msg(
                                    ::std::mem::size_of::<sctp_gen_error_cause>() as libc::c_uint,
                                    0i32,
                                    0x1i32,
                                    1i32,
                                    1i32,
                                );
                                if !op_err.is_null() {
                                    let mut cause = 0 as *mut sctp_gen_error_cause;
                                    let mut len = 0;
                                    len = if (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                        > (length - *offset) as uint32_t
                                    {
                                        (length - *offset) as uint32_t
                                    } else {
                                        (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                    } as libc::c_int;
                                    cause = (*op_err).m_hdr.mh_data as *mut sctp_gen_error_cause;
                                    (*cause).code = htons(0x6u16);
                                    (*cause).length =
                                        htons((len as libc::c_ulong).wrapping_add(
                                            ::std::mem::size_of::<sctp_gen_error_cause>()
                                                as libc::c_ulong,
                                        )
                                            as uint16_t);
                                    (*op_err).m_hdr.mh_len =
                                        ::std::mem::size_of::<sctp_gen_error_cause>()
                                            as libc::c_int;
                                    (*op_err).m_hdr.mh_next = m_copym(m, *offset, len, 0x1i32);
                                    if !(*op_err).m_hdr.mh_next.is_null() {
                                        sctp_queue_op_err(stcb, op_err);
                                    } else {
                                        m_freem(op_err);
                                    }
                                }
                            }
                            if (*ch).chunk_type as libc::c_int & 0x80i32 == 0i32 {
                                *offset = length;
                                return stcb;
                            }
                        }
                    }
                }
                3 | 16 => {
                    current_block = 7940804887512848672;
                    match current_block {
                        17766256343850198083 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_COMPLETE, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_complete(
                                    ch as *mut sctp_shutdown_complete_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        12601157616349825580 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT_ACK\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0 {
                                } else {
                                    *offset = length;
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1di32);
                                    }
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                ret = sctp_handle_init_ack(
                                    m,
                                    iphlen,
                                    *offset,
                                    src,
                                    dst,
                                    sh,
                                    ch as *mut sctp_init_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_no_unlock,
                                    vrf_id,
                                )
                            } else {
                                ret = -(1i32)
                            }
                            *offset = length;
                            if abort_no_unlock != 0 {
                                return 0 as *mut sctp_tcb;
                            }
                            if !stcb.is_null() && ret == 0i32 {
                                sctp_chunk_output((*stcb).sctp_ep, stcb, 3i32, 0i32);
                            }
                            return stcb;
                        }
                        16195856799229720522 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                if !stcb.is_null() {
                                    pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                }
                                return 0 as *mut sctp_tcb;
                            }
                            if chk_length > (65535i32 - 2048i32) as libc::c_uint {
                                op_err = sctp_generate_cause(
                                    0x4u16,
                                    b"\x00" as *const u8 as *mut libc::c_char,
                                );
                                sctp_abort_association(
                                    inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id, port,
                                );
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            sctp_handle_init(
                                m,
                                iphlen,
                                *offset,
                                src,
                                dst,
                                sh,
                                ch as *mut sctp_init_chunk,
                                inp,
                                stcb,
                                *netp,
                                &mut abort_no_unlock,
                                vrf_id,
                                port,
                            );
                            *offset = length;
                            if abort_no_unlock == 0 && !stcb.is_null() {
                                pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                            }
                            return 0 as *mut sctp_tcb;
                        }
                        6246479402878884953 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_ack(
                                    ch as *mut sctp_shutdown_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        4558417918157925232 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ABORT, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            *offset = length;
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if sctp_handle_abort(ch as *mut sctp_abort_chunk, stcb, *netp) != 0
                                {
                                    return 0 as *mut sctp_tcb;
                                } else {
                                    return stcb;
                                }
                            } else {
                                return 0 as *mut sctp_tcb;
                            }
                        }
                        9379646460352968115 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ECHO, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && (*stcb).asoc.total_output_queue_size > 0u32 {
                                current_block = 15201865807353435331;
                            } else if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                current_block = 15767785092075175044;
                            } else {
                                current_block = 15201865807353435331;
                            }
                            match current_block {
                                15201865807353435331 => {
                                    if stcb.is_null()
                                        && (!((*inp).sctp_flags & 0x8u32 != 0u32)
                                            || (*inp).sctp_flags & 0x1u32 == 0
                                                && (*(*inp).sctp_socket).so_qlen as libc::c_int
                                                    >= (*(*inp).sctp_socket).so_qlimit
                                                        as libc::c_int)
                                    {
                                        if (*inp).sctp_flags & 0x2u32 != 0
                                            && system_base_info
                                                .sctpsysctl
                                                .sctp_abort_if_one_2_one_hits_limit
                                                != 0
                                        {
                                            op_err = sctp_generate_cause(
                                                0x4u16,
                                                b"\x00" as *const u8 as *mut libc::c_char,
                                            );
                                            sctp_abort_association(
                                                inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id,
                                                port,
                                            );
                                        }
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    } else {
                                        let mut linp = 0 as *mut sctp_inpcb;
                                        if !stcb.is_null() {
                                            linp = 0 as *mut sctp_inpcb
                                        } else {
                                            linp = inp
                                        }
                                        if !linp.is_null() {
                                            pthread_mutex_lock(&mut (*linp).inp_create_mtx);
                                            if (*inp).sctp_flags & 0x10000000u32 != 0
                                                || (*inp).sctp_flags & 0x20000000u32 != 0
                                            {
                                                pthread_mutex_unlock(&mut (*linp).inp_create_mtx);
                                                current_block = 15767785092075175044;
                                            } else {
                                                current_block = 2358125959230175008;
                                            }
                                        } else {
                                            current_block = 2358125959230175008;
                                        }
                                        match current_block {
                                            15767785092075175044 => {}
                                            _ => {
                                                let mut ret_buf = 0 as *mut mbuf;
                                                if !netp.is_null() {
                                                    let mut locked_stcb = 0 as *mut sctp_tcb;
                                                    locked_stcb = stcb;
                                                    ret_buf = sctp_handle_cookie_echo(
                                                        m,
                                                        iphlen,
                                                        *offset,
                                                        src,
                                                        dst,
                                                        sh,
                                                        ch as *mut sctp_cookie_echo_chunk,
                                                        &mut inp,
                                                        &mut stcb,
                                                        netp,
                                                        auth_skipped,
                                                        auth_offset,
                                                        auth_len,
                                                        &mut locked_stcb,
                                                        vrf_id,
                                                        port,
                                                    );
                                                    if !locked_stcb.is_null() && locked_stcb != stcb
                                                    {
                                                        pthread_mutex_unlock(
                                                            &mut (*locked_stcb).tcb_mtx,
                                                        );
                                                    }
                                                    !stcb.is_null();
                                                } else {
                                                    ret_buf = 0 as *mut mbuf
                                                }
                                                if !linp.is_null() {
                                                    pthread_mutex_unlock(
                                                        &mut (*linp).inp_create_mtx,
                                                    );
                                                }
                                                if ret_buf.is_null() {
                                                    if !stcb.is_null() {
                                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                                    }
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"GAK, null buffer\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    *offset = length;
                                                    return 0 as *mut sctp_tcb;
                                                }
                                                if auth_skipped != 0 {
                                                    got_auth = 1i32;
                                                    auth_skipped = 0i32
                                                }
                                                if !(*stcb).asoc.sent_queue.tqh_first.is_null() {
                                                    let mut chk = 0 as *mut sctp_tmit_chunk;
                                                    chk = (*stcb).asoc.sent_queue.tqh_first;
                                                    sctp_timer_start(
                                                        1i32,
                                                        (*stcb).sctp_ep,
                                                        stcb,
                                                        (*chk).whoTo,
                                                    );
                                                }
                                                current_block = 13422570431586403309;
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                            match current_block {
                                13422570431586403309 => {}
                                _ => {
                                    if !stcb.is_null() {
                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                    }
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                        }
                        10582330624169799780 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_PACKET_DROPPED\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_pktdrop_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !ch.is_null()
                                && !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                            {
                                if (*stcb).asoc.pktdrop_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_packet_dropped(
                                        ch as *mut sctp_pktdrop_chunk,
                                        stcb,
                                        *netp,
                                        if chk_length > contiguous {
                                            contiguous
                                        } else {
                                            chk_length
                                        },
                                    );
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13268550889959046632 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_STREAM_RESET\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || ch.is_null()
                                || (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_stream_reset_tsn_req>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.reconfig_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if sctp_handle_stream_reset(stcb, m, *offset, ch) != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                                current_block = 13422570431586403309;
                            }
                        }
                        13497718421940148126 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_FWD_TSN\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_forward_tsn_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.prsctp_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    let mut abort_flag_0 = 0i32;
                                    *fwd_tsn_seen = 1i32;
                                    if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1fi32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    (*stcb).asoc.last_data_chunk_from =
                                        (*stcb).asoc.last_control_chunk_from;
                                    sctp_handle_forward_tsn(
                                        stcb,
                                        ch as *mut sctp_forward_tsn_chunk,
                                        &mut abort_flag_0,
                                        m,
                                        *offset,
                                    );
                                    if abort_flag_0 != 0 {
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13226217046118304493 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_asconf_ack_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    if system_base_info.sctpsysctl.sctp_logging_level & 0x2000000u32
                                        != 0
                                    {
                                        sctp_misc_ints(
                                            120u8,
                                            (*stcb).asoc.overall_error_count,
                                            0u32,
                                            0x10000000u32,
                                            5531u32,
                                        );
                                    }
                                    (*stcb).asoc.overall_error_count = 0u32;
                                    sctp_handle_asconf_ack(
                                        m,
                                        *offset,
                                        ch as *mut sctp_asconf_ack_chunk,
                                        stcb,
                                        *netp,
                                        &mut abort_no_unlock,
                                    );
                                    if abort_no_unlock != 0 {
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        11399179239179359665 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_asconf(
                                        m,
                                        *offset as libc::c_uint,
                                        src,
                                        ch as *mut sctp_asconf_chunk,
                                        stcb,
                                        (asconf_cnt == 0i32) as libc::c_int,
                                    );
                                    asconf_cnt += 1;
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        3371148184269687219 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_CWR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cwr_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_cwr(ch as *mut sctp_cwr_chunk, stcb, *netp);
                                current_block = 13422570431586403309;
                            }
                        }
                        13594799726619700391 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_ECHO\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_ecne_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_echo(ch as *mut sctp_ecne_chunk, stcb);
                                ecne_seen = 1i32;
                                current_block = 13422570431586403309;
                            }
                        }
                        2781125740367032387 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cookie_ack_chunk>()
                                        as libc::c_ulong
                            {
                                return stcb;
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !(!stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0) {
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1ei32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                }
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_cookie_ack(
                                    ch as *mut sctp_cookie_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        17092723434217905016 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_OP_ERR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                                && sctp_handle_error(ch, stcb, *netp, contiguous) < 0i32
                            {
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            current_block = 13422570431586403309;
                        }
                        6770586402544785651 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_shutdown_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                let mut abort_flag = 0i32;
                                sctp_handle_shutdown(
                                    ch as *mut sctp_shutdown_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_flag,
                                );
                                if abort_flag != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            current_block = 13422570431586403309;
                        }
                        12945290292467802513 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_heartbeat_chunk>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvheartbeatack,
                                1u32,
                            );
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_heartbeat_ack(
                                    ch as *mut sctp_heartbeat_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        5491205026464363454 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                ::std::intrinsics::atomic_xadd(
                                    &mut system_base_info.sctpstat.sctps_recvheartbeat,
                                    1u32,
                                );
                                sctp_send_heartbeat_ack(
                                    stcb,
                                    m,
                                    *offset,
                                    chk_length as libc::c_int,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        7940804887512848672 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"%s\n\x00" as *const u8 as *const libc::c_char,
                                        if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                            b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                        } else {
                                            b"SCTP_NR_SACK\x00" as *const u8 as *const libc::c_char
                                        },
                                    );
                                }
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvsacks,
                                1u32,
                            );
                            if stcb.is_null() {
                                if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0 {
                                    if system_base_info.debug_printf.is_some() {
                                        system_base_info
                                            .debug_printf
                                            .expect("non-null function pointer")(
                                            b"No stcb when processing %s chunk\n\x00" as *const u8
                                                as *const libc::c_char,
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                            } else {
                                                b"SCTP_NR_SACK\x00" as *const u8
                                                    as *const libc::c_char
                                            },
                                        );
                                    }
                                }
                                current_block = 13422570431586403309;
                            } else {
                                if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                    if (chk_length as libc::c_ulong)
                                        < ::std::mem::size_of::<sctp_sack_chunk>() as libc::c_ulong
                                    {
                                        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32
                                            != 0
                                        {
                                            if system_base_info.debug_printf.is_some() {
                                                system_base_info
                                                    .debug_printf
                                                    .expect("non-null function pointer")(
                                                    b"Bad size on SACK chunk, too small\n\x00"
                                                        as *const u8
                                                        as *const libc::c_char,
                                                );
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    } else {
                                        current_block = 17937968408868551711;
                                    }
                                } else if (*stcb).asoc.nrsack_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_nr_sack_chunk>() as libc::c_ulong
                                {
                                    if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0
                                    {
                                        if system_base_info.debug_printf.is_some() {
                                            system_base_info
                                                .debug_printf
                                                .expect("non-null function pointer")(
                                                b"Bad size on NR_SACK chunk, too small\n\x00"
                                                    as *const u8
                                                    as *const libc::c_char,
                                            );
                                        }
                                    }
                                    current_block = 13422570431586403309;
                                } else {
                                    current_block = 17937968408868551711;
                                }
                                match current_block {
                                    6765806975593869225 => {}
                                    13422570431586403309 => {}
                                    _ => {
                                        if !((*stcb).asoc.state & 0x7fi32 == 0x40i32) {
                                            let mut a_rwnd = 0;
                                            let mut cum_ack = 0;
                                            let mut num_seg = 0;
                                            let mut num_nr_seg = 0;
                                            let mut num_dup = 0;
                                            let mut flags = 0;
                                            let mut offset_seg = 0;
                                            let mut offset_dup = 0;
                                            flags = (*ch).chunk_flags;
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                let mut sack = 0 as *mut sctp_sack_chunk;
                                                sack = ch as *mut sctp_sack_chunk;
                                                cum_ack = ntohl((*sack).sack.cum_tsn_ack);
                                                num_seg = ntohs((*sack).sack.num_gap_ack_blks);
                                                num_nr_seg = 0u16;
                                                num_dup = ntohs((*sack).sack.num_dup_tsns);
                                                a_rwnd = ntohl((*sack).sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_sack_chunk>()
                                                        as
                                                        libc::c_ulong).wrapping_add((num_seg
                                                                                         as
                                                                                         libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                         as
                                                                                                                         libc::c_ulong)).wrapping_add((num_dup
                                                                                                                                                           as
                                                                                                                                                           libc::c_ulong).wrapping_mul(::std::mem::size_of::<uint32_t>()
                                                                                                                                                                                           as
                                                                                                                                                                                           libc::c_ulong))
                                                       !=
                                                       chk_length as
                                                           libc::c_ulong {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                           &
                                                           0x1000000u32 !=
                                                           0 {
                                                        if system_base_info.debug_printf.is_some()
                                                           {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"Bad size of SACK chunk\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char);
                                                        }
                                                    }
                                                    current_block =
                                                        13422570431586403309;
                                                } else {
                                                    offset_seg =
                                                        (*offset as
                                                             libc::c_ulong).wrapping_add(::std::mem::size_of::<sctp_sack_chunk>()
                                                                                             as
                                                                                             libc::c_ulong)
                                                            as libc::c_int;
                                                    offset_dup =
                                                        (offset_seg as
                                                             libc::c_ulong).wrapping_add((num_seg
                                                                                              as
                                                                                              libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                              as
                                                                                                                              libc::c_ulong))
                                                            as libc::c_int;
                                                    current_block =
                                                        8752412851861032177;
                                                }
                                            } else {
                                                let mut nr_sack = 0 as *mut sctp_nr_sack_chunk;
                                                nr_sack = ch as *mut sctp_nr_sack_chunk;
                                                cum_ack = ntohl((*nr_sack).nr_sack.cum_tsn_ack);
                                                num_seg =
                                                    ntohs((*nr_sack).nr_sack.num_gap_ack_blks);
                                                num_nr_seg =
                                                    ntohs((*nr_sack).nr_sack.num_nr_gap_ack_blks);
                                                num_dup = ntohs((*nr_sack).nr_sack.num_dup_tsns);
                                                a_rwnd = ntohl((*nr_sack).nr_sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_nr_sack_chunk>()
                                                    as libc::c_ulong)
                                                    .wrapping_add(
                                                        ((num_seg as libc::c_int
                                                            + num_nr_seg as libc::c_int)
                                                            as libc::c_ulong)
                                                            .wrapping_mul(::std::mem::size_of::<
                                                                sctp_gap_ack_block,
                                                            >(
                                                            )
                                                                as libc::c_ulong),
                                                    )
                                                    .wrapping_add(
                                                        (num_dup as libc::c_ulong).wrapping_mul(
                                                            ::std::mem::size_of::<uint32_t>()
                                                                as libc::c_ulong,
                                                        ),
                                                    )
                                                    != chk_length as libc::c_ulong
                                                {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x1000000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"Bad size of NR_SACK chunk\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    current_block = 13422570431586403309;
                                                } else {
                                                    offset_seg = (*offset as libc::c_ulong)
                                                        .wrapping_add(::std::mem::size_of::<
                                                            sctp_nr_sack_chunk,
                                                        >(
                                                        )
                                                            as libc::c_ulong)
                                                        as libc::c_int;
                                                    offset_dup = (offset_seg as libc::c_ulong)
                                                        .wrapping_add(
                                                            ((num_seg as libc::c_int
                                                                + num_nr_seg as libc::c_int)
                                                                as libc::c_ulong)
                                                                .wrapping_mul(
                                                                    ::std::mem::size_of::<
                                                                        sctp_gap_ack_block,
                                                                    >(
                                                                    )
                                                                        as libc::c_ulong,
                                                                ),
                                                        )
                                                        as libc::c_int;
                                                    current_block = 8752412851861032177;
                                                }
                                            }
                                            match current_block {
                                                13422570431586403309 => {}
                                                _ => {
                                                    let mut abort_now = 0i32;
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"%s process cum_ack:%x num_seg:%d a_rwnd:%d\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char,
                                                                                                                              if (*ch).chunk_type
                                                                                                                                     as
                                                                                                                                     libc::c_int
                                                                                                                                     ==
                                                                                                                                     0x3i32
                                                                                                                                 {
                                                                                                                                  b"SCTP_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              } else {
                                                                                                                                  b"SCTP_NR_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              },
                                                                                                                              cum_ack,
                                                                                                                              num_seg
                                                                                                                                  as
                                                                                                                                  libc::c_int,
                                                                                                                              a_rwnd);
                                                        }
                                                    }
                                                    (*stcb).asoc.seen_a_sack_this_pkt = 1u8;
                                                    if (*stcb).asoc.pr_sctp_cnt == 0u32
                                                        && num_seg as libc::c_int == 0i32
                                                        && num_nr_seg as libc::c_int == 0i32
                                                        && (cum_ack < (*stcb).asoc.last_acked_seq
                                                            && (*stcb)
                                                                .asoc
                                                                .last_acked_seq
                                                                .wrapping_sub(cum_ack)
                                                                > (1u32) << 31i32
                                                            || cum_ack
                                                                > (*stcb).asoc.last_acked_seq
                                                                && cum_ack.wrapping_sub(
                                                                    (*stcb).asoc.last_acked_seq,
                                                                ) < (1u32) << 31i32
                                                            || cum_ack
                                                                == (*stcb).asoc.last_acked_seq)
                                                        && (*stcb).asoc.saw_sack_with_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && (*stcb).asoc.saw_sack_with_nr_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && !(*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                    {
                                                        sctp_express_handle_sack(
                                                            stcb,
                                                            cum_ack,
                                                            a_rwnd,
                                                            &mut abort_now,
                                                            ecne_seen,
                                                        );
                                                    } else if !netp.is_null() && !(*netp).is_null()
                                                    {
                                                        sctp_handle_sack(
                                                            m,
                                                            offset_seg,
                                                            offset_dup,
                                                            stcb,
                                                            num_seg,
                                                            num_nr_seg,
                                                            num_dup,
                                                            &mut abort_now,
                                                            flags,
                                                            cum_ack,
                                                            a_rwnd,
                                                            ecne_seen,
                                                        );
                                                    }
                                                    if abort_now != 0 {
                                                        *offset = length;
                                                        return 0 as *mut sctp_tcb;
                                                    }
                                                    if (*stcb).asoc.send_queue.tqh_first.is_null()
                                                        && (*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                        && (*stcb).asoc.stream_queue_cnt == 0u32
                                                    {
                                                        sctp_ulp_notify(
                                                            26u32,
                                                            stcb,
                                                            0u32,
                                                            0 as *mut libc::c_void,
                                                            0i32,
                                                        );
                                                    }
                                                }
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    }
                                }
                            }
                        }
                        2349180396633407496 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_AUTHENTICATION\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null() {
                                if auth_skipped == 0i32 {
                                    auth_offset = *offset as uint32_t;
                                    auth_len = chk_length;
                                    auth_skipped = 1i32
                                }
                                current_block = 13422570431586403309;
                            } else if (*stcb).asoc.auth_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_auth_chunk>() as libc::c_ulong
                                    || chk_length as libc::c_ulong
                                        > (::std::mem::size_of::<sctp_auth_chunk>()
                                            as libc::c_ulong)
                                            .wrapping_add(32u64)
                                {
                                    *offset = length;
                                    return stcb;
                                }
                                if got_auth == 1i32 {
                                    current_block = 13422570431586403309;
                                } else {
                                    got_auth = 1i32;
                                    if ch.is_null()
                                        || sctp_handle_auth(
                                            stcb,
                                            ch as *mut sctp_auth_chunk,
                                            m,
                                            *offset as uint32_t,
                                        ) != 0
                                    {
                                        *offset = length;
                                        return stcb;
                                    } else {
                                        (*stcb).asoc.authenticated = 1u8
                                    }
                                    current_block = 13422570431586403309;
                                }
                            }
                        }
                        _ => {}
                    }
                    match current_block {
                        13422570431586403309 => {}
                        _ => {
                            if (*ch).chunk_type as libc::c_int & 0x40i32 != 0 && !stcb.is_null() {
                                op_err = sctp_get_mbuf_for_msg(
                                    ::std::mem::size_of::<sctp_gen_error_cause>() as libc::c_uint,
                                    0i32,
                                    0x1i32,
                                    1i32,
                                    1i32,
                                );
                                if !op_err.is_null() {
                                    let mut cause = 0 as *mut sctp_gen_error_cause;
                                    let mut len = 0;
                                    len = if (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                        > (length - *offset) as uint32_t
                                    {
                                        (length - *offset) as uint32_t
                                    } else {
                                        (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                    } as libc::c_int;
                                    cause = (*op_err).m_hdr.mh_data as *mut sctp_gen_error_cause;
                                    (*cause).code = htons(0x6u16);
                                    (*cause).length =
                                        htons((len as libc::c_ulong).wrapping_add(
                                            ::std::mem::size_of::<sctp_gen_error_cause>()
                                                as libc::c_ulong,
                                        )
                                            as uint16_t);
                                    (*op_err).m_hdr.mh_len =
                                        ::std::mem::size_of::<sctp_gen_error_cause>()
                                            as libc::c_int;
                                    (*op_err).m_hdr.mh_next = m_copym(m, *offset, len, 0x1i32);
                                    if !(*op_err).m_hdr.mh_next.is_null() {
                                        sctp_queue_op_err(stcb, op_err);
                                    } else {
                                        m_freem(op_err);
                                    }
                                }
                            }
                            if (*ch).chunk_type as libc::c_int & 0x80i32 == 0i32 {
                                *offset = length;
                                return stcb;
                            }
                        }
                    }
                }
                4 => {
                    current_block = 5491205026464363454;
                    match current_block {
                        17766256343850198083 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_COMPLETE, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_complete(
                                    ch as *mut sctp_shutdown_complete_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        12601157616349825580 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT_ACK\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0 {
                                } else {
                                    *offset = length;
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1di32);
                                    }
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                ret = sctp_handle_init_ack(
                                    m,
                                    iphlen,
                                    *offset,
                                    src,
                                    dst,
                                    sh,
                                    ch as *mut sctp_init_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_no_unlock,
                                    vrf_id,
                                )
                            } else {
                                ret = -(1i32)
                            }
                            *offset = length;
                            if abort_no_unlock != 0 {
                                return 0 as *mut sctp_tcb;
                            }
                            if !stcb.is_null() && ret == 0i32 {
                                sctp_chunk_output((*stcb).sctp_ep, stcb, 3i32, 0i32);
                            }
                            return stcb;
                        }
                        16195856799229720522 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                if !stcb.is_null() {
                                    pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                }
                                return 0 as *mut sctp_tcb;
                            }
                            if chk_length > (65535i32 - 2048i32) as libc::c_uint {
                                op_err = sctp_generate_cause(
                                    0x4u16,
                                    b"\x00" as *const u8 as *mut libc::c_char,
                                );
                                sctp_abort_association(
                                    inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id, port,
                                );
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            sctp_handle_init(
                                m,
                                iphlen,
                                *offset,
                                src,
                                dst,
                                sh,
                                ch as *mut sctp_init_chunk,
                                inp,
                                stcb,
                                *netp,
                                &mut abort_no_unlock,
                                vrf_id,
                                port,
                            );
                            *offset = length;
                            if abort_no_unlock == 0 && !stcb.is_null() {
                                pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                            }
                            return 0 as *mut sctp_tcb;
                        }
                        6246479402878884953 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_ack(
                                    ch as *mut sctp_shutdown_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        4558417918157925232 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ABORT, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            *offset = length;
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if sctp_handle_abort(ch as *mut sctp_abort_chunk, stcb, *netp) != 0
                                {
                                    return 0 as *mut sctp_tcb;
                                } else {
                                    return stcb;
                                }
                            } else {
                                return 0 as *mut sctp_tcb;
                            }
                        }
                        9379646460352968115 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ECHO, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && (*stcb).asoc.total_output_queue_size > 0u32 {
                                current_block = 15201865807353435331;
                            } else if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                current_block = 15767785092075175044;
                            } else {
                                current_block = 15201865807353435331;
                            }
                            match current_block {
                                15201865807353435331 => {
                                    if stcb.is_null()
                                        && (!((*inp).sctp_flags & 0x8u32 != 0u32)
                                            || (*inp).sctp_flags & 0x1u32 == 0
                                                && (*(*inp).sctp_socket).so_qlen as libc::c_int
                                                    >= (*(*inp).sctp_socket).so_qlimit
                                                        as libc::c_int)
                                    {
                                        if (*inp).sctp_flags & 0x2u32 != 0
                                            && system_base_info
                                                .sctpsysctl
                                                .sctp_abort_if_one_2_one_hits_limit
                                                != 0
                                        {
                                            op_err = sctp_generate_cause(
                                                0x4u16,
                                                b"\x00" as *const u8 as *mut libc::c_char,
                                            );
                                            sctp_abort_association(
                                                inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id,
                                                port,
                                            );
                                        }
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    } else {
                                        let mut linp = 0 as *mut sctp_inpcb;
                                        if !stcb.is_null() {
                                            linp = 0 as *mut sctp_inpcb
                                        } else {
                                            linp = inp
                                        }
                                        if !linp.is_null() {
                                            pthread_mutex_lock(&mut (*linp).inp_create_mtx);
                                            if (*inp).sctp_flags & 0x10000000u32 != 0
                                                || (*inp).sctp_flags & 0x20000000u32 != 0
                                            {
                                                pthread_mutex_unlock(&mut (*linp).inp_create_mtx);
                                                current_block = 15767785092075175044;
                                            } else {
                                                current_block = 2358125959230175008;
                                            }
                                        } else {
                                            current_block = 2358125959230175008;
                                        }
                                        match current_block {
                                            15767785092075175044 => {}
                                            _ => {
                                                let mut ret_buf = 0 as *mut mbuf;
                                                if !netp.is_null() {
                                                    let mut locked_stcb = 0 as *mut sctp_tcb;
                                                    locked_stcb = stcb;
                                                    ret_buf = sctp_handle_cookie_echo(
                                                        m,
                                                        iphlen,
                                                        *offset,
                                                        src,
                                                        dst,
                                                        sh,
                                                        ch as *mut sctp_cookie_echo_chunk,
                                                        &mut inp,
                                                        &mut stcb,
                                                        netp,
                                                        auth_skipped,
                                                        auth_offset,
                                                        auth_len,
                                                        &mut locked_stcb,
                                                        vrf_id,
                                                        port,
                                                    );
                                                    if !locked_stcb.is_null() && locked_stcb != stcb
                                                    {
                                                        pthread_mutex_unlock(
                                                            &mut (*locked_stcb).tcb_mtx,
                                                        );
                                                    }
                                                    !stcb.is_null();
                                                } else {
                                                    ret_buf = 0 as *mut mbuf
                                                }
                                                if !linp.is_null() {
                                                    pthread_mutex_unlock(
                                                        &mut (*linp).inp_create_mtx,
                                                    );
                                                }
                                                if ret_buf.is_null() {
                                                    if !stcb.is_null() {
                                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                                    }
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"GAK, null buffer\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    *offset = length;
                                                    return 0 as *mut sctp_tcb;
                                                }
                                                if auth_skipped != 0 {
                                                    got_auth = 1i32;
                                                    auth_skipped = 0i32
                                                }
                                                if !(*stcb).asoc.sent_queue.tqh_first.is_null() {
                                                    let mut chk = 0 as *mut sctp_tmit_chunk;
                                                    chk = (*stcb).asoc.sent_queue.tqh_first;
                                                    sctp_timer_start(
                                                        1i32,
                                                        (*stcb).sctp_ep,
                                                        stcb,
                                                        (*chk).whoTo,
                                                    );
                                                }
                                                current_block = 13422570431586403309;
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                            match current_block {
                                13422570431586403309 => {}
                                _ => {
                                    if !stcb.is_null() {
                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                    }
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                        }
                        10582330624169799780 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_PACKET_DROPPED\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_pktdrop_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !ch.is_null()
                                && !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                            {
                                if (*stcb).asoc.pktdrop_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_packet_dropped(
                                        ch as *mut sctp_pktdrop_chunk,
                                        stcb,
                                        *netp,
                                        if chk_length > contiguous {
                                            contiguous
                                        } else {
                                            chk_length
                                        },
                                    );
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13268550889959046632 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_STREAM_RESET\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || ch.is_null()
                                || (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_stream_reset_tsn_req>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.reconfig_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if sctp_handle_stream_reset(stcb, m, *offset, ch) != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                                current_block = 13422570431586403309;
                            }
                        }
                        13497718421940148126 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_FWD_TSN\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_forward_tsn_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.prsctp_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    let mut abort_flag_0 = 0i32;
                                    *fwd_tsn_seen = 1i32;
                                    if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1fi32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    (*stcb).asoc.last_data_chunk_from =
                                        (*stcb).asoc.last_control_chunk_from;
                                    sctp_handle_forward_tsn(
                                        stcb,
                                        ch as *mut sctp_forward_tsn_chunk,
                                        &mut abort_flag_0,
                                        m,
                                        *offset,
                                    );
                                    if abort_flag_0 != 0 {
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13226217046118304493 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_asconf_ack_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    if system_base_info.sctpsysctl.sctp_logging_level & 0x2000000u32
                                        != 0
                                    {
                                        sctp_misc_ints(
                                            120u8,
                                            (*stcb).asoc.overall_error_count,
                                            0u32,
                                            0x10000000u32,
                                            5531u32,
                                        );
                                    }
                                    (*stcb).asoc.overall_error_count = 0u32;
                                    sctp_handle_asconf_ack(
                                        m,
                                        *offset,
                                        ch as *mut sctp_asconf_ack_chunk,
                                        stcb,
                                        *netp,
                                        &mut abort_no_unlock,
                                    );
                                    if abort_no_unlock != 0 {
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        11399179239179359665 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_asconf(
                                        m,
                                        *offset as libc::c_uint,
                                        src,
                                        ch as *mut sctp_asconf_chunk,
                                        stcb,
                                        (asconf_cnt == 0i32) as libc::c_int,
                                    );
                                    asconf_cnt += 1;
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        3371148184269687219 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_CWR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cwr_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_cwr(ch as *mut sctp_cwr_chunk, stcb, *netp);
                                current_block = 13422570431586403309;
                            }
                        }
                        13594799726619700391 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_ECHO\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_ecne_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_echo(ch as *mut sctp_ecne_chunk, stcb);
                                ecne_seen = 1i32;
                                current_block = 13422570431586403309;
                            }
                        }
                        2781125740367032387 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cookie_ack_chunk>()
                                        as libc::c_ulong
                            {
                                return stcb;
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !(!stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0) {
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1ei32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                }
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_cookie_ack(
                                    ch as *mut sctp_cookie_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        17092723434217905016 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_OP_ERR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                                && sctp_handle_error(ch, stcb, *netp, contiguous) < 0i32
                            {
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            current_block = 13422570431586403309;
                        }
                        6770586402544785651 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_shutdown_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                let mut abort_flag = 0i32;
                                sctp_handle_shutdown(
                                    ch as *mut sctp_shutdown_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_flag,
                                );
                                if abort_flag != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            current_block = 13422570431586403309;
                        }
                        12945290292467802513 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_heartbeat_chunk>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvheartbeatack,
                                1u32,
                            );
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_heartbeat_ack(
                                    ch as *mut sctp_heartbeat_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        5491205026464363454 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                ::std::intrinsics::atomic_xadd(
                                    &mut system_base_info.sctpstat.sctps_recvheartbeat,
                                    1u32,
                                );
                                sctp_send_heartbeat_ack(
                                    stcb,
                                    m,
                                    *offset,
                                    chk_length as libc::c_int,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        7940804887512848672 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"%s\n\x00" as *const u8 as *const libc::c_char,
                                        if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                            b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                        } else {
                                            b"SCTP_NR_SACK\x00" as *const u8 as *const libc::c_char
                                        },
                                    );
                                }
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvsacks,
                                1u32,
                            );
                            if stcb.is_null() {
                                if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0 {
                                    if system_base_info.debug_printf.is_some() {
                                        system_base_info
                                            .debug_printf
                                            .expect("non-null function pointer")(
                                            b"No stcb when processing %s chunk\n\x00" as *const u8
                                                as *const libc::c_char,
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                            } else {
                                                b"SCTP_NR_SACK\x00" as *const u8
                                                    as *const libc::c_char
                                            },
                                        );
                                    }
                                }
                                current_block = 13422570431586403309;
                            } else {
                                if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                    if (chk_length as libc::c_ulong)
                                        < ::std::mem::size_of::<sctp_sack_chunk>() as libc::c_ulong
                                    {
                                        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32
                                            != 0
                                        {
                                            if system_base_info.debug_printf.is_some() {
                                                system_base_info
                                                    .debug_printf
                                                    .expect("non-null function pointer")(
                                                    b"Bad size on SACK chunk, too small\n\x00"
                                                        as *const u8
                                                        as *const libc::c_char,
                                                );
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    } else {
                                        current_block = 17937968408868551711;
                                    }
                                } else if (*stcb).asoc.nrsack_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_nr_sack_chunk>() as libc::c_ulong
                                {
                                    if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0
                                    {
                                        if system_base_info.debug_printf.is_some() {
                                            system_base_info
                                                .debug_printf
                                                .expect("non-null function pointer")(
                                                b"Bad size on NR_SACK chunk, too small\n\x00"
                                                    as *const u8
                                                    as *const libc::c_char,
                                            );
                                        }
                                    }
                                    current_block = 13422570431586403309;
                                } else {
                                    current_block = 17937968408868551711;
                                }
                                match current_block {
                                    6765806975593869225 => {}
                                    13422570431586403309 => {}
                                    _ => {
                                        if !((*stcb).asoc.state & 0x7fi32 == 0x40i32) {
                                            let mut a_rwnd = 0;
                                            let mut cum_ack = 0;
                                            let mut num_seg = 0;
                                            let mut num_nr_seg = 0;
                                            let mut num_dup = 0;
                                            let mut flags = 0;
                                            let mut offset_seg = 0;
                                            let mut offset_dup = 0;
                                            flags = (*ch).chunk_flags;
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                let mut sack = 0 as *mut sctp_sack_chunk;
                                                sack = ch as *mut sctp_sack_chunk;
                                                cum_ack = ntohl((*sack).sack.cum_tsn_ack);
                                                num_seg = ntohs((*sack).sack.num_gap_ack_blks);
                                                num_nr_seg = 0u16;
                                                num_dup = ntohs((*sack).sack.num_dup_tsns);
                                                a_rwnd = ntohl((*sack).sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_sack_chunk>()
                                                        as
                                                        libc::c_ulong).wrapping_add((num_seg
                                                                                         as
                                                                                         libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                         as
                                                                                                                         libc::c_ulong)).wrapping_add((num_dup
                                                                                                                                                           as
                                                                                                                                                           libc::c_ulong).wrapping_mul(::std::mem::size_of::<uint32_t>()
                                                                                                                                                                                           as
                                                                                                                                                                                           libc::c_ulong))
                                                       !=
                                                       chk_length as
                                                           libc::c_ulong {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                           &
                                                           0x1000000u32 !=
                                                           0 {
                                                        if system_base_info.debug_printf.is_some()
                                                           {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"Bad size of SACK chunk\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char);
                                                        }
                                                    }
                                                    current_block =
                                                        13422570431586403309;
                                                } else {
                                                    offset_seg =
                                                        (*offset as
                                                             libc::c_ulong).wrapping_add(::std::mem::size_of::<sctp_sack_chunk>()
                                                                                             as
                                                                                             libc::c_ulong)
                                                            as libc::c_int;
                                                    offset_dup =
                                                        (offset_seg as
                                                             libc::c_ulong).wrapping_add((num_seg
                                                                                              as
                                                                                              libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                              as
                                                                                                                              libc::c_ulong))
                                                            as libc::c_int;
                                                    current_block =
                                                        8752412851861032177;
                                                }
                                            } else {
                                                let mut nr_sack = 0 as *mut sctp_nr_sack_chunk;
                                                nr_sack = ch as *mut sctp_nr_sack_chunk;
                                                cum_ack = ntohl((*nr_sack).nr_sack.cum_tsn_ack);
                                                num_seg =
                                                    ntohs((*nr_sack).nr_sack.num_gap_ack_blks);
                                                num_nr_seg =
                                                    ntohs((*nr_sack).nr_sack.num_nr_gap_ack_blks);
                                                num_dup = ntohs((*nr_sack).nr_sack.num_dup_tsns);
                                                a_rwnd = ntohl((*nr_sack).nr_sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_nr_sack_chunk>()
                                                    as libc::c_ulong)
                                                    .wrapping_add(
                                                        ((num_seg as libc::c_int
                                                            + num_nr_seg as libc::c_int)
                                                            as libc::c_ulong)
                                                            .wrapping_mul(::std::mem::size_of::<
                                                                sctp_gap_ack_block,
                                                            >(
                                                            )
                                                                as libc::c_ulong),
                                                    )
                                                    .wrapping_add(
                                                        (num_dup as libc::c_ulong).wrapping_mul(
                                                            ::std::mem::size_of::<uint32_t>()
                                                                as libc::c_ulong,
                                                        ),
                                                    )
                                                    != chk_length as libc::c_ulong
                                                {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x1000000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"Bad size of NR_SACK chunk\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    current_block = 13422570431586403309;
                                                } else {
                                                    offset_seg = (*offset as libc::c_ulong)
                                                        .wrapping_add(::std::mem::size_of::<
                                                            sctp_nr_sack_chunk,
                                                        >(
                                                        )
                                                            as libc::c_ulong)
                                                        as libc::c_int;
                                                    offset_dup = (offset_seg as libc::c_ulong)
                                                        .wrapping_add(
                                                            ((num_seg as libc::c_int
                                                                + num_nr_seg as libc::c_int)
                                                                as libc::c_ulong)
                                                                .wrapping_mul(
                                                                    ::std::mem::size_of::<
                                                                        sctp_gap_ack_block,
                                                                    >(
                                                                    )
                                                                        as libc::c_ulong,
                                                                ),
                                                        )
                                                        as libc::c_int;
                                                    current_block = 8752412851861032177;
                                                }
                                            }
                                            match current_block {
                                                13422570431586403309 => {}
                                                _ => {
                                                    let mut abort_now = 0i32;
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"%s process cum_ack:%x num_seg:%d a_rwnd:%d\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char,
                                                                                                                              if (*ch).chunk_type
                                                                                                                                     as
                                                                                                                                     libc::c_int
                                                                                                                                     ==
                                                                                                                                     0x3i32
                                                                                                                                 {
                                                                                                                                  b"SCTP_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              } else {
                                                                                                                                  b"SCTP_NR_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              },
                                                                                                                              cum_ack,
                                                                                                                              num_seg
                                                                                                                                  as
                                                                                                                                  libc::c_int,
                                                                                                                              a_rwnd);
                                                        }
                                                    }
                                                    (*stcb).asoc.seen_a_sack_this_pkt = 1u8;
                                                    if (*stcb).asoc.pr_sctp_cnt == 0u32
                                                        && num_seg as libc::c_int == 0i32
                                                        && num_nr_seg as libc::c_int == 0i32
                                                        && (cum_ack < (*stcb).asoc.last_acked_seq
                                                            && (*stcb)
                                                                .asoc
                                                                .last_acked_seq
                                                                .wrapping_sub(cum_ack)
                                                                > (1u32) << 31i32
                                                            || cum_ack
                                                                > (*stcb).asoc.last_acked_seq
                                                                && cum_ack.wrapping_sub(
                                                                    (*stcb).asoc.last_acked_seq,
                                                                ) < (1u32) << 31i32
                                                            || cum_ack
                                                                == (*stcb).asoc.last_acked_seq)
                                                        && (*stcb).asoc.saw_sack_with_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && (*stcb).asoc.saw_sack_with_nr_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && !(*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                    {
                                                        sctp_express_handle_sack(
                                                            stcb,
                                                            cum_ack,
                                                            a_rwnd,
                                                            &mut abort_now,
                                                            ecne_seen,
                                                        );
                                                    } else if !netp.is_null() && !(*netp).is_null()
                                                    {
                                                        sctp_handle_sack(
                                                            m,
                                                            offset_seg,
                                                            offset_dup,
                                                            stcb,
                                                            num_seg,
                                                            num_nr_seg,
                                                            num_dup,
                                                            &mut abort_now,
                                                            flags,
                                                            cum_ack,
                                                            a_rwnd,
                                                            ecne_seen,
                                                        );
                                                    }
                                                    if abort_now != 0 {
                                                        *offset = length;
                                                        return 0 as *mut sctp_tcb;
                                                    }
                                                    if (*stcb).asoc.send_queue.tqh_first.is_null()
                                                        && (*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                        && (*stcb).asoc.stream_queue_cnt == 0u32
                                                    {
                                                        sctp_ulp_notify(
                                                            26u32,
                                                            stcb,
                                                            0u32,
                                                            0 as *mut libc::c_void,
                                                            0i32,
                                                        );
                                                    }
                                                }
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    }
                                }
                            }
                        }
                        2349180396633407496 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_AUTHENTICATION\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null() {
                                if auth_skipped == 0i32 {
                                    auth_offset = *offset as uint32_t;
                                    auth_len = chk_length;
                                    auth_skipped = 1i32
                                }
                                current_block = 13422570431586403309;
                            } else if (*stcb).asoc.auth_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_auth_chunk>() as libc::c_ulong
                                    || chk_length as libc::c_ulong
                                        > (::std::mem::size_of::<sctp_auth_chunk>()
                                            as libc::c_ulong)
                                            .wrapping_add(32u64)
                                {
                                    *offset = length;
                                    return stcb;
                                }
                                if got_auth == 1i32 {
                                    current_block = 13422570431586403309;
                                } else {
                                    got_auth = 1i32;
                                    if ch.is_null()
                                        || sctp_handle_auth(
                                            stcb,
                                            ch as *mut sctp_auth_chunk,
                                            m,
                                            *offset as uint32_t,
                                        ) != 0
                                    {
                                        *offset = length;
                                        return stcb;
                                    } else {
                                        (*stcb).asoc.authenticated = 1u8
                                    }
                                    current_block = 13422570431586403309;
                                }
                            }
                        }
                        _ => {}
                    }
                    match current_block {
                        13422570431586403309 => {}
                        _ => {
                            if (*ch).chunk_type as libc::c_int & 0x40i32 != 0 && !stcb.is_null() {
                                op_err = sctp_get_mbuf_for_msg(
                                    ::std::mem::size_of::<sctp_gen_error_cause>() as libc::c_uint,
                                    0i32,
                                    0x1i32,
                                    1i32,
                                    1i32,
                                );
                                if !op_err.is_null() {
                                    let mut cause = 0 as *mut sctp_gen_error_cause;
                                    let mut len = 0;
                                    len = if (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                        > (length - *offset) as uint32_t
                                    {
                                        (length - *offset) as uint32_t
                                    } else {
                                        (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                    } as libc::c_int;
                                    cause = (*op_err).m_hdr.mh_data as *mut sctp_gen_error_cause;
                                    (*cause).code = htons(0x6u16);
                                    (*cause).length =
                                        htons((len as libc::c_ulong).wrapping_add(
                                            ::std::mem::size_of::<sctp_gen_error_cause>()
                                                as libc::c_ulong,
                                        )
                                            as uint16_t);
                                    (*op_err).m_hdr.mh_len =
                                        ::std::mem::size_of::<sctp_gen_error_cause>()
                                            as libc::c_int;
                                    (*op_err).m_hdr.mh_next = m_copym(m, *offset, len, 0x1i32);
                                    if !(*op_err).m_hdr.mh_next.is_null() {
                                        sctp_queue_op_err(stcb, op_err);
                                    } else {
                                        m_freem(op_err);
                                    }
                                }
                            }
                            if (*ch).chunk_type as libc::c_int & 0x80i32 == 0i32 {
                                *offset = length;
                                return stcb;
                            }
                        }
                    }
                }
                5 => {
                    current_block = 12945290292467802513;
                    match current_block {
                        17766256343850198083 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_COMPLETE, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_complete(
                                    ch as *mut sctp_shutdown_complete_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        12601157616349825580 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT_ACK\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0 {
                                } else {
                                    *offset = length;
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1di32);
                                    }
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                ret = sctp_handle_init_ack(
                                    m,
                                    iphlen,
                                    *offset,
                                    src,
                                    dst,
                                    sh,
                                    ch as *mut sctp_init_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_no_unlock,
                                    vrf_id,
                                )
                            } else {
                                ret = -(1i32)
                            }
                            *offset = length;
                            if abort_no_unlock != 0 {
                                return 0 as *mut sctp_tcb;
                            }
                            if !stcb.is_null() && ret == 0i32 {
                                sctp_chunk_output((*stcb).sctp_ep, stcb, 3i32, 0i32);
                            }
                            return stcb;
                        }
                        16195856799229720522 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                if !stcb.is_null() {
                                    pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                }
                                return 0 as *mut sctp_tcb;
                            }
                            if chk_length > (65535i32 - 2048i32) as libc::c_uint {
                                op_err = sctp_generate_cause(
                                    0x4u16,
                                    b"\x00" as *const u8 as *mut libc::c_char,
                                );
                                sctp_abort_association(
                                    inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id, port,
                                );
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            sctp_handle_init(
                                m,
                                iphlen,
                                *offset,
                                src,
                                dst,
                                sh,
                                ch as *mut sctp_init_chunk,
                                inp,
                                stcb,
                                *netp,
                                &mut abort_no_unlock,
                                vrf_id,
                                port,
                            );
                            *offset = length;
                            if abort_no_unlock == 0 && !stcb.is_null() {
                                pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                            }
                            return 0 as *mut sctp_tcb;
                        }
                        6246479402878884953 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_ack(
                                    ch as *mut sctp_shutdown_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        4558417918157925232 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ABORT, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            *offset = length;
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if sctp_handle_abort(ch as *mut sctp_abort_chunk, stcb, *netp) != 0
                                {
                                    return 0 as *mut sctp_tcb;
                                } else {
                                    return stcb;
                                }
                            } else {
                                return 0 as *mut sctp_tcb;
                            }
                        }
                        9379646460352968115 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ECHO, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && (*stcb).asoc.total_output_queue_size > 0u32 {
                                current_block = 15201865807353435331;
                            } else if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                current_block = 15767785092075175044;
                            } else {
                                current_block = 15201865807353435331;
                            }
                            match current_block {
                                15201865807353435331 => {
                                    if stcb.is_null()
                                        && (!((*inp).sctp_flags & 0x8u32 != 0u32)
                                            || (*inp).sctp_flags & 0x1u32 == 0
                                                && (*(*inp).sctp_socket).so_qlen as libc::c_int
                                                    >= (*(*inp).sctp_socket).so_qlimit
                                                        as libc::c_int)
                                    {
                                        if (*inp).sctp_flags & 0x2u32 != 0
                                            && system_base_info
                                                .sctpsysctl
                                                .sctp_abort_if_one_2_one_hits_limit
                                                != 0
                                        {
                                            op_err = sctp_generate_cause(
                                                0x4u16,
                                                b"\x00" as *const u8 as *mut libc::c_char,
                                            );
                                            sctp_abort_association(
                                                inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id,
                                                port,
                                            );
                                        }
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    } else {
                                        let mut linp = 0 as *mut sctp_inpcb;
                                        if !stcb.is_null() {
                                            linp = 0 as *mut sctp_inpcb
                                        } else {
                                            linp = inp
                                        }
                                        if !linp.is_null() {
                                            pthread_mutex_lock(&mut (*linp).inp_create_mtx);
                                            if (*inp).sctp_flags & 0x10000000u32 != 0
                                                || (*inp).sctp_flags & 0x20000000u32 != 0
                                            {
                                                pthread_mutex_unlock(&mut (*linp).inp_create_mtx);
                                                current_block = 15767785092075175044;
                                            } else {
                                                current_block = 2358125959230175008;
                                            }
                                        } else {
                                            current_block = 2358125959230175008;
                                        }
                                        match current_block {
                                            15767785092075175044 => {}
                                            _ => {
                                                let mut ret_buf = 0 as *mut mbuf;
                                                if !netp.is_null() {
                                                    let mut locked_stcb = 0 as *mut sctp_tcb;
                                                    locked_stcb = stcb;
                                                    ret_buf = sctp_handle_cookie_echo(
                                                        m,
                                                        iphlen,
                                                        *offset,
                                                        src,
                                                        dst,
                                                        sh,
                                                        ch as *mut sctp_cookie_echo_chunk,
                                                        &mut inp,
                                                        &mut stcb,
                                                        netp,
                                                        auth_skipped,
                                                        auth_offset,
                                                        auth_len,
                                                        &mut locked_stcb,
                                                        vrf_id,
                                                        port,
                                                    );
                                                    if !locked_stcb.is_null() && locked_stcb != stcb
                                                    {
                                                        pthread_mutex_unlock(
                                                            &mut (*locked_stcb).tcb_mtx,
                                                        );
                                                    }
                                                    !stcb.is_null();
                                                } else {
                                                    ret_buf = 0 as *mut mbuf
                                                }
                                                if !linp.is_null() {
                                                    pthread_mutex_unlock(
                                                        &mut (*linp).inp_create_mtx,
                                                    );
                                                }
                                                if ret_buf.is_null() {
                                                    if !stcb.is_null() {
                                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                                    }
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"GAK, null buffer\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    *offset = length;
                                                    return 0 as *mut sctp_tcb;
                                                }
                                                if auth_skipped != 0 {
                                                    got_auth = 1i32;
                                                    auth_skipped = 0i32
                                                }
                                                if !(*stcb).asoc.sent_queue.tqh_first.is_null() {
                                                    let mut chk = 0 as *mut sctp_tmit_chunk;
                                                    chk = (*stcb).asoc.sent_queue.tqh_first;
                                                    sctp_timer_start(
                                                        1i32,
                                                        (*stcb).sctp_ep,
                                                        stcb,
                                                        (*chk).whoTo,
                                                    );
                                                }
                                                current_block = 13422570431586403309;
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                            match current_block {
                                13422570431586403309 => {}
                                _ => {
                                    if !stcb.is_null() {
                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                    }
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                        }
                        10582330624169799780 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_PACKET_DROPPED\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_pktdrop_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !ch.is_null()
                                && !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                            {
                                if (*stcb).asoc.pktdrop_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_packet_dropped(
                                        ch as *mut sctp_pktdrop_chunk,
                                        stcb,
                                        *netp,
                                        if chk_length > contiguous {
                                            contiguous
                                        } else {
                                            chk_length
                                        },
                                    );
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13268550889959046632 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_STREAM_RESET\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || ch.is_null()
                                || (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_stream_reset_tsn_req>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.reconfig_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if sctp_handle_stream_reset(stcb, m, *offset, ch) != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                                current_block = 13422570431586403309;
                            }
                        }
                        13497718421940148126 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_FWD_TSN\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_forward_tsn_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.prsctp_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    let mut abort_flag_0 = 0i32;
                                    *fwd_tsn_seen = 1i32;
                                    if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1fi32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    (*stcb).asoc.last_data_chunk_from =
                                        (*stcb).asoc.last_control_chunk_from;
                                    sctp_handle_forward_tsn(
                                        stcb,
                                        ch as *mut sctp_forward_tsn_chunk,
                                        &mut abort_flag_0,
                                        m,
                                        *offset,
                                    );
                                    if abort_flag_0 != 0 {
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13226217046118304493 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_asconf_ack_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    if system_base_info.sctpsysctl.sctp_logging_level & 0x2000000u32
                                        != 0
                                    {
                                        sctp_misc_ints(
                                            120u8,
                                            (*stcb).asoc.overall_error_count,
                                            0u32,
                                            0x10000000u32,
                                            5531u32,
                                        );
                                    }
                                    (*stcb).asoc.overall_error_count = 0u32;
                                    sctp_handle_asconf_ack(
                                        m,
                                        *offset,
                                        ch as *mut sctp_asconf_ack_chunk,
                                        stcb,
                                        *netp,
                                        &mut abort_no_unlock,
                                    );
                                    if abort_no_unlock != 0 {
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        11399179239179359665 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_asconf(
                                        m,
                                        *offset as libc::c_uint,
                                        src,
                                        ch as *mut sctp_asconf_chunk,
                                        stcb,
                                        (asconf_cnt == 0i32) as libc::c_int,
                                    );
                                    asconf_cnt += 1;
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        3371148184269687219 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_CWR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cwr_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_cwr(ch as *mut sctp_cwr_chunk, stcb, *netp);
                                current_block = 13422570431586403309;
                            }
                        }
                        13594799726619700391 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_ECHO\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_ecne_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_echo(ch as *mut sctp_ecne_chunk, stcb);
                                ecne_seen = 1i32;
                                current_block = 13422570431586403309;
                            }
                        }
                        2781125740367032387 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cookie_ack_chunk>()
                                        as libc::c_ulong
                            {
                                return stcb;
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !(!stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0) {
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1ei32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                }
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_cookie_ack(
                                    ch as *mut sctp_cookie_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        17092723434217905016 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_OP_ERR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                                && sctp_handle_error(ch, stcb, *netp, contiguous) < 0i32
                            {
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            current_block = 13422570431586403309;
                        }
                        6770586402544785651 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_shutdown_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                let mut abort_flag = 0i32;
                                sctp_handle_shutdown(
                                    ch as *mut sctp_shutdown_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_flag,
                                );
                                if abort_flag != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            current_block = 13422570431586403309;
                        }
                        12945290292467802513 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_heartbeat_chunk>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvheartbeatack,
                                1u32,
                            );
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_heartbeat_ack(
                                    ch as *mut sctp_heartbeat_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        5491205026464363454 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                ::std::intrinsics::atomic_xadd(
                                    &mut system_base_info.sctpstat.sctps_recvheartbeat,
                                    1u32,
                                );
                                sctp_send_heartbeat_ack(
                                    stcb,
                                    m,
                                    *offset,
                                    chk_length as libc::c_int,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        7940804887512848672 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"%s\n\x00" as *const u8 as *const libc::c_char,
                                        if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                            b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                        } else {
                                            b"SCTP_NR_SACK\x00" as *const u8 as *const libc::c_char
                                        },
                                    );
                                }
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvsacks,
                                1u32,
                            );
                            if stcb.is_null() {
                                if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0 {
                                    if system_base_info.debug_printf.is_some() {
                                        system_base_info
                                            .debug_printf
                                            .expect("non-null function pointer")(
                                            b"No stcb when processing %s chunk\n\x00" as *const u8
                                                as *const libc::c_char,
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                            } else {
                                                b"SCTP_NR_SACK\x00" as *const u8
                                                    as *const libc::c_char
                                            },
                                        );
                                    }
                                }
                                current_block = 13422570431586403309;
                            } else {
                                if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                    if (chk_length as libc::c_ulong)
                                        < ::std::mem::size_of::<sctp_sack_chunk>() as libc::c_ulong
                                    {
                                        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32
                                            != 0
                                        {
                                            if system_base_info.debug_printf.is_some() {
                                                system_base_info
                                                    .debug_printf
                                                    .expect("non-null function pointer")(
                                                    b"Bad size on SACK chunk, too small\n\x00"
                                                        as *const u8
                                                        as *const libc::c_char,
                                                );
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    } else {
                                        current_block = 17937968408868551711;
                                    }
                                } else if (*stcb).asoc.nrsack_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_nr_sack_chunk>() as libc::c_ulong
                                {
                                    if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0
                                    {
                                        if system_base_info.debug_printf.is_some() {
                                            system_base_info
                                                .debug_printf
                                                .expect("non-null function pointer")(
                                                b"Bad size on NR_SACK chunk, too small\n\x00"
                                                    as *const u8
                                                    as *const libc::c_char,
                                            );
                                        }
                                    }
                                    current_block = 13422570431586403309;
                                } else {
                                    current_block = 17937968408868551711;
                                }
                                match current_block {
                                    6765806975593869225 => {}
                                    13422570431586403309 => {}
                                    _ => {
                                        if !((*stcb).asoc.state & 0x7fi32 == 0x40i32) {
                                            let mut a_rwnd = 0;
                                            let mut cum_ack = 0;
                                            let mut num_seg = 0;
                                            let mut num_nr_seg = 0;
                                            let mut num_dup = 0;
                                            let mut flags = 0;
                                            let mut offset_seg = 0;
                                            let mut offset_dup = 0;
                                            flags = (*ch).chunk_flags;
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                let mut sack = 0 as *mut sctp_sack_chunk;
                                                sack = ch as *mut sctp_sack_chunk;
                                                cum_ack = ntohl((*sack).sack.cum_tsn_ack);
                                                num_seg = ntohs((*sack).sack.num_gap_ack_blks);
                                                num_nr_seg = 0u16;
                                                num_dup = ntohs((*sack).sack.num_dup_tsns);
                                                a_rwnd = ntohl((*sack).sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_sack_chunk>()
                                                        as
                                                        libc::c_ulong).wrapping_add((num_seg
                                                                                         as
                                                                                         libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                         as
                                                                                                                         libc::c_ulong)).wrapping_add((num_dup
                                                                                                                                                           as
                                                                                                                                                           libc::c_ulong).wrapping_mul(::std::mem::size_of::<uint32_t>()
                                                                                                                                                                                           as
                                                                                                                                                                                           libc::c_ulong))
                                                       !=
                                                       chk_length as
                                                           libc::c_ulong {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                           &
                                                           0x1000000u32 !=
                                                           0 {
                                                        if system_base_info.debug_printf.is_some()
                                                           {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"Bad size of SACK chunk\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char);
                                                        }
                                                    }
                                                    current_block =
                                                        13422570431586403309;
                                                } else {
                                                    offset_seg =
                                                        (*offset as
                                                             libc::c_ulong).wrapping_add(::std::mem::size_of::<sctp_sack_chunk>()
                                                                                             as
                                                                                             libc::c_ulong)
                                                            as libc::c_int;
                                                    offset_dup =
                                                        (offset_seg as
                                                             libc::c_ulong).wrapping_add((num_seg
                                                                                              as
                                                                                              libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                              as
                                                                                                                              libc::c_ulong))
                                                            as libc::c_int;
                                                    current_block =
                                                        8752412851861032177;
                                                }
                                            } else {
                                                let mut nr_sack = 0 as *mut sctp_nr_sack_chunk;
                                                nr_sack = ch as *mut sctp_nr_sack_chunk;
                                                cum_ack = ntohl((*nr_sack).nr_sack.cum_tsn_ack);
                                                num_seg =
                                                    ntohs((*nr_sack).nr_sack.num_gap_ack_blks);
                                                num_nr_seg =
                                                    ntohs((*nr_sack).nr_sack.num_nr_gap_ack_blks);
                                                num_dup = ntohs((*nr_sack).nr_sack.num_dup_tsns);
                                                a_rwnd = ntohl((*nr_sack).nr_sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_nr_sack_chunk>()
                                                    as libc::c_ulong)
                                                    .wrapping_add(
                                                        ((num_seg as libc::c_int
                                                            + num_nr_seg as libc::c_int)
                                                            as libc::c_ulong)
                                                            .wrapping_mul(::std::mem::size_of::<
                                                                sctp_gap_ack_block,
                                                            >(
                                                            )
                                                                as libc::c_ulong),
                                                    )
                                                    .wrapping_add(
                                                        (num_dup as libc::c_ulong).wrapping_mul(
                                                            ::std::mem::size_of::<uint32_t>()
                                                                as libc::c_ulong,
                                                        ),
                                                    )
                                                    != chk_length as libc::c_ulong
                                                {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x1000000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"Bad size of NR_SACK chunk\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    current_block = 13422570431586403309;
                                                } else {
                                                    offset_seg = (*offset as libc::c_ulong)
                                                        .wrapping_add(::std::mem::size_of::<
                                                            sctp_nr_sack_chunk,
                                                        >(
                                                        )
                                                            as libc::c_ulong)
                                                        as libc::c_int;
                                                    offset_dup = (offset_seg as libc::c_ulong)
                                                        .wrapping_add(
                                                            ((num_seg as libc::c_int
                                                                + num_nr_seg as libc::c_int)
                                                                as libc::c_ulong)
                                                                .wrapping_mul(
                                                                    ::std::mem::size_of::<
                                                                        sctp_gap_ack_block,
                                                                    >(
                                                                    )
                                                                        as libc::c_ulong,
                                                                ),
                                                        )
                                                        as libc::c_int;
                                                    current_block = 8752412851861032177;
                                                }
                                            }
                                            match current_block {
                                                13422570431586403309 => {}
                                                _ => {
                                                    let mut abort_now = 0i32;
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"%s process cum_ack:%x num_seg:%d a_rwnd:%d\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char,
                                                                                                                              if (*ch).chunk_type
                                                                                                                                     as
                                                                                                                                     libc::c_int
                                                                                                                                     ==
                                                                                                                                     0x3i32
                                                                                                                                 {
                                                                                                                                  b"SCTP_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              } else {
                                                                                                                                  b"SCTP_NR_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              },
                                                                                                                              cum_ack,
                                                                                                                              num_seg
                                                                                                                                  as
                                                                                                                                  libc::c_int,
                                                                                                                              a_rwnd);
                                                        }
                                                    }
                                                    (*stcb).asoc.seen_a_sack_this_pkt = 1u8;
                                                    if (*stcb).asoc.pr_sctp_cnt == 0u32
                                                        && num_seg as libc::c_int == 0i32
                                                        && num_nr_seg as libc::c_int == 0i32
                                                        && (cum_ack < (*stcb).asoc.last_acked_seq
                                                            && (*stcb)
                                                                .asoc
                                                                .last_acked_seq
                                                                .wrapping_sub(cum_ack)
                                                                > (1u32) << 31i32
                                                            || cum_ack
                                                                > (*stcb).asoc.last_acked_seq
                                                                && cum_ack.wrapping_sub(
                                                                    (*stcb).asoc.last_acked_seq,
                                                                ) < (1u32) << 31i32
                                                            || cum_ack
                                                                == (*stcb).asoc.last_acked_seq)
                                                        && (*stcb).asoc.saw_sack_with_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && (*stcb).asoc.saw_sack_with_nr_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && !(*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                    {
                                                        sctp_express_handle_sack(
                                                            stcb,
                                                            cum_ack,
                                                            a_rwnd,
                                                            &mut abort_now,
                                                            ecne_seen,
                                                        );
                                                    } else if !netp.is_null() && !(*netp).is_null()
                                                    {
                                                        sctp_handle_sack(
                                                            m,
                                                            offset_seg,
                                                            offset_dup,
                                                            stcb,
                                                            num_seg,
                                                            num_nr_seg,
                                                            num_dup,
                                                            &mut abort_now,
                                                            flags,
                                                            cum_ack,
                                                            a_rwnd,
                                                            ecne_seen,
                                                        );
                                                    }
                                                    if abort_now != 0 {
                                                        *offset = length;
                                                        return 0 as *mut sctp_tcb;
                                                    }
                                                    if (*stcb).asoc.send_queue.tqh_first.is_null()
                                                        && (*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                        && (*stcb).asoc.stream_queue_cnt == 0u32
                                                    {
                                                        sctp_ulp_notify(
                                                            26u32,
                                                            stcb,
                                                            0u32,
                                                            0 as *mut libc::c_void,
                                                            0i32,
                                                        );
                                                    }
                                                }
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    }
                                }
                            }
                        }
                        2349180396633407496 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_AUTHENTICATION\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null() {
                                if auth_skipped == 0i32 {
                                    auth_offset = *offset as uint32_t;
                                    auth_len = chk_length;
                                    auth_skipped = 1i32
                                }
                                current_block = 13422570431586403309;
                            } else if (*stcb).asoc.auth_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_auth_chunk>() as libc::c_ulong
                                    || chk_length as libc::c_ulong
                                        > (::std::mem::size_of::<sctp_auth_chunk>()
                                            as libc::c_ulong)
                                            .wrapping_add(32u64)
                                {
                                    *offset = length;
                                    return stcb;
                                }
                                if got_auth == 1i32 {
                                    current_block = 13422570431586403309;
                                } else {
                                    got_auth = 1i32;
                                    if ch.is_null()
                                        || sctp_handle_auth(
                                            stcb,
                                            ch as *mut sctp_auth_chunk,
                                            m,
                                            *offset as uint32_t,
                                        ) != 0
                                    {
                                        *offset = length;
                                        return stcb;
                                    } else {
                                        (*stcb).asoc.authenticated = 1u8
                                    }
                                    current_block = 13422570431586403309;
                                }
                            }
                        }
                        _ => {}
                    }
                    match current_block {
                        13422570431586403309 => {}
                        _ => {
                            if (*ch).chunk_type as libc::c_int & 0x40i32 != 0 && !stcb.is_null() {
                                op_err = sctp_get_mbuf_for_msg(
                                    ::std::mem::size_of::<sctp_gen_error_cause>() as libc::c_uint,
                                    0i32,
                                    0x1i32,
                                    1i32,
                                    1i32,
                                );
                                if !op_err.is_null() {
                                    let mut cause = 0 as *mut sctp_gen_error_cause;
                                    let mut len = 0;
                                    len = if (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                        > (length - *offset) as uint32_t
                                    {
                                        (length - *offset) as uint32_t
                                    } else {
                                        (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                    } as libc::c_int;
                                    cause = (*op_err).m_hdr.mh_data as *mut sctp_gen_error_cause;
                                    (*cause).code = htons(0x6u16);
                                    (*cause).length =
                                        htons((len as libc::c_ulong).wrapping_add(
                                            ::std::mem::size_of::<sctp_gen_error_cause>()
                                                as libc::c_ulong,
                                        )
                                            as uint16_t);
                                    (*op_err).m_hdr.mh_len =
                                        ::std::mem::size_of::<sctp_gen_error_cause>()
                                            as libc::c_int;
                                    (*op_err).m_hdr.mh_next = m_copym(m, *offset, len, 0x1i32);
                                    if !(*op_err).m_hdr.mh_next.is_null() {
                                        sctp_queue_op_err(stcb, op_err);
                                    } else {
                                        m_freem(op_err);
                                    }
                                }
                            }
                            if (*ch).chunk_type as libc::c_int & 0x80i32 == 0i32 {
                                *offset = length;
                                return stcb;
                            }
                        }
                    }
                }
                6 => {
                    current_block = 4558417918157925232;
                    match current_block {
                        17766256343850198083 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_COMPLETE, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_complete(
                                    ch as *mut sctp_shutdown_complete_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        12601157616349825580 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT_ACK\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0 {
                                } else {
                                    *offset = length;
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1di32);
                                    }
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                ret = sctp_handle_init_ack(
                                    m,
                                    iphlen,
                                    *offset,
                                    src,
                                    dst,
                                    sh,
                                    ch as *mut sctp_init_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_no_unlock,
                                    vrf_id,
                                )
                            } else {
                                ret = -(1i32)
                            }
                            *offset = length;
                            if abort_no_unlock != 0 {
                                return 0 as *mut sctp_tcb;
                            }
                            if !stcb.is_null() && ret == 0i32 {
                                sctp_chunk_output((*stcb).sctp_ep, stcb, 3i32, 0i32);
                            }
                            return stcb;
                        }
                        16195856799229720522 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                if !stcb.is_null() {
                                    pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                }
                                return 0 as *mut sctp_tcb;
                            }
                            if chk_length > (65535i32 - 2048i32) as libc::c_uint {
                                op_err = sctp_generate_cause(
                                    0x4u16,
                                    b"\x00" as *const u8 as *mut libc::c_char,
                                );
                                sctp_abort_association(
                                    inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id, port,
                                );
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            sctp_handle_init(
                                m,
                                iphlen,
                                *offset,
                                src,
                                dst,
                                sh,
                                ch as *mut sctp_init_chunk,
                                inp,
                                stcb,
                                *netp,
                                &mut abort_no_unlock,
                                vrf_id,
                                port,
                            );
                            *offset = length;
                            if abort_no_unlock == 0 && !stcb.is_null() {
                                pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                            }
                            return 0 as *mut sctp_tcb;
                        }
                        6246479402878884953 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_ack(
                                    ch as *mut sctp_shutdown_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        4558417918157925232 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ABORT, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            *offset = length;
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if sctp_handle_abort(ch as *mut sctp_abort_chunk, stcb, *netp) != 0
                                {
                                    return 0 as *mut sctp_tcb;
                                } else {
                                    return stcb;
                                }
                            } else {
                                return 0 as *mut sctp_tcb;
                            }
                        }
                        9379646460352968115 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ECHO, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && (*stcb).asoc.total_output_queue_size > 0u32 {
                                current_block = 15201865807353435331;
                            } else if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                current_block = 15767785092075175044;
                            } else {
                                current_block = 15201865807353435331;
                            }
                            match current_block {
                                15201865807353435331 => {
                                    if stcb.is_null()
                                        && (!((*inp).sctp_flags & 0x8u32 != 0u32)
                                            || (*inp).sctp_flags & 0x1u32 == 0
                                                && (*(*inp).sctp_socket).so_qlen as libc::c_int
                                                    >= (*(*inp).sctp_socket).so_qlimit
                                                        as libc::c_int)
                                    {
                                        if (*inp).sctp_flags & 0x2u32 != 0
                                            && system_base_info
                                                .sctpsysctl
                                                .sctp_abort_if_one_2_one_hits_limit
                                                != 0
                                        {
                                            op_err = sctp_generate_cause(
                                                0x4u16,
                                                b"\x00" as *const u8 as *mut libc::c_char,
                                            );
                                            sctp_abort_association(
                                                inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id,
                                                port,
                                            );
                                        }
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    } else {
                                        let mut linp = 0 as *mut sctp_inpcb;
                                        if !stcb.is_null() {
                                            linp = 0 as *mut sctp_inpcb
                                        } else {
                                            linp = inp
                                        }
                                        if !linp.is_null() {
                                            pthread_mutex_lock(&mut (*linp).inp_create_mtx);
                                            if (*inp).sctp_flags & 0x10000000u32 != 0
                                                || (*inp).sctp_flags & 0x20000000u32 != 0
                                            {
                                                pthread_mutex_unlock(&mut (*linp).inp_create_mtx);
                                                current_block = 15767785092075175044;
                                            } else {
                                                current_block = 2358125959230175008;
                                            }
                                        } else {
                                            current_block = 2358125959230175008;
                                        }
                                        match current_block {
                                            15767785092075175044 => {}
                                            _ => {
                                                let mut ret_buf = 0 as *mut mbuf;
                                                if !netp.is_null() {
                                                    let mut locked_stcb = 0 as *mut sctp_tcb;
                                                    locked_stcb = stcb;
                                                    ret_buf = sctp_handle_cookie_echo(
                                                        m,
                                                        iphlen,
                                                        *offset,
                                                        src,
                                                        dst,
                                                        sh,
                                                        ch as *mut sctp_cookie_echo_chunk,
                                                        &mut inp,
                                                        &mut stcb,
                                                        netp,
                                                        auth_skipped,
                                                        auth_offset,
                                                        auth_len,
                                                        &mut locked_stcb,
                                                        vrf_id,
                                                        port,
                                                    );
                                                    if !locked_stcb.is_null() && locked_stcb != stcb
                                                    {
                                                        pthread_mutex_unlock(
                                                            &mut (*locked_stcb).tcb_mtx,
                                                        );
                                                    }
                                                    !stcb.is_null();
                                                } else {
                                                    ret_buf = 0 as *mut mbuf
                                                }
                                                if !linp.is_null() {
                                                    pthread_mutex_unlock(
                                                        &mut (*linp).inp_create_mtx,
                                                    );
                                                }
                                                if ret_buf.is_null() {
                                                    if !stcb.is_null() {
                                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                                    }
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"GAK, null buffer\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    *offset = length;
                                                    return 0 as *mut sctp_tcb;
                                                }
                                                if auth_skipped != 0 {
                                                    got_auth = 1i32;
                                                    auth_skipped = 0i32
                                                }
                                                if !(*stcb).asoc.sent_queue.tqh_first.is_null() {
                                                    let mut chk = 0 as *mut sctp_tmit_chunk;
                                                    chk = (*stcb).asoc.sent_queue.tqh_first;
                                                    sctp_timer_start(
                                                        1i32,
                                                        (*stcb).sctp_ep,
                                                        stcb,
                                                        (*chk).whoTo,
                                                    );
                                                }
                                                current_block = 13422570431586403309;
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                            match current_block {
                                13422570431586403309 => {}
                                _ => {
                                    if !stcb.is_null() {
                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                    }
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                        }
                        10582330624169799780 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_PACKET_DROPPED\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_pktdrop_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !ch.is_null()
                                && !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                            {
                                if (*stcb).asoc.pktdrop_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_packet_dropped(
                                        ch as *mut sctp_pktdrop_chunk,
                                        stcb,
                                        *netp,
                                        if chk_length > contiguous {
                                            contiguous
                                        } else {
                                            chk_length
                                        },
                                    );
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13268550889959046632 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_STREAM_RESET\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || ch.is_null()
                                || (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_stream_reset_tsn_req>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.reconfig_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if sctp_handle_stream_reset(stcb, m, *offset, ch) != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                                current_block = 13422570431586403309;
                            }
                        }
                        13497718421940148126 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_FWD_TSN\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_forward_tsn_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.prsctp_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    let mut abort_flag_0 = 0i32;
                                    *fwd_tsn_seen = 1i32;
                                    if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1fi32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    (*stcb).asoc.last_data_chunk_from =
                                        (*stcb).asoc.last_control_chunk_from;
                                    sctp_handle_forward_tsn(
                                        stcb,
                                        ch as *mut sctp_forward_tsn_chunk,
                                        &mut abort_flag_0,
                                        m,
                                        *offset,
                                    );
                                    if abort_flag_0 != 0 {
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13226217046118304493 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_asconf_ack_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    if system_base_info.sctpsysctl.sctp_logging_level & 0x2000000u32
                                        != 0
                                    {
                                        sctp_misc_ints(
                                            120u8,
                                            (*stcb).asoc.overall_error_count,
                                            0u32,
                                            0x10000000u32,
                                            5531u32,
                                        );
                                    }
                                    (*stcb).asoc.overall_error_count = 0u32;
                                    sctp_handle_asconf_ack(
                                        m,
                                        *offset,
                                        ch as *mut sctp_asconf_ack_chunk,
                                        stcb,
                                        *netp,
                                        &mut abort_no_unlock,
                                    );
                                    if abort_no_unlock != 0 {
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        11399179239179359665 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_asconf(
                                        m,
                                        *offset as libc::c_uint,
                                        src,
                                        ch as *mut sctp_asconf_chunk,
                                        stcb,
                                        (asconf_cnt == 0i32) as libc::c_int,
                                    );
                                    asconf_cnt += 1;
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        3371148184269687219 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_CWR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cwr_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_cwr(ch as *mut sctp_cwr_chunk, stcb, *netp);
                                current_block = 13422570431586403309;
                            }
                        }
                        13594799726619700391 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_ECHO\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_ecne_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_echo(ch as *mut sctp_ecne_chunk, stcb);
                                ecne_seen = 1i32;
                                current_block = 13422570431586403309;
                            }
                        }
                        2781125740367032387 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cookie_ack_chunk>()
                                        as libc::c_ulong
                            {
                                return stcb;
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !(!stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0) {
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1ei32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                }
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_cookie_ack(
                                    ch as *mut sctp_cookie_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        17092723434217905016 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_OP_ERR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                                && sctp_handle_error(ch, stcb, *netp, contiguous) < 0i32
                            {
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            current_block = 13422570431586403309;
                        }
                        6770586402544785651 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_shutdown_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                let mut abort_flag = 0i32;
                                sctp_handle_shutdown(
                                    ch as *mut sctp_shutdown_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_flag,
                                );
                                if abort_flag != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            current_block = 13422570431586403309;
                        }
                        12945290292467802513 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_heartbeat_chunk>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvheartbeatack,
                                1u32,
                            );
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_heartbeat_ack(
                                    ch as *mut sctp_heartbeat_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        5491205026464363454 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                ::std::intrinsics::atomic_xadd(
                                    &mut system_base_info.sctpstat.sctps_recvheartbeat,
                                    1u32,
                                );
                                sctp_send_heartbeat_ack(
                                    stcb,
                                    m,
                                    *offset,
                                    chk_length as libc::c_int,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        7940804887512848672 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"%s\n\x00" as *const u8 as *const libc::c_char,
                                        if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                            b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                        } else {
                                            b"SCTP_NR_SACK\x00" as *const u8 as *const libc::c_char
                                        },
                                    );
                                }
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvsacks,
                                1u32,
                            );
                            if stcb.is_null() {
                                if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0 {
                                    if system_base_info.debug_printf.is_some() {
                                        system_base_info
                                            .debug_printf
                                            .expect("non-null function pointer")(
                                            b"No stcb when processing %s chunk\n\x00" as *const u8
                                                as *const libc::c_char,
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                            } else {
                                                b"SCTP_NR_SACK\x00" as *const u8
                                                    as *const libc::c_char
                                            },
                                        );
                                    }
                                }
                                current_block = 13422570431586403309;
                            } else {
                                if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                    if (chk_length as libc::c_ulong)
                                        < ::std::mem::size_of::<sctp_sack_chunk>() as libc::c_ulong
                                    {
                                        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32
                                            != 0
                                        {
                                            if system_base_info.debug_printf.is_some() {
                                                system_base_info
                                                    .debug_printf
                                                    .expect("non-null function pointer")(
                                                    b"Bad size on SACK chunk, too small\n\x00"
                                                        as *const u8
                                                        as *const libc::c_char,
                                                );
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    } else {
                                        current_block = 17937968408868551711;
                                    }
                                } else if (*stcb).asoc.nrsack_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_nr_sack_chunk>() as libc::c_ulong
                                {
                                    if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0
                                    {
                                        if system_base_info.debug_printf.is_some() {
                                            system_base_info
                                                .debug_printf
                                                .expect("non-null function pointer")(
                                                b"Bad size on NR_SACK chunk, too small\n\x00"
                                                    as *const u8
                                                    as *const libc::c_char,
                                            );
                                        }
                                    }
                                    current_block = 13422570431586403309;
                                } else {
                                    current_block = 17937968408868551711;
                                }
                                match current_block {
                                    6765806975593869225 => {}
                                    13422570431586403309 => {}
                                    _ => {
                                        if !((*stcb).asoc.state & 0x7fi32 == 0x40i32) {
                                            let mut a_rwnd = 0;
                                            let mut cum_ack = 0;
                                            let mut num_seg = 0;
                                            let mut num_nr_seg = 0;
                                            let mut num_dup = 0;
                                            let mut flags = 0;
                                            let mut offset_seg = 0;
                                            let mut offset_dup = 0;
                                            flags = (*ch).chunk_flags;
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                let mut sack = 0 as *mut sctp_sack_chunk;
                                                sack = ch as *mut sctp_sack_chunk;
                                                cum_ack = ntohl((*sack).sack.cum_tsn_ack);
                                                num_seg = ntohs((*sack).sack.num_gap_ack_blks);
                                                num_nr_seg = 0u16;
                                                num_dup = ntohs((*sack).sack.num_dup_tsns);
                                                a_rwnd = ntohl((*sack).sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_sack_chunk>()
                                                        as
                                                        libc::c_ulong).wrapping_add((num_seg
                                                                                         as
                                                                                         libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                         as
                                                                                                                         libc::c_ulong)).wrapping_add((num_dup
                                                                                                                                                           as
                                                                                                                                                           libc::c_ulong).wrapping_mul(::std::mem::size_of::<uint32_t>()
                                                                                                                                                                                           as
                                                                                                                                                                                           libc::c_ulong))
                                                       !=
                                                       chk_length as
                                                           libc::c_ulong {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                           &
                                                           0x1000000u32 !=
                                                           0 {
                                                        if system_base_info.debug_printf.is_some()
                                                           {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"Bad size of SACK chunk\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char);
                                                        }
                                                    }
                                                    current_block =
                                                        13422570431586403309;
                                                } else {
                                                    offset_seg =
                                                        (*offset as
                                                             libc::c_ulong).wrapping_add(::std::mem::size_of::<sctp_sack_chunk>()
                                                                                             as
                                                                                             libc::c_ulong)
                                                            as libc::c_int;
                                                    offset_dup =
                                                        (offset_seg as
                                                             libc::c_ulong).wrapping_add((num_seg
                                                                                              as
                                                                                              libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                              as
                                                                                                                              libc::c_ulong))
                                                            as libc::c_int;
                                                    current_block =
                                                        8752412851861032177;
                                                }
                                            } else {
                                                let mut nr_sack = 0 as *mut sctp_nr_sack_chunk;
                                                nr_sack = ch as *mut sctp_nr_sack_chunk;
                                                cum_ack = ntohl((*nr_sack).nr_sack.cum_tsn_ack);
                                                num_seg =
                                                    ntohs((*nr_sack).nr_sack.num_gap_ack_blks);
                                                num_nr_seg =
                                                    ntohs((*nr_sack).nr_sack.num_nr_gap_ack_blks);
                                                num_dup = ntohs((*nr_sack).nr_sack.num_dup_tsns);
                                                a_rwnd = ntohl((*nr_sack).nr_sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_nr_sack_chunk>()
                                                    as libc::c_ulong)
                                                    .wrapping_add(
                                                        ((num_seg as libc::c_int
                                                            + num_nr_seg as libc::c_int)
                                                            as libc::c_ulong)
                                                            .wrapping_mul(::std::mem::size_of::<
                                                                sctp_gap_ack_block,
                                                            >(
                                                            )
                                                                as libc::c_ulong),
                                                    )
                                                    .wrapping_add(
                                                        (num_dup as libc::c_ulong).wrapping_mul(
                                                            ::std::mem::size_of::<uint32_t>()
                                                                as libc::c_ulong,
                                                        ),
                                                    )
                                                    != chk_length as libc::c_ulong
                                                {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x1000000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"Bad size of NR_SACK chunk\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    current_block = 13422570431586403309;
                                                } else {
                                                    offset_seg = (*offset as libc::c_ulong)
                                                        .wrapping_add(::std::mem::size_of::<
                                                            sctp_nr_sack_chunk,
                                                        >(
                                                        )
                                                            as libc::c_ulong)
                                                        as libc::c_int;
                                                    offset_dup = (offset_seg as libc::c_ulong)
                                                        .wrapping_add(
                                                            ((num_seg as libc::c_int
                                                                + num_nr_seg as libc::c_int)
                                                                as libc::c_ulong)
                                                                .wrapping_mul(
                                                                    ::std::mem::size_of::<
                                                                        sctp_gap_ack_block,
                                                                    >(
                                                                    )
                                                                        as libc::c_ulong,
                                                                ),
                                                        )
                                                        as libc::c_int;
                                                    current_block = 8752412851861032177;
                                                }
                                            }
                                            match current_block {
                                                13422570431586403309 => {}
                                                _ => {
                                                    let mut abort_now = 0i32;
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"%s process cum_ack:%x num_seg:%d a_rwnd:%d\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char,
                                                                                                                              if (*ch).chunk_type
                                                                                                                                     as
                                                                                                                                     libc::c_int
                                                                                                                                     ==
                                                                                                                                     0x3i32
                                                                                                                                 {
                                                                                                                                  b"SCTP_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              } else {
                                                                                                                                  b"SCTP_NR_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              },
                                                                                                                              cum_ack,
                                                                                                                              num_seg
                                                                                                                                  as
                                                                                                                                  libc::c_int,
                                                                                                                              a_rwnd);
                                                        }
                                                    }
                                                    (*stcb).asoc.seen_a_sack_this_pkt = 1u8;
                                                    if (*stcb).asoc.pr_sctp_cnt == 0u32
                                                        && num_seg as libc::c_int == 0i32
                                                        && num_nr_seg as libc::c_int == 0i32
                                                        && (cum_ack < (*stcb).asoc.last_acked_seq
                                                            && (*stcb)
                                                                .asoc
                                                                .last_acked_seq
                                                                .wrapping_sub(cum_ack)
                                                                > (1u32) << 31i32
                                                            || cum_ack
                                                                > (*stcb).asoc.last_acked_seq
                                                                && cum_ack.wrapping_sub(
                                                                    (*stcb).asoc.last_acked_seq,
                                                                ) < (1u32) << 31i32
                                                            || cum_ack
                                                                == (*stcb).asoc.last_acked_seq)
                                                        && (*stcb).asoc.saw_sack_with_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && (*stcb).asoc.saw_sack_with_nr_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && !(*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                    {
                                                        sctp_express_handle_sack(
                                                            stcb,
                                                            cum_ack,
                                                            a_rwnd,
                                                            &mut abort_now,
                                                            ecne_seen,
                                                        );
                                                    } else if !netp.is_null() && !(*netp).is_null()
                                                    {
                                                        sctp_handle_sack(
                                                            m,
                                                            offset_seg,
                                                            offset_dup,
                                                            stcb,
                                                            num_seg,
                                                            num_nr_seg,
                                                            num_dup,
                                                            &mut abort_now,
                                                            flags,
                                                            cum_ack,
                                                            a_rwnd,
                                                            ecne_seen,
                                                        );
                                                    }
                                                    if abort_now != 0 {
                                                        *offset = length;
                                                        return 0 as *mut sctp_tcb;
                                                    }
                                                    if (*stcb).asoc.send_queue.tqh_first.is_null()
                                                        && (*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                        && (*stcb).asoc.stream_queue_cnt == 0u32
                                                    {
                                                        sctp_ulp_notify(
                                                            26u32,
                                                            stcb,
                                                            0u32,
                                                            0 as *mut libc::c_void,
                                                            0i32,
                                                        );
                                                    }
                                                }
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    }
                                }
                            }
                        }
                        2349180396633407496 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_AUTHENTICATION\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null() {
                                if auth_skipped == 0i32 {
                                    auth_offset = *offset as uint32_t;
                                    auth_len = chk_length;
                                    auth_skipped = 1i32
                                }
                                current_block = 13422570431586403309;
                            } else if (*stcb).asoc.auth_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_auth_chunk>() as libc::c_ulong
                                    || chk_length as libc::c_ulong
                                        > (::std::mem::size_of::<sctp_auth_chunk>()
                                            as libc::c_ulong)
                                            .wrapping_add(32u64)
                                {
                                    *offset = length;
                                    return stcb;
                                }
                                if got_auth == 1i32 {
                                    current_block = 13422570431586403309;
                                } else {
                                    got_auth = 1i32;
                                    if ch.is_null()
                                        || sctp_handle_auth(
                                            stcb,
                                            ch as *mut sctp_auth_chunk,
                                            m,
                                            *offset as uint32_t,
                                        ) != 0
                                    {
                                        *offset = length;
                                        return stcb;
                                    } else {
                                        (*stcb).asoc.authenticated = 1u8
                                    }
                                    current_block = 13422570431586403309;
                                }
                            }
                        }
                        _ => {}
                    }
                    match current_block {
                        13422570431586403309 => {}
                        _ => {
                            if (*ch).chunk_type as libc::c_int & 0x40i32 != 0 && !stcb.is_null() {
                                op_err = sctp_get_mbuf_for_msg(
                                    ::std::mem::size_of::<sctp_gen_error_cause>() as libc::c_uint,
                                    0i32,
                                    0x1i32,
                                    1i32,
                                    1i32,
                                );
                                if !op_err.is_null() {
                                    let mut cause = 0 as *mut sctp_gen_error_cause;
                                    let mut len = 0;
                                    len = if (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                        > (length - *offset) as uint32_t
                                    {
                                        (length - *offset) as uint32_t
                                    } else {
                                        (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                    } as libc::c_int;
                                    cause = (*op_err).m_hdr.mh_data as *mut sctp_gen_error_cause;
                                    (*cause).code = htons(0x6u16);
                                    (*cause).length =
                                        htons((len as libc::c_ulong).wrapping_add(
                                            ::std::mem::size_of::<sctp_gen_error_cause>()
                                                as libc::c_ulong,
                                        )
                                            as uint16_t);
                                    (*op_err).m_hdr.mh_len =
                                        ::std::mem::size_of::<sctp_gen_error_cause>()
                                            as libc::c_int;
                                    (*op_err).m_hdr.mh_next = m_copym(m, *offset, len, 0x1i32);
                                    if !(*op_err).m_hdr.mh_next.is_null() {
                                        sctp_queue_op_err(stcb, op_err);
                                    } else {
                                        m_freem(op_err);
                                    }
                                }
                            }
                            if (*ch).chunk_type as libc::c_int & 0x80i32 == 0i32 {
                                *offset = length;
                                return stcb;
                            }
                        }
                    }
                }
                7 => {
                    current_block = 6770586402544785651;
                    match current_block {
                        17766256343850198083 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_COMPLETE, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_complete(
                                    ch as *mut sctp_shutdown_complete_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        12601157616349825580 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT_ACK\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0 {
                                } else {
                                    *offset = length;
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1di32);
                                    }
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                ret = sctp_handle_init_ack(
                                    m,
                                    iphlen,
                                    *offset,
                                    src,
                                    dst,
                                    sh,
                                    ch as *mut sctp_init_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_no_unlock,
                                    vrf_id,
                                )
                            } else {
                                ret = -(1i32)
                            }
                            *offset = length;
                            if abort_no_unlock != 0 {
                                return 0 as *mut sctp_tcb;
                            }
                            if !stcb.is_null() && ret == 0i32 {
                                sctp_chunk_output((*stcb).sctp_ep, stcb, 3i32, 0i32);
                            }
                            return stcb;
                        }
                        16195856799229720522 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                if !stcb.is_null() {
                                    pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                }
                                return 0 as *mut sctp_tcb;
                            }
                            if chk_length > (65535i32 - 2048i32) as libc::c_uint {
                                op_err = sctp_generate_cause(
                                    0x4u16,
                                    b"\x00" as *const u8 as *mut libc::c_char,
                                );
                                sctp_abort_association(
                                    inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id, port,
                                );
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            sctp_handle_init(
                                m,
                                iphlen,
                                *offset,
                                src,
                                dst,
                                sh,
                                ch as *mut sctp_init_chunk,
                                inp,
                                stcb,
                                *netp,
                                &mut abort_no_unlock,
                                vrf_id,
                                port,
                            );
                            *offset = length;
                            if abort_no_unlock == 0 && !stcb.is_null() {
                                pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                            }
                            return 0 as *mut sctp_tcb;
                        }
                        6246479402878884953 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_ack(
                                    ch as *mut sctp_shutdown_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        4558417918157925232 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ABORT, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            *offset = length;
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if sctp_handle_abort(ch as *mut sctp_abort_chunk, stcb, *netp) != 0
                                {
                                    return 0 as *mut sctp_tcb;
                                } else {
                                    return stcb;
                                }
                            } else {
                                return 0 as *mut sctp_tcb;
                            }
                        }
                        9379646460352968115 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ECHO, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && (*stcb).asoc.total_output_queue_size > 0u32 {
                                current_block = 15201865807353435331;
                            } else if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                current_block = 15767785092075175044;
                            } else {
                                current_block = 15201865807353435331;
                            }
                            match current_block {
                                15201865807353435331 => {
                                    if stcb.is_null()
                                        && (!((*inp).sctp_flags & 0x8u32 != 0u32)
                                            || (*inp).sctp_flags & 0x1u32 == 0
                                                && (*(*inp).sctp_socket).so_qlen as libc::c_int
                                                    >= (*(*inp).sctp_socket).so_qlimit
                                                        as libc::c_int)
                                    {
                                        if (*inp).sctp_flags & 0x2u32 != 0
                                            && system_base_info
                                                .sctpsysctl
                                                .sctp_abort_if_one_2_one_hits_limit
                                                != 0
                                        {
                                            op_err = sctp_generate_cause(
                                                0x4u16,
                                                b"\x00" as *const u8 as *mut libc::c_char,
                                            );
                                            sctp_abort_association(
                                                inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id,
                                                port,
                                            );
                                        }
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    } else {
                                        let mut linp = 0 as *mut sctp_inpcb;
                                        if !stcb.is_null() {
                                            linp = 0 as *mut sctp_inpcb
                                        } else {
                                            linp = inp
                                        }
                                        if !linp.is_null() {
                                            pthread_mutex_lock(&mut (*linp).inp_create_mtx);
                                            if (*inp).sctp_flags & 0x10000000u32 != 0
                                                || (*inp).sctp_flags & 0x20000000u32 != 0
                                            {
                                                pthread_mutex_unlock(&mut (*linp).inp_create_mtx);
                                                current_block = 15767785092075175044;
                                            } else {
                                                current_block = 2358125959230175008;
                                            }
                                        } else {
                                            current_block = 2358125959230175008;
                                        }
                                        match current_block {
                                            15767785092075175044 => {}
                                            _ => {
                                                let mut ret_buf = 0 as *mut mbuf;
                                                if !netp.is_null() {
                                                    let mut locked_stcb = 0 as *mut sctp_tcb;
                                                    locked_stcb = stcb;
                                                    ret_buf = sctp_handle_cookie_echo(
                                                        m,
                                                        iphlen,
                                                        *offset,
                                                        src,
                                                        dst,
                                                        sh,
                                                        ch as *mut sctp_cookie_echo_chunk,
                                                        &mut inp,
                                                        &mut stcb,
                                                        netp,
                                                        auth_skipped,
                                                        auth_offset,
                                                        auth_len,
                                                        &mut locked_stcb,
                                                        vrf_id,
                                                        port,
                                                    );
                                                    if !locked_stcb.is_null() && locked_stcb != stcb
                                                    {
                                                        pthread_mutex_unlock(
                                                            &mut (*locked_stcb).tcb_mtx,
                                                        );
                                                    }
                                                    !stcb.is_null();
                                                } else {
                                                    ret_buf = 0 as *mut mbuf
                                                }
                                                if !linp.is_null() {
                                                    pthread_mutex_unlock(
                                                        &mut (*linp).inp_create_mtx,
                                                    );
                                                }
                                                if ret_buf.is_null() {
                                                    if !stcb.is_null() {
                                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                                    }
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"GAK, null buffer\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    *offset = length;
                                                    return 0 as *mut sctp_tcb;
                                                }
                                                if auth_skipped != 0 {
                                                    got_auth = 1i32;
                                                    auth_skipped = 0i32
                                                }
                                                if !(*stcb).asoc.sent_queue.tqh_first.is_null() {
                                                    let mut chk = 0 as *mut sctp_tmit_chunk;
                                                    chk = (*stcb).asoc.sent_queue.tqh_first;
                                                    sctp_timer_start(
                                                        1i32,
                                                        (*stcb).sctp_ep,
                                                        stcb,
                                                        (*chk).whoTo,
                                                    );
                                                }
                                                current_block = 13422570431586403309;
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                            match current_block {
                                13422570431586403309 => {}
                                _ => {
                                    if !stcb.is_null() {
                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                    }
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                        }
                        10582330624169799780 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_PACKET_DROPPED\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_pktdrop_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !ch.is_null()
                                && !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                            {
                                if (*stcb).asoc.pktdrop_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_packet_dropped(
                                        ch as *mut sctp_pktdrop_chunk,
                                        stcb,
                                        *netp,
                                        if chk_length > contiguous {
                                            contiguous
                                        } else {
                                            chk_length
                                        },
                                    );
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13268550889959046632 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_STREAM_RESET\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || ch.is_null()
                                || (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_stream_reset_tsn_req>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.reconfig_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if sctp_handle_stream_reset(stcb, m, *offset, ch) != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                                current_block = 13422570431586403309;
                            }
                        }
                        13497718421940148126 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_FWD_TSN\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_forward_tsn_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.prsctp_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    let mut abort_flag_0 = 0i32;
                                    *fwd_tsn_seen = 1i32;
                                    if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1fi32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    (*stcb).asoc.last_data_chunk_from =
                                        (*stcb).asoc.last_control_chunk_from;
                                    sctp_handle_forward_tsn(
                                        stcb,
                                        ch as *mut sctp_forward_tsn_chunk,
                                        &mut abort_flag_0,
                                        m,
                                        *offset,
                                    );
                                    if abort_flag_0 != 0 {
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13226217046118304493 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_asconf_ack_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    if system_base_info.sctpsysctl.sctp_logging_level & 0x2000000u32
                                        != 0
                                    {
                                        sctp_misc_ints(
                                            120u8,
                                            (*stcb).asoc.overall_error_count,
                                            0u32,
                                            0x10000000u32,
                                            5531u32,
                                        );
                                    }
                                    (*stcb).asoc.overall_error_count = 0u32;
                                    sctp_handle_asconf_ack(
                                        m,
                                        *offset,
                                        ch as *mut sctp_asconf_ack_chunk,
                                        stcb,
                                        *netp,
                                        &mut abort_no_unlock,
                                    );
                                    if abort_no_unlock != 0 {
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        11399179239179359665 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_asconf(
                                        m,
                                        *offset as libc::c_uint,
                                        src,
                                        ch as *mut sctp_asconf_chunk,
                                        stcb,
                                        (asconf_cnt == 0i32) as libc::c_int,
                                    );
                                    asconf_cnt += 1;
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        3371148184269687219 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_CWR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cwr_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_cwr(ch as *mut sctp_cwr_chunk, stcb, *netp);
                                current_block = 13422570431586403309;
                            }
                        }
                        13594799726619700391 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_ECHO\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_ecne_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_echo(ch as *mut sctp_ecne_chunk, stcb);
                                ecne_seen = 1i32;
                                current_block = 13422570431586403309;
                            }
                        }
                        2781125740367032387 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cookie_ack_chunk>()
                                        as libc::c_ulong
                            {
                                return stcb;
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !(!stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0) {
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1ei32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                }
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_cookie_ack(
                                    ch as *mut sctp_cookie_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        17092723434217905016 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_OP_ERR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                                && sctp_handle_error(ch, stcb, *netp, contiguous) < 0i32
                            {
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            current_block = 13422570431586403309;
                        }
                        6770586402544785651 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_shutdown_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                let mut abort_flag = 0i32;
                                sctp_handle_shutdown(
                                    ch as *mut sctp_shutdown_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_flag,
                                );
                                if abort_flag != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            current_block = 13422570431586403309;
                        }
                        12945290292467802513 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_heartbeat_chunk>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvheartbeatack,
                                1u32,
                            );
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_heartbeat_ack(
                                    ch as *mut sctp_heartbeat_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        5491205026464363454 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                ::std::intrinsics::atomic_xadd(
                                    &mut system_base_info.sctpstat.sctps_recvheartbeat,
                                    1u32,
                                );
                                sctp_send_heartbeat_ack(
                                    stcb,
                                    m,
                                    *offset,
                                    chk_length as libc::c_int,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        7940804887512848672 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"%s\n\x00" as *const u8 as *const libc::c_char,
                                        if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                            b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                        } else {
                                            b"SCTP_NR_SACK\x00" as *const u8 as *const libc::c_char
                                        },
                                    );
                                }
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvsacks,
                                1u32,
                            );
                            if stcb.is_null() {
                                if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0 {
                                    if system_base_info.debug_printf.is_some() {
                                        system_base_info
                                            .debug_printf
                                            .expect("non-null function pointer")(
                                            b"No stcb when processing %s chunk\n\x00" as *const u8
                                                as *const libc::c_char,
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                            } else {
                                                b"SCTP_NR_SACK\x00" as *const u8
                                                    as *const libc::c_char
                                            },
                                        );
                                    }
                                }
                                current_block = 13422570431586403309;
                            } else {
                                if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                    if (chk_length as libc::c_ulong)
                                        < ::std::mem::size_of::<sctp_sack_chunk>() as libc::c_ulong
                                    {
                                        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32
                                            != 0
                                        {
                                            if system_base_info.debug_printf.is_some() {
                                                system_base_info
                                                    .debug_printf
                                                    .expect("non-null function pointer")(
                                                    b"Bad size on SACK chunk, too small\n\x00"
                                                        as *const u8
                                                        as *const libc::c_char,
                                                );
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    } else {
                                        current_block = 17937968408868551711;
                                    }
                                } else if (*stcb).asoc.nrsack_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_nr_sack_chunk>() as libc::c_ulong
                                {
                                    if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0
                                    {
                                        if system_base_info.debug_printf.is_some() {
                                            system_base_info
                                                .debug_printf
                                                .expect("non-null function pointer")(
                                                b"Bad size on NR_SACK chunk, too small\n\x00"
                                                    as *const u8
                                                    as *const libc::c_char,
                                            );
                                        }
                                    }
                                    current_block = 13422570431586403309;
                                } else {
                                    current_block = 17937968408868551711;
                                }
                                match current_block {
                                    6765806975593869225 => {}
                                    13422570431586403309 => {}
                                    _ => {
                                        if !((*stcb).asoc.state & 0x7fi32 == 0x40i32) {
                                            let mut a_rwnd = 0;
                                            let mut cum_ack = 0;
                                            let mut num_seg = 0;
                                            let mut num_nr_seg = 0;
                                            let mut num_dup = 0;
                                            let mut flags = 0;
                                            let mut offset_seg = 0;
                                            let mut offset_dup = 0;
                                            flags = (*ch).chunk_flags;
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                let mut sack = 0 as *mut sctp_sack_chunk;
                                                sack = ch as *mut sctp_sack_chunk;
                                                cum_ack = ntohl((*sack).sack.cum_tsn_ack);
                                                num_seg = ntohs((*sack).sack.num_gap_ack_blks);
                                                num_nr_seg = 0u16;
                                                num_dup = ntohs((*sack).sack.num_dup_tsns);
                                                a_rwnd = ntohl((*sack).sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_sack_chunk>()
                                                        as
                                                        libc::c_ulong).wrapping_add((num_seg
                                                                                         as
                                                                                         libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                         as
                                                                                                                         libc::c_ulong)).wrapping_add((num_dup
                                                                                                                                                           as
                                                                                                                                                           libc::c_ulong).wrapping_mul(::std::mem::size_of::<uint32_t>()
                                                                                                                                                                                           as
                                                                                                                                                                                           libc::c_ulong))
                                                       !=
                                                       chk_length as
                                                           libc::c_ulong {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                           &
                                                           0x1000000u32 !=
                                                           0 {
                                                        if system_base_info.debug_printf.is_some()
                                                           {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"Bad size of SACK chunk\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char);
                                                        }
                                                    }
                                                    current_block =
                                                        13422570431586403309;
                                                } else {
                                                    offset_seg =
                                                        (*offset as
                                                             libc::c_ulong).wrapping_add(::std::mem::size_of::<sctp_sack_chunk>()
                                                                                             as
                                                                                             libc::c_ulong)
                                                            as libc::c_int;
                                                    offset_dup =
                                                        (offset_seg as
                                                             libc::c_ulong).wrapping_add((num_seg
                                                                                              as
                                                                                              libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                              as
                                                                                                                              libc::c_ulong))
                                                            as libc::c_int;
                                                    current_block =
                                                        8752412851861032177;
                                                }
                                            } else {
                                                let mut nr_sack = 0 as *mut sctp_nr_sack_chunk;
                                                nr_sack = ch as *mut sctp_nr_sack_chunk;
                                                cum_ack = ntohl((*nr_sack).nr_sack.cum_tsn_ack);
                                                num_seg =
                                                    ntohs((*nr_sack).nr_sack.num_gap_ack_blks);
                                                num_nr_seg =
                                                    ntohs((*nr_sack).nr_sack.num_nr_gap_ack_blks);
                                                num_dup = ntohs((*nr_sack).nr_sack.num_dup_tsns);
                                                a_rwnd = ntohl((*nr_sack).nr_sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_nr_sack_chunk>()
                                                    as libc::c_ulong)
                                                    .wrapping_add(
                                                        ((num_seg as libc::c_int
                                                            + num_nr_seg as libc::c_int)
                                                            as libc::c_ulong)
                                                            .wrapping_mul(::std::mem::size_of::<
                                                                sctp_gap_ack_block,
                                                            >(
                                                            )
                                                                as libc::c_ulong),
                                                    )
                                                    .wrapping_add(
                                                        (num_dup as libc::c_ulong).wrapping_mul(
                                                            ::std::mem::size_of::<uint32_t>()
                                                                as libc::c_ulong,
                                                        ),
                                                    )
                                                    != chk_length as libc::c_ulong
                                                {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x1000000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"Bad size of NR_SACK chunk\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    current_block = 13422570431586403309;
                                                } else {
                                                    offset_seg = (*offset as libc::c_ulong)
                                                        .wrapping_add(::std::mem::size_of::<
                                                            sctp_nr_sack_chunk,
                                                        >(
                                                        )
                                                            as libc::c_ulong)
                                                        as libc::c_int;
                                                    offset_dup = (offset_seg as libc::c_ulong)
                                                        .wrapping_add(
                                                            ((num_seg as libc::c_int
                                                                + num_nr_seg as libc::c_int)
                                                                as libc::c_ulong)
                                                                .wrapping_mul(
                                                                    ::std::mem::size_of::<
                                                                        sctp_gap_ack_block,
                                                                    >(
                                                                    )
                                                                        as libc::c_ulong,
                                                                ),
                                                        )
                                                        as libc::c_int;
                                                    current_block = 8752412851861032177;
                                                }
                                            }
                                            match current_block {
                                                13422570431586403309 => {}
                                                _ => {
                                                    let mut abort_now = 0i32;
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"%s process cum_ack:%x num_seg:%d a_rwnd:%d\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char,
                                                                                                                              if (*ch).chunk_type
                                                                                                                                     as
                                                                                                                                     libc::c_int
                                                                                                                                     ==
                                                                                                                                     0x3i32
                                                                                                                                 {
                                                                                                                                  b"SCTP_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              } else {
                                                                                                                                  b"SCTP_NR_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              },
                                                                                                                              cum_ack,
                                                                                                                              num_seg
                                                                                                                                  as
                                                                                                                                  libc::c_int,
                                                                                                                              a_rwnd);
                                                        }
                                                    }
                                                    (*stcb).asoc.seen_a_sack_this_pkt = 1u8;
                                                    if (*stcb).asoc.pr_sctp_cnt == 0u32
                                                        && num_seg as libc::c_int == 0i32
                                                        && num_nr_seg as libc::c_int == 0i32
                                                        && (cum_ack < (*stcb).asoc.last_acked_seq
                                                            && (*stcb)
                                                                .asoc
                                                                .last_acked_seq
                                                                .wrapping_sub(cum_ack)
                                                                > (1u32) << 31i32
                                                            || cum_ack
                                                                > (*stcb).asoc.last_acked_seq
                                                                && cum_ack.wrapping_sub(
                                                                    (*stcb).asoc.last_acked_seq,
                                                                ) < (1u32) << 31i32
                                                            || cum_ack
                                                                == (*stcb).asoc.last_acked_seq)
                                                        && (*stcb).asoc.saw_sack_with_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && (*stcb).asoc.saw_sack_with_nr_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && !(*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                    {
                                                        sctp_express_handle_sack(
                                                            stcb,
                                                            cum_ack,
                                                            a_rwnd,
                                                            &mut abort_now,
                                                            ecne_seen,
                                                        );
                                                    } else if !netp.is_null() && !(*netp).is_null()
                                                    {
                                                        sctp_handle_sack(
                                                            m,
                                                            offset_seg,
                                                            offset_dup,
                                                            stcb,
                                                            num_seg,
                                                            num_nr_seg,
                                                            num_dup,
                                                            &mut abort_now,
                                                            flags,
                                                            cum_ack,
                                                            a_rwnd,
                                                            ecne_seen,
                                                        );
                                                    }
                                                    if abort_now != 0 {
                                                        *offset = length;
                                                        return 0 as *mut sctp_tcb;
                                                    }
                                                    if (*stcb).asoc.send_queue.tqh_first.is_null()
                                                        && (*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                        && (*stcb).asoc.stream_queue_cnt == 0u32
                                                    {
                                                        sctp_ulp_notify(
                                                            26u32,
                                                            stcb,
                                                            0u32,
                                                            0 as *mut libc::c_void,
                                                            0i32,
                                                        );
                                                    }
                                                }
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    }
                                }
                            }
                        }
                        2349180396633407496 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_AUTHENTICATION\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null() {
                                if auth_skipped == 0i32 {
                                    auth_offset = *offset as uint32_t;
                                    auth_len = chk_length;
                                    auth_skipped = 1i32
                                }
                                current_block = 13422570431586403309;
                            } else if (*stcb).asoc.auth_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_auth_chunk>() as libc::c_ulong
                                    || chk_length as libc::c_ulong
                                        > (::std::mem::size_of::<sctp_auth_chunk>()
                                            as libc::c_ulong)
                                            .wrapping_add(32u64)
                                {
                                    *offset = length;
                                    return stcb;
                                }
                                if got_auth == 1i32 {
                                    current_block = 13422570431586403309;
                                } else {
                                    got_auth = 1i32;
                                    if ch.is_null()
                                        || sctp_handle_auth(
                                            stcb,
                                            ch as *mut sctp_auth_chunk,
                                            m,
                                            *offset as uint32_t,
                                        ) != 0
                                    {
                                        *offset = length;
                                        return stcb;
                                    } else {
                                        (*stcb).asoc.authenticated = 1u8
                                    }
                                    current_block = 13422570431586403309;
                                }
                            }
                        }
                        _ => {}
                    }
                    match current_block {
                        13422570431586403309 => {}
                        _ => {
                            if (*ch).chunk_type as libc::c_int & 0x40i32 != 0 && !stcb.is_null() {
                                op_err = sctp_get_mbuf_for_msg(
                                    ::std::mem::size_of::<sctp_gen_error_cause>() as libc::c_uint,
                                    0i32,
                                    0x1i32,
                                    1i32,
                                    1i32,
                                );
                                if !op_err.is_null() {
                                    let mut cause = 0 as *mut sctp_gen_error_cause;
                                    let mut len = 0;
                                    len = if (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                        > (length - *offset) as uint32_t
                                    {
                                        (length - *offset) as uint32_t
                                    } else {
                                        (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                    } as libc::c_int;
                                    cause = (*op_err).m_hdr.mh_data as *mut sctp_gen_error_cause;
                                    (*cause).code = htons(0x6u16);
                                    (*cause).length =
                                        htons((len as libc::c_ulong).wrapping_add(
                                            ::std::mem::size_of::<sctp_gen_error_cause>()
                                                as libc::c_ulong,
                                        )
                                            as uint16_t);
                                    (*op_err).m_hdr.mh_len =
                                        ::std::mem::size_of::<sctp_gen_error_cause>()
                                            as libc::c_int;
                                    (*op_err).m_hdr.mh_next = m_copym(m, *offset, len, 0x1i32);
                                    if !(*op_err).m_hdr.mh_next.is_null() {
                                        sctp_queue_op_err(stcb, op_err);
                                    } else {
                                        m_freem(op_err);
                                    }
                                }
                            }
                            if (*ch).chunk_type as libc::c_int & 0x80i32 == 0i32 {
                                *offset = length;
                                return stcb;
                            }
                        }
                    }
                }
                8 => {
                    current_block = 6246479402878884953;
                    match current_block {
                        17766256343850198083 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_COMPLETE, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_complete(
                                    ch as *mut sctp_shutdown_complete_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        12601157616349825580 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT_ACK\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0 {
                                } else {
                                    *offset = length;
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1di32);
                                    }
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                ret = sctp_handle_init_ack(
                                    m,
                                    iphlen,
                                    *offset,
                                    src,
                                    dst,
                                    sh,
                                    ch as *mut sctp_init_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_no_unlock,
                                    vrf_id,
                                )
                            } else {
                                ret = -(1i32)
                            }
                            *offset = length;
                            if abort_no_unlock != 0 {
                                return 0 as *mut sctp_tcb;
                            }
                            if !stcb.is_null() && ret == 0i32 {
                                sctp_chunk_output((*stcb).sctp_ep, stcb, 3i32, 0i32);
                            }
                            return stcb;
                        }
                        16195856799229720522 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                if !stcb.is_null() {
                                    pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                }
                                return 0 as *mut sctp_tcb;
                            }
                            if chk_length > (65535i32 - 2048i32) as libc::c_uint {
                                op_err = sctp_generate_cause(
                                    0x4u16,
                                    b"\x00" as *const u8 as *mut libc::c_char,
                                );
                                sctp_abort_association(
                                    inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id, port,
                                );
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            sctp_handle_init(
                                m,
                                iphlen,
                                *offset,
                                src,
                                dst,
                                sh,
                                ch as *mut sctp_init_chunk,
                                inp,
                                stcb,
                                *netp,
                                &mut abort_no_unlock,
                                vrf_id,
                                port,
                            );
                            *offset = length;
                            if abort_no_unlock == 0 && !stcb.is_null() {
                                pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                            }
                            return 0 as *mut sctp_tcb;
                        }
                        6246479402878884953 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_ack(
                                    ch as *mut sctp_shutdown_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        4558417918157925232 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ABORT, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            *offset = length;
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if sctp_handle_abort(ch as *mut sctp_abort_chunk, stcb, *netp) != 0
                                {
                                    return 0 as *mut sctp_tcb;
                                } else {
                                    return stcb;
                                }
                            } else {
                                return 0 as *mut sctp_tcb;
                            }
                        }
                        9379646460352968115 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ECHO, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && (*stcb).asoc.total_output_queue_size > 0u32 {
                                current_block = 15201865807353435331;
                            } else if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                current_block = 15767785092075175044;
                            } else {
                                current_block = 15201865807353435331;
                            }
                            match current_block {
                                15201865807353435331 => {
                                    if stcb.is_null()
                                        && (!((*inp).sctp_flags & 0x8u32 != 0u32)
                                            || (*inp).sctp_flags & 0x1u32 == 0
                                                && (*(*inp).sctp_socket).so_qlen as libc::c_int
                                                    >= (*(*inp).sctp_socket).so_qlimit
                                                        as libc::c_int)
                                    {
                                        if (*inp).sctp_flags & 0x2u32 != 0
                                            && system_base_info
                                                .sctpsysctl
                                                .sctp_abort_if_one_2_one_hits_limit
                                                != 0
                                        {
                                            op_err = sctp_generate_cause(
                                                0x4u16,
                                                b"\x00" as *const u8 as *mut libc::c_char,
                                            );
                                            sctp_abort_association(
                                                inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id,
                                                port,
                                            );
                                        }
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    } else {
                                        let mut linp = 0 as *mut sctp_inpcb;
                                        if !stcb.is_null() {
                                            linp = 0 as *mut sctp_inpcb
                                        } else {
                                            linp = inp
                                        }
                                        if !linp.is_null() {
                                            pthread_mutex_lock(&mut (*linp).inp_create_mtx);
                                            if (*inp).sctp_flags & 0x10000000u32 != 0
                                                || (*inp).sctp_flags & 0x20000000u32 != 0
                                            {
                                                pthread_mutex_unlock(&mut (*linp).inp_create_mtx);
                                                current_block = 15767785092075175044;
                                            } else {
                                                current_block = 2358125959230175008;
                                            }
                                        } else {
                                            current_block = 2358125959230175008;
                                        }
                                        match current_block {
                                            15767785092075175044 => {}
                                            _ => {
                                                let mut ret_buf = 0 as *mut mbuf;
                                                if !netp.is_null() {
                                                    let mut locked_stcb = 0 as *mut sctp_tcb;
                                                    locked_stcb = stcb;
                                                    ret_buf = sctp_handle_cookie_echo(
                                                        m,
                                                        iphlen,
                                                        *offset,
                                                        src,
                                                        dst,
                                                        sh,
                                                        ch as *mut sctp_cookie_echo_chunk,
                                                        &mut inp,
                                                        &mut stcb,
                                                        netp,
                                                        auth_skipped,
                                                        auth_offset,
                                                        auth_len,
                                                        &mut locked_stcb,
                                                        vrf_id,
                                                        port,
                                                    );
                                                    if !locked_stcb.is_null() && locked_stcb != stcb
                                                    {
                                                        pthread_mutex_unlock(
                                                            &mut (*locked_stcb).tcb_mtx,
                                                        );
                                                    }
                                                    !stcb.is_null();
                                                } else {
                                                    ret_buf = 0 as *mut mbuf
                                                }
                                                if !linp.is_null() {
                                                    pthread_mutex_unlock(
                                                        &mut (*linp).inp_create_mtx,
                                                    );
                                                }
                                                if ret_buf.is_null() {
                                                    if !stcb.is_null() {
                                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                                    }
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"GAK, null buffer\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    *offset = length;
                                                    return 0 as *mut sctp_tcb;
                                                }
                                                if auth_skipped != 0 {
                                                    got_auth = 1i32;
                                                    auth_skipped = 0i32
                                                }
                                                if !(*stcb).asoc.sent_queue.tqh_first.is_null() {
                                                    let mut chk = 0 as *mut sctp_tmit_chunk;
                                                    chk = (*stcb).asoc.sent_queue.tqh_first;
                                                    sctp_timer_start(
                                                        1i32,
                                                        (*stcb).sctp_ep,
                                                        stcb,
                                                        (*chk).whoTo,
                                                    );
                                                }
                                                current_block = 13422570431586403309;
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                            match current_block {
                                13422570431586403309 => {}
                                _ => {
                                    if !stcb.is_null() {
                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                    }
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                        }
                        10582330624169799780 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_PACKET_DROPPED\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_pktdrop_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !ch.is_null()
                                && !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                            {
                                if (*stcb).asoc.pktdrop_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_packet_dropped(
                                        ch as *mut sctp_pktdrop_chunk,
                                        stcb,
                                        *netp,
                                        if chk_length > contiguous {
                                            contiguous
                                        } else {
                                            chk_length
                                        },
                                    );
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13268550889959046632 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_STREAM_RESET\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || ch.is_null()
                                || (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_stream_reset_tsn_req>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.reconfig_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if sctp_handle_stream_reset(stcb, m, *offset, ch) != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                                current_block = 13422570431586403309;
                            }
                        }
                        13497718421940148126 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_FWD_TSN\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_forward_tsn_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.prsctp_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    let mut abort_flag_0 = 0i32;
                                    *fwd_tsn_seen = 1i32;
                                    if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1fi32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    (*stcb).asoc.last_data_chunk_from =
                                        (*stcb).asoc.last_control_chunk_from;
                                    sctp_handle_forward_tsn(
                                        stcb,
                                        ch as *mut sctp_forward_tsn_chunk,
                                        &mut abort_flag_0,
                                        m,
                                        *offset,
                                    );
                                    if abort_flag_0 != 0 {
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13226217046118304493 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_asconf_ack_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    if system_base_info.sctpsysctl.sctp_logging_level & 0x2000000u32
                                        != 0
                                    {
                                        sctp_misc_ints(
                                            120u8,
                                            (*stcb).asoc.overall_error_count,
                                            0u32,
                                            0x10000000u32,
                                            5531u32,
                                        );
                                    }
                                    (*stcb).asoc.overall_error_count = 0u32;
                                    sctp_handle_asconf_ack(
                                        m,
                                        *offset,
                                        ch as *mut sctp_asconf_ack_chunk,
                                        stcb,
                                        *netp,
                                        &mut abort_no_unlock,
                                    );
                                    if abort_no_unlock != 0 {
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        11399179239179359665 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_asconf(
                                        m,
                                        *offset as libc::c_uint,
                                        src,
                                        ch as *mut sctp_asconf_chunk,
                                        stcb,
                                        (asconf_cnt == 0i32) as libc::c_int,
                                    );
                                    asconf_cnt += 1;
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        3371148184269687219 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_CWR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cwr_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_cwr(ch as *mut sctp_cwr_chunk, stcb, *netp);
                                current_block = 13422570431586403309;
                            }
                        }
                        13594799726619700391 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_ECHO\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_ecne_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_echo(ch as *mut sctp_ecne_chunk, stcb);
                                ecne_seen = 1i32;
                                current_block = 13422570431586403309;
                            }
                        }
                        2781125740367032387 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cookie_ack_chunk>()
                                        as libc::c_ulong
                            {
                                return stcb;
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !(!stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0) {
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1ei32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                }
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_cookie_ack(
                                    ch as *mut sctp_cookie_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        17092723434217905016 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_OP_ERR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                                && sctp_handle_error(ch, stcb, *netp, contiguous) < 0i32
                            {
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            current_block = 13422570431586403309;
                        }
                        6770586402544785651 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_shutdown_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                let mut abort_flag = 0i32;
                                sctp_handle_shutdown(
                                    ch as *mut sctp_shutdown_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_flag,
                                );
                                if abort_flag != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            current_block = 13422570431586403309;
                        }
                        12945290292467802513 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_heartbeat_chunk>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvheartbeatack,
                                1u32,
                            );
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_heartbeat_ack(
                                    ch as *mut sctp_heartbeat_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        5491205026464363454 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                ::std::intrinsics::atomic_xadd(
                                    &mut system_base_info.sctpstat.sctps_recvheartbeat,
                                    1u32,
                                );
                                sctp_send_heartbeat_ack(
                                    stcb,
                                    m,
                                    *offset,
                                    chk_length as libc::c_int,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        7940804887512848672 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"%s\n\x00" as *const u8 as *const libc::c_char,
                                        if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                            b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                        } else {
                                            b"SCTP_NR_SACK\x00" as *const u8 as *const libc::c_char
                                        },
                                    );
                                }
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvsacks,
                                1u32,
                            );
                            if stcb.is_null() {
                                if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0 {
                                    if system_base_info.debug_printf.is_some() {
                                        system_base_info
                                            .debug_printf
                                            .expect("non-null function pointer")(
                                            b"No stcb when processing %s chunk\n\x00" as *const u8
                                                as *const libc::c_char,
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                            } else {
                                                b"SCTP_NR_SACK\x00" as *const u8
                                                    as *const libc::c_char
                                            },
                                        );
                                    }
                                }
                                current_block = 13422570431586403309;
                            } else {
                                if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                    if (chk_length as libc::c_ulong)
                                        < ::std::mem::size_of::<sctp_sack_chunk>() as libc::c_ulong
                                    {
                                        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32
                                            != 0
                                        {
                                            if system_base_info.debug_printf.is_some() {
                                                system_base_info
                                                    .debug_printf
                                                    .expect("non-null function pointer")(
                                                    b"Bad size on SACK chunk, too small\n\x00"
                                                        as *const u8
                                                        as *const libc::c_char,
                                                );
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    } else {
                                        current_block = 17937968408868551711;
                                    }
                                } else if (*stcb).asoc.nrsack_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_nr_sack_chunk>() as libc::c_ulong
                                {
                                    if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0
                                    {
                                        if system_base_info.debug_printf.is_some() {
                                            system_base_info
                                                .debug_printf
                                                .expect("non-null function pointer")(
                                                b"Bad size on NR_SACK chunk, too small\n\x00"
                                                    as *const u8
                                                    as *const libc::c_char,
                                            );
                                        }
                                    }
                                    current_block = 13422570431586403309;
                                } else {
                                    current_block = 17937968408868551711;
                                }
                                match current_block {
                                    6765806975593869225 => {}
                                    13422570431586403309 => {}
                                    _ => {
                                        if !((*stcb).asoc.state & 0x7fi32 == 0x40i32) {
                                            let mut a_rwnd = 0;
                                            let mut cum_ack = 0;
                                            let mut num_seg = 0;
                                            let mut num_nr_seg = 0;
                                            let mut num_dup = 0;
                                            let mut flags = 0;
                                            let mut offset_seg = 0;
                                            let mut offset_dup = 0;
                                            flags = (*ch).chunk_flags;
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                let mut sack = 0 as *mut sctp_sack_chunk;
                                                sack = ch as *mut sctp_sack_chunk;
                                                cum_ack = ntohl((*sack).sack.cum_tsn_ack);
                                                num_seg = ntohs((*sack).sack.num_gap_ack_blks);
                                                num_nr_seg = 0u16;
                                                num_dup = ntohs((*sack).sack.num_dup_tsns);
                                                a_rwnd = ntohl((*sack).sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_sack_chunk>()
                                                        as
                                                        libc::c_ulong).wrapping_add((num_seg
                                                                                         as
                                                                                         libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                         as
                                                                                                                         libc::c_ulong)).wrapping_add((num_dup
                                                                                                                                                           as
                                                                                                                                                           libc::c_ulong).wrapping_mul(::std::mem::size_of::<uint32_t>()
                                                                                                                                                                                           as
                                                                                                                                                                                           libc::c_ulong))
                                                       !=
                                                       chk_length as
                                                           libc::c_ulong {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                           &
                                                           0x1000000u32 !=
                                                           0 {
                                                        if system_base_info.debug_printf.is_some()
                                                           {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"Bad size of SACK chunk\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char);
                                                        }
                                                    }
                                                    current_block =
                                                        13422570431586403309;
                                                } else {
                                                    offset_seg =
                                                        (*offset as
                                                             libc::c_ulong).wrapping_add(::std::mem::size_of::<sctp_sack_chunk>()
                                                                                             as
                                                                                             libc::c_ulong)
                                                            as libc::c_int;
                                                    offset_dup =
                                                        (offset_seg as
                                                             libc::c_ulong).wrapping_add((num_seg
                                                                                              as
                                                                                              libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                              as
                                                                                                                              libc::c_ulong))
                                                            as libc::c_int;
                                                    current_block =
                                                        8752412851861032177;
                                                }
                                            } else {
                                                let mut nr_sack = 0 as *mut sctp_nr_sack_chunk;
                                                nr_sack = ch as *mut sctp_nr_sack_chunk;
                                                cum_ack = ntohl((*nr_sack).nr_sack.cum_tsn_ack);
                                                num_seg =
                                                    ntohs((*nr_sack).nr_sack.num_gap_ack_blks);
                                                num_nr_seg =
                                                    ntohs((*nr_sack).nr_sack.num_nr_gap_ack_blks);
                                                num_dup = ntohs((*nr_sack).nr_sack.num_dup_tsns);
                                                a_rwnd = ntohl((*nr_sack).nr_sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_nr_sack_chunk>()
                                                    as libc::c_ulong)
                                                    .wrapping_add(
                                                        ((num_seg as libc::c_int
                                                            + num_nr_seg as libc::c_int)
                                                            as libc::c_ulong)
                                                            .wrapping_mul(::std::mem::size_of::<
                                                                sctp_gap_ack_block,
                                                            >(
                                                            )
                                                                as libc::c_ulong),
                                                    )
                                                    .wrapping_add(
                                                        (num_dup as libc::c_ulong).wrapping_mul(
                                                            ::std::mem::size_of::<uint32_t>()
                                                                as libc::c_ulong,
                                                        ),
                                                    )
                                                    != chk_length as libc::c_ulong
                                                {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x1000000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"Bad size of NR_SACK chunk\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    current_block = 13422570431586403309;
                                                } else {
                                                    offset_seg = (*offset as libc::c_ulong)
                                                        .wrapping_add(::std::mem::size_of::<
                                                            sctp_nr_sack_chunk,
                                                        >(
                                                        )
                                                            as libc::c_ulong)
                                                        as libc::c_int;
                                                    offset_dup = (offset_seg as libc::c_ulong)
                                                        .wrapping_add(
                                                            ((num_seg as libc::c_int
                                                                + num_nr_seg as libc::c_int)
                                                                as libc::c_ulong)
                                                                .wrapping_mul(
                                                                    ::std::mem::size_of::<
                                                                        sctp_gap_ack_block,
                                                                    >(
                                                                    )
                                                                        as libc::c_ulong,
                                                                ),
                                                        )
                                                        as libc::c_int;
                                                    current_block = 8752412851861032177;
                                                }
                                            }
                                            match current_block {
                                                13422570431586403309 => {}
                                                _ => {
                                                    let mut abort_now = 0i32;
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"%s process cum_ack:%x num_seg:%d a_rwnd:%d\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char,
                                                                                                                              if (*ch).chunk_type
                                                                                                                                     as
                                                                                                                                     libc::c_int
                                                                                                                                     ==
                                                                                                                                     0x3i32
                                                                                                                                 {
                                                                                                                                  b"SCTP_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              } else {
                                                                                                                                  b"SCTP_NR_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              },
                                                                                                                              cum_ack,
                                                                                                                              num_seg
                                                                                                                                  as
                                                                                                                                  libc::c_int,
                                                                                                                              a_rwnd);
                                                        }
                                                    }
                                                    (*stcb).asoc.seen_a_sack_this_pkt = 1u8;
                                                    if (*stcb).asoc.pr_sctp_cnt == 0u32
                                                        && num_seg as libc::c_int == 0i32
                                                        && num_nr_seg as libc::c_int == 0i32
                                                        && (cum_ack < (*stcb).asoc.last_acked_seq
                                                            && (*stcb)
                                                                .asoc
                                                                .last_acked_seq
                                                                .wrapping_sub(cum_ack)
                                                                > (1u32) << 31i32
                                                            || cum_ack
                                                                > (*stcb).asoc.last_acked_seq
                                                                && cum_ack.wrapping_sub(
                                                                    (*stcb).asoc.last_acked_seq,
                                                                ) < (1u32) << 31i32
                                                            || cum_ack
                                                                == (*stcb).asoc.last_acked_seq)
                                                        && (*stcb).asoc.saw_sack_with_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && (*stcb).asoc.saw_sack_with_nr_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && !(*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                    {
                                                        sctp_express_handle_sack(
                                                            stcb,
                                                            cum_ack,
                                                            a_rwnd,
                                                            &mut abort_now,
                                                            ecne_seen,
                                                        );
                                                    } else if !netp.is_null() && !(*netp).is_null()
                                                    {
                                                        sctp_handle_sack(
                                                            m,
                                                            offset_seg,
                                                            offset_dup,
                                                            stcb,
                                                            num_seg,
                                                            num_nr_seg,
                                                            num_dup,
                                                            &mut abort_now,
                                                            flags,
                                                            cum_ack,
                                                            a_rwnd,
                                                            ecne_seen,
                                                        );
                                                    }
                                                    if abort_now != 0 {
                                                        *offset = length;
                                                        return 0 as *mut sctp_tcb;
                                                    }
                                                    if (*stcb).asoc.send_queue.tqh_first.is_null()
                                                        && (*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                        && (*stcb).asoc.stream_queue_cnt == 0u32
                                                    {
                                                        sctp_ulp_notify(
                                                            26u32,
                                                            stcb,
                                                            0u32,
                                                            0 as *mut libc::c_void,
                                                            0i32,
                                                        );
                                                    }
                                                }
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    }
                                }
                            }
                        }
                        2349180396633407496 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_AUTHENTICATION\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null() {
                                if auth_skipped == 0i32 {
                                    auth_offset = *offset as uint32_t;
                                    auth_len = chk_length;
                                    auth_skipped = 1i32
                                }
                                current_block = 13422570431586403309;
                            } else if (*stcb).asoc.auth_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_auth_chunk>() as libc::c_ulong
                                    || chk_length as libc::c_ulong
                                        > (::std::mem::size_of::<sctp_auth_chunk>()
                                            as libc::c_ulong)
                                            .wrapping_add(32u64)
                                {
                                    *offset = length;
                                    return stcb;
                                }
                                if got_auth == 1i32 {
                                    current_block = 13422570431586403309;
                                } else {
                                    got_auth = 1i32;
                                    if ch.is_null()
                                        || sctp_handle_auth(
                                            stcb,
                                            ch as *mut sctp_auth_chunk,
                                            m,
                                            *offset as uint32_t,
                                        ) != 0
                                    {
                                        *offset = length;
                                        return stcb;
                                    } else {
                                        (*stcb).asoc.authenticated = 1u8
                                    }
                                    current_block = 13422570431586403309;
                                }
                            }
                        }
                        _ => {}
                    }
                    match current_block {
                        13422570431586403309 => {}
                        _ => {
                            if (*ch).chunk_type as libc::c_int & 0x40i32 != 0 && !stcb.is_null() {
                                op_err = sctp_get_mbuf_for_msg(
                                    ::std::mem::size_of::<sctp_gen_error_cause>() as libc::c_uint,
                                    0i32,
                                    0x1i32,
                                    1i32,
                                    1i32,
                                );
                                if !op_err.is_null() {
                                    let mut cause = 0 as *mut sctp_gen_error_cause;
                                    let mut len = 0;
                                    len = if (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                        > (length - *offset) as uint32_t
                                    {
                                        (length - *offset) as uint32_t
                                    } else {
                                        (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                    } as libc::c_int;
                                    cause = (*op_err).m_hdr.mh_data as *mut sctp_gen_error_cause;
                                    (*cause).code = htons(0x6u16);
                                    (*cause).length =
                                        htons((len as libc::c_ulong).wrapping_add(
                                            ::std::mem::size_of::<sctp_gen_error_cause>()
                                                as libc::c_ulong,
                                        )
                                            as uint16_t);
                                    (*op_err).m_hdr.mh_len =
                                        ::std::mem::size_of::<sctp_gen_error_cause>()
                                            as libc::c_int;
                                    (*op_err).m_hdr.mh_next = m_copym(m, *offset, len, 0x1i32);
                                    if !(*op_err).m_hdr.mh_next.is_null() {
                                        sctp_queue_op_err(stcb, op_err);
                                    } else {
                                        m_freem(op_err);
                                    }
                                }
                            }
                            if (*ch).chunk_type as libc::c_int & 0x80i32 == 0i32 {
                                *offset = length;
                                return stcb;
                            }
                        }
                    }
                }
                9 => {
                    current_block = 17092723434217905016;
                    match current_block {
                        17766256343850198083 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_COMPLETE, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_complete(
                                    ch as *mut sctp_shutdown_complete_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        12601157616349825580 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT_ACK\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0 {
                                } else {
                                    *offset = length;
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1di32);
                                    }
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                ret = sctp_handle_init_ack(
                                    m,
                                    iphlen,
                                    *offset,
                                    src,
                                    dst,
                                    sh,
                                    ch as *mut sctp_init_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_no_unlock,
                                    vrf_id,
                                )
                            } else {
                                ret = -(1i32)
                            }
                            *offset = length;
                            if abort_no_unlock != 0 {
                                return 0 as *mut sctp_tcb;
                            }
                            if !stcb.is_null() && ret == 0i32 {
                                sctp_chunk_output((*stcb).sctp_ep, stcb, 3i32, 0i32);
                            }
                            return stcb;
                        }
                        16195856799229720522 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                if !stcb.is_null() {
                                    pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                }
                                return 0 as *mut sctp_tcb;
                            }
                            if chk_length > (65535i32 - 2048i32) as libc::c_uint {
                                op_err = sctp_generate_cause(
                                    0x4u16,
                                    b"\x00" as *const u8 as *mut libc::c_char,
                                );
                                sctp_abort_association(
                                    inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id, port,
                                );
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            sctp_handle_init(
                                m,
                                iphlen,
                                *offset,
                                src,
                                dst,
                                sh,
                                ch as *mut sctp_init_chunk,
                                inp,
                                stcb,
                                *netp,
                                &mut abort_no_unlock,
                                vrf_id,
                                port,
                            );
                            *offset = length;
                            if abort_no_unlock == 0 && !stcb.is_null() {
                                pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                            }
                            return 0 as *mut sctp_tcb;
                        }
                        6246479402878884953 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_ack(
                                    ch as *mut sctp_shutdown_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        4558417918157925232 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ABORT, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            *offset = length;
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if sctp_handle_abort(ch as *mut sctp_abort_chunk, stcb, *netp) != 0
                                {
                                    return 0 as *mut sctp_tcb;
                                } else {
                                    return stcb;
                                }
                            } else {
                                return 0 as *mut sctp_tcb;
                            }
                        }
                        9379646460352968115 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ECHO, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && (*stcb).asoc.total_output_queue_size > 0u32 {
                                current_block = 15201865807353435331;
                            } else if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                current_block = 15767785092075175044;
                            } else {
                                current_block = 15201865807353435331;
                            }
                            match current_block {
                                15201865807353435331 => {
                                    if stcb.is_null()
                                        && (!((*inp).sctp_flags & 0x8u32 != 0u32)
                                            || (*inp).sctp_flags & 0x1u32 == 0
                                                && (*(*inp).sctp_socket).so_qlen as libc::c_int
                                                    >= (*(*inp).sctp_socket).so_qlimit
                                                        as libc::c_int)
                                    {
                                        if (*inp).sctp_flags & 0x2u32 != 0
                                            && system_base_info
                                                .sctpsysctl
                                                .sctp_abort_if_one_2_one_hits_limit
                                                != 0
                                        {
                                            op_err = sctp_generate_cause(
                                                0x4u16,
                                                b"\x00" as *const u8 as *mut libc::c_char,
                                            );
                                            sctp_abort_association(
                                                inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id,
                                                port,
                                            );
                                        }
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    } else {
                                        let mut linp = 0 as *mut sctp_inpcb;
                                        if !stcb.is_null() {
                                            linp = 0 as *mut sctp_inpcb
                                        } else {
                                            linp = inp
                                        }
                                        if !linp.is_null() {
                                            pthread_mutex_lock(&mut (*linp).inp_create_mtx);
                                            if (*inp).sctp_flags & 0x10000000u32 != 0
                                                || (*inp).sctp_flags & 0x20000000u32 != 0
                                            {
                                                pthread_mutex_unlock(&mut (*linp).inp_create_mtx);
                                                current_block = 15767785092075175044;
                                            } else {
                                                current_block = 2358125959230175008;
                                            }
                                        } else {
                                            current_block = 2358125959230175008;
                                        }
                                        match current_block {
                                            15767785092075175044 => {}
                                            _ => {
                                                let mut ret_buf = 0 as *mut mbuf;
                                                if !netp.is_null() {
                                                    let mut locked_stcb = 0 as *mut sctp_tcb;
                                                    locked_stcb = stcb;
                                                    ret_buf = sctp_handle_cookie_echo(
                                                        m,
                                                        iphlen,
                                                        *offset,
                                                        src,
                                                        dst,
                                                        sh,
                                                        ch as *mut sctp_cookie_echo_chunk,
                                                        &mut inp,
                                                        &mut stcb,
                                                        netp,
                                                        auth_skipped,
                                                        auth_offset,
                                                        auth_len,
                                                        &mut locked_stcb,
                                                        vrf_id,
                                                        port,
                                                    );
                                                    if !locked_stcb.is_null() && locked_stcb != stcb
                                                    {
                                                        pthread_mutex_unlock(
                                                            &mut (*locked_stcb).tcb_mtx,
                                                        );
                                                    }
                                                    !stcb.is_null();
                                                } else {
                                                    ret_buf = 0 as *mut mbuf
                                                }
                                                if !linp.is_null() {
                                                    pthread_mutex_unlock(
                                                        &mut (*linp).inp_create_mtx,
                                                    );
                                                }
                                                if ret_buf.is_null() {
                                                    if !stcb.is_null() {
                                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                                    }
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"GAK, null buffer\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    *offset = length;
                                                    return 0 as *mut sctp_tcb;
                                                }
                                                if auth_skipped != 0 {
                                                    got_auth = 1i32;
                                                    auth_skipped = 0i32
                                                }
                                                if !(*stcb).asoc.sent_queue.tqh_first.is_null() {
                                                    let mut chk = 0 as *mut sctp_tmit_chunk;
                                                    chk = (*stcb).asoc.sent_queue.tqh_first;
                                                    sctp_timer_start(
                                                        1i32,
                                                        (*stcb).sctp_ep,
                                                        stcb,
                                                        (*chk).whoTo,
                                                    );
                                                }
                                                current_block = 13422570431586403309;
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                            match current_block {
                                13422570431586403309 => {}
                                _ => {
                                    if !stcb.is_null() {
                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                    }
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                        }
                        10582330624169799780 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_PACKET_DROPPED\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_pktdrop_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !ch.is_null()
                                && !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                            {
                                if (*stcb).asoc.pktdrop_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_packet_dropped(
                                        ch as *mut sctp_pktdrop_chunk,
                                        stcb,
                                        *netp,
                                        if chk_length > contiguous {
                                            contiguous
                                        } else {
                                            chk_length
                                        },
                                    );
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13268550889959046632 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_STREAM_RESET\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || ch.is_null()
                                || (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_stream_reset_tsn_req>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.reconfig_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if sctp_handle_stream_reset(stcb, m, *offset, ch) != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                                current_block = 13422570431586403309;
                            }
                        }
                        13497718421940148126 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_FWD_TSN\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_forward_tsn_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.prsctp_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    let mut abort_flag_0 = 0i32;
                                    *fwd_tsn_seen = 1i32;
                                    if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1fi32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    (*stcb).asoc.last_data_chunk_from =
                                        (*stcb).asoc.last_control_chunk_from;
                                    sctp_handle_forward_tsn(
                                        stcb,
                                        ch as *mut sctp_forward_tsn_chunk,
                                        &mut abort_flag_0,
                                        m,
                                        *offset,
                                    );
                                    if abort_flag_0 != 0 {
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13226217046118304493 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_asconf_ack_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    if system_base_info.sctpsysctl.sctp_logging_level & 0x2000000u32
                                        != 0
                                    {
                                        sctp_misc_ints(
                                            120u8,
                                            (*stcb).asoc.overall_error_count,
                                            0u32,
                                            0x10000000u32,
                                            5531u32,
                                        );
                                    }
                                    (*stcb).asoc.overall_error_count = 0u32;
                                    sctp_handle_asconf_ack(
                                        m,
                                        *offset,
                                        ch as *mut sctp_asconf_ack_chunk,
                                        stcb,
                                        *netp,
                                        &mut abort_no_unlock,
                                    );
                                    if abort_no_unlock != 0 {
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        11399179239179359665 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_asconf(
                                        m,
                                        *offset as libc::c_uint,
                                        src,
                                        ch as *mut sctp_asconf_chunk,
                                        stcb,
                                        (asconf_cnt == 0i32) as libc::c_int,
                                    );
                                    asconf_cnt += 1;
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        3371148184269687219 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_CWR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cwr_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_cwr(ch as *mut sctp_cwr_chunk, stcb, *netp);
                                current_block = 13422570431586403309;
                            }
                        }
                        13594799726619700391 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_ECHO\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_ecne_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_echo(ch as *mut sctp_ecne_chunk, stcb);
                                ecne_seen = 1i32;
                                current_block = 13422570431586403309;
                            }
                        }
                        2781125740367032387 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cookie_ack_chunk>()
                                        as libc::c_ulong
                            {
                                return stcb;
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !(!stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0) {
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1ei32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                }
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_cookie_ack(
                                    ch as *mut sctp_cookie_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        17092723434217905016 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_OP_ERR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                                && sctp_handle_error(ch, stcb, *netp, contiguous) < 0i32
                            {
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            current_block = 13422570431586403309;
                        }
                        6770586402544785651 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_shutdown_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                let mut abort_flag = 0i32;
                                sctp_handle_shutdown(
                                    ch as *mut sctp_shutdown_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_flag,
                                );
                                if abort_flag != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            current_block = 13422570431586403309;
                        }
                        12945290292467802513 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_heartbeat_chunk>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvheartbeatack,
                                1u32,
                            );
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_heartbeat_ack(
                                    ch as *mut sctp_heartbeat_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        5491205026464363454 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                ::std::intrinsics::atomic_xadd(
                                    &mut system_base_info.sctpstat.sctps_recvheartbeat,
                                    1u32,
                                );
                                sctp_send_heartbeat_ack(
                                    stcb,
                                    m,
                                    *offset,
                                    chk_length as libc::c_int,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        7940804887512848672 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"%s\n\x00" as *const u8 as *const libc::c_char,
                                        if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                            b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                        } else {
                                            b"SCTP_NR_SACK\x00" as *const u8 as *const libc::c_char
                                        },
                                    );
                                }
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvsacks,
                                1u32,
                            );
                            if stcb.is_null() {
                                if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0 {
                                    if system_base_info.debug_printf.is_some() {
                                        system_base_info
                                            .debug_printf
                                            .expect("non-null function pointer")(
                                            b"No stcb when processing %s chunk\n\x00" as *const u8
                                                as *const libc::c_char,
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                            } else {
                                                b"SCTP_NR_SACK\x00" as *const u8
                                                    as *const libc::c_char
                                            },
                                        );
                                    }
                                }
                                current_block = 13422570431586403309;
                            } else {
                                if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                    if (chk_length as libc::c_ulong)
                                        < ::std::mem::size_of::<sctp_sack_chunk>() as libc::c_ulong
                                    {
                                        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32
                                            != 0
                                        {
                                            if system_base_info.debug_printf.is_some() {
                                                system_base_info
                                                    .debug_printf
                                                    .expect("non-null function pointer")(
                                                    b"Bad size on SACK chunk, too small\n\x00"
                                                        as *const u8
                                                        as *const libc::c_char,
                                                );
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    } else {
                                        current_block = 17937968408868551711;
                                    }
                                } else if (*stcb).asoc.nrsack_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_nr_sack_chunk>() as libc::c_ulong
                                {
                                    if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0
                                    {
                                        if system_base_info.debug_printf.is_some() {
                                            system_base_info
                                                .debug_printf
                                                .expect("non-null function pointer")(
                                                b"Bad size on NR_SACK chunk, too small\n\x00"
                                                    as *const u8
                                                    as *const libc::c_char,
                                            );
                                        }
                                    }
                                    current_block = 13422570431586403309;
                                } else {
                                    current_block = 17937968408868551711;
                                }
                                match current_block {
                                    6765806975593869225 => {}
                                    13422570431586403309 => {}
                                    _ => {
                                        if !((*stcb).asoc.state & 0x7fi32 == 0x40i32) {
                                            let mut a_rwnd = 0;
                                            let mut cum_ack = 0;
                                            let mut num_seg = 0;
                                            let mut num_nr_seg = 0;
                                            let mut num_dup = 0;
                                            let mut flags = 0;
                                            let mut offset_seg = 0;
                                            let mut offset_dup = 0;
                                            flags = (*ch).chunk_flags;
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                let mut sack = 0 as *mut sctp_sack_chunk;
                                                sack = ch as *mut sctp_sack_chunk;
                                                cum_ack = ntohl((*sack).sack.cum_tsn_ack);
                                                num_seg = ntohs((*sack).sack.num_gap_ack_blks);
                                                num_nr_seg = 0u16;
                                                num_dup = ntohs((*sack).sack.num_dup_tsns);
                                                a_rwnd = ntohl((*sack).sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_sack_chunk>()
                                                        as
                                                        libc::c_ulong).wrapping_add((num_seg
                                                                                         as
                                                                                         libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                         as
                                                                                                                         libc::c_ulong)).wrapping_add((num_dup
                                                                                                                                                           as
                                                                                                                                                           libc::c_ulong).wrapping_mul(::std::mem::size_of::<uint32_t>()
                                                                                                                                                                                           as
                                                                                                                                                                                           libc::c_ulong))
                                                       !=
                                                       chk_length as
                                                           libc::c_ulong {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                           &
                                                           0x1000000u32 !=
                                                           0 {
                                                        if system_base_info.debug_printf.is_some()
                                                           {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"Bad size of SACK chunk\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char);
                                                        }
                                                    }
                                                    current_block =
                                                        13422570431586403309;
                                                } else {
                                                    offset_seg =
                                                        (*offset as
                                                             libc::c_ulong).wrapping_add(::std::mem::size_of::<sctp_sack_chunk>()
                                                                                             as
                                                                                             libc::c_ulong)
                                                            as libc::c_int;
                                                    offset_dup =
                                                        (offset_seg as
                                                             libc::c_ulong).wrapping_add((num_seg
                                                                                              as
                                                                                              libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                              as
                                                                                                                              libc::c_ulong))
                                                            as libc::c_int;
                                                    current_block =
                                                        8752412851861032177;
                                                }
                                            } else {
                                                let mut nr_sack = 0 as *mut sctp_nr_sack_chunk;
                                                nr_sack = ch as *mut sctp_nr_sack_chunk;
                                                cum_ack = ntohl((*nr_sack).nr_sack.cum_tsn_ack);
                                                num_seg =
                                                    ntohs((*nr_sack).nr_sack.num_gap_ack_blks);
                                                num_nr_seg =
                                                    ntohs((*nr_sack).nr_sack.num_nr_gap_ack_blks);
                                                num_dup = ntohs((*nr_sack).nr_sack.num_dup_tsns);
                                                a_rwnd = ntohl((*nr_sack).nr_sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_nr_sack_chunk>()
                                                    as libc::c_ulong)
                                                    .wrapping_add(
                                                        ((num_seg as libc::c_int
                                                            + num_nr_seg as libc::c_int)
                                                            as libc::c_ulong)
                                                            .wrapping_mul(::std::mem::size_of::<
                                                                sctp_gap_ack_block,
                                                            >(
                                                            )
                                                                as libc::c_ulong),
                                                    )
                                                    .wrapping_add(
                                                        (num_dup as libc::c_ulong).wrapping_mul(
                                                            ::std::mem::size_of::<uint32_t>()
                                                                as libc::c_ulong,
                                                        ),
                                                    )
                                                    != chk_length as libc::c_ulong
                                                {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x1000000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"Bad size of NR_SACK chunk\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    current_block = 13422570431586403309;
                                                } else {
                                                    offset_seg = (*offset as libc::c_ulong)
                                                        .wrapping_add(::std::mem::size_of::<
                                                            sctp_nr_sack_chunk,
                                                        >(
                                                        )
                                                            as libc::c_ulong)
                                                        as libc::c_int;
                                                    offset_dup = (offset_seg as libc::c_ulong)
                                                        .wrapping_add(
                                                            ((num_seg as libc::c_int
                                                                + num_nr_seg as libc::c_int)
                                                                as libc::c_ulong)
                                                                .wrapping_mul(
                                                                    ::std::mem::size_of::<
                                                                        sctp_gap_ack_block,
                                                                    >(
                                                                    )
                                                                        as libc::c_ulong,
                                                                ),
                                                        )
                                                        as libc::c_int;
                                                    current_block = 8752412851861032177;
                                                }
                                            }
                                            match current_block {
                                                13422570431586403309 => {}
                                                _ => {
                                                    let mut abort_now = 0i32;
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"%s process cum_ack:%x num_seg:%d a_rwnd:%d\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char,
                                                                                                                              if (*ch).chunk_type
                                                                                                                                     as
                                                                                                                                     libc::c_int
                                                                                                                                     ==
                                                                                                                                     0x3i32
                                                                                                                                 {
                                                                                                                                  b"SCTP_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              } else {
                                                                                                                                  b"SCTP_NR_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              },
                                                                                                                              cum_ack,
                                                                                                                              num_seg
                                                                                                                                  as
                                                                                                                                  libc::c_int,
                                                                                                                              a_rwnd);
                                                        }
                                                    }
                                                    (*stcb).asoc.seen_a_sack_this_pkt = 1u8;
                                                    if (*stcb).asoc.pr_sctp_cnt == 0u32
                                                        && num_seg as libc::c_int == 0i32
                                                        && num_nr_seg as libc::c_int == 0i32
                                                        && (cum_ack < (*stcb).asoc.last_acked_seq
                                                            && (*stcb)
                                                                .asoc
                                                                .last_acked_seq
                                                                .wrapping_sub(cum_ack)
                                                                > (1u32) << 31i32
                                                            || cum_ack
                                                                > (*stcb).asoc.last_acked_seq
                                                                && cum_ack.wrapping_sub(
                                                                    (*stcb).asoc.last_acked_seq,
                                                                ) < (1u32) << 31i32
                                                            || cum_ack
                                                                == (*stcb).asoc.last_acked_seq)
                                                        && (*stcb).asoc.saw_sack_with_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && (*stcb).asoc.saw_sack_with_nr_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && !(*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                    {
                                                        sctp_express_handle_sack(
                                                            stcb,
                                                            cum_ack,
                                                            a_rwnd,
                                                            &mut abort_now,
                                                            ecne_seen,
                                                        );
                                                    } else if !netp.is_null() && !(*netp).is_null()
                                                    {
                                                        sctp_handle_sack(
                                                            m,
                                                            offset_seg,
                                                            offset_dup,
                                                            stcb,
                                                            num_seg,
                                                            num_nr_seg,
                                                            num_dup,
                                                            &mut abort_now,
                                                            flags,
                                                            cum_ack,
                                                            a_rwnd,
                                                            ecne_seen,
                                                        );
                                                    }
                                                    if abort_now != 0 {
                                                        *offset = length;
                                                        return 0 as *mut sctp_tcb;
                                                    }
                                                    if (*stcb).asoc.send_queue.tqh_first.is_null()
                                                        && (*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                        && (*stcb).asoc.stream_queue_cnt == 0u32
                                                    {
                                                        sctp_ulp_notify(
                                                            26u32,
                                                            stcb,
                                                            0u32,
                                                            0 as *mut libc::c_void,
                                                            0i32,
                                                        );
                                                    }
                                                }
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    }
                                }
                            }
                        }
                        2349180396633407496 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_AUTHENTICATION\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null() {
                                if auth_skipped == 0i32 {
                                    auth_offset = *offset as uint32_t;
                                    auth_len = chk_length;
                                    auth_skipped = 1i32
                                }
                                current_block = 13422570431586403309;
                            } else if (*stcb).asoc.auth_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_auth_chunk>() as libc::c_ulong
                                    || chk_length as libc::c_ulong
                                        > (::std::mem::size_of::<sctp_auth_chunk>()
                                            as libc::c_ulong)
                                            .wrapping_add(32u64)
                                {
                                    *offset = length;
                                    return stcb;
                                }
                                if got_auth == 1i32 {
                                    current_block = 13422570431586403309;
                                } else {
                                    got_auth = 1i32;
                                    if ch.is_null()
                                        || sctp_handle_auth(
                                            stcb,
                                            ch as *mut sctp_auth_chunk,
                                            m,
                                            *offset as uint32_t,
                                        ) != 0
                                    {
                                        *offset = length;
                                        return stcb;
                                    } else {
                                        (*stcb).asoc.authenticated = 1u8
                                    }
                                    current_block = 13422570431586403309;
                                }
                            }
                        }
                        _ => {}
                    }
                    match current_block {
                        13422570431586403309 => {}
                        _ => {
                            if (*ch).chunk_type as libc::c_int & 0x40i32 != 0 && !stcb.is_null() {
                                op_err = sctp_get_mbuf_for_msg(
                                    ::std::mem::size_of::<sctp_gen_error_cause>() as libc::c_uint,
                                    0i32,
                                    0x1i32,
                                    1i32,
                                    1i32,
                                );
                                if !op_err.is_null() {
                                    let mut cause = 0 as *mut sctp_gen_error_cause;
                                    let mut len = 0;
                                    len = if (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                        > (length - *offset) as uint32_t
                                    {
                                        (length - *offset) as uint32_t
                                    } else {
                                        (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                    } as libc::c_int;
                                    cause = (*op_err).m_hdr.mh_data as *mut sctp_gen_error_cause;
                                    (*cause).code = htons(0x6u16);
                                    (*cause).length =
                                        htons((len as libc::c_ulong).wrapping_add(
                                            ::std::mem::size_of::<sctp_gen_error_cause>()
                                                as libc::c_ulong,
                                        )
                                            as uint16_t);
                                    (*op_err).m_hdr.mh_len =
                                        ::std::mem::size_of::<sctp_gen_error_cause>()
                                            as libc::c_int;
                                    (*op_err).m_hdr.mh_next = m_copym(m, *offset, len, 0x1i32);
                                    if !(*op_err).m_hdr.mh_next.is_null() {
                                        sctp_queue_op_err(stcb, op_err);
                                    } else {
                                        m_freem(op_err);
                                    }
                                }
                            }
                            if (*ch).chunk_type as libc::c_int & 0x80i32 == 0i32 {
                                *offset = length;
                                return stcb;
                            }
                        }
                    }
                }
                10 => {
                    current_block = 9379646460352968115;
                    match current_block {
                        17766256343850198083 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_COMPLETE, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_complete(
                                    ch as *mut sctp_shutdown_complete_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        12601157616349825580 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT_ACK\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0 {
                                } else {
                                    *offset = length;
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1di32);
                                    }
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                ret = sctp_handle_init_ack(
                                    m,
                                    iphlen,
                                    *offset,
                                    src,
                                    dst,
                                    sh,
                                    ch as *mut sctp_init_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_no_unlock,
                                    vrf_id,
                                )
                            } else {
                                ret = -(1i32)
                            }
                            *offset = length;
                            if abort_no_unlock != 0 {
                                return 0 as *mut sctp_tcb;
                            }
                            if !stcb.is_null() && ret == 0i32 {
                                sctp_chunk_output((*stcb).sctp_ep, stcb, 3i32, 0i32);
                            }
                            return stcb;
                        }
                        16195856799229720522 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                if !stcb.is_null() {
                                    pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                }
                                return 0 as *mut sctp_tcb;
                            }
                            if chk_length > (65535i32 - 2048i32) as libc::c_uint {
                                op_err = sctp_generate_cause(
                                    0x4u16,
                                    b"\x00" as *const u8 as *mut libc::c_char,
                                );
                                sctp_abort_association(
                                    inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id, port,
                                );
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            sctp_handle_init(
                                m,
                                iphlen,
                                *offset,
                                src,
                                dst,
                                sh,
                                ch as *mut sctp_init_chunk,
                                inp,
                                stcb,
                                *netp,
                                &mut abort_no_unlock,
                                vrf_id,
                                port,
                            );
                            *offset = length;
                            if abort_no_unlock == 0 && !stcb.is_null() {
                                pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                            }
                            return 0 as *mut sctp_tcb;
                        }
                        6246479402878884953 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_ack(
                                    ch as *mut sctp_shutdown_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        4558417918157925232 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ABORT, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            *offset = length;
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if sctp_handle_abort(ch as *mut sctp_abort_chunk, stcb, *netp) != 0
                                {
                                    return 0 as *mut sctp_tcb;
                                } else {
                                    return stcb;
                                }
                            } else {
                                return 0 as *mut sctp_tcb;
                            }
                        }
                        9379646460352968115 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ECHO, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && (*stcb).asoc.total_output_queue_size > 0u32 {
                                current_block = 15201865807353435331;
                            } else if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                current_block = 15767785092075175044;
                            } else {
                                current_block = 15201865807353435331;
                            }
                            match current_block {
                                15201865807353435331 => {
                                    if stcb.is_null()
                                        && (!((*inp).sctp_flags & 0x8u32 != 0u32)
                                            || (*inp).sctp_flags & 0x1u32 == 0
                                                && (*(*inp).sctp_socket).so_qlen as libc::c_int
                                                    >= (*(*inp).sctp_socket).so_qlimit
                                                        as libc::c_int)
                                    {
                                        if (*inp).sctp_flags & 0x2u32 != 0
                                            && system_base_info
                                                .sctpsysctl
                                                .sctp_abort_if_one_2_one_hits_limit
                                                != 0
                                        {
                                            op_err = sctp_generate_cause(
                                                0x4u16,
                                                b"\x00" as *const u8 as *mut libc::c_char,
                                            );
                                            sctp_abort_association(
                                                inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id,
                                                port,
                                            );
                                        }
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    } else {
                                        let mut linp = 0 as *mut sctp_inpcb;
                                        if !stcb.is_null() {
                                            linp = 0 as *mut sctp_inpcb
                                        } else {
                                            linp = inp
                                        }
                                        if !linp.is_null() {
                                            pthread_mutex_lock(&mut (*linp).inp_create_mtx);
                                            if (*inp).sctp_flags & 0x10000000u32 != 0
                                                || (*inp).sctp_flags & 0x20000000u32 != 0
                                            {
                                                pthread_mutex_unlock(&mut (*linp).inp_create_mtx);
                                                current_block = 15767785092075175044;
                                            } else {
                                                current_block = 2358125959230175008;
                                            }
                                        } else {
                                            current_block = 2358125959230175008;
                                        }
                                        match current_block {
                                            15767785092075175044 => {}
                                            _ => {
                                                let mut ret_buf = 0 as *mut mbuf;
                                                if !netp.is_null() {
                                                    let mut locked_stcb = 0 as *mut sctp_tcb;
                                                    locked_stcb = stcb;
                                                    ret_buf = sctp_handle_cookie_echo(
                                                        m,
                                                        iphlen,
                                                        *offset,
                                                        src,
                                                        dst,
                                                        sh,
                                                        ch as *mut sctp_cookie_echo_chunk,
                                                        &mut inp,
                                                        &mut stcb,
                                                        netp,
                                                        auth_skipped,
                                                        auth_offset,
                                                        auth_len,
                                                        &mut locked_stcb,
                                                        vrf_id,
                                                        port,
                                                    );
                                                    if !locked_stcb.is_null() && locked_stcb != stcb
                                                    {
                                                        pthread_mutex_unlock(
                                                            &mut (*locked_stcb).tcb_mtx,
                                                        );
                                                    }
                                                    !stcb.is_null();
                                                } else {
                                                    ret_buf = 0 as *mut mbuf
                                                }
                                                if !linp.is_null() {
                                                    pthread_mutex_unlock(
                                                        &mut (*linp).inp_create_mtx,
                                                    );
                                                }
                                                if ret_buf.is_null() {
                                                    if !stcb.is_null() {
                                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                                    }
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"GAK, null buffer\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    *offset = length;
                                                    return 0 as *mut sctp_tcb;
                                                }
                                                if auth_skipped != 0 {
                                                    got_auth = 1i32;
                                                    auth_skipped = 0i32
                                                }
                                                if !(*stcb).asoc.sent_queue.tqh_first.is_null() {
                                                    let mut chk = 0 as *mut sctp_tmit_chunk;
                                                    chk = (*stcb).asoc.sent_queue.tqh_first;
                                                    sctp_timer_start(
                                                        1i32,
                                                        (*stcb).sctp_ep,
                                                        stcb,
                                                        (*chk).whoTo,
                                                    );
                                                }
                                                current_block = 13422570431586403309;
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                            match current_block {
                                13422570431586403309 => {}
                                _ => {
                                    if !stcb.is_null() {
                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                    }
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                        }
                        10582330624169799780 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_PACKET_DROPPED\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_pktdrop_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !ch.is_null()
                                && !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                            {
                                if (*stcb).asoc.pktdrop_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_packet_dropped(
                                        ch as *mut sctp_pktdrop_chunk,
                                        stcb,
                                        *netp,
                                        if chk_length > contiguous {
                                            contiguous
                                        } else {
                                            chk_length
                                        },
                                    );
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13268550889959046632 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_STREAM_RESET\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || ch.is_null()
                                || (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_stream_reset_tsn_req>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.reconfig_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if sctp_handle_stream_reset(stcb, m, *offset, ch) != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                                current_block = 13422570431586403309;
                            }
                        }
                        13497718421940148126 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_FWD_TSN\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_forward_tsn_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.prsctp_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    let mut abort_flag_0 = 0i32;
                                    *fwd_tsn_seen = 1i32;
                                    if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1fi32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    (*stcb).asoc.last_data_chunk_from =
                                        (*stcb).asoc.last_control_chunk_from;
                                    sctp_handle_forward_tsn(
                                        stcb,
                                        ch as *mut sctp_forward_tsn_chunk,
                                        &mut abort_flag_0,
                                        m,
                                        *offset,
                                    );
                                    if abort_flag_0 != 0 {
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13226217046118304493 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_asconf_ack_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    if system_base_info.sctpsysctl.sctp_logging_level & 0x2000000u32
                                        != 0
                                    {
                                        sctp_misc_ints(
                                            120u8,
                                            (*stcb).asoc.overall_error_count,
                                            0u32,
                                            0x10000000u32,
                                            5531u32,
                                        );
                                    }
                                    (*stcb).asoc.overall_error_count = 0u32;
                                    sctp_handle_asconf_ack(
                                        m,
                                        *offset,
                                        ch as *mut sctp_asconf_ack_chunk,
                                        stcb,
                                        *netp,
                                        &mut abort_no_unlock,
                                    );
                                    if abort_no_unlock != 0 {
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        11399179239179359665 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_asconf(
                                        m,
                                        *offset as libc::c_uint,
                                        src,
                                        ch as *mut sctp_asconf_chunk,
                                        stcb,
                                        (asconf_cnt == 0i32) as libc::c_int,
                                    );
                                    asconf_cnt += 1;
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        3371148184269687219 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_CWR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cwr_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_cwr(ch as *mut sctp_cwr_chunk, stcb, *netp);
                                current_block = 13422570431586403309;
                            }
                        }
                        13594799726619700391 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_ECHO\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_ecne_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_echo(ch as *mut sctp_ecne_chunk, stcb);
                                ecne_seen = 1i32;
                                current_block = 13422570431586403309;
                            }
                        }
                        2781125740367032387 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cookie_ack_chunk>()
                                        as libc::c_ulong
                            {
                                return stcb;
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !(!stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0) {
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1ei32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                }
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_cookie_ack(
                                    ch as *mut sctp_cookie_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        17092723434217905016 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_OP_ERR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                                && sctp_handle_error(ch, stcb, *netp, contiguous) < 0i32
                            {
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            current_block = 13422570431586403309;
                        }
                        6770586402544785651 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_shutdown_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                let mut abort_flag = 0i32;
                                sctp_handle_shutdown(
                                    ch as *mut sctp_shutdown_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_flag,
                                );
                                if abort_flag != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            current_block = 13422570431586403309;
                        }
                        12945290292467802513 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_heartbeat_chunk>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvheartbeatack,
                                1u32,
                            );
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_heartbeat_ack(
                                    ch as *mut sctp_heartbeat_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        5491205026464363454 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                ::std::intrinsics::atomic_xadd(
                                    &mut system_base_info.sctpstat.sctps_recvheartbeat,
                                    1u32,
                                );
                                sctp_send_heartbeat_ack(
                                    stcb,
                                    m,
                                    *offset,
                                    chk_length as libc::c_int,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        7940804887512848672 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"%s\n\x00" as *const u8 as *const libc::c_char,
                                        if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                            b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                        } else {
                                            b"SCTP_NR_SACK\x00" as *const u8 as *const libc::c_char
                                        },
                                    );
                                }
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvsacks,
                                1u32,
                            );
                            if stcb.is_null() {
                                if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0 {
                                    if system_base_info.debug_printf.is_some() {
                                        system_base_info
                                            .debug_printf
                                            .expect("non-null function pointer")(
                                            b"No stcb when processing %s chunk\n\x00" as *const u8
                                                as *const libc::c_char,
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                            } else {
                                                b"SCTP_NR_SACK\x00" as *const u8
                                                    as *const libc::c_char
                                            },
                                        );
                                    }
                                }
                                current_block = 13422570431586403309;
                            } else {
                                if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                    if (chk_length as libc::c_ulong)
                                        < ::std::mem::size_of::<sctp_sack_chunk>() as libc::c_ulong
                                    {
                                        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32
                                            != 0
                                        {
                                            if system_base_info.debug_printf.is_some() {
                                                system_base_info
                                                    .debug_printf
                                                    .expect("non-null function pointer")(
                                                    b"Bad size on SACK chunk, too small\n\x00"
                                                        as *const u8
                                                        as *const libc::c_char,
                                                );
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    } else {
                                        current_block = 17937968408868551711;
                                    }
                                } else if (*stcb).asoc.nrsack_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_nr_sack_chunk>() as libc::c_ulong
                                {
                                    if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0
                                    {
                                        if system_base_info.debug_printf.is_some() {
                                            system_base_info
                                                .debug_printf
                                                .expect("non-null function pointer")(
                                                b"Bad size on NR_SACK chunk, too small\n\x00"
                                                    as *const u8
                                                    as *const libc::c_char,
                                            );
                                        }
                                    }
                                    current_block = 13422570431586403309;
                                } else {
                                    current_block = 17937968408868551711;
                                }
                                match current_block {
                                    6765806975593869225 => {}
                                    13422570431586403309 => {}
                                    _ => {
                                        if !((*stcb).asoc.state & 0x7fi32 == 0x40i32) {
                                            let mut a_rwnd = 0;
                                            let mut cum_ack = 0;
                                            let mut num_seg = 0;
                                            let mut num_nr_seg = 0;
                                            let mut num_dup = 0;
                                            let mut flags = 0;
                                            let mut offset_seg = 0;
                                            let mut offset_dup = 0;
                                            flags = (*ch).chunk_flags;
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                let mut sack = 0 as *mut sctp_sack_chunk;
                                                sack = ch as *mut sctp_sack_chunk;
                                                cum_ack = ntohl((*sack).sack.cum_tsn_ack);
                                                num_seg = ntohs((*sack).sack.num_gap_ack_blks);
                                                num_nr_seg = 0u16;
                                                num_dup = ntohs((*sack).sack.num_dup_tsns);
                                                a_rwnd = ntohl((*sack).sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_sack_chunk>()
                                                        as
                                                        libc::c_ulong).wrapping_add((num_seg
                                                                                         as
                                                                                         libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                         as
                                                                                                                         libc::c_ulong)).wrapping_add((num_dup
                                                                                                                                                           as
                                                                                                                                                           libc::c_ulong).wrapping_mul(::std::mem::size_of::<uint32_t>()
                                                                                                                                                                                           as
                                                                                                                                                                                           libc::c_ulong))
                                                       !=
                                                       chk_length as
                                                           libc::c_ulong {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                           &
                                                           0x1000000u32 !=
                                                           0 {
                                                        if system_base_info.debug_printf.is_some()
                                                           {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"Bad size of SACK chunk\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char);
                                                        }
                                                    }
                                                    current_block =
                                                        13422570431586403309;
                                                } else {
                                                    offset_seg =
                                                        (*offset as
                                                             libc::c_ulong).wrapping_add(::std::mem::size_of::<sctp_sack_chunk>()
                                                                                             as
                                                                                             libc::c_ulong)
                                                            as libc::c_int;
                                                    offset_dup =
                                                        (offset_seg as
                                                             libc::c_ulong).wrapping_add((num_seg
                                                                                              as
                                                                                              libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                              as
                                                                                                                              libc::c_ulong))
                                                            as libc::c_int;
                                                    current_block =
                                                        8752412851861032177;
                                                }
                                            } else {
                                                let mut nr_sack = 0 as *mut sctp_nr_sack_chunk;
                                                nr_sack = ch as *mut sctp_nr_sack_chunk;
                                                cum_ack = ntohl((*nr_sack).nr_sack.cum_tsn_ack);
                                                num_seg =
                                                    ntohs((*nr_sack).nr_sack.num_gap_ack_blks);
                                                num_nr_seg =
                                                    ntohs((*nr_sack).nr_sack.num_nr_gap_ack_blks);
                                                num_dup = ntohs((*nr_sack).nr_sack.num_dup_tsns);
                                                a_rwnd = ntohl((*nr_sack).nr_sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_nr_sack_chunk>()
                                                    as libc::c_ulong)
                                                    .wrapping_add(
                                                        ((num_seg as libc::c_int
                                                            + num_nr_seg as libc::c_int)
                                                            as libc::c_ulong)
                                                            .wrapping_mul(::std::mem::size_of::<
                                                                sctp_gap_ack_block,
                                                            >(
                                                            )
                                                                as libc::c_ulong),
                                                    )
                                                    .wrapping_add(
                                                        (num_dup as libc::c_ulong).wrapping_mul(
                                                            ::std::mem::size_of::<uint32_t>()
                                                                as libc::c_ulong,
                                                        ),
                                                    )
                                                    != chk_length as libc::c_ulong
                                                {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x1000000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"Bad size of NR_SACK chunk\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    current_block = 13422570431586403309;
                                                } else {
                                                    offset_seg = (*offset as libc::c_ulong)
                                                        .wrapping_add(::std::mem::size_of::<
                                                            sctp_nr_sack_chunk,
                                                        >(
                                                        )
                                                            as libc::c_ulong)
                                                        as libc::c_int;
                                                    offset_dup = (offset_seg as libc::c_ulong)
                                                        .wrapping_add(
                                                            ((num_seg as libc::c_int
                                                                + num_nr_seg as libc::c_int)
                                                                as libc::c_ulong)
                                                                .wrapping_mul(
                                                                    ::std::mem::size_of::<
                                                                        sctp_gap_ack_block,
                                                                    >(
                                                                    )
                                                                        as libc::c_ulong,
                                                                ),
                                                        )
                                                        as libc::c_int;
                                                    current_block = 8752412851861032177;
                                                }
                                            }
                                            match current_block {
                                                13422570431586403309 => {}
                                                _ => {
                                                    let mut abort_now = 0i32;
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"%s process cum_ack:%x num_seg:%d a_rwnd:%d\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char,
                                                                                                                              if (*ch).chunk_type
                                                                                                                                     as
                                                                                                                                     libc::c_int
                                                                                                                                     ==
                                                                                                                                     0x3i32
                                                                                                                                 {
                                                                                                                                  b"SCTP_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              } else {
                                                                                                                                  b"SCTP_NR_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              },
                                                                                                                              cum_ack,
                                                                                                                              num_seg
                                                                                                                                  as
                                                                                                                                  libc::c_int,
                                                                                                                              a_rwnd);
                                                        }
                                                    }
                                                    (*stcb).asoc.seen_a_sack_this_pkt = 1u8;
                                                    if (*stcb).asoc.pr_sctp_cnt == 0u32
                                                        && num_seg as libc::c_int == 0i32
                                                        && num_nr_seg as libc::c_int == 0i32
                                                        && (cum_ack < (*stcb).asoc.last_acked_seq
                                                            && (*stcb)
                                                                .asoc
                                                                .last_acked_seq
                                                                .wrapping_sub(cum_ack)
                                                                > (1u32) << 31i32
                                                            || cum_ack
                                                                > (*stcb).asoc.last_acked_seq
                                                                && cum_ack.wrapping_sub(
                                                                    (*stcb).asoc.last_acked_seq,
                                                                ) < (1u32) << 31i32
                                                            || cum_ack
                                                                == (*stcb).asoc.last_acked_seq)
                                                        && (*stcb).asoc.saw_sack_with_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && (*stcb).asoc.saw_sack_with_nr_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && !(*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                    {
                                                        sctp_express_handle_sack(
                                                            stcb,
                                                            cum_ack,
                                                            a_rwnd,
                                                            &mut abort_now,
                                                            ecne_seen,
                                                        );
                                                    } else if !netp.is_null() && !(*netp).is_null()
                                                    {
                                                        sctp_handle_sack(
                                                            m,
                                                            offset_seg,
                                                            offset_dup,
                                                            stcb,
                                                            num_seg,
                                                            num_nr_seg,
                                                            num_dup,
                                                            &mut abort_now,
                                                            flags,
                                                            cum_ack,
                                                            a_rwnd,
                                                            ecne_seen,
                                                        );
                                                    }
                                                    if abort_now != 0 {
                                                        *offset = length;
                                                        return 0 as *mut sctp_tcb;
                                                    }
                                                    if (*stcb).asoc.send_queue.tqh_first.is_null()
                                                        && (*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                        && (*stcb).asoc.stream_queue_cnt == 0u32
                                                    {
                                                        sctp_ulp_notify(
                                                            26u32,
                                                            stcb,
                                                            0u32,
                                                            0 as *mut libc::c_void,
                                                            0i32,
                                                        );
                                                    }
                                                }
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    }
                                }
                            }
                        }
                        2349180396633407496 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_AUTHENTICATION\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null() {
                                if auth_skipped == 0i32 {
                                    auth_offset = *offset as uint32_t;
                                    auth_len = chk_length;
                                    auth_skipped = 1i32
                                }
                                current_block = 13422570431586403309;
                            } else if (*stcb).asoc.auth_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_auth_chunk>() as libc::c_ulong
                                    || chk_length as libc::c_ulong
                                        > (::std::mem::size_of::<sctp_auth_chunk>()
                                            as libc::c_ulong)
                                            .wrapping_add(32u64)
                                {
                                    *offset = length;
                                    return stcb;
                                }
                                if got_auth == 1i32 {
                                    current_block = 13422570431586403309;
                                } else {
                                    got_auth = 1i32;
                                    if ch.is_null()
                                        || sctp_handle_auth(
                                            stcb,
                                            ch as *mut sctp_auth_chunk,
                                            m,
                                            *offset as uint32_t,
                                        ) != 0
                                    {
                                        *offset = length;
                                        return stcb;
                                    } else {
                                        (*stcb).asoc.authenticated = 1u8
                                    }
                                    current_block = 13422570431586403309;
                                }
                            }
                        }
                        _ => {}
                    }
                    match current_block {
                        13422570431586403309 => {}
                        _ => {
                            if (*ch).chunk_type as libc::c_int & 0x40i32 != 0 && !stcb.is_null() {
                                op_err = sctp_get_mbuf_for_msg(
                                    ::std::mem::size_of::<sctp_gen_error_cause>() as libc::c_uint,
                                    0i32,
                                    0x1i32,
                                    1i32,
                                    1i32,
                                );
                                if !op_err.is_null() {
                                    let mut cause = 0 as *mut sctp_gen_error_cause;
                                    let mut len = 0;
                                    len = if (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                        > (length - *offset) as uint32_t
                                    {
                                        (length - *offset) as uint32_t
                                    } else {
                                        (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                    } as libc::c_int;
                                    cause = (*op_err).m_hdr.mh_data as *mut sctp_gen_error_cause;
                                    (*cause).code = htons(0x6u16);
                                    (*cause).length =
                                        htons((len as libc::c_ulong).wrapping_add(
                                            ::std::mem::size_of::<sctp_gen_error_cause>()
                                                as libc::c_ulong,
                                        )
                                            as uint16_t);
                                    (*op_err).m_hdr.mh_len =
                                        ::std::mem::size_of::<sctp_gen_error_cause>()
                                            as libc::c_int;
                                    (*op_err).m_hdr.mh_next = m_copym(m, *offset, len, 0x1i32);
                                    if !(*op_err).m_hdr.mh_next.is_null() {
                                        sctp_queue_op_err(stcb, op_err);
                                    } else {
                                        m_freem(op_err);
                                    }
                                }
                            }
                            if (*ch).chunk_type as libc::c_int & 0x80i32 == 0i32 {
                                *offset = length;
                                return stcb;
                            }
                        }
                    }
                }
                11 => {
                    current_block = 2781125740367032387;
                    match current_block {
                        17766256343850198083 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_COMPLETE, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_complete(
                                    ch as *mut sctp_shutdown_complete_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        12601157616349825580 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT_ACK\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0 {
                                } else {
                                    *offset = length;
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1di32);
                                    }
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                ret = sctp_handle_init_ack(
                                    m,
                                    iphlen,
                                    *offset,
                                    src,
                                    dst,
                                    sh,
                                    ch as *mut sctp_init_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_no_unlock,
                                    vrf_id,
                                )
                            } else {
                                ret = -(1i32)
                            }
                            *offset = length;
                            if abort_no_unlock != 0 {
                                return 0 as *mut sctp_tcb;
                            }
                            if !stcb.is_null() && ret == 0i32 {
                                sctp_chunk_output((*stcb).sctp_ep, stcb, 3i32, 0i32);
                            }
                            return stcb;
                        }
                        16195856799229720522 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                if !stcb.is_null() {
                                    pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                }
                                return 0 as *mut sctp_tcb;
                            }
                            if chk_length > (65535i32 - 2048i32) as libc::c_uint {
                                op_err = sctp_generate_cause(
                                    0x4u16,
                                    b"\x00" as *const u8 as *mut libc::c_char,
                                );
                                sctp_abort_association(
                                    inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id, port,
                                );
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            sctp_handle_init(
                                m,
                                iphlen,
                                *offset,
                                src,
                                dst,
                                sh,
                                ch as *mut sctp_init_chunk,
                                inp,
                                stcb,
                                *netp,
                                &mut abort_no_unlock,
                                vrf_id,
                                port,
                            );
                            *offset = length;
                            if abort_no_unlock == 0 && !stcb.is_null() {
                                pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                            }
                            return 0 as *mut sctp_tcb;
                        }
                        6246479402878884953 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_ack(
                                    ch as *mut sctp_shutdown_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        4558417918157925232 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ABORT, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            *offset = length;
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if sctp_handle_abort(ch as *mut sctp_abort_chunk, stcb, *netp) != 0
                                {
                                    return 0 as *mut sctp_tcb;
                                } else {
                                    return stcb;
                                }
                            } else {
                                return 0 as *mut sctp_tcb;
                            }
                        }
                        9379646460352968115 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ECHO, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && (*stcb).asoc.total_output_queue_size > 0u32 {
                                current_block = 15201865807353435331;
                            } else if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                current_block = 15767785092075175044;
                            } else {
                                current_block = 15201865807353435331;
                            }
                            match current_block {
                                15201865807353435331 => {
                                    if stcb.is_null()
                                        && (!((*inp).sctp_flags & 0x8u32 != 0u32)
                                            || (*inp).sctp_flags & 0x1u32 == 0
                                                && (*(*inp).sctp_socket).so_qlen as libc::c_int
                                                    >= (*(*inp).sctp_socket).so_qlimit
                                                        as libc::c_int)
                                    {
                                        if (*inp).sctp_flags & 0x2u32 != 0
                                            && system_base_info
                                                .sctpsysctl
                                                .sctp_abort_if_one_2_one_hits_limit
                                                != 0
                                        {
                                            op_err = sctp_generate_cause(
                                                0x4u16,
                                                b"\x00" as *const u8 as *mut libc::c_char,
                                            );
                                            sctp_abort_association(
                                                inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id,
                                                port,
                                            );
                                        }
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    } else {
                                        let mut linp = 0 as *mut sctp_inpcb;
                                        if !stcb.is_null() {
                                            linp = 0 as *mut sctp_inpcb
                                        } else {
                                            linp = inp
                                        }
                                        if !linp.is_null() {
                                            pthread_mutex_lock(&mut (*linp).inp_create_mtx);
                                            if (*inp).sctp_flags & 0x10000000u32 != 0
                                                || (*inp).sctp_flags & 0x20000000u32 != 0
                                            {
                                                pthread_mutex_unlock(&mut (*linp).inp_create_mtx);
                                                current_block = 15767785092075175044;
                                            } else {
                                                current_block = 2358125959230175008;
                                            }
                                        } else {
                                            current_block = 2358125959230175008;
                                        }
                                        match current_block {
                                            15767785092075175044 => {}
                                            _ => {
                                                let mut ret_buf = 0 as *mut mbuf;
                                                if !netp.is_null() {
                                                    let mut locked_stcb = 0 as *mut sctp_tcb;
                                                    locked_stcb = stcb;
                                                    ret_buf = sctp_handle_cookie_echo(
                                                        m,
                                                        iphlen,
                                                        *offset,
                                                        src,
                                                        dst,
                                                        sh,
                                                        ch as *mut sctp_cookie_echo_chunk,
                                                        &mut inp,
                                                        &mut stcb,
                                                        netp,
                                                        auth_skipped,
                                                        auth_offset,
                                                        auth_len,
                                                        &mut locked_stcb,
                                                        vrf_id,
                                                        port,
                                                    );
                                                    if !locked_stcb.is_null() && locked_stcb != stcb
                                                    {
                                                        pthread_mutex_unlock(
                                                            &mut (*locked_stcb).tcb_mtx,
                                                        );
                                                    }
                                                    !stcb.is_null();
                                                } else {
                                                    ret_buf = 0 as *mut mbuf
                                                }
                                                if !linp.is_null() {
                                                    pthread_mutex_unlock(
                                                        &mut (*linp).inp_create_mtx,
                                                    );
                                                }
                                                if ret_buf.is_null() {
                                                    if !stcb.is_null() {
                                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                                    }
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"GAK, null buffer\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    *offset = length;
                                                    return 0 as *mut sctp_tcb;
                                                }
                                                if auth_skipped != 0 {
                                                    got_auth = 1i32;
                                                    auth_skipped = 0i32
                                                }
                                                if !(*stcb).asoc.sent_queue.tqh_first.is_null() {
                                                    let mut chk = 0 as *mut sctp_tmit_chunk;
                                                    chk = (*stcb).asoc.sent_queue.tqh_first;
                                                    sctp_timer_start(
                                                        1i32,
                                                        (*stcb).sctp_ep,
                                                        stcb,
                                                        (*chk).whoTo,
                                                    );
                                                }
                                                current_block = 13422570431586403309;
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                            match current_block {
                                13422570431586403309 => {}
                                _ => {
                                    if !stcb.is_null() {
                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                    }
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                        }
                        10582330624169799780 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_PACKET_DROPPED\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_pktdrop_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !ch.is_null()
                                && !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                            {
                                if (*stcb).asoc.pktdrop_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_packet_dropped(
                                        ch as *mut sctp_pktdrop_chunk,
                                        stcb,
                                        *netp,
                                        if chk_length > contiguous {
                                            contiguous
                                        } else {
                                            chk_length
                                        },
                                    );
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13268550889959046632 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_STREAM_RESET\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || ch.is_null()
                                || (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_stream_reset_tsn_req>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.reconfig_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if sctp_handle_stream_reset(stcb, m, *offset, ch) != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                                current_block = 13422570431586403309;
                            }
                        }
                        13497718421940148126 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_FWD_TSN\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_forward_tsn_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.prsctp_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    let mut abort_flag_0 = 0i32;
                                    *fwd_tsn_seen = 1i32;
                                    if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1fi32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    (*stcb).asoc.last_data_chunk_from =
                                        (*stcb).asoc.last_control_chunk_from;
                                    sctp_handle_forward_tsn(
                                        stcb,
                                        ch as *mut sctp_forward_tsn_chunk,
                                        &mut abort_flag_0,
                                        m,
                                        *offset,
                                    );
                                    if abort_flag_0 != 0 {
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13226217046118304493 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_asconf_ack_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    if system_base_info.sctpsysctl.sctp_logging_level & 0x2000000u32
                                        != 0
                                    {
                                        sctp_misc_ints(
                                            120u8,
                                            (*stcb).asoc.overall_error_count,
                                            0u32,
                                            0x10000000u32,
                                            5531u32,
                                        );
                                    }
                                    (*stcb).asoc.overall_error_count = 0u32;
                                    sctp_handle_asconf_ack(
                                        m,
                                        *offset,
                                        ch as *mut sctp_asconf_ack_chunk,
                                        stcb,
                                        *netp,
                                        &mut abort_no_unlock,
                                    );
                                    if abort_no_unlock != 0 {
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        11399179239179359665 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_asconf(
                                        m,
                                        *offset as libc::c_uint,
                                        src,
                                        ch as *mut sctp_asconf_chunk,
                                        stcb,
                                        (asconf_cnt == 0i32) as libc::c_int,
                                    );
                                    asconf_cnt += 1;
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        3371148184269687219 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_CWR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cwr_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_cwr(ch as *mut sctp_cwr_chunk, stcb, *netp);
                                current_block = 13422570431586403309;
                            }
                        }
                        13594799726619700391 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_ECHO\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_ecne_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_echo(ch as *mut sctp_ecne_chunk, stcb);
                                ecne_seen = 1i32;
                                current_block = 13422570431586403309;
                            }
                        }
                        2781125740367032387 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cookie_ack_chunk>()
                                        as libc::c_ulong
                            {
                                return stcb;
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !(!stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0) {
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1ei32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                }
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_cookie_ack(
                                    ch as *mut sctp_cookie_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        17092723434217905016 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_OP_ERR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                                && sctp_handle_error(ch, stcb, *netp, contiguous) < 0i32
                            {
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            current_block = 13422570431586403309;
                        }
                        6770586402544785651 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_shutdown_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                let mut abort_flag = 0i32;
                                sctp_handle_shutdown(
                                    ch as *mut sctp_shutdown_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_flag,
                                );
                                if abort_flag != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            current_block = 13422570431586403309;
                        }
                        12945290292467802513 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_heartbeat_chunk>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvheartbeatack,
                                1u32,
                            );
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_heartbeat_ack(
                                    ch as *mut sctp_heartbeat_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        5491205026464363454 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                ::std::intrinsics::atomic_xadd(
                                    &mut system_base_info.sctpstat.sctps_recvheartbeat,
                                    1u32,
                                );
                                sctp_send_heartbeat_ack(
                                    stcb,
                                    m,
                                    *offset,
                                    chk_length as libc::c_int,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        7940804887512848672 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"%s\n\x00" as *const u8 as *const libc::c_char,
                                        if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                            b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                        } else {
                                            b"SCTP_NR_SACK\x00" as *const u8 as *const libc::c_char
                                        },
                                    );
                                }
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvsacks,
                                1u32,
                            );
                            if stcb.is_null() {
                                if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0 {
                                    if system_base_info.debug_printf.is_some() {
                                        system_base_info
                                            .debug_printf
                                            .expect("non-null function pointer")(
                                            b"No stcb when processing %s chunk\n\x00" as *const u8
                                                as *const libc::c_char,
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                            } else {
                                                b"SCTP_NR_SACK\x00" as *const u8
                                                    as *const libc::c_char
                                            },
                                        );
                                    }
                                }
                                current_block = 13422570431586403309;
                            } else {
                                if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                    if (chk_length as libc::c_ulong)
                                        < ::std::mem::size_of::<sctp_sack_chunk>() as libc::c_ulong
                                    {
                                        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32
                                            != 0
                                        {
                                            if system_base_info.debug_printf.is_some() {
                                                system_base_info
                                                    .debug_printf
                                                    .expect("non-null function pointer")(
                                                    b"Bad size on SACK chunk, too small\n\x00"
                                                        as *const u8
                                                        as *const libc::c_char,
                                                );
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    } else {
                                        current_block = 17937968408868551711;
                                    }
                                } else if (*stcb).asoc.nrsack_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_nr_sack_chunk>() as libc::c_ulong
                                {
                                    if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0
                                    {
                                        if system_base_info.debug_printf.is_some() {
                                            system_base_info
                                                .debug_printf
                                                .expect("non-null function pointer")(
                                                b"Bad size on NR_SACK chunk, too small\n\x00"
                                                    as *const u8
                                                    as *const libc::c_char,
                                            );
                                        }
                                    }
                                    current_block = 13422570431586403309;
                                } else {
                                    current_block = 17937968408868551711;
                                }
                                match current_block {
                                    6765806975593869225 => {}
                                    13422570431586403309 => {}
                                    _ => {
                                        if !((*stcb).asoc.state & 0x7fi32 == 0x40i32) {
                                            let mut a_rwnd = 0;
                                            let mut cum_ack = 0;
                                            let mut num_seg = 0;
                                            let mut num_nr_seg = 0;
                                            let mut num_dup = 0;
                                            let mut flags = 0;
                                            let mut offset_seg = 0;
                                            let mut offset_dup = 0;
                                            flags = (*ch).chunk_flags;
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                let mut sack = 0 as *mut sctp_sack_chunk;
                                                sack = ch as *mut sctp_sack_chunk;
                                                cum_ack = ntohl((*sack).sack.cum_tsn_ack);
                                                num_seg = ntohs((*sack).sack.num_gap_ack_blks);
                                                num_nr_seg = 0u16;
                                                num_dup = ntohs((*sack).sack.num_dup_tsns);
                                                a_rwnd = ntohl((*sack).sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_sack_chunk>()
                                                        as
                                                        libc::c_ulong).wrapping_add((num_seg
                                                                                         as
                                                                                         libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                         as
                                                                                                                         libc::c_ulong)).wrapping_add((num_dup
                                                                                                                                                           as
                                                                                                                                                           libc::c_ulong).wrapping_mul(::std::mem::size_of::<uint32_t>()
                                                                                                                                                                                           as
                                                                                                                                                                                           libc::c_ulong))
                                                       !=
                                                       chk_length as
                                                           libc::c_ulong {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                           &
                                                           0x1000000u32 !=
                                                           0 {
                                                        if system_base_info.debug_printf.is_some()
                                                           {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"Bad size of SACK chunk\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char);
                                                        }
                                                    }
                                                    current_block =
                                                        13422570431586403309;
                                                } else {
                                                    offset_seg =
                                                        (*offset as
                                                             libc::c_ulong).wrapping_add(::std::mem::size_of::<sctp_sack_chunk>()
                                                                                             as
                                                                                             libc::c_ulong)
                                                            as libc::c_int;
                                                    offset_dup =
                                                        (offset_seg as
                                                             libc::c_ulong).wrapping_add((num_seg
                                                                                              as
                                                                                              libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                              as
                                                                                                                              libc::c_ulong))
                                                            as libc::c_int;
                                                    current_block =
                                                        8752412851861032177;
                                                }
                                            } else {
                                                let mut nr_sack = 0 as *mut sctp_nr_sack_chunk;
                                                nr_sack = ch as *mut sctp_nr_sack_chunk;
                                                cum_ack = ntohl((*nr_sack).nr_sack.cum_tsn_ack);
                                                num_seg =
                                                    ntohs((*nr_sack).nr_sack.num_gap_ack_blks);
                                                num_nr_seg =
                                                    ntohs((*nr_sack).nr_sack.num_nr_gap_ack_blks);
                                                num_dup = ntohs((*nr_sack).nr_sack.num_dup_tsns);
                                                a_rwnd = ntohl((*nr_sack).nr_sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_nr_sack_chunk>()
                                                    as libc::c_ulong)
                                                    .wrapping_add(
                                                        ((num_seg as libc::c_int
                                                            + num_nr_seg as libc::c_int)
                                                            as libc::c_ulong)
                                                            .wrapping_mul(::std::mem::size_of::<
                                                                sctp_gap_ack_block,
                                                            >(
                                                            )
                                                                as libc::c_ulong),
                                                    )
                                                    .wrapping_add(
                                                        (num_dup as libc::c_ulong).wrapping_mul(
                                                            ::std::mem::size_of::<uint32_t>()
                                                                as libc::c_ulong,
                                                        ),
                                                    )
                                                    != chk_length as libc::c_ulong
                                                {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x1000000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"Bad size of NR_SACK chunk\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    current_block = 13422570431586403309;
                                                } else {
                                                    offset_seg = (*offset as libc::c_ulong)
                                                        .wrapping_add(::std::mem::size_of::<
                                                            sctp_nr_sack_chunk,
                                                        >(
                                                        )
                                                            as libc::c_ulong)
                                                        as libc::c_int;
                                                    offset_dup = (offset_seg as libc::c_ulong)
                                                        .wrapping_add(
                                                            ((num_seg as libc::c_int
                                                                + num_nr_seg as libc::c_int)
                                                                as libc::c_ulong)
                                                                .wrapping_mul(
                                                                    ::std::mem::size_of::<
                                                                        sctp_gap_ack_block,
                                                                    >(
                                                                    )
                                                                        as libc::c_ulong,
                                                                ),
                                                        )
                                                        as libc::c_int;
                                                    current_block = 8752412851861032177;
                                                }
                                            }
                                            match current_block {
                                                13422570431586403309 => {}
                                                _ => {
                                                    let mut abort_now = 0i32;
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"%s process cum_ack:%x num_seg:%d a_rwnd:%d\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char,
                                                                                                                              if (*ch).chunk_type
                                                                                                                                     as
                                                                                                                                     libc::c_int
                                                                                                                                     ==
                                                                                                                                     0x3i32
                                                                                                                                 {
                                                                                                                                  b"SCTP_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              } else {
                                                                                                                                  b"SCTP_NR_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              },
                                                                                                                              cum_ack,
                                                                                                                              num_seg
                                                                                                                                  as
                                                                                                                                  libc::c_int,
                                                                                                                              a_rwnd);
                                                        }
                                                    }
                                                    (*stcb).asoc.seen_a_sack_this_pkt = 1u8;
                                                    if (*stcb).asoc.pr_sctp_cnt == 0u32
                                                        && num_seg as libc::c_int == 0i32
                                                        && num_nr_seg as libc::c_int == 0i32
                                                        && (cum_ack < (*stcb).asoc.last_acked_seq
                                                            && (*stcb)
                                                                .asoc
                                                                .last_acked_seq
                                                                .wrapping_sub(cum_ack)
                                                                > (1u32) << 31i32
                                                            || cum_ack
                                                                > (*stcb).asoc.last_acked_seq
                                                                && cum_ack.wrapping_sub(
                                                                    (*stcb).asoc.last_acked_seq,
                                                                ) < (1u32) << 31i32
                                                            || cum_ack
                                                                == (*stcb).asoc.last_acked_seq)
                                                        && (*stcb).asoc.saw_sack_with_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && (*stcb).asoc.saw_sack_with_nr_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && !(*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                    {
                                                        sctp_express_handle_sack(
                                                            stcb,
                                                            cum_ack,
                                                            a_rwnd,
                                                            &mut abort_now,
                                                            ecne_seen,
                                                        );
                                                    } else if !netp.is_null() && !(*netp).is_null()
                                                    {
                                                        sctp_handle_sack(
                                                            m,
                                                            offset_seg,
                                                            offset_dup,
                                                            stcb,
                                                            num_seg,
                                                            num_nr_seg,
                                                            num_dup,
                                                            &mut abort_now,
                                                            flags,
                                                            cum_ack,
                                                            a_rwnd,
                                                            ecne_seen,
                                                        );
                                                    }
                                                    if abort_now != 0 {
                                                        *offset = length;
                                                        return 0 as *mut sctp_tcb;
                                                    }
                                                    if (*stcb).asoc.send_queue.tqh_first.is_null()
                                                        && (*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                        && (*stcb).asoc.stream_queue_cnt == 0u32
                                                    {
                                                        sctp_ulp_notify(
                                                            26u32,
                                                            stcb,
                                                            0u32,
                                                            0 as *mut libc::c_void,
                                                            0i32,
                                                        );
                                                    }
                                                }
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    }
                                }
                            }
                        }
                        2349180396633407496 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_AUTHENTICATION\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null() {
                                if auth_skipped == 0i32 {
                                    auth_offset = *offset as uint32_t;
                                    auth_len = chk_length;
                                    auth_skipped = 1i32
                                }
                                current_block = 13422570431586403309;
                            } else if (*stcb).asoc.auth_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_auth_chunk>() as libc::c_ulong
                                    || chk_length as libc::c_ulong
                                        > (::std::mem::size_of::<sctp_auth_chunk>()
                                            as libc::c_ulong)
                                            .wrapping_add(32u64)
                                {
                                    *offset = length;
                                    return stcb;
                                }
                                if got_auth == 1i32 {
                                    current_block = 13422570431586403309;
                                } else {
                                    got_auth = 1i32;
                                    if ch.is_null()
                                        || sctp_handle_auth(
                                            stcb,
                                            ch as *mut sctp_auth_chunk,
                                            m,
                                            *offset as uint32_t,
                                        ) != 0
                                    {
                                        *offset = length;
                                        return stcb;
                                    } else {
                                        (*stcb).asoc.authenticated = 1u8
                                    }
                                    current_block = 13422570431586403309;
                                }
                            }
                        }
                        _ => {}
                    }
                    match current_block {
                        13422570431586403309 => {}
                        _ => {
                            if (*ch).chunk_type as libc::c_int & 0x40i32 != 0 && !stcb.is_null() {
                                op_err = sctp_get_mbuf_for_msg(
                                    ::std::mem::size_of::<sctp_gen_error_cause>() as libc::c_uint,
                                    0i32,
                                    0x1i32,
                                    1i32,
                                    1i32,
                                );
                                if !op_err.is_null() {
                                    let mut cause = 0 as *mut sctp_gen_error_cause;
                                    let mut len = 0;
                                    len = if (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                        > (length - *offset) as uint32_t
                                    {
                                        (length - *offset) as uint32_t
                                    } else {
                                        (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                    } as libc::c_int;
                                    cause = (*op_err).m_hdr.mh_data as *mut sctp_gen_error_cause;
                                    (*cause).code = htons(0x6u16);
                                    (*cause).length =
                                        htons((len as libc::c_ulong).wrapping_add(
                                            ::std::mem::size_of::<sctp_gen_error_cause>()
                                                as libc::c_ulong,
                                        )
                                            as uint16_t);
                                    (*op_err).m_hdr.mh_len =
                                        ::std::mem::size_of::<sctp_gen_error_cause>()
                                            as libc::c_int;
                                    (*op_err).m_hdr.mh_next = m_copym(m, *offset, len, 0x1i32);
                                    if !(*op_err).m_hdr.mh_next.is_null() {
                                        sctp_queue_op_err(stcb, op_err);
                                    } else {
                                        m_freem(op_err);
                                    }
                                }
                            }
                            if (*ch).chunk_type as libc::c_int & 0x80i32 == 0i32 {
                                *offset = length;
                                return stcb;
                            }
                        }
                    }
                }
                12 => {
                    current_block = 13594799726619700391;
                    match current_block {
                        17766256343850198083 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_COMPLETE, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_complete(
                                    ch as *mut sctp_shutdown_complete_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        12601157616349825580 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT_ACK\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0 {
                                } else {
                                    *offset = length;
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1di32);
                                    }
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                ret = sctp_handle_init_ack(
                                    m,
                                    iphlen,
                                    *offset,
                                    src,
                                    dst,
                                    sh,
                                    ch as *mut sctp_init_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_no_unlock,
                                    vrf_id,
                                )
                            } else {
                                ret = -(1i32)
                            }
                            *offset = length;
                            if abort_no_unlock != 0 {
                                return 0 as *mut sctp_tcb;
                            }
                            if !stcb.is_null() && ret == 0i32 {
                                sctp_chunk_output((*stcb).sctp_ep, stcb, 3i32, 0i32);
                            }
                            return stcb;
                        }
                        16195856799229720522 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                if !stcb.is_null() {
                                    pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                }
                                return 0 as *mut sctp_tcb;
                            }
                            if chk_length > (65535i32 - 2048i32) as libc::c_uint {
                                op_err = sctp_generate_cause(
                                    0x4u16,
                                    b"\x00" as *const u8 as *mut libc::c_char,
                                );
                                sctp_abort_association(
                                    inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id, port,
                                );
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            sctp_handle_init(
                                m,
                                iphlen,
                                *offset,
                                src,
                                dst,
                                sh,
                                ch as *mut sctp_init_chunk,
                                inp,
                                stcb,
                                *netp,
                                &mut abort_no_unlock,
                                vrf_id,
                                port,
                            );
                            *offset = length;
                            if abort_no_unlock == 0 && !stcb.is_null() {
                                pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                            }
                            return 0 as *mut sctp_tcb;
                        }
                        6246479402878884953 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_ack(
                                    ch as *mut sctp_shutdown_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        4558417918157925232 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ABORT, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            *offset = length;
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if sctp_handle_abort(ch as *mut sctp_abort_chunk, stcb, *netp) != 0
                                {
                                    return 0 as *mut sctp_tcb;
                                } else {
                                    return stcb;
                                }
                            } else {
                                return 0 as *mut sctp_tcb;
                            }
                        }
                        9379646460352968115 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ECHO, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && (*stcb).asoc.total_output_queue_size > 0u32 {
                                current_block = 15201865807353435331;
                            } else if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                current_block = 15767785092075175044;
                            } else {
                                current_block = 15201865807353435331;
                            }
                            match current_block {
                                15201865807353435331 => {
                                    if stcb.is_null()
                                        && (!((*inp).sctp_flags & 0x8u32 != 0u32)
                                            || (*inp).sctp_flags & 0x1u32 == 0
                                                && (*(*inp).sctp_socket).so_qlen as libc::c_int
                                                    >= (*(*inp).sctp_socket).so_qlimit
                                                        as libc::c_int)
                                    {
                                        if (*inp).sctp_flags & 0x2u32 != 0
                                            && system_base_info
                                                .sctpsysctl
                                                .sctp_abort_if_one_2_one_hits_limit
                                                != 0
                                        {
                                            op_err = sctp_generate_cause(
                                                0x4u16,
                                                b"\x00" as *const u8 as *mut libc::c_char,
                                            );
                                            sctp_abort_association(
                                                inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id,
                                                port,
                                            );
                                        }
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    } else {
                                        let mut linp = 0 as *mut sctp_inpcb;
                                        if !stcb.is_null() {
                                            linp = 0 as *mut sctp_inpcb
                                        } else {
                                            linp = inp
                                        }
                                        if !linp.is_null() {
                                            pthread_mutex_lock(&mut (*linp).inp_create_mtx);
                                            if (*inp).sctp_flags & 0x10000000u32 != 0
                                                || (*inp).sctp_flags & 0x20000000u32 != 0
                                            {
                                                pthread_mutex_unlock(&mut (*linp).inp_create_mtx);
                                                current_block = 15767785092075175044;
                                            } else {
                                                current_block = 2358125959230175008;
                                            }
                                        } else {
                                            current_block = 2358125959230175008;
                                        }
                                        match current_block {
                                            15767785092075175044 => {}
                                            _ => {
                                                let mut ret_buf = 0 as *mut mbuf;
                                                if !netp.is_null() {
                                                    let mut locked_stcb = 0 as *mut sctp_tcb;
                                                    locked_stcb = stcb;
                                                    ret_buf = sctp_handle_cookie_echo(
                                                        m,
                                                        iphlen,
                                                        *offset,
                                                        src,
                                                        dst,
                                                        sh,
                                                        ch as *mut sctp_cookie_echo_chunk,
                                                        &mut inp,
                                                        &mut stcb,
                                                        netp,
                                                        auth_skipped,
                                                        auth_offset,
                                                        auth_len,
                                                        &mut locked_stcb,
                                                        vrf_id,
                                                        port,
                                                    );
                                                    if !locked_stcb.is_null() && locked_stcb != stcb
                                                    {
                                                        pthread_mutex_unlock(
                                                            &mut (*locked_stcb).tcb_mtx,
                                                        );
                                                    }
                                                    !stcb.is_null();
                                                } else {
                                                    ret_buf = 0 as *mut mbuf
                                                }
                                                if !linp.is_null() {
                                                    pthread_mutex_unlock(
                                                        &mut (*linp).inp_create_mtx,
                                                    );
                                                }
                                                if ret_buf.is_null() {
                                                    if !stcb.is_null() {
                                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                                    }
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"GAK, null buffer\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    *offset = length;
                                                    return 0 as *mut sctp_tcb;
                                                }
                                                if auth_skipped != 0 {
                                                    got_auth = 1i32;
                                                    auth_skipped = 0i32
                                                }
                                                if !(*stcb).asoc.sent_queue.tqh_first.is_null() {
                                                    let mut chk = 0 as *mut sctp_tmit_chunk;
                                                    chk = (*stcb).asoc.sent_queue.tqh_first;
                                                    sctp_timer_start(
                                                        1i32,
                                                        (*stcb).sctp_ep,
                                                        stcb,
                                                        (*chk).whoTo,
                                                    );
                                                }
                                                current_block = 13422570431586403309;
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                            match current_block {
                                13422570431586403309 => {}
                                _ => {
                                    if !stcb.is_null() {
                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                    }
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                        }
                        10582330624169799780 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_PACKET_DROPPED\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_pktdrop_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !ch.is_null()
                                && !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                            {
                                if (*stcb).asoc.pktdrop_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_packet_dropped(
                                        ch as *mut sctp_pktdrop_chunk,
                                        stcb,
                                        *netp,
                                        if chk_length > contiguous {
                                            contiguous
                                        } else {
                                            chk_length
                                        },
                                    );
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13268550889959046632 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_STREAM_RESET\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || ch.is_null()
                                || (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_stream_reset_tsn_req>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.reconfig_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if sctp_handle_stream_reset(stcb, m, *offset, ch) != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                                current_block = 13422570431586403309;
                            }
                        }
                        13497718421940148126 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_FWD_TSN\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_forward_tsn_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.prsctp_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    let mut abort_flag_0 = 0i32;
                                    *fwd_tsn_seen = 1i32;
                                    if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1fi32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    (*stcb).asoc.last_data_chunk_from =
                                        (*stcb).asoc.last_control_chunk_from;
                                    sctp_handle_forward_tsn(
                                        stcb,
                                        ch as *mut sctp_forward_tsn_chunk,
                                        &mut abort_flag_0,
                                        m,
                                        *offset,
                                    );
                                    if abort_flag_0 != 0 {
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13226217046118304493 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_asconf_ack_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    if system_base_info.sctpsysctl.sctp_logging_level & 0x2000000u32
                                        != 0
                                    {
                                        sctp_misc_ints(
                                            120u8,
                                            (*stcb).asoc.overall_error_count,
                                            0u32,
                                            0x10000000u32,
                                            5531u32,
                                        );
                                    }
                                    (*stcb).asoc.overall_error_count = 0u32;
                                    sctp_handle_asconf_ack(
                                        m,
                                        *offset,
                                        ch as *mut sctp_asconf_ack_chunk,
                                        stcb,
                                        *netp,
                                        &mut abort_no_unlock,
                                    );
                                    if abort_no_unlock != 0 {
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        11399179239179359665 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_asconf(
                                        m,
                                        *offset as libc::c_uint,
                                        src,
                                        ch as *mut sctp_asconf_chunk,
                                        stcb,
                                        (asconf_cnt == 0i32) as libc::c_int,
                                    );
                                    asconf_cnt += 1;
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        3371148184269687219 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_CWR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cwr_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_cwr(ch as *mut sctp_cwr_chunk, stcb, *netp);
                                current_block = 13422570431586403309;
                            }
                        }
                        13594799726619700391 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_ECHO\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_ecne_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_echo(ch as *mut sctp_ecne_chunk, stcb);
                                ecne_seen = 1i32;
                                current_block = 13422570431586403309;
                            }
                        }
                        2781125740367032387 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cookie_ack_chunk>()
                                        as libc::c_ulong
                            {
                                return stcb;
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !(!stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0) {
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1ei32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                }
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_cookie_ack(
                                    ch as *mut sctp_cookie_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        17092723434217905016 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_OP_ERR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                                && sctp_handle_error(ch, stcb, *netp, contiguous) < 0i32
                            {
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            current_block = 13422570431586403309;
                        }
                        6770586402544785651 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_shutdown_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                let mut abort_flag = 0i32;
                                sctp_handle_shutdown(
                                    ch as *mut sctp_shutdown_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_flag,
                                );
                                if abort_flag != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            current_block = 13422570431586403309;
                        }
                        12945290292467802513 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_heartbeat_chunk>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvheartbeatack,
                                1u32,
                            );
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_heartbeat_ack(
                                    ch as *mut sctp_heartbeat_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        5491205026464363454 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                ::std::intrinsics::atomic_xadd(
                                    &mut system_base_info.sctpstat.sctps_recvheartbeat,
                                    1u32,
                                );
                                sctp_send_heartbeat_ack(
                                    stcb,
                                    m,
                                    *offset,
                                    chk_length as libc::c_int,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        7940804887512848672 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"%s\n\x00" as *const u8 as *const libc::c_char,
                                        if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                            b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                        } else {
                                            b"SCTP_NR_SACK\x00" as *const u8 as *const libc::c_char
                                        },
                                    );
                                }
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvsacks,
                                1u32,
                            );
                            if stcb.is_null() {
                                if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0 {
                                    if system_base_info.debug_printf.is_some() {
                                        system_base_info
                                            .debug_printf
                                            .expect("non-null function pointer")(
                                            b"No stcb when processing %s chunk\n\x00" as *const u8
                                                as *const libc::c_char,
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                            } else {
                                                b"SCTP_NR_SACK\x00" as *const u8
                                                    as *const libc::c_char
                                            },
                                        );
                                    }
                                }
                                current_block = 13422570431586403309;
                            } else {
                                if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                    if (chk_length as libc::c_ulong)
                                        < ::std::mem::size_of::<sctp_sack_chunk>() as libc::c_ulong
                                    {
                                        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32
                                            != 0
                                        {
                                            if system_base_info.debug_printf.is_some() {
                                                system_base_info
                                                    .debug_printf
                                                    .expect("non-null function pointer")(
                                                    b"Bad size on SACK chunk, too small\n\x00"
                                                        as *const u8
                                                        as *const libc::c_char,
                                                );
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    } else {
                                        current_block = 17937968408868551711;
                                    }
                                } else if (*stcb).asoc.nrsack_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_nr_sack_chunk>() as libc::c_ulong
                                {
                                    if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0
                                    {
                                        if system_base_info.debug_printf.is_some() {
                                            system_base_info
                                                .debug_printf
                                                .expect("non-null function pointer")(
                                                b"Bad size on NR_SACK chunk, too small\n\x00"
                                                    as *const u8
                                                    as *const libc::c_char,
                                            );
                                        }
                                    }
                                    current_block = 13422570431586403309;
                                } else {
                                    current_block = 17937968408868551711;
                                }
                                match current_block {
                                    6765806975593869225 => {}
                                    13422570431586403309 => {}
                                    _ => {
                                        if !((*stcb).asoc.state & 0x7fi32 == 0x40i32) {
                                            let mut a_rwnd = 0;
                                            let mut cum_ack = 0;
                                            let mut num_seg = 0;
                                            let mut num_nr_seg = 0;
                                            let mut num_dup = 0;
                                            let mut flags = 0;
                                            let mut offset_seg = 0;
                                            let mut offset_dup = 0;
                                            flags = (*ch).chunk_flags;
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                let mut sack = 0 as *mut sctp_sack_chunk;
                                                sack = ch as *mut sctp_sack_chunk;
                                                cum_ack = ntohl((*sack).sack.cum_tsn_ack);
                                                num_seg = ntohs((*sack).sack.num_gap_ack_blks);
                                                num_nr_seg = 0u16;
                                                num_dup = ntohs((*sack).sack.num_dup_tsns);
                                                a_rwnd = ntohl((*sack).sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_sack_chunk>()
                                                        as
                                                        libc::c_ulong).wrapping_add((num_seg
                                                                                         as
                                                                                         libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                         as
                                                                                                                         libc::c_ulong)).wrapping_add((num_dup
                                                                                                                                                           as
                                                                                                                                                           libc::c_ulong).wrapping_mul(::std::mem::size_of::<uint32_t>()
                                                                                                                                                                                           as
                                                                                                                                                                                           libc::c_ulong))
                                                       !=
                                                       chk_length as
                                                           libc::c_ulong {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                           &
                                                           0x1000000u32 !=
                                                           0 {
                                                        if system_base_info.debug_printf.is_some()
                                                           {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"Bad size of SACK chunk\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char);
                                                        }
                                                    }
                                                    current_block =
                                                        13422570431586403309;
                                                } else {
                                                    offset_seg =
                                                        (*offset as
                                                             libc::c_ulong).wrapping_add(::std::mem::size_of::<sctp_sack_chunk>()
                                                                                             as
                                                                                             libc::c_ulong)
                                                            as libc::c_int;
                                                    offset_dup =
                                                        (offset_seg as
                                                             libc::c_ulong).wrapping_add((num_seg
                                                                                              as
                                                                                              libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                              as
                                                                                                                              libc::c_ulong))
                                                            as libc::c_int;
                                                    current_block =
                                                        8752412851861032177;
                                                }
                                            } else {
                                                let mut nr_sack = 0 as *mut sctp_nr_sack_chunk;
                                                nr_sack = ch as *mut sctp_nr_sack_chunk;
                                                cum_ack = ntohl((*nr_sack).nr_sack.cum_tsn_ack);
                                                num_seg =
                                                    ntohs((*nr_sack).nr_sack.num_gap_ack_blks);
                                                num_nr_seg =
                                                    ntohs((*nr_sack).nr_sack.num_nr_gap_ack_blks);
                                                num_dup = ntohs((*nr_sack).nr_sack.num_dup_tsns);
                                                a_rwnd = ntohl((*nr_sack).nr_sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_nr_sack_chunk>()
                                                    as libc::c_ulong)
                                                    .wrapping_add(
                                                        ((num_seg as libc::c_int
                                                            + num_nr_seg as libc::c_int)
                                                            as libc::c_ulong)
                                                            .wrapping_mul(::std::mem::size_of::<
                                                                sctp_gap_ack_block,
                                                            >(
                                                            )
                                                                as libc::c_ulong),
                                                    )
                                                    .wrapping_add(
                                                        (num_dup as libc::c_ulong).wrapping_mul(
                                                            ::std::mem::size_of::<uint32_t>()
                                                                as libc::c_ulong,
                                                        ),
                                                    )
                                                    != chk_length as libc::c_ulong
                                                {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x1000000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"Bad size of NR_SACK chunk\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    current_block = 13422570431586403309;
                                                } else {
                                                    offset_seg = (*offset as libc::c_ulong)
                                                        .wrapping_add(::std::mem::size_of::<
                                                            sctp_nr_sack_chunk,
                                                        >(
                                                        )
                                                            as libc::c_ulong)
                                                        as libc::c_int;
                                                    offset_dup = (offset_seg as libc::c_ulong)
                                                        .wrapping_add(
                                                            ((num_seg as libc::c_int
                                                                + num_nr_seg as libc::c_int)
                                                                as libc::c_ulong)
                                                                .wrapping_mul(
                                                                    ::std::mem::size_of::<
                                                                        sctp_gap_ack_block,
                                                                    >(
                                                                    )
                                                                        as libc::c_ulong,
                                                                ),
                                                        )
                                                        as libc::c_int;
                                                    current_block = 8752412851861032177;
                                                }
                                            }
                                            match current_block {
                                                13422570431586403309 => {}
                                                _ => {
                                                    let mut abort_now = 0i32;
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"%s process cum_ack:%x num_seg:%d a_rwnd:%d\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char,
                                                                                                                              if (*ch).chunk_type
                                                                                                                                     as
                                                                                                                                     libc::c_int
                                                                                                                                     ==
                                                                                                                                     0x3i32
                                                                                                                                 {
                                                                                                                                  b"SCTP_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              } else {
                                                                                                                                  b"SCTP_NR_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              },
                                                                                                                              cum_ack,
                                                                                                                              num_seg
                                                                                                                                  as
                                                                                                                                  libc::c_int,
                                                                                                                              a_rwnd);
                                                        }
                                                    }
                                                    (*stcb).asoc.seen_a_sack_this_pkt = 1u8;
                                                    if (*stcb).asoc.pr_sctp_cnt == 0u32
                                                        && num_seg as libc::c_int == 0i32
                                                        && num_nr_seg as libc::c_int == 0i32
                                                        && (cum_ack < (*stcb).asoc.last_acked_seq
                                                            && (*stcb)
                                                                .asoc
                                                                .last_acked_seq
                                                                .wrapping_sub(cum_ack)
                                                                > (1u32) << 31i32
                                                            || cum_ack
                                                                > (*stcb).asoc.last_acked_seq
                                                                && cum_ack.wrapping_sub(
                                                                    (*stcb).asoc.last_acked_seq,
                                                                ) < (1u32) << 31i32
                                                            || cum_ack
                                                                == (*stcb).asoc.last_acked_seq)
                                                        && (*stcb).asoc.saw_sack_with_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && (*stcb).asoc.saw_sack_with_nr_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && !(*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                    {
                                                        sctp_express_handle_sack(
                                                            stcb,
                                                            cum_ack,
                                                            a_rwnd,
                                                            &mut abort_now,
                                                            ecne_seen,
                                                        );
                                                    } else if !netp.is_null() && !(*netp).is_null()
                                                    {
                                                        sctp_handle_sack(
                                                            m,
                                                            offset_seg,
                                                            offset_dup,
                                                            stcb,
                                                            num_seg,
                                                            num_nr_seg,
                                                            num_dup,
                                                            &mut abort_now,
                                                            flags,
                                                            cum_ack,
                                                            a_rwnd,
                                                            ecne_seen,
                                                        );
                                                    }
                                                    if abort_now != 0 {
                                                        *offset = length;
                                                        return 0 as *mut sctp_tcb;
                                                    }
                                                    if (*stcb).asoc.send_queue.tqh_first.is_null()
                                                        && (*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                        && (*stcb).asoc.stream_queue_cnt == 0u32
                                                    {
                                                        sctp_ulp_notify(
                                                            26u32,
                                                            stcb,
                                                            0u32,
                                                            0 as *mut libc::c_void,
                                                            0i32,
                                                        );
                                                    }
                                                }
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    }
                                }
                            }
                        }
                        2349180396633407496 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_AUTHENTICATION\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null() {
                                if auth_skipped == 0i32 {
                                    auth_offset = *offset as uint32_t;
                                    auth_len = chk_length;
                                    auth_skipped = 1i32
                                }
                                current_block = 13422570431586403309;
                            } else if (*stcb).asoc.auth_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_auth_chunk>() as libc::c_ulong
                                    || chk_length as libc::c_ulong
                                        > (::std::mem::size_of::<sctp_auth_chunk>()
                                            as libc::c_ulong)
                                            .wrapping_add(32u64)
                                {
                                    *offset = length;
                                    return stcb;
                                }
                                if got_auth == 1i32 {
                                    current_block = 13422570431586403309;
                                } else {
                                    got_auth = 1i32;
                                    if ch.is_null()
                                        || sctp_handle_auth(
                                            stcb,
                                            ch as *mut sctp_auth_chunk,
                                            m,
                                            *offset as uint32_t,
                                        ) != 0
                                    {
                                        *offset = length;
                                        return stcb;
                                    } else {
                                        (*stcb).asoc.authenticated = 1u8
                                    }
                                    current_block = 13422570431586403309;
                                }
                            }
                        }
                        _ => {}
                    }
                    match current_block {
                        13422570431586403309 => {}
                        _ => {
                            if (*ch).chunk_type as libc::c_int & 0x40i32 != 0 && !stcb.is_null() {
                                op_err = sctp_get_mbuf_for_msg(
                                    ::std::mem::size_of::<sctp_gen_error_cause>() as libc::c_uint,
                                    0i32,
                                    0x1i32,
                                    1i32,
                                    1i32,
                                );
                                if !op_err.is_null() {
                                    let mut cause = 0 as *mut sctp_gen_error_cause;
                                    let mut len = 0;
                                    len = if (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                        > (length - *offset) as uint32_t
                                    {
                                        (length - *offset) as uint32_t
                                    } else {
                                        (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                    } as libc::c_int;
                                    cause = (*op_err).m_hdr.mh_data as *mut sctp_gen_error_cause;
                                    (*cause).code = htons(0x6u16);
                                    (*cause).length =
                                        htons((len as libc::c_ulong).wrapping_add(
                                            ::std::mem::size_of::<sctp_gen_error_cause>()
                                                as libc::c_ulong,
                                        )
                                            as uint16_t);
                                    (*op_err).m_hdr.mh_len =
                                        ::std::mem::size_of::<sctp_gen_error_cause>()
                                            as libc::c_int;
                                    (*op_err).m_hdr.mh_next = m_copym(m, *offset, len, 0x1i32);
                                    if !(*op_err).m_hdr.mh_next.is_null() {
                                        sctp_queue_op_err(stcb, op_err);
                                    } else {
                                        m_freem(op_err);
                                    }
                                }
                            }
                            if (*ch).chunk_type as libc::c_int & 0x80i32 == 0i32 {
                                *offset = length;
                                return stcb;
                            }
                        }
                    }
                }
                13 => {
                    current_block = 3371148184269687219;
                    match current_block {
                        17766256343850198083 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_COMPLETE, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_complete(
                                    ch as *mut sctp_shutdown_complete_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        12601157616349825580 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT_ACK\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0 {
                                } else {
                                    *offset = length;
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1di32);
                                    }
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                ret = sctp_handle_init_ack(
                                    m,
                                    iphlen,
                                    *offset,
                                    src,
                                    dst,
                                    sh,
                                    ch as *mut sctp_init_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_no_unlock,
                                    vrf_id,
                                )
                            } else {
                                ret = -(1i32)
                            }
                            *offset = length;
                            if abort_no_unlock != 0 {
                                return 0 as *mut sctp_tcb;
                            }
                            if !stcb.is_null() && ret == 0i32 {
                                sctp_chunk_output((*stcb).sctp_ep, stcb, 3i32, 0i32);
                            }
                            return stcb;
                        }
                        16195856799229720522 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                if !stcb.is_null() {
                                    pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                }
                                return 0 as *mut sctp_tcb;
                            }
                            if chk_length > (65535i32 - 2048i32) as libc::c_uint {
                                op_err = sctp_generate_cause(
                                    0x4u16,
                                    b"\x00" as *const u8 as *mut libc::c_char,
                                );
                                sctp_abort_association(
                                    inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id, port,
                                );
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            sctp_handle_init(
                                m,
                                iphlen,
                                *offset,
                                src,
                                dst,
                                sh,
                                ch as *mut sctp_init_chunk,
                                inp,
                                stcb,
                                *netp,
                                &mut abort_no_unlock,
                                vrf_id,
                                port,
                            );
                            *offset = length;
                            if abort_no_unlock == 0 && !stcb.is_null() {
                                pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                            }
                            return 0 as *mut sctp_tcb;
                        }
                        6246479402878884953 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_ack(
                                    ch as *mut sctp_shutdown_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        4558417918157925232 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ABORT, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            *offset = length;
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if sctp_handle_abort(ch as *mut sctp_abort_chunk, stcb, *netp) != 0
                                {
                                    return 0 as *mut sctp_tcb;
                                } else {
                                    return stcb;
                                }
                            } else {
                                return 0 as *mut sctp_tcb;
                            }
                        }
                        9379646460352968115 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ECHO, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && (*stcb).asoc.total_output_queue_size > 0u32 {
                                current_block = 15201865807353435331;
                            } else if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                current_block = 15767785092075175044;
                            } else {
                                current_block = 15201865807353435331;
                            }
                            match current_block {
                                15201865807353435331 => {
                                    if stcb.is_null()
                                        && (!((*inp).sctp_flags & 0x8u32 != 0u32)
                                            || (*inp).sctp_flags & 0x1u32 == 0
                                                && (*(*inp).sctp_socket).so_qlen as libc::c_int
                                                    >= (*(*inp).sctp_socket).so_qlimit
                                                        as libc::c_int)
                                    {
                                        if (*inp).sctp_flags & 0x2u32 != 0
                                            && system_base_info
                                                .sctpsysctl
                                                .sctp_abort_if_one_2_one_hits_limit
                                                != 0
                                        {
                                            op_err = sctp_generate_cause(
                                                0x4u16,
                                                b"\x00" as *const u8 as *mut libc::c_char,
                                            );
                                            sctp_abort_association(
                                                inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id,
                                                port,
                                            );
                                        }
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    } else {
                                        let mut linp = 0 as *mut sctp_inpcb;
                                        if !stcb.is_null() {
                                            linp = 0 as *mut sctp_inpcb
                                        } else {
                                            linp = inp
                                        }
                                        if !linp.is_null() {
                                            pthread_mutex_lock(&mut (*linp).inp_create_mtx);
                                            if (*inp).sctp_flags & 0x10000000u32 != 0
                                                || (*inp).sctp_flags & 0x20000000u32 != 0
                                            {
                                                pthread_mutex_unlock(&mut (*linp).inp_create_mtx);
                                                current_block = 15767785092075175044;
                                            } else {
                                                current_block = 2358125959230175008;
                                            }
                                        } else {
                                            current_block = 2358125959230175008;
                                        }
                                        match current_block {
                                            15767785092075175044 => {}
                                            _ => {
                                                let mut ret_buf = 0 as *mut mbuf;
                                                if !netp.is_null() {
                                                    let mut locked_stcb = 0 as *mut sctp_tcb;
                                                    locked_stcb = stcb;
                                                    ret_buf = sctp_handle_cookie_echo(
                                                        m,
                                                        iphlen,
                                                        *offset,
                                                        src,
                                                        dst,
                                                        sh,
                                                        ch as *mut sctp_cookie_echo_chunk,
                                                        &mut inp,
                                                        &mut stcb,
                                                        netp,
                                                        auth_skipped,
                                                        auth_offset,
                                                        auth_len,
                                                        &mut locked_stcb,
                                                        vrf_id,
                                                        port,
                                                    );
                                                    if !locked_stcb.is_null() && locked_stcb != stcb
                                                    {
                                                        pthread_mutex_unlock(
                                                            &mut (*locked_stcb).tcb_mtx,
                                                        );
                                                    }
                                                    !stcb.is_null();
                                                } else {
                                                    ret_buf = 0 as *mut mbuf
                                                }
                                                if !linp.is_null() {
                                                    pthread_mutex_unlock(
                                                        &mut (*linp).inp_create_mtx,
                                                    );
                                                }
                                                if ret_buf.is_null() {
                                                    if !stcb.is_null() {
                                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                                    }
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"GAK, null buffer\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    *offset = length;
                                                    return 0 as *mut sctp_tcb;
                                                }
                                                if auth_skipped != 0 {
                                                    got_auth = 1i32;
                                                    auth_skipped = 0i32
                                                }
                                                if !(*stcb).asoc.sent_queue.tqh_first.is_null() {
                                                    let mut chk = 0 as *mut sctp_tmit_chunk;
                                                    chk = (*stcb).asoc.sent_queue.tqh_first;
                                                    sctp_timer_start(
                                                        1i32,
                                                        (*stcb).sctp_ep,
                                                        stcb,
                                                        (*chk).whoTo,
                                                    );
                                                }
                                                current_block = 13422570431586403309;
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                            match current_block {
                                13422570431586403309 => {}
                                _ => {
                                    if !stcb.is_null() {
                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                    }
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                        }
                        10582330624169799780 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_PACKET_DROPPED\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_pktdrop_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !ch.is_null()
                                && !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                            {
                                if (*stcb).asoc.pktdrop_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_packet_dropped(
                                        ch as *mut sctp_pktdrop_chunk,
                                        stcb,
                                        *netp,
                                        if chk_length > contiguous {
                                            contiguous
                                        } else {
                                            chk_length
                                        },
                                    );
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13268550889959046632 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_STREAM_RESET\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || ch.is_null()
                                || (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_stream_reset_tsn_req>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.reconfig_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if sctp_handle_stream_reset(stcb, m, *offset, ch) != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                                current_block = 13422570431586403309;
                            }
                        }
                        13497718421940148126 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_FWD_TSN\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_forward_tsn_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.prsctp_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    let mut abort_flag_0 = 0i32;
                                    *fwd_tsn_seen = 1i32;
                                    if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1fi32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    (*stcb).asoc.last_data_chunk_from =
                                        (*stcb).asoc.last_control_chunk_from;
                                    sctp_handle_forward_tsn(
                                        stcb,
                                        ch as *mut sctp_forward_tsn_chunk,
                                        &mut abort_flag_0,
                                        m,
                                        *offset,
                                    );
                                    if abort_flag_0 != 0 {
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13226217046118304493 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_asconf_ack_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    if system_base_info.sctpsysctl.sctp_logging_level & 0x2000000u32
                                        != 0
                                    {
                                        sctp_misc_ints(
                                            120u8,
                                            (*stcb).asoc.overall_error_count,
                                            0u32,
                                            0x10000000u32,
                                            5531u32,
                                        );
                                    }
                                    (*stcb).asoc.overall_error_count = 0u32;
                                    sctp_handle_asconf_ack(
                                        m,
                                        *offset,
                                        ch as *mut sctp_asconf_ack_chunk,
                                        stcb,
                                        *netp,
                                        &mut abort_no_unlock,
                                    );
                                    if abort_no_unlock != 0 {
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        11399179239179359665 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_asconf(
                                        m,
                                        *offset as libc::c_uint,
                                        src,
                                        ch as *mut sctp_asconf_chunk,
                                        stcb,
                                        (asconf_cnt == 0i32) as libc::c_int,
                                    );
                                    asconf_cnt += 1;
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        3371148184269687219 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_CWR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cwr_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_cwr(ch as *mut sctp_cwr_chunk, stcb, *netp);
                                current_block = 13422570431586403309;
                            }
                        }
                        13594799726619700391 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_ECHO\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_ecne_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_echo(ch as *mut sctp_ecne_chunk, stcb);
                                ecne_seen = 1i32;
                                current_block = 13422570431586403309;
                            }
                        }
                        2781125740367032387 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cookie_ack_chunk>()
                                        as libc::c_ulong
                            {
                                return stcb;
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !(!stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0) {
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1ei32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                }
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_cookie_ack(
                                    ch as *mut sctp_cookie_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        17092723434217905016 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_OP_ERR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                                && sctp_handle_error(ch, stcb, *netp, contiguous) < 0i32
                            {
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            current_block = 13422570431586403309;
                        }
                        6770586402544785651 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_shutdown_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                let mut abort_flag = 0i32;
                                sctp_handle_shutdown(
                                    ch as *mut sctp_shutdown_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_flag,
                                );
                                if abort_flag != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            current_block = 13422570431586403309;
                        }
                        12945290292467802513 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_heartbeat_chunk>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvheartbeatack,
                                1u32,
                            );
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_heartbeat_ack(
                                    ch as *mut sctp_heartbeat_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        5491205026464363454 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                ::std::intrinsics::atomic_xadd(
                                    &mut system_base_info.sctpstat.sctps_recvheartbeat,
                                    1u32,
                                );
                                sctp_send_heartbeat_ack(
                                    stcb,
                                    m,
                                    *offset,
                                    chk_length as libc::c_int,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        7940804887512848672 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"%s\n\x00" as *const u8 as *const libc::c_char,
                                        if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                            b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                        } else {
                                            b"SCTP_NR_SACK\x00" as *const u8 as *const libc::c_char
                                        },
                                    );
                                }
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvsacks,
                                1u32,
                            );
                            if stcb.is_null() {
                                if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0 {
                                    if system_base_info.debug_printf.is_some() {
                                        system_base_info
                                            .debug_printf
                                            .expect("non-null function pointer")(
                                            b"No stcb when processing %s chunk\n\x00" as *const u8
                                                as *const libc::c_char,
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                            } else {
                                                b"SCTP_NR_SACK\x00" as *const u8
                                                    as *const libc::c_char
                                            },
                                        );
                                    }
                                }
                                current_block = 13422570431586403309;
                            } else {
                                if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                    if (chk_length as libc::c_ulong)
                                        < ::std::mem::size_of::<sctp_sack_chunk>() as libc::c_ulong
                                    {
                                        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32
                                            != 0
                                        {
                                            if system_base_info.debug_printf.is_some() {
                                                system_base_info
                                                    .debug_printf
                                                    .expect("non-null function pointer")(
                                                    b"Bad size on SACK chunk, too small\n\x00"
                                                        as *const u8
                                                        as *const libc::c_char,
                                                );
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    } else {
                                        current_block = 17937968408868551711;
                                    }
                                } else if (*stcb).asoc.nrsack_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_nr_sack_chunk>() as libc::c_ulong
                                {
                                    if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0
                                    {
                                        if system_base_info.debug_printf.is_some() {
                                            system_base_info
                                                .debug_printf
                                                .expect("non-null function pointer")(
                                                b"Bad size on NR_SACK chunk, too small\n\x00"
                                                    as *const u8
                                                    as *const libc::c_char,
                                            );
                                        }
                                    }
                                    current_block = 13422570431586403309;
                                } else {
                                    current_block = 17937968408868551711;
                                }
                                match current_block {
                                    6765806975593869225 => {}
                                    13422570431586403309 => {}
                                    _ => {
                                        if !((*stcb).asoc.state & 0x7fi32 == 0x40i32) {
                                            let mut a_rwnd = 0;
                                            let mut cum_ack = 0;
                                            let mut num_seg = 0;
                                            let mut num_nr_seg = 0;
                                            let mut num_dup = 0;
                                            let mut flags = 0;
                                            let mut offset_seg = 0;
                                            let mut offset_dup = 0;
                                            flags = (*ch).chunk_flags;
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                let mut sack = 0 as *mut sctp_sack_chunk;
                                                sack = ch as *mut sctp_sack_chunk;
                                                cum_ack = ntohl((*sack).sack.cum_tsn_ack);
                                                num_seg = ntohs((*sack).sack.num_gap_ack_blks);
                                                num_nr_seg = 0u16;
                                                num_dup = ntohs((*sack).sack.num_dup_tsns);
                                                a_rwnd = ntohl((*sack).sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_sack_chunk>()
                                                        as
                                                        libc::c_ulong).wrapping_add((num_seg
                                                                                         as
                                                                                         libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                         as
                                                                                                                         libc::c_ulong)).wrapping_add((num_dup
                                                                                                                                                           as
                                                                                                                                                           libc::c_ulong).wrapping_mul(::std::mem::size_of::<uint32_t>()
                                                                                                                                                                                           as
                                                                                                                                                                                           libc::c_ulong))
                                                       !=
                                                       chk_length as
                                                           libc::c_ulong {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                           &
                                                           0x1000000u32 !=
                                                           0 {
                                                        if system_base_info.debug_printf.is_some()
                                                           {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"Bad size of SACK chunk\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char);
                                                        }
                                                    }
                                                    current_block =
                                                        13422570431586403309;
                                                } else {
                                                    offset_seg =
                                                        (*offset as
                                                             libc::c_ulong).wrapping_add(::std::mem::size_of::<sctp_sack_chunk>()
                                                                                             as
                                                                                             libc::c_ulong)
                                                            as libc::c_int;
                                                    offset_dup =
                                                        (offset_seg as
                                                             libc::c_ulong).wrapping_add((num_seg
                                                                                              as
                                                                                              libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                              as
                                                                                                                              libc::c_ulong))
                                                            as libc::c_int;
                                                    current_block =
                                                        8752412851861032177;
                                                }
                                            } else {
                                                let mut nr_sack = 0 as *mut sctp_nr_sack_chunk;
                                                nr_sack = ch as *mut sctp_nr_sack_chunk;
                                                cum_ack = ntohl((*nr_sack).nr_sack.cum_tsn_ack);
                                                num_seg =
                                                    ntohs((*nr_sack).nr_sack.num_gap_ack_blks);
                                                num_nr_seg =
                                                    ntohs((*nr_sack).nr_sack.num_nr_gap_ack_blks);
                                                num_dup = ntohs((*nr_sack).nr_sack.num_dup_tsns);
                                                a_rwnd = ntohl((*nr_sack).nr_sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_nr_sack_chunk>()
                                                    as libc::c_ulong)
                                                    .wrapping_add(
                                                        ((num_seg as libc::c_int
                                                            + num_nr_seg as libc::c_int)
                                                            as libc::c_ulong)
                                                            .wrapping_mul(::std::mem::size_of::<
                                                                sctp_gap_ack_block,
                                                            >(
                                                            )
                                                                as libc::c_ulong),
                                                    )
                                                    .wrapping_add(
                                                        (num_dup as libc::c_ulong).wrapping_mul(
                                                            ::std::mem::size_of::<uint32_t>()
                                                                as libc::c_ulong,
                                                        ),
                                                    )
                                                    != chk_length as libc::c_ulong
                                                {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x1000000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"Bad size of NR_SACK chunk\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    current_block = 13422570431586403309;
                                                } else {
                                                    offset_seg = (*offset as libc::c_ulong)
                                                        .wrapping_add(::std::mem::size_of::<
                                                            sctp_nr_sack_chunk,
                                                        >(
                                                        )
                                                            as libc::c_ulong)
                                                        as libc::c_int;
                                                    offset_dup = (offset_seg as libc::c_ulong)
                                                        .wrapping_add(
                                                            ((num_seg as libc::c_int
                                                                + num_nr_seg as libc::c_int)
                                                                as libc::c_ulong)
                                                                .wrapping_mul(
                                                                    ::std::mem::size_of::<
                                                                        sctp_gap_ack_block,
                                                                    >(
                                                                    )
                                                                        as libc::c_ulong,
                                                                ),
                                                        )
                                                        as libc::c_int;
                                                    current_block = 8752412851861032177;
                                                }
                                            }
                                            match current_block {
                                                13422570431586403309 => {}
                                                _ => {
                                                    let mut abort_now = 0i32;
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"%s process cum_ack:%x num_seg:%d a_rwnd:%d\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char,
                                                                                                                              if (*ch).chunk_type
                                                                                                                                     as
                                                                                                                                     libc::c_int
                                                                                                                                     ==
                                                                                                                                     0x3i32
                                                                                                                                 {
                                                                                                                                  b"SCTP_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              } else {
                                                                                                                                  b"SCTP_NR_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              },
                                                                                                                              cum_ack,
                                                                                                                              num_seg
                                                                                                                                  as
                                                                                                                                  libc::c_int,
                                                                                                                              a_rwnd);
                                                        }
                                                    }
                                                    (*stcb).asoc.seen_a_sack_this_pkt = 1u8;
                                                    if (*stcb).asoc.pr_sctp_cnt == 0u32
                                                        && num_seg as libc::c_int == 0i32
                                                        && num_nr_seg as libc::c_int == 0i32
                                                        && (cum_ack < (*stcb).asoc.last_acked_seq
                                                            && (*stcb)
                                                                .asoc
                                                                .last_acked_seq
                                                                .wrapping_sub(cum_ack)
                                                                > (1u32) << 31i32
                                                            || cum_ack
                                                                > (*stcb).asoc.last_acked_seq
                                                                && cum_ack.wrapping_sub(
                                                                    (*stcb).asoc.last_acked_seq,
                                                                ) < (1u32) << 31i32
                                                            || cum_ack
                                                                == (*stcb).asoc.last_acked_seq)
                                                        && (*stcb).asoc.saw_sack_with_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && (*stcb).asoc.saw_sack_with_nr_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && !(*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                    {
                                                        sctp_express_handle_sack(
                                                            stcb,
                                                            cum_ack,
                                                            a_rwnd,
                                                            &mut abort_now,
                                                            ecne_seen,
                                                        );
                                                    } else if !netp.is_null() && !(*netp).is_null()
                                                    {
                                                        sctp_handle_sack(
                                                            m,
                                                            offset_seg,
                                                            offset_dup,
                                                            stcb,
                                                            num_seg,
                                                            num_nr_seg,
                                                            num_dup,
                                                            &mut abort_now,
                                                            flags,
                                                            cum_ack,
                                                            a_rwnd,
                                                            ecne_seen,
                                                        );
                                                    }
                                                    if abort_now != 0 {
                                                        *offset = length;
                                                        return 0 as *mut sctp_tcb;
                                                    }
                                                    if (*stcb).asoc.send_queue.tqh_first.is_null()
                                                        && (*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                        && (*stcb).asoc.stream_queue_cnt == 0u32
                                                    {
                                                        sctp_ulp_notify(
                                                            26u32,
                                                            stcb,
                                                            0u32,
                                                            0 as *mut libc::c_void,
                                                            0i32,
                                                        );
                                                    }
                                                }
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    }
                                }
                            }
                        }
                        2349180396633407496 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_AUTHENTICATION\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null() {
                                if auth_skipped == 0i32 {
                                    auth_offset = *offset as uint32_t;
                                    auth_len = chk_length;
                                    auth_skipped = 1i32
                                }
                                current_block = 13422570431586403309;
                            } else if (*stcb).asoc.auth_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_auth_chunk>() as libc::c_ulong
                                    || chk_length as libc::c_ulong
                                        > (::std::mem::size_of::<sctp_auth_chunk>()
                                            as libc::c_ulong)
                                            .wrapping_add(32u64)
                                {
                                    *offset = length;
                                    return stcb;
                                }
                                if got_auth == 1i32 {
                                    current_block = 13422570431586403309;
                                } else {
                                    got_auth = 1i32;
                                    if ch.is_null()
                                        || sctp_handle_auth(
                                            stcb,
                                            ch as *mut sctp_auth_chunk,
                                            m,
                                            *offset as uint32_t,
                                        ) != 0
                                    {
                                        *offset = length;
                                        return stcb;
                                    } else {
                                        (*stcb).asoc.authenticated = 1u8
                                    }
                                    current_block = 13422570431586403309;
                                }
                            }
                        }
                        _ => {}
                    }
                    match current_block {
                        13422570431586403309 => {}
                        _ => {
                            if (*ch).chunk_type as libc::c_int & 0x40i32 != 0 && !stcb.is_null() {
                                op_err = sctp_get_mbuf_for_msg(
                                    ::std::mem::size_of::<sctp_gen_error_cause>() as libc::c_uint,
                                    0i32,
                                    0x1i32,
                                    1i32,
                                    1i32,
                                );
                                if !op_err.is_null() {
                                    let mut cause = 0 as *mut sctp_gen_error_cause;
                                    let mut len = 0;
                                    len = if (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                        > (length - *offset) as uint32_t
                                    {
                                        (length - *offset) as uint32_t
                                    } else {
                                        (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                    } as libc::c_int;
                                    cause = (*op_err).m_hdr.mh_data as *mut sctp_gen_error_cause;
                                    (*cause).code = htons(0x6u16);
                                    (*cause).length =
                                        htons((len as libc::c_ulong).wrapping_add(
                                            ::std::mem::size_of::<sctp_gen_error_cause>()
                                                as libc::c_ulong,
                                        )
                                            as uint16_t);
                                    (*op_err).m_hdr.mh_len =
                                        ::std::mem::size_of::<sctp_gen_error_cause>()
                                            as libc::c_int;
                                    (*op_err).m_hdr.mh_next = m_copym(m, *offset, len, 0x1i32);
                                    if !(*op_err).m_hdr.mh_next.is_null() {
                                        sctp_queue_op_err(stcb, op_err);
                                    } else {
                                        m_freem(op_err);
                                    }
                                }
                            }
                            if (*ch).chunk_type as libc::c_int & 0x80i32 == 0i32 {
                                *offset = length;
                                return stcb;
                            }
                        }
                    }
                }
                14 => {
                    current_block = 17766256343850198083;
                    match current_block {
                        17766256343850198083 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_COMPLETE, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_complete(
                                    ch as *mut sctp_shutdown_complete_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        12601157616349825580 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT_ACK\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0 {
                                } else {
                                    *offset = length;
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1di32);
                                    }
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                ret = sctp_handle_init_ack(
                                    m,
                                    iphlen,
                                    *offset,
                                    src,
                                    dst,
                                    sh,
                                    ch as *mut sctp_init_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_no_unlock,
                                    vrf_id,
                                )
                            } else {
                                ret = -(1i32)
                            }
                            *offset = length;
                            if abort_no_unlock != 0 {
                                return 0 as *mut sctp_tcb;
                            }
                            if !stcb.is_null() && ret == 0i32 {
                                sctp_chunk_output((*stcb).sctp_ep, stcb, 3i32, 0i32);
                            }
                            return stcb;
                        }
                        16195856799229720522 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                if !stcb.is_null() {
                                    pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                }
                                return 0 as *mut sctp_tcb;
                            }
                            if chk_length > (65535i32 - 2048i32) as libc::c_uint {
                                op_err = sctp_generate_cause(
                                    0x4u16,
                                    b"\x00" as *const u8 as *mut libc::c_char,
                                );
                                sctp_abort_association(
                                    inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id, port,
                                );
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            sctp_handle_init(
                                m,
                                iphlen,
                                *offset,
                                src,
                                dst,
                                sh,
                                ch as *mut sctp_init_chunk,
                                inp,
                                stcb,
                                *netp,
                                &mut abort_no_unlock,
                                vrf_id,
                                port,
                            );
                            *offset = length;
                            if abort_no_unlock == 0 && !stcb.is_null() {
                                pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                            }
                            return 0 as *mut sctp_tcb;
                        }
                        6246479402878884953 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_ack(
                                    ch as *mut sctp_shutdown_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        4558417918157925232 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ABORT, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            *offset = length;
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if sctp_handle_abort(ch as *mut sctp_abort_chunk, stcb, *netp) != 0
                                {
                                    return 0 as *mut sctp_tcb;
                                } else {
                                    return stcb;
                                }
                            } else {
                                return 0 as *mut sctp_tcb;
                            }
                        }
                        9379646460352968115 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ECHO, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && (*stcb).asoc.total_output_queue_size > 0u32 {
                                current_block = 15201865807353435331;
                            } else if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                current_block = 15767785092075175044;
                            } else {
                                current_block = 15201865807353435331;
                            }
                            match current_block {
                                15201865807353435331 => {
                                    if stcb.is_null()
                                        && (!((*inp).sctp_flags & 0x8u32 != 0u32)
                                            || (*inp).sctp_flags & 0x1u32 == 0
                                                && (*(*inp).sctp_socket).so_qlen as libc::c_int
                                                    >= (*(*inp).sctp_socket).so_qlimit
                                                        as libc::c_int)
                                    {
                                        if (*inp).sctp_flags & 0x2u32 != 0
                                            && system_base_info
                                                .sctpsysctl
                                                .sctp_abort_if_one_2_one_hits_limit
                                                != 0
                                        {
                                            op_err = sctp_generate_cause(
                                                0x4u16,
                                                b"\x00" as *const u8 as *mut libc::c_char,
                                            );
                                            sctp_abort_association(
                                                inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id,
                                                port,
                                            );
                                        }
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    } else {
                                        let mut linp = 0 as *mut sctp_inpcb;
                                        if !stcb.is_null() {
                                            linp = 0 as *mut sctp_inpcb
                                        } else {
                                            linp = inp
                                        }
                                        if !linp.is_null() {
                                            pthread_mutex_lock(&mut (*linp).inp_create_mtx);
                                            if (*inp).sctp_flags & 0x10000000u32 != 0
                                                || (*inp).sctp_flags & 0x20000000u32 != 0
                                            {
                                                pthread_mutex_unlock(&mut (*linp).inp_create_mtx);
                                                current_block = 15767785092075175044;
                                            } else {
                                                current_block = 2358125959230175008;
                                            }
                                        } else {
                                            current_block = 2358125959230175008;
                                        }
                                        match current_block {
                                            15767785092075175044 => {}
                                            _ => {
                                                let mut ret_buf = 0 as *mut mbuf;
                                                if !netp.is_null() {
                                                    let mut locked_stcb = 0 as *mut sctp_tcb;
                                                    locked_stcb = stcb;
                                                    ret_buf = sctp_handle_cookie_echo(
                                                        m,
                                                        iphlen,
                                                        *offset,
                                                        src,
                                                        dst,
                                                        sh,
                                                        ch as *mut sctp_cookie_echo_chunk,
                                                        &mut inp,
                                                        &mut stcb,
                                                        netp,
                                                        auth_skipped,
                                                        auth_offset,
                                                        auth_len,
                                                        &mut locked_stcb,
                                                        vrf_id,
                                                        port,
                                                    );
                                                    if !locked_stcb.is_null() && locked_stcb != stcb
                                                    {
                                                        pthread_mutex_unlock(
                                                            &mut (*locked_stcb).tcb_mtx,
                                                        );
                                                    }
                                                    !stcb.is_null();
                                                } else {
                                                    ret_buf = 0 as *mut mbuf
                                                }
                                                if !linp.is_null() {
                                                    pthread_mutex_unlock(
                                                        &mut (*linp).inp_create_mtx,
                                                    );
                                                }
                                                if ret_buf.is_null() {
                                                    if !stcb.is_null() {
                                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                                    }
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"GAK, null buffer\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    *offset = length;
                                                    return 0 as *mut sctp_tcb;
                                                }
                                                if auth_skipped != 0 {
                                                    got_auth = 1i32;
                                                    auth_skipped = 0i32
                                                }
                                                if !(*stcb).asoc.sent_queue.tqh_first.is_null() {
                                                    let mut chk = 0 as *mut sctp_tmit_chunk;
                                                    chk = (*stcb).asoc.sent_queue.tqh_first;
                                                    sctp_timer_start(
                                                        1i32,
                                                        (*stcb).sctp_ep,
                                                        stcb,
                                                        (*chk).whoTo,
                                                    );
                                                }
                                                current_block = 13422570431586403309;
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                            match current_block {
                                13422570431586403309 => {}
                                _ => {
                                    if !stcb.is_null() {
                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                    }
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                        }
                        10582330624169799780 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_PACKET_DROPPED\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_pktdrop_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !ch.is_null()
                                && !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                            {
                                if (*stcb).asoc.pktdrop_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_packet_dropped(
                                        ch as *mut sctp_pktdrop_chunk,
                                        stcb,
                                        *netp,
                                        if chk_length > contiguous {
                                            contiguous
                                        } else {
                                            chk_length
                                        },
                                    );
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13268550889959046632 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_STREAM_RESET\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || ch.is_null()
                                || (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_stream_reset_tsn_req>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.reconfig_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if sctp_handle_stream_reset(stcb, m, *offset, ch) != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                                current_block = 13422570431586403309;
                            }
                        }
                        13497718421940148126 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_FWD_TSN\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_forward_tsn_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.prsctp_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    let mut abort_flag_0 = 0i32;
                                    *fwd_tsn_seen = 1i32;
                                    if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1fi32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    (*stcb).asoc.last_data_chunk_from =
                                        (*stcb).asoc.last_control_chunk_from;
                                    sctp_handle_forward_tsn(
                                        stcb,
                                        ch as *mut sctp_forward_tsn_chunk,
                                        &mut abort_flag_0,
                                        m,
                                        *offset,
                                    );
                                    if abort_flag_0 != 0 {
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13226217046118304493 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_asconf_ack_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    if system_base_info.sctpsysctl.sctp_logging_level & 0x2000000u32
                                        != 0
                                    {
                                        sctp_misc_ints(
                                            120u8,
                                            (*stcb).asoc.overall_error_count,
                                            0u32,
                                            0x10000000u32,
                                            5531u32,
                                        );
                                    }
                                    (*stcb).asoc.overall_error_count = 0u32;
                                    sctp_handle_asconf_ack(
                                        m,
                                        *offset,
                                        ch as *mut sctp_asconf_ack_chunk,
                                        stcb,
                                        *netp,
                                        &mut abort_no_unlock,
                                    );
                                    if abort_no_unlock != 0 {
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        11399179239179359665 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_asconf(
                                        m,
                                        *offset as libc::c_uint,
                                        src,
                                        ch as *mut sctp_asconf_chunk,
                                        stcb,
                                        (asconf_cnt == 0i32) as libc::c_int,
                                    );
                                    asconf_cnt += 1;
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        3371148184269687219 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_CWR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cwr_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_cwr(ch as *mut sctp_cwr_chunk, stcb, *netp);
                                current_block = 13422570431586403309;
                            }
                        }
                        13594799726619700391 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_ECHO\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_ecne_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_echo(ch as *mut sctp_ecne_chunk, stcb);
                                ecne_seen = 1i32;
                                current_block = 13422570431586403309;
                            }
                        }
                        2781125740367032387 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cookie_ack_chunk>()
                                        as libc::c_ulong
                            {
                                return stcb;
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !(!stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0) {
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1ei32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                }
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_cookie_ack(
                                    ch as *mut sctp_cookie_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        17092723434217905016 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_OP_ERR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                                && sctp_handle_error(ch, stcb, *netp, contiguous) < 0i32
                            {
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            current_block = 13422570431586403309;
                        }
                        6770586402544785651 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_shutdown_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                let mut abort_flag = 0i32;
                                sctp_handle_shutdown(
                                    ch as *mut sctp_shutdown_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_flag,
                                );
                                if abort_flag != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            current_block = 13422570431586403309;
                        }
                        12945290292467802513 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_heartbeat_chunk>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvheartbeatack,
                                1u32,
                            );
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_heartbeat_ack(
                                    ch as *mut sctp_heartbeat_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        5491205026464363454 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                ::std::intrinsics::atomic_xadd(
                                    &mut system_base_info.sctpstat.sctps_recvheartbeat,
                                    1u32,
                                );
                                sctp_send_heartbeat_ack(
                                    stcb,
                                    m,
                                    *offset,
                                    chk_length as libc::c_int,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        7940804887512848672 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"%s\n\x00" as *const u8 as *const libc::c_char,
                                        if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                            b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                        } else {
                                            b"SCTP_NR_SACK\x00" as *const u8 as *const libc::c_char
                                        },
                                    );
                                }
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvsacks,
                                1u32,
                            );
                            if stcb.is_null() {
                                if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0 {
                                    if system_base_info.debug_printf.is_some() {
                                        system_base_info
                                            .debug_printf
                                            .expect("non-null function pointer")(
                                            b"No stcb when processing %s chunk\n\x00" as *const u8
                                                as *const libc::c_char,
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                            } else {
                                                b"SCTP_NR_SACK\x00" as *const u8
                                                    as *const libc::c_char
                                            },
                                        );
                                    }
                                }
                                current_block = 13422570431586403309;
                            } else {
                                if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                    if (chk_length as libc::c_ulong)
                                        < ::std::mem::size_of::<sctp_sack_chunk>() as libc::c_ulong
                                    {
                                        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32
                                            != 0
                                        {
                                            if system_base_info.debug_printf.is_some() {
                                                system_base_info
                                                    .debug_printf
                                                    .expect("non-null function pointer")(
                                                    b"Bad size on SACK chunk, too small\n\x00"
                                                        as *const u8
                                                        as *const libc::c_char,
                                                );
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    } else {
                                        current_block = 17937968408868551711;
                                    }
                                } else if (*stcb).asoc.nrsack_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_nr_sack_chunk>() as libc::c_ulong
                                {
                                    if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0
                                    {
                                        if system_base_info.debug_printf.is_some() {
                                            system_base_info
                                                .debug_printf
                                                .expect("non-null function pointer")(
                                                b"Bad size on NR_SACK chunk, too small\n\x00"
                                                    as *const u8
                                                    as *const libc::c_char,
                                            );
                                        }
                                    }
                                    current_block = 13422570431586403309;
                                } else {
                                    current_block = 17937968408868551711;
                                }
                                match current_block {
                                    6765806975593869225 => {}
                                    13422570431586403309 => {}
                                    _ => {
                                        if !((*stcb).asoc.state & 0x7fi32 == 0x40i32) {
                                            let mut a_rwnd = 0;
                                            let mut cum_ack = 0;
                                            let mut num_seg = 0;
                                            let mut num_nr_seg = 0;
                                            let mut num_dup = 0;
                                            let mut flags = 0;
                                            let mut offset_seg = 0;
                                            let mut offset_dup = 0;
                                            flags = (*ch).chunk_flags;
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                let mut sack = 0 as *mut sctp_sack_chunk;
                                                sack = ch as *mut sctp_sack_chunk;
                                                cum_ack = ntohl((*sack).sack.cum_tsn_ack);
                                                num_seg = ntohs((*sack).sack.num_gap_ack_blks);
                                                num_nr_seg = 0u16;
                                                num_dup = ntohs((*sack).sack.num_dup_tsns);
                                                a_rwnd = ntohl((*sack).sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_sack_chunk>()
                                                        as
                                                        libc::c_ulong).wrapping_add((num_seg
                                                                                         as
                                                                                         libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                         as
                                                                                                                         libc::c_ulong)).wrapping_add((num_dup
                                                                                                                                                           as
                                                                                                                                                           libc::c_ulong).wrapping_mul(::std::mem::size_of::<uint32_t>()
                                                                                                                                                                                           as
                                                                                                                                                                                           libc::c_ulong))
                                                       !=
                                                       chk_length as
                                                           libc::c_ulong {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                           &
                                                           0x1000000u32 !=
                                                           0 {
                                                        if system_base_info.debug_printf.is_some()
                                                           {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"Bad size of SACK chunk\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char);
                                                        }
                                                    }
                                                    current_block =
                                                        13422570431586403309;
                                                } else {
                                                    offset_seg =
                                                        (*offset as
                                                             libc::c_ulong).wrapping_add(::std::mem::size_of::<sctp_sack_chunk>()
                                                                                             as
                                                                                             libc::c_ulong)
                                                            as libc::c_int;
                                                    offset_dup =
                                                        (offset_seg as
                                                             libc::c_ulong).wrapping_add((num_seg
                                                                                              as
                                                                                              libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                              as
                                                                                                                              libc::c_ulong))
                                                            as libc::c_int;
                                                    current_block =
                                                        8752412851861032177;
                                                }
                                            } else {
                                                let mut nr_sack = 0 as *mut sctp_nr_sack_chunk;
                                                nr_sack = ch as *mut sctp_nr_sack_chunk;
                                                cum_ack = ntohl((*nr_sack).nr_sack.cum_tsn_ack);
                                                num_seg =
                                                    ntohs((*nr_sack).nr_sack.num_gap_ack_blks);
                                                num_nr_seg =
                                                    ntohs((*nr_sack).nr_sack.num_nr_gap_ack_blks);
                                                num_dup = ntohs((*nr_sack).nr_sack.num_dup_tsns);
                                                a_rwnd = ntohl((*nr_sack).nr_sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_nr_sack_chunk>()
                                                    as libc::c_ulong)
                                                    .wrapping_add(
                                                        ((num_seg as libc::c_int
                                                            + num_nr_seg as libc::c_int)
                                                            as libc::c_ulong)
                                                            .wrapping_mul(::std::mem::size_of::<
                                                                sctp_gap_ack_block,
                                                            >(
                                                            )
                                                                as libc::c_ulong),
                                                    )
                                                    .wrapping_add(
                                                        (num_dup as libc::c_ulong).wrapping_mul(
                                                            ::std::mem::size_of::<uint32_t>()
                                                                as libc::c_ulong,
                                                        ),
                                                    )
                                                    != chk_length as libc::c_ulong
                                                {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x1000000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"Bad size of NR_SACK chunk\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    current_block = 13422570431586403309;
                                                } else {
                                                    offset_seg = (*offset as libc::c_ulong)
                                                        .wrapping_add(::std::mem::size_of::<
                                                            sctp_nr_sack_chunk,
                                                        >(
                                                        )
                                                            as libc::c_ulong)
                                                        as libc::c_int;
                                                    offset_dup = (offset_seg as libc::c_ulong)
                                                        .wrapping_add(
                                                            ((num_seg as libc::c_int
                                                                + num_nr_seg as libc::c_int)
                                                                as libc::c_ulong)
                                                                .wrapping_mul(
                                                                    ::std::mem::size_of::<
                                                                        sctp_gap_ack_block,
                                                                    >(
                                                                    )
                                                                        as libc::c_ulong,
                                                                ),
                                                        )
                                                        as libc::c_int;
                                                    current_block = 8752412851861032177;
                                                }
                                            }
                                            match current_block {
                                                13422570431586403309 => {}
                                                _ => {
                                                    let mut abort_now = 0i32;
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"%s process cum_ack:%x num_seg:%d a_rwnd:%d\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char,
                                                                                                                              if (*ch).chunk_type
                                                                                                                                     as
                                                                                                                                     libc::c_int
                                                                                                                                     ==
                                                                                                                                     0x3i32
                                                                                                                                 {
                                                                                                                                  b"SCTP_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              } else {
                                                                                                                                  b"SCTP_NR_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              },
                                                                                                                              cum_ack,
                                                                                                                              num_seg
                                                                                                                                  as
                                                                                                                                  libc::c_int,
                                                                                                                              a_rwnd);
                                                        }
                                                    }
                                                    (*stcb).asoc.seen_a_sack_this_pkt = 1u8;
                                                    if (*stcb).asoc.pr_sctp_cnt == 0u32
                                                        && num_seg as libc::c_int == 0i32
                                                        && num_nr_seg as libc::c_int == 0i32
                                                        && (cum_ack < (*stcb).asoc.last_acked_seq
                                                            && (*stcb)
                                                                .asoc
                                                                .last_acked_seq
                                                                .wrapping_sub(cum_ack)
                                                                > (1u32) << 31i32
                                                            || cum_ack
                                                                > (*stcb).asoc.last_acked_seq
                                                                && cum_ack.wrapping_sub(
                                                                    (*stcb).asoc.last_acked_seq,
                                                                ) < (1u32) << 31i32
                                                            || cum_ack
                                                                == (*stcb).asoc.last_acked_seq)
                                                        && (*stcb).asoc.saw_sack_with_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && (*stcb).asoc.saw_sack_with_nr_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && !(*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                    {
                                                        sctp_express_handle_sack(
                                                            stcb,
                                                            cum_ack,
                                                            a_rwnd,
                                                            &mut abort_now,
                                                            ecne_seen,
                                                        );
                                                    } else if !netp.is_null() && !(*netp).is_null()
                                                    {
                                                        sctp_handle_sack(
                                                            m,
                                                            offset_seg,
                                                            offset_dup,
                                                            stcb,
                                                            num_seg,
                                                            num_nr_seg,
                                                            num_dup,
                                                            &mut abort_now,
                                                            flags,
                                                            cum_ack,
                                                            a_rwnd,
                                                            ecne_seen,
                                                        );
                                                    }
                                                    if abort_now != 0 {
                                                        *offset = length;
                                                        return 0 as *mut sctp_tcb;
                                                    }
                                                    if (*stcb).asoc.send_queue.tqh_first.is_null()
                                                        && (*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                        && (*stcb).asoc.stream_queue_cnt == 0u32
                                                    {
                                                        sctp_ulp_notify(
                                                            26u32,
                                                            stcb,
                                                            0u32,
                                                            0 as *mut libc::c_void,
                                                            0i32,
                                                        );
                                                    }
                                                }
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    }
                                }
                            }
                        }
                        2349180396633407496 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_AUTHENTICATION\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null() {
                                if auth_skipped == 0i32 {
                                    auth_offset = *offset as uint32_t;
                                    auth_len = chk_length;
                                    auth_skipped = 1i32
                                }
                                current_block = 13422570431586403309;
                            } else if (*stcb).asoc.auth_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_auth_chunk>() as libc::c_ulong
                                    || chk_length as libc::c_ulong
                                        > (::std::mem::size_of::<sctp_auth_chunk>()
                                            as libc::c_ulong)
                                            .wrapping_add(32u64)
                                {
                                    *offset = length;
                                    return stcb;
                                }
                                if got_auth == 1i32 {
                                    current_block = 13422570431586403309;
                                } else {
                                    got_auth = 1i32;
                                    if ch.is_null()
                                        || sctp_handle_auth(
                                            stcb,
                                            ch as *mut sctp_auth_chunk,
                                            m,
                                            *offset as uint32_t,
                                        ) != 0
                                    {
                                        *offset = length;
                                        return stcb;
                                    } else {
                                        (*stcb).asoc.authenticated = 1u8
                                    }
                                    current_block = 13422570431586403309;
                                }
                            }
                        }
                        _ => {}
                    }
                    match current_block {
                        13422570431586403309 => {}
                        _ => {
                            if (*ch).chunk_type as libc::c_int & 0x40i32 != 0 && !stcb.is_null() {
                                op_err = sctp_get_mbuf_for_msg(
                                    ::std::mem::size_of::<sctp_gen_error_cause>() as libc::c_uint,
                                    0i32,
                                    0x1i32,
                                    1i32,
                                    1i32,
                                );
                                if !op_err.is_null() {
                                    let mut cause = 0 as *mut sctp_gen_error_cause;
                                    let mut len = 0;
                                    len = if (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                        > (length - *offset) as uint32_t
                                    {
                                        (length - *offset) as uint32_t
                                    } else {
                                        (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                    } as libc::c_int;
                                    cause = (*op_err).m_hdr.mh_data as *mut sctp_gen_error_cause;
                                    (*cause).code = htons(0x6u16);
                                    (*cause).length =
                                        htons((len as libc::c_ulong).wrapping_add(
                                            ::std::mem::size_of::<sctp_gen_error_cause>()
                                                as libc::c_ulong,
                                        )
                                            as uint16_t);
                                    (*op_err).m_hdr.mh_len =
                                        ::std::mem::size_of::<sctp_gen_error_cause>()
                                            as libc::c_int;
                                    (*op_err).m_hdr.mh_next = m_copym(m, *offset, len, 0x1i32);
                                    if !(*op_err).m_hdr.mh_next.is_null() {
                                        sctp_queue_op_err(stcb, op_err);
                                    } else {
                                        m_freem(op_err);
                                    }
                                }
                            }
                            if (*ch).chunk_type as libc::c_int & 0x80i32 == 0i32 {
                                *offset = length;
                                return stcb;
                            }
                        }
                    }
                }
                193 => {
                    current_block = 11399179239179359665;
                    match current_block {
                        17766256343850198083 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_COMPLETE, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_complete(
                                    ch as *mut sctp_shutdown_complete_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        12601157616349825580 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT_ACK\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0 {
                                } else {
                                    *offset = length;
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1di32);
                                    }
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                ret = sctp_handle_init_ack(
                                    m,
                                    iphlen,
                                    *offset,
                                    src,
                                    dst,
                                    sh,
                                    ch as *mut sctp_init_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_no_unlock,
                                    vrf_id,
                                )
                            } else {
                                ret = -(1i32)
                            }
                            *offset = length;
                            if abort_no_unlock != 0 {
                                return 0 as *mut sctp_tcb;
                            }
                            if !stcb.is_null() && ret == 0i32 {
                                sctp_chunk_output((*stcb).sctp_ep, stcb, 3i32, 0i32);
                            }
                            return stcb;
                        }
                        16195856799229720522 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                if !stcb.is_null() {
                                    pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                }
                                return 0 as *mut sctp_tcb;
                            }
                            if chk_length > (65535i32 - 2048i32) as libc::c_uint {
                                op_err = sctp_generate_cause(
                                    0x4u16,
                                    b"\x00" as *const u8 as *mut libc::c_char,
                                );
                                sctp_abort_association(
                                    inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id, port,
                                );
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            sctp_handle_init(
                                m,
                                iphlen,
                                *offset,
                                src,
                                dst,
                                sh,
                                ch as *mut sctp_init_chunk,
                                inp,
                                stcb,
                                *netp,
                                &mut abort_no_unlock,
                                vrf_id,
                                port,
                            );
                            *offset = length;
                            if abort_no_unlock == 0 && !stcb.is_null() {
                                pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                            }
                            return 0 as *mut sctp_tcb;
                        }
                        6246479402878884953 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_ack(
                                    ch as *mut sctp_shutdown_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        4558417918157925232 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ABORT, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            *offset = length;
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if sctp_handle_abort(ch as *mut sctp_abort_chunk, stcb, *netp) != 0
                                {
                                    return 0 as *mut sctp_tcb;
                                } else {
                                    return stcb;
                                }
                            } else {
                                return 0 as *mut sctp_tcb;
                            }
                        }
                        9379646460352968115 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ECHO, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && (*stcb).asoc.total_output_queue_size > 0u32 {
                                current_block = 15201865807353435331;
                            } else if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                current_block = 15767785092075175044;
                            } else {
                                current_block = 15201865807353435331;
                            }
                            match current_block {
                                15201865807353435331 => {
                                    if stcb.is_null()
                                        && (!((*inp).sctp_flags & 0x8u32 != 0u32)
                                            || (*inp).sctp_flags & 0x1u32 == 0
                                                && (*(*inp).sctp_socket).so_qlen as libc::c_int
                                                    >= (*(*inp).sctp_socket).so_qlimit
                                                        as libc::c_int)
                                    {
                                        if (*inp).sctp_flags & 0x2u32 != 0
                                            && system_base_info
                                                .sctpsysctl
                                                .sctp_abort_if_one_2_one_hits_limit
                                                != 0
                                        {
                                            op_err = sctp_generate_cause(
                                                0x4u16,
                                                b"\x00" as *const u8 as *mut libc::c_char,
                                            );
                                            sctp_abort_association(
                                                inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id,
                                                port,
                                            );
                                        }
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    } else {
                                        let mut linp = 0 as *mut sctp_inpcb;
                                        if !stcb.is_null() {
                                            linp = 0 as *mut sctp_inpcb
                                        } else {
                                            linp = inp
                                        }
                                        if !linp.is_null() {
                                            pthread_mutex_lock(&mut (*linp).inp_create_mtx);
                                            if (*inp).sctp_flags & 0x10000000u32 != 0
                                                || (*inp).sctp_flags & 0x20000000u32 != 0
                                            {
                                                pthread_mutex_unlock(&mut (*linp).inp_create_mtx);
                                                current_block = 15767785092075175044;
                                            } else {
                                                current_block = 2358125959230175008;
                                            }
                                        } else {
                                            current_block = 2358125959230175008;
                                        }
                                        match current_block {
                                            15767785092075175044 => {}
                                            _ => {
                                                let mut ret_buf = 0 as *mut mbuf;
                                                if !netp.is_null() {
                                                    let mut locked_stcb = 0 as *mut sctp_tcb;
                                                    locked_stcb = stcb;
                                                    ret_buf = sctp_handle_cookie_echo(
                                                        m,
                                                        iphlen,
                                                        *offset,
                                                        src,
                                                        dst,
                                                        sh,
                                                        ch as *mut sctp_cookie_echo_chunk,
                                                        &mut inp,
                                                        &mut stcb,
                                                        netp,
                                                        auth_skipped,
                                                        auth_offset,
                                                        auth_len,
                                                        &mut locked_stcb,
                                                        vrf_id,
                                                        port,
                                                    );
                                                    if !locked_stcb.is_null() && locked_stcb != stcb
                                                    {
                                                        pthread_mutex_unlock(
                                                            &mut (*locked_stcb).tcb_mtx,
                                                        );
                                                    }
                                                    !stcb.is_null();
                                                } else {
                                                    ret_buf = 0 as *mut mbuf
                                                }
                                                if !linp.is_null() {
                                                    pthread_mutex_unlock(
                                                        &mut (*linp).inp_create_mtx,
                                                    );
                                                }
                                                if ret_buf.is_null() {
                                                    if !stcb.is_null() {
                                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                                    }
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"GAK, null buffer\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    *offset = length;
                                                    return 0 as *mut sctp_tcb;
                                                }
                                                if auth_skipped != 0 {
                                                    got_auth = 1i32;
                                                    auth_skipped = 0i32
                                                }
                                                if !(*stcb).asoc.sent_queue.tqh_first.is_null() {
                                                    let mut chk = 0 as *mut sctp_tmit_chunk;
                                                    chk = (*stcb).asoc.sent_queue.tqh_first;
                                                    sctp_timer_start(
                                                        1i32,
                                                        (*stcb).sctp_ep,
                                                        stcb,
                                                        (*chk).whoTo,
                                                    );
                                                }
                                                current_block = 13422570431586403309;
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                            match current_block {
                                13422570431586403309 => {}
                                _ => {
                                    if !stcb.is_null() {
                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                    }
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                        }
                        10582330624169799780 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_PACKET_DROPPED\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_pktdrop_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !ch.is_null()
                                && !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                            {
                                if (*stcb).asoc.pktdrop_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_packet_dropped(
                                        ch as *mut sctp_pktdrop_chunk,
                                        stcb,
                                        *netp,
                                        if chk_length > contiguous {
                                            contiguous
                                        } else {
                                            chk_length
                                        },
                                    );
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13268550889959046632 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_STREAM_RESET\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || ch.is_null()
                                || (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_stream_reset_tsn_req>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.reconfig_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if sctp_handle_stream_reset(stcb, m, *offset, ch) != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                                current_block = 13422570431586403309;
                            }
                        }
                        13497718421940148126 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_FWD_TSN\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_forward_tsn_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.prsctp_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    let mut abort_flag_0 = 0i32;
                                    *fwd_tsn_seen = 1i32;
                                    if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1fi32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    (*stcb).asoc.last_data_chunk_from =
                                        (*stcb).asoc.last_control_chunk_from;
                                    sctp_handle_forward_tsn(
                                        stcb,
                                        ch as *mut sctp_forward_tsn_chunk,
                                        &mut abort_flag_0,
                                        m,
                                        *offset,
                                    );
                                    if abort_flag_0 != 0 {
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13226217046118304493 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_asconf_ack_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    if system_base_info.sctpsysctl.sctp_logging_level & 0x2000000u32
                                        != 0
                                    {
                                        sctp_misc_ints(
                                            120u8,
                                            (*stcb).asoc.overall_error_count,
                                            0u32,
                                            0x10000000u32,
                                            5531u32,
                                        );
                                    }
                                    (*stcb).asoc.overall_error_count = 0u32;
                                    sctp_handle_asconf_ack(
                                        m,
                                        *offset,
                                        ch as *mut sctp_asconf_ack_chunk,
                                        stcb,
                                        *netp,
                                        &mut abort_no_unlock,
                                    );
                                    if abort_no_unlock != 0 {
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        11399179239179359665 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_asconf(
                                        m,
                                        *offset as libc::c_uint,
                                        src,
                                        ch as *mut sctp_asconf_chunk,
                                        stcb,
                                        (asconf_cnt == 0i32) as libc::c_int,
                                    );
                                    asconf_cnt += 1;
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        3371148184269687219 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_CWR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cwr_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_cwr(ch as *mut sctp_cwr_chunk, stcb, *netp);
                                current_block = 13422570431586403309;
                            }
                        }
                        13594799726619700391 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_ECHO\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_ecne_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_echo(ch as *mut sctp_ecne_chunk, stcb);
                                ecne_seen = 1i32;
                                current_block = 13422570431586403309;
                            }
                        }
                        2781125740367032387 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cookie_ack_chunk>()
                                        as libc::c_ulong
                            {
                                return stcb;
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !(!stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0) {
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1ei32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                }
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_cookie_ack(
                                    ch as *mut sctp_cookie_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        17092723434217905016 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_OP_ERR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                                && sctp_handle_error(ch, stcb, *netp, contiguous) < 0i32
                            {
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            current_block = 13422570431586403309;
                        }
                        6770586402544785651 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_shutdown_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                let mut abort_flag = 0i32;
                                sctp_handle_shutdown(
                                    ch as *mut sctp_shutdown_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_flag,
                                );
                                if abort_flag != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            current_block = 13422570431586403309;
                        }
                        12945290292467802513 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_heartbeat_chunk>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvheartbeatack,
                                1u32,
                            );
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_heartbeat_ack(
                                    ch as *mut sctp_heartbeat_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        5491205026464363454 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                ::std::intrinsics::atomic_xadd(
                                    &mut system_base_info.sctpstat.sctps_recvheartbeat,
                                    1u32,
                                );
                                sctp_send_heartbeat_ack(
                                    stcb,
                                    m,
                                    *offset,
                                    chk_length as libc::c_int,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        7940804887512848672 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"%s\n\x00" as *const u8 as *const libc::c_char,
                                        if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                            b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                        } else {
                                            b"SCTP_NR_SACK\x00" as *const u8 as *const libc::c_char
                                        },
                                    );
                                }
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvsacks,
                                1u32,
                            );
                            if stcb.is_null() {
                                if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0 {
                                    if system_base_info.debug_printf.is_some() {
                                        system_base_info
                                            .debug_printf
                                            .expect("non-null function pointer")(
                                            b"No stcb when processing %s chunk\n\x00" as *const u8
                                                as *const libc::c_char,
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                            } else {
                                                b"SCTP_NR_SACK\x00" as *const u8
                                                    as *const libc::c_char
                                            },
                                        );
                                    }
                                }
                                current_block = 13422570431586403309;
                            } else {
                                if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                    if (chk_length as libc::c_ulong)
                                        < ::std::mem::size_of::<sctp_sack_chunk>() as libc::c_ulong
                                    {
                                        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32
                                            != 0
                                        {
                                            if system_base_info.debug_printf.is_some() {
                                                system_base_info
                                                    .debug_printf
                                                    .expect("non-null function pointer")(
                                                    b"Bad size on SACK chunk, too small\n\x00"
                                                        as *const u8
                                                        as *const libc::c_char,
                                                );
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    } else {
                                        current_block = 17937968408868551711;
                                    }
                                } else if (*stcb).asoc.nrsack_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_nr_sack_chunk>() as libc::c_ulong
                                {
                                    if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0
                                    {
                                        if system_base_info.debug_printf.is_some() {
                                            system_base_info
                                                .debug_printf
                                                .expect("non-null function pointer")(
                                                b"Bad size on NR_SACK chunk, too small\n\x00"
                                                    as *const u8
                                                    as *const libc::c_char,
                                            );
                                        }
                                    }
                                    current_block = 13422570431586403309;
                                } else {
                                    current_block = 17937968408868551711;
                                }
                                match current_block {
                                    6765806975593869225 => {}
                                    13422570431586403309 => {}
                                    _ => {
                                        if !((*stcb).asoc.state & 0x7fi32 == 0x40i32) {
                                            let mut a_rwnd = 0;
                                            let mut cum_ack = 0;
                                            let mut num_seg = 0;
                                            let mut num_nr_seg = 0;
                                            let mut num_dup = 0;
                                            let mut flags = 0;
                                            let mut offset_seg = 0;
                                            let mut offset_dup = 0;
                                            flags = (*ch).chunk_flags;
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                let mut sack = 0 as *mut sctp_sack_chunk;
                                                sack = ch as *mut sctp_sack_chunk;
                                                cum_ack = ntohl((*sack).sack.cum_tsn_ack);
                                                num_seg = ntohs((*sack).sack.num_gap_ack_blks);
                                                num_nr_seg = 0u16;
                                                num_dup = ntohs((*sack).sack.num_dup_tsns);
                                                a_rwnd = ntohl((*sack).sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_sack_chunk>()
                                                        as
                                                        libc::c_ulong).wrapping_add((num_seg
                                                                                         as
                                                                                         libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                         as
                                                                                                                         libc::c_ulong)).wrapping_add((num_dup
                                                                                                                                                           as
                                                                                                                                                           libc::c_ulong).wrapping_mul(::std::mem::size_of::<uint32_t>()
                                                                                                                                                                                           as
                                                                                                                                                                                           libc::c_ulong))
                                                       !=
                                                       chk_length as
                                                           libc::c_ulong {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                           &
                                                           0x1000000u32 !=
                                                           0 {
                                                        if system_base_info.debug_printf.is_some()
                                                           {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"Bad size of SACK chunk\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char);
                                                        }
                                                    }
                                                    current_block =
                                                        13422570431586403309;
                                                } else {
                                                    offset_seg =
                                                        (*offset as
                                                             libc::c_ulong).wrapping_add(::std::mem::size_of::<sctp_sack_chunk>()
                                                                                             as
                                                                                             libc::c_ulong)
                                                            as libc::c_int;
                                                    offset_dup =
                                                        (offset_seg as
                                                             libc::c_ulong).wrapping_add((num_seg
                                                                                              as
                                                                                              libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                              as
                                                                                                                              libc::c_ulong))
                                                            as libc::c_int;
                                                    current_block =
                                                        8752412851861032177;
                                                }
                                            } else {
                                                let mut nr_sack = 0 as *mut sctp_nr_sack_chunk;
                                                nr_sack = ch as *mut sctp_nr_sack_chunk;
                                                cum_ack = ntohl((*nr_sack).nr_sack.cum_tsn_ack);
                                                num_seg =
                                                    ntohs((*nr_sack).nr_sack.num_gap_ack_blks);
                                                num_nr_seg =
                                                    ntohs((*nr_sack).nr_sack.num_nr_gap_ack_blks);
                                                num_dup = ntohs((*nr_sack).nr_sack.num_dup_tsns);
                                                a_rwnd = ntohl((*nr_sack).nr_sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_nr_sack_chunk>()
                                                    as libc::c_ulong)
                                                    .wrapping_add(
                                                        ((num_seg as libc::c_int
                                                            + num_nr_seg as libc::c_int)
                                                            as libc::c_ulong)
                                                            .wrapping_mul(::std::mem::size_of::<
                                                                sctp_gap_ack_block,
                                                            >(
                                                            )
                                                                as libc::c_ulong),
                                                    )
                                                    .wrapping_add(
                                                        (num_dup as libc::c_ulong).wrapping_mul(
                                                            ::std::mem::size_of::<uint32_t>()
                                                                as libc::c_ulong,
                                                        ),
                                                    )
                                                    != chk_length as libc::c_ulong
                                                {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x1000000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"Bad size of NR_SACK chunk\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    current_block = 13422570431586403309;
                                                } else {
                                                    offset_seg = (*offset as libc::c_ulong)
                                                        .wrapping_add(::std::mem::size_of::<
                                                            sctp_nr_sack_chunk,
                                                        >(
                                                        )
                                                            as libc::c_ulong)
                                                        as libc::c_int;
                                                    offset_dup = (offset_seg as libc::c_ulong)
                                                        .wrapping_add(
                                                            ((num_seg as libc::c_int
                                                                + num_nr_seg as libc::c_int)
                                                                as libc::c_ulong)
                                                                .wrapping_mul(
                                                                    ::std::mem::size_of::<
                                                                        sctp_gap_ack_block,
                                                                    >(
                                                                    )
                                                                        as libc::c_ulong,
                                                                ),
                                                        )
                                                        as libc::c_int;
                                                    current_block = 8752412851861032177;
                                                }
                                            }
                                            match current_block {
                                                13422570431586403309 => {}
                                                _ => {
                                                    let mut abort_now = 0i32;
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"%s process cum_ack:%x num_seg:%d a_rwnd:%d\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char,
                                                                                                                              if (*ch).chunk_type
                                                                                                                                     as
                                                                                                                                     libc::c_int
                                                                                                                                     ==
                                                                                                                                     0x3i32
                                                                                                                                 {
                                                                                                                                  b"SCTP_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              } else {
                                                                                                                                  b"SCTP_NR_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              },
                                                                                                                              cum_ack,
                                                                                                                              num_seg
                                                                                                                                  as
                                                                                                                                  libc::c_int,
                                                                                                                              a_rwnd);
                                                        }
                                                    }
                                                    (*stcb).asoc.seen_a_sack_this_pkt = 1u8;
                                                    if (*stcb).asoc.pr_sctp_cnt == 0u32
                                                        && num_seg as libc::c_int == 0i32
                                                        && num_nr_seg as libc::c_int == 0i32
                                                        && (cum_ack < (*stcb).asoc.last_acked_seq
                                                            && (*stcb)
                                                                .asoc
                                                                .last_acked_seq
                                                                .wrapping_sub(cum_ack)
                                                                > (1u32) << 31i32
                                                            || cum_ack
                                                                > (*stcb).asoc.last_acked_seq
                                                                && cum_ack.wrapping_sub(
                                                                    (*stcb).asoc.last_acked_seq,
                                                                ) < (1u32) << 31i32
                                                            || cum_ack
                                                                == (*stcb).asoc.last_acked_seq)
                                                        && (*stcb).asoc.saw_sack_with_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && (*stcb).asoc.saw_sack_with_nr_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && !(*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                    {
                                                        sctp_express_handle_sack(
                                                            stcb,
                                                            cum_ack,
                                                            a_rwnd,
                                                            &mut abort_now,
                                                            ecne_seen,
                                                        );
                                                    } else if !netp.is_null() && !(*netp).is_null()
                                                    {
                                                        sctp_handle_sack(
                                                            m,
                                                            offset_seg,
                                                            offset_dup,
                                                            stcb,
                                                            num_seg,
                                                            num_nr_seg,
                                                            num_dup,
                                                            &mut abort_now,
                                                            flags,
                                                            cum_ack,
                                                            a_rwnd,
                                                            ecne_seen,
                                                        );
                                                    }
                                                    if abort_now != 0 {
                                                        *offset = length;
                                                        return 0 as *mut sctp_tcb;
                                                    }
                                                    if (*stcb).asoc.send_queue.tqh_first.is_null()
                                                        && (*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                        && (*stcb).asoc.stream_queue_cnt == 0u32
                                                    {
                                                        sctp_ulp_notify(
                                                            26u32,
                                                            stcb,
                                                            0u32,
                                                            0 as *mut libc::c_void,
                                                            0i32,
                                                        );
                                                    }
                                                }
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    }
                                }
                            }
                        }
                        2349180396633407496 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_AUTHENTICATION\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null() {
                                if auth_skipped == 0i32 {
                                    auth_offset = *offset as uint32_t;
                                    auth_len = chk_length;
                                    auth_skipped = 1i32
                                }
                                current_block = 13422570431586403309;
                            } else if (*stcb).asoc.auth_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_auth_chunk>() as libc::c_ulong
                                    || chk_length as libc::c_ulong
                                        > (::std::mem::size_of::<sctp_auth_chunk>()
                                            as libc::c_ulong)
                                            .wrapping_add(32u64)
                                {
                                    *offset = length;
                                    return stcb;
                                }
                                if got_auth == 1i32 {
                                    current_block = 13422570431586403309;
                                } else {
                                    got_auth = 1i32;
                                    if ch.is_null()
                                        || sctp_handle_auth(
                                            stcb,
                                            ch as *mut sctp_auth_chunk,
                                            m,
                                            *offset as uint32_t,
                                        ) != 0
                                    {
                                        *offset = length;
                                        return stcb;
                                    } else {
                                        (*stcb).asoc.authenticated = 1u8
                                    }
                                    current_block = 13422570431586403309;
                                }
                            }
                        }
                        _ => {}
                    }
                    match current_block {
                        13422570431586403309 => {}
                        _ => {
                            if (*ch).chunk_type as libc::c_int & 0x40i32 != 0 && !stcb.is_null() {
                                op_err = sctp_get_mbuf_for_msg(
                                    ::std::mem::size_of::<sctp_gen_error_cause>() as libc::c_uint,
                                    0i32,
                                    0x1i32,
                                    1i32,
                                    1i32,
                                );
                                if !op_err.is_null() {
                                    let mut cause = 0 as *mut sctp_gen_error_cause;
                                    let mut len = 0;
                                    len = if (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                        > (length - *offset) as uint32_t
                                    {
                                        (length - *offset) as uint32_t
                                    } else {
                                        (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                    } as libc::c_int;
                                    cause = (*op_err).m_hdr.mh_data as *mut sctp_gen_error_cause;
                                    (*cause).code = htons(0x6u16);
                                    (*cause).length =
                                        htons((len as libc::c_ulong).wrapping_add(
                                            ::std::mem::size_of::<sctp_gen_error_cause>()
                                                as libc::c_ulong,
                                        )
                                            as uint16_t);
                                    (*op_err).m_hdr.mh_len =
                                        ::std::mem::size_of::<sctp_gen_error_cause>()
                                            as libc::c_int;
                                    (*op_err).m_hdr.mh_next = m_copym(m, *offset, len, 0x1i32);
                                    if !(*op_err).m_hdr.mh_next.is_null() {
                                        sctp_queue_op_err(stcb, op_err);
                                    } else {
                                        m_freem(op_err);
                                    }
                                }
                            }
                            if (*ch).chunk_type as libc::c_int & 0x80i32 == 0i32 {
                                *offset = length;
                                return stcb;
                            }
                        }
                    }
                }
                128 => {
                    current_block = 13226217046118304493;
                    match current_block {
                        17766256343850198083 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_COMPLETE, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_complete(
                                    ch as *mut sctp_shutdown_complete_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        12601157616349825580 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT_ACK\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0 {
                                } else {
                                    *offset = length;
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1di32);
                                    }
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                ret = sctp_handle_init_ack(
                                    m,
                                    iphlen,
                                    *offset,
                                    src,
                                    dst,
                                    sh,
                                    ch as *mut sctp_init_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_no_unlock,
                                    vrf_id,
                                )
                            } else {
                                ret = -(1i32)
                            }
                            *offset = length;
                            if abort_no_unlock != 0 {
                                return 0 as *mut sctp_tcb;
                            }
                            if !stcb.is_null() && ret == 0i32 {
                                sctp_chunk_output((*stcb).sctp_ep, stcb, 3i32, 0i32);
                            }
                            return stcb;
                        }
                        16195856799229720522 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                if !stcb.is_null() {
                                    pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                }
                                return 0 as *mut sctp_tcb;
                            }
                            if chk_length > (65535i32 - 2048i32) as libc::c_uint {
                                op_err = sctp_generate_cause(
                                    0x4u16,
                                    b"\x00" as *const u8 as *mut libc::c_char,
                                );
                                sctp_abort_association(
                                    inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id, port,
                                );
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            sctp_handle_init(
                                m,
                                iphlen,
                                *offset,
                                src,
                                dst,
                                sh,
                                ch as *mut sctp_init_chunk,
                                inp,
                                stcb,
                                *netp,
                                &mut abort_no_unlock,
                                vrf_id,
                                port,
                            );
                            *offset = length;
                            if abort_no_unlock == 0 && !stcb.is_null() {
                                pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                            }
                            return 0 as *mut sctp_tcb;
                        }
                        6246479402878884953 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_ack(
                                    ch as *mut sctp_shutdown_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        4558417918157925232 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ABORT, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            *offset = length;
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if sctp_handle_abort(ch as *mut sctp_abort_chunk, stcb, *netp) != 0
                                {
                                    return 0 as *mut sctp_tcb;
                                } else {
                                    return stcb;
                                }
                            } else {
                                return 0 as *mut sctp_tcb;
                            }
                        }
                        9379646460352968115 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ECHO, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && (*stcb).asoc.total_output_queue_size > 0u32 {
                                current_block = 15201865807353435331;
                            } else if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                current_block = 15767785092075175044;
                            } else {
                                current_block = 15201865807353435331;
                            }
                            match current_block {
                                15201865807353435331 => {
                                    if stcb.is_null()
                                        && (!((*inp).sctp_flags & 0x8u32 != 0u32)
                                            || (*inp).sctp_flags & 0x1u32 == 0
                                                && (*(*inp).sctp_socket).so_qlen as libc::c_int
                                                    >= (*(*inp).sctp_socket).so_qlimit
                                                        as libc::c_int)
                                    {
                                        if (*inp).sctp_flags & 0x2u32 != 0
                                            && system_base_info
                                                .sctpsysctl
                                                .sctp_abort_if_one_2_one_hits_limit
                                                != 0
                                        {
                                            op_err = sctp_generate_cause(
                                                0x4u16,
                                                b"\x00" as *const u8 as *mut libc::c_char,
                                            );
                                            sctp_abort_association(
                                                inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id,
                                                port,
                                            );
                                        }
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    } else {
                                        let mut linp = 0 as *mut sctp_inpcb;
                                        if !stcb.is_null() {
                                            linp = 0 as *mut sctp_inpcb
                                        } else {
                                            linp = inp
                                        }
                                        if !linp.is_null() {
                                            pthread_mutex_lock(&mut (*linp).inp_create_mtx);
                                            if (*inp).sctp_flags & 0x10000000u32 != 0
                                                || (*inp).sctp_flags & 0x20000000u32 != 0
                                            {
                                                pthread_mutex_unlock(&mut (*linp).inp_create_mtx);
                                                current_block = 15767785092075175044;
                                            } else {
                                                current_block = 2358125959230175008;
                                            }
                                        } else {
                                            current_block = 2358125959230175008;
                                        }
                                        match current_block {
                                            15767785092075175044 => {}
                                            _ => {
                                                let mut ret_buf = 0 as *mut mbuf;
                                                if !netp.is_null() {
                                                    let mut locked_stcb = 0 as *mut sctp_tcb;
                                                    locked_stcb = stcb;
                                                    ret_buf = sctp_handle_cookie_echo(
                                                        m,
                                                        iphlen,
                                                        *offset,
                                                        src,
                                                        dst,
                                                        sh,
                                                        ch as *mut sctp_cookie_echo_chunk,
                                                        &mut inp,
                                                        &mut stcb,
                                                        netp,
                                                        auth_skipped,
                                                        auth_offset,
                                                        auth_len,
                                                        &mut locked_stcb,
                                                        vrf_id,
                                                        port,
                                                    );
                                                    if !locked_stcb.is_null() && locked_stcb != stcb
                                                    {
                                                        pthread_mutex_unlock(
                                                            &mut (*locked_stcb).tcb_mtx,
                                                        );
                                                    }
                                                    !stcb.is_null();
                                                } else {
                                                    ret_buf = 0 as *mut mbuf
                                                }
                                                if !linp.is_null() {
                                                    pthread_mutex_unlock(
                                                        &mut (*linp).inp_create_mtx,
                                                    );
                                                }
                                                if ret_buf.is_null() {
                                                    if !stcb.is_null() {
                                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                                    }
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"GAK, null buffer\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    *offset = length;
                                                    return 0 as *mut sctp_tcb;
                                                }
                                                if auth_skipped != 0 {
                                                    got_auth = 1i32;
                                                    auth_skipped = 0i32
                                                }
                                                if !(*stcb).asoc.sent_queue.tqh_first.is_null() {
                                                    let mut chk = 0 as *mut sctp_tmit_chunk;
                                                    chk = (*stcb).asoc.sent_queue.tqh_first;
                                                    sctp_timer_start(
                                                        1i32,
                                                        (*stcb).sctp_ep,
                                                        stcb,
                                                        (*chk).whoTo,
                                                    );
                                                }
                                                current_block = 13422570431586403309;
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                            match current_block {
                                13422570431586403309 => {}
                                _ => {
                                    if !stcb.is_null() {
                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                    }
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                        }
                        10582330624169799780 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_PACKET_DROPPED\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_pktdrop_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !ch.is_null()
                                && !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                            {
                                if (*stcb).asoc.pktdrop_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_packet_dropped(
                                        ch as *mut sctp_pktdrop_chunk,
                                        stcb,
                                        *netp,
                                        if chk_length > contiguous {
                                            contiguous
                                        } else {
                                            chk_length
                                        },
                                    );
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13268550889959046632 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_STREAM_RESET\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || ch.is_null()
                                || (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_stream_reset_tsn_req>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.reconfig_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if sctp_handle_stream_reset(stcb, m, *offset, ch) != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                                current_block = 13422570431586403309;
                            }
                        }
                        13497718421940148126 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_FWD_TSN\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_forward_tsn_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.prsctp_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    let mut abort_flag_0 = 0i32;
                                    *fwd_tsn_seen = 1i32;
                                    if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1fi32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    (*stcb).asoc.last_data_chunk_from =
                                        (*stcb).asoc.last_control_chunk_from;
                                    sctp_handle_forward_tsn(
                                        stcb,
                                        ch as *mut sctp_forward_tsn_chunk,
                                        &mut abort_flag_0,
                                        m,
                                        *offset,
                                    );
                                    if abort_flag_0 != 0 {
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13226217046118304493 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_asconf_ack_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    if system_base_info.sctpsysctl.sctp_logging_level & 0x2000000u32
                                        != 0
                                    {
                                        sctp_misc_ints(
                                            120u8,
                                            (*stcb).asoc.overall_error_count,
                                            0u32,
                                            0x10000000u32,
                                            5531u32,
                                        );
                                    }
                                    (*stcb).asoc.overall_error_count = 0u32;
                                    sctp_handle_asconf_ack(
                                        m,
                                        *offset,
                                        ch as *mut sctp_asconf_ack_chunk,
                                        stcb,
                                        *netp,
                                        &mut abort_no_unlock,
                                    );
                                    if abort_no_unlock != 0 {
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        11399179239179359665 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_asconf(
                                        m,
                                        *offset as libc::c_uint,
                                        src,
                                        ch as *mut sctp_asconf_chunk,
                                        stcb,
                                        (asconf_cnt == 0i32) as libc::c_int,
                                    );
                                    asconf_cnt += 1;
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        3371148184269687219 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_CWR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cwr_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_cwr(ch as *mut sctp_cwr_chunk, stcb, *netp);
                                current_block = 13422570431586403309;
                            }
                        }
                        13594799726619700391 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_ECHO\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_ecne_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_echo(ch as *mut sctp_ecne_chunk, stcb);
                                ecne_seen = 1i32;
                                current_block = 13422570431586403309;
                            }
                        }
                        2781125740367032387 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cookie_ack_chunk>()
                                        as libc::c_ulong
                            {
                                return stcb;
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !(!stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0) {
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1ei32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                }
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_cookie_ack(
                                    ch as *mut sctp_cookie_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        17092723434217905016 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_OP_ERR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                                && sctp_handle_error(ch, stcb, *netp, contiguous) < 0i32
                            {
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            current_block = 13422570431586403309;
                        }
                        6770586402544785651 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_shutdown_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                let mut abort_flag = 0i32;
                                sctp_handle_shutdown(
                                    ch as *mut sctp_shutdown_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_flag,
                                );
                                if abort_flag != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            current_block = 13422570431586403309;
                        }
                        12945290292467802513 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_heartbeat_chunk>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvheartbeatack,
                                1u32,
                            );
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_heartbeat_ack(
                                    ch as *mut sctp_heartbeat_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        5491205026464363454 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                ::std::intrinsics::atomic_xadd(
                                    &mut system_base_info.sctpstat.sctps_recvheartbeat,
                                    1u32,
                                );
                                sctp_send_heartbeat_ack(
                                    stcb,
                                    m,
                                    *offset,
                                    chk_length as libc::c_int,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        7940804887512848672 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"%s\n\x00" as *const u8 as *const libc::c_char,
                                        if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                            b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                        } else {
                                            b"SCTP_NR_SACK\x00" as *const u8 as *const libc::c_char
                                        },
                                    );
                                }
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvsacks,
                                1u32,
                            );
                            if stcb.is_null() {
                                if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0 {
                                    if system_base_info.debug_printf.is_some() {
                                        system_base_info
                                            .debug_printf
                                            .expect("non-null function pointer")(
                                            b"No stcb when processing %s chunk\n\x00" as *const u8
                                                as *const libc::c_char,
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                            } else {
                                                b"SCTP_NR_SACK\x00" as *const u8
                                                    as *const libc::c_char
                                            },
                                        );
                                    }
                                }
                                current_block = 13422570431586403309;
                            } else {
                                if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                    if (chk_length as libc::c_ulong)
                                        < ::std::mem::size_of::<sctp_sack_chunk>() as libc::c_ulong
                                    {
                                        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32
                                            != 0
                                        {
                                            if system_base_info.debug_printf.is_some() {
                                                system_base_info
                                                    .debug_printf
                                                    .expect("non-null function pointer")(
                                                    b"Bad size on SACK chunk, too small\n\x00"
                                                        as *const u8
                                                        as *const libc::c_char,
                                                );
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    } else {
                                        current_block = 17937968408868551711;
                                    }
                                } else if (*stcb).asoc.nrsack_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_nr_sack_chunk>() as libc::c_ulong
                                {
                                    if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0
                                    {
                                        if system_base_info.debug_printf.is_some() {
                                            system_base_info
                                                .debug_printf
                                                .expect("non-null function pointer")(
                                                b"Bad size on NR_SACK chunk, too small\n\x00"
                                                    as *const u8
                                                    as *const libc::c_char,
                                            );
                                        }
                                    }
                                    current_block = 13422570431586403309;
                                } else {
                                    current_block = 17937968408868551711;
                                }
                                match current_block {
                                    6765806975593869225 => {}
                                    13422570431586403309 => {}
                                    _ => {
                                        if !((*stcb).asoc.state & 0x7fi32 == 0x40i32) {
                                            let mut a_rwnd = 0;
                                            let mut cum_ack = 0;
                                            let mut num_seg = 0;
                                            let mut num_nr_seg = 0;
                                            let mut num_dup = 0;
                                            let mut flags = 0;
                                            let mut offset_seg = 0;
                                            let mut offset_dup = 0;
                                            flags = (*ch).chunk_flags;
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                let mut sack = 0 as *mut sctp_sack_chunk;
                                                sack = ch as *mut sctp_sack_chunk;
                                                cum_ack = ntohl((*sack).sack.cum_tsn_ack);
                                                num_seg = ntohs((*sack).sack.num_gap_ack_blks);
                                                num_nr_seg = 0u16;
                                                num_dup = ntohs((*sack).sack.num_dup_tsns);
                                                a_rwnd = ntohl((*sack).sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_sack_chunk>()
                                                        as
                                                        libc::c_ulong).wrapping_add((num_seg
                                                                                         as
                                                                                         libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                         as
                                                                                                                         libc::c_ulong)).wrapping_add((num_dup
                                                                                                                                                           as
                                                                                                                                                           libc::c_ulong).wrapping_mul(::std::mem::size_of::<uint32_t>()
                                                                                                                                                                                           as
                                                                                                                                                                                           libc::c_ulong))
                                                       !=
                                                       chk_length as
                                                           libc::c_ulong {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                           &
                                                           0x1000000u32 !=
                                                           0 {
                                                        if system_base_info.debug_printf.is_some()
                                                           {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"Bad size of SACK chunk\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char);
                                                        }
                                                    }
                                                    current_block =
                                                        13422570431586403309;
                                                } else {
                                                    offset_seg =
                                                        (*offset as
                                                             libc::c_ulong).wrapping_add(::std::mem::size_of::<sctp_sack_chunk>()
                                                                                             as
                                                                                             libc::c_ulong)
                                                            as libc::c_int;
                                                    offset_dup =
                                                        (offset_seg as
                                                             libc::c_ulong).wrapping_add((num_seg
                                                                                              as
                                                                                              libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                              as
                                                                                                                              libc::c_ulong))
                                                            as libc::c_int;
                                                    current_block =
                                                        8752412851861032177;
                                                }
                                            } else {
                                                let mut nr_sack = 0 as *mut sctp_nr_sack_chunk;
                                                nr_sack = ch as *mut sctp_nr_sack_chunk;
                                                cum_ack = ntohl((*nr_sack).nr_sack.cum_tsn_ack);
                                                num_seg =
                                                    ntohs((*nr_sack).nr_sack.num_gap_ack_blks);
                                                num_nr_seg =
                                                    ntohs((*nr_sack).nr_sack.num_nr_gap_ack_blks);
                                                num_dup = ntohs((*nr_sack).nr_sack.num_dup_tsns);
                                                a_rwnd = ntohl((*nr_sack).nr_sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_nr_sack_chunk>()
                                                    as libc::c_ulong)
                                                    .wrapping_add(
                                                        ((num_seg as libc::c_int
                                                            + num_nr_seg as libc::c_int)
                                                            as libc::c_ulong)
                                                            .wrapping_mul(::std::mem::size_of::<
                                                                sctp_gap_ack_block,
                                                            >(
                                                            )
                                                                as libc::c_ulong),
                                                    )
                                                    .wrapping_add(
                                                        (num_dup as libc::c_ulong).wrapping_mul(
                                                            ::std::mem::size_of::<uint32_t>()
                                                                as libc::c_ulong,
                                                        ),
                                                    )
                                                    != chk_length as libc::c_ulong
                                                {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x1000000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"Bad size of NR_SACK chunk\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    current_block = 13422570431586403309;
                                                } else {
                                                    offset_seg = (*offset as libc::c_ulong)
                                                        .wrapping_add(::std::mem::size_of::<
                                                            sctp_nr_sack_chunk,
                                                        >(
                                                        )
                                                            as libc::c_ulong)
                                                        as libc::c_int;
                                                    offset_dup = (offset_seg as libc::c_ulong)
                                                        .wrapping_add(
                                                            ((num_seg as libc::c_int
                                                                + num_nr_seg as libc::c_int)
                                                                as libc::c_ulong)
                                                                .wrapping_mul(
                                                                    ::std::mem::size_of::<
                                                                        sctp_gap_ack_block,
                                                                    >(
                                                                    )
                                                                        as libc::c_ulong,
                                                                ),
                                                        )
                                                        as libc::c_int;
                                                    current_block = 8752412851861032177;
                                                }
                                            }
                                            match current_block {
                                                13422570431586403309 => {}
                                                _ => {
                                                    let mut abort_now = 0i32;
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"%s process cum_ack:%x num_seg:%d a_rwnd:%d\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char,
                                                                                                                              if (*ch).chunk_type
                                                                                                                                     as
                                                                                                                                     libc::c_int
                                                                                                                                     ==
                                                                                                                                     0x3i32
                                                                                                                                 {
                                                                                                                                  b"SCTP_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              } else {
                                                                                                                                  b"SCTP_NR_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              },
                                                                                                                              cum_ack,
                                                                                                                              num_seg
                                                                                                                                  as
                                                                                                                                  libc::c_int,
                                                                                                                              a_rwnd);
                                                        }
                                                    }
                                                    (*stcb).asoc.seen_a_sack_this_pkt = 1u8;
                                                    if (*stcb).asoc.pr_sctp_cnt == 0u32
                                                        && num_seg as libc::c_int == 0i32
                                                        && num_nr_seg as libc::c_int == 0i32
                                                        && (cum_ack < (*stcb).asoc.last_acked_seq
                                                            && (*stcb)
                                                                .asoc
                                                                .last_acked_seq
                                                                .wrapping_sub(cum_ack)
                                                                > (1u32) << 31i32
                                                            || cum_ack
                                                                > (*stcb).asoc.last_acked_seq
                                                                && cum_ack.wrapping_sub(
                                                                    (*stcb).asoc.last_acked_seq,
                                                                ) < (1u32) << 31i32
                                                            || cum_ack
                                                                == (*stcb).asoc.last_acked_seq)
                                                        && (*stcb).asoc.saw_sack_with_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && (*stcb).asoc.saw_sack_with_nr_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && !(*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                    {
                                                        sctp_express_handle_sack(
                                                            stcb,
                                                            cum_ack,
                                                            a_rwnd,
                                                            &mut abort_now,
                                                            ecne_seen,
                                                        );
                                                    } else if !netp.is_null() && !(*netp).is_null()
                                                    {
                                                        sctp_handle_sack(
                                                            m,
                                                            offset_seg,
                                                            offset_dup,
                                                            stcb,
                                                            num_seg,
                                                            num_nr_seg,
                                                            num_dup,
                                                            &mut abort_now,
                                                            flags,
                                                            cum_ack,
                                                            a_rwnd,
                                                            ecne_seen,
                                                        );
                                                    }
                                                    if abort_now != 0 {
                                                        *offset = length;
                                                        return 0 as *mut sctp_tcb;
                                                    }
                                                    if (*stcb).asoc.send_queue.tqh_first.is_null()
                                                        && (*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                        && (*stcb).asoc.stream_queue_cnt == 0u32
                                                    {
                                                        sctp_ulp_notify(
                                                            26u32,
                                                            stcb,
                                                            0u32,
                                                            0 as *mut libc::c_void,
                                                            0i32,
                                                        );
                                                    }
                                                }
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    }
                                }
                            }
                        }
                        2349180396633407496 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_AUTHENTICATION\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null() {
                                if auth_skipped == 0i32 {
                                    auth_offset = *offset as uint32_t;
                                    auth_len = chk_length;
                                    auth_skipped = 1i32
                                }
                                current_block = 13422570431586403309;
                            } else if (*stcb).asoc.auth_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_auth_chunk>() as libc::c_ulong
                                    || chk_length as libc::c_ulong
                                        > (::std::mem::size_of::<sctp_auth_chunk>()
                                            as libc::c_ulong)
                                            .wrapping_add(32u64)
                                {
                                    *offset = length;
                                    return stcb;
                                }
                                if got_auth == 1i32 {
                                    current_block = 13422570431586403309;
                                } else {
                                    got_auth = 1i32;
                                    if ch.is_null()
                                        || sctp_handle_auth(
                                            stcb,
                                            ch as *mut sctp_auth_chunk,
                                            m,
                                            *offset as uint32_t,
                                        ) != 0
                                    {
                                        *offset = length;
                                        return stcb;
                                    } else {
                                        (*stcb).asoc.authenticated = 1u8
                                    }
                                    current_block = 13422570431586403309;
                                }
                            }
                        }
                        _ => {}
                    }
                    match current_block {
                        13422570431586403309 => {}
                        _ => {
                            if (*ch).chunk_type as libc::c_int & 0x40i32 != 0 && !stcb.is_null() {
                                op_err = sctp_get_mbuf_for_msg(
                                    ::std::mem::size_of::<sctp_gen_error_cause>() as libc::c_uint,
                                    0i32,
                                    0x1i32,
                                    1i32,
                                    1i32,
                                );
                                if !op_err.is_null() {
                                    let mut cause = 0 as *mut sctp_gen_error_cause;
                                    let mut len = 0;
                                    len = if (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                        > (length - *offset) as uint32_t
                                    {
                                        (length - *offset) as uint32_t
                                    } else {
                                        (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                    } as libc::c_int;
                                    cause = (*op_err).m_hdr.mh_data as *mut sctp_gen_error_cause;
                                    (*cause).code = htons(0x6u16);
                                    (*cause).length =
                                        htons((len as libc::c_ulong).wrapping_add(
                                            ::std::mem::size_of::<sctp_gen_error_cause>()
                                                as libc::c_ulong,
                                        )
                                            as uint16_t);
                                    (*op_err).m_hdr.mh_len =
                                        ::std::mem::size_of::<sctp_gen_error_cause>()
                                            as libc::c_int;
                                    (*op_err).m_hdr.mh_next = m_copym(m, *offset, len, 0x1i32);
                                    if !(*op_err).m_hdr.mh_next.is_null() {
                                        sctp_queue_op_err(stcb, op_err);
                                    } else {
                                        m_freem(op_err);
                                    }
                                }
                            }
                            if (*ch).chunk_type as libc::c_int & 0x80i32 == 0i32 {
                                *offset = length;
                                return stcb;
                            }
                        }
                    }
                }
                192 | 194 => {
                    current_block = 13497718421940148126;
                    match current_block {
                        17766256343850198083 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_COMPLETE, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_complete(
                                    ch as *mut sctp_shutdown_complete_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        12601157616349825580 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT_ACK\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0 {
                                } else {
                                    *offset = length;
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1di32);
                                    }
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                ret = sctp_handle_init_ack(
                                    m,
                                    iphlen,
                                    *offset,
                                    src,
                                    dst,
                                    sh,
                                    ch as *mut sctp_init_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_no_unlock,
                                    vrf_id,
                                )
                            } else {
                                ret = -(1i32)
                            }
                            *offset = length;
                            if abort_no_unlock != 0 {
                                return 0 as *mut sctp_tcb;
                            }
                            if !stcb.is_null() && ret == 0i32 {
                                sctp_chunk_output((*stcb).sctp_ep, stcb, 3i32, 0i32);
                            }
                            return stcb;
                        }
                        16195856799229720522 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                if !stcb.is_null() {
                                    pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                }
                                return 0 as *mut sctp_tcb;
                            }
                            if chk_length > (65535i32 - 2048i32) as libc::c_uint {
                                op_err = sctp_generate_cause(
                                    0x4u16,
                                    b"\x00" as *const u8 as *mut libc::c_char,
                                );
                                sctp_abort_association(
                                    inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id, port,
                                );
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            sctp_handle_init(
                                m,
                                iphlen,
                                *offset,
                                src,
                                dst,
                                sh,
                                ch as *mut sctp_init_chunk,
                                inp,
                                stcb,
                                *netp,
                                &mut abort_no_unlock,
                                vrf_id,
                                port,
                            );
                            *offset = length;
                            if abort_no_unlock == 0 && !stcb.is_null() {
                                pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                            }
                            return 0 as *mut sctp_tcb;
                        }
                        6246479402878884953 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_ack(
                                    ch as *mut sctp_shutdown_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        4558417918157925232 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ABORT, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            *offset = length;
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if sctp_handle_abort(ch as *mut sctp_abort_chunk, stcb, *netp) != 0
                                {
                                    return 0 as *mut sctp_tcb;
                                } else {
                                    return stcb;
                                }
                            } else {
                                return 0 as *mut sctp_tcb;
                            }
                        }
                        9379646460352968115 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ECHO, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && (*stcb).asoc.total_output_queue_size > 0u32 {
                                current_block = 15201865807353435331;
                            } else if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                current_block = 15767785092075175044;
                            } else {
                                current_block = 15201865807353435331;
                            }
                            match current_block {
                                15201865807353435331 => {
                                    if stcb.is_null()
                                        && (!((*inp).sctp_flags & 0x8u32 != 0u32)
                                            || (*inp).sctp_flags & 0x1u32 == 0
                                                && (*(*inp).sctp_socket).so_qlen as libc::c_int
                                                    >= (*(*inp).sctp_socket).so_qlimit
                                                        as libc::c_int)
                                    {
                                        if (*inp).sctp_flags & 0x2u32 != 0
                                            && system_base_info
                                                .sctpsysctl
                                                .sctp_abort_if_one_2_one_hits_limit
                                                != 0
                                        {
                                            op_err = sctp_generate_cause(
                                                0x4u16,
                                                b"\x00" as *const u8 as *mut libc::c_char,
                                            );
                                            sctp_abort_association(
                                                inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id,
                                                port,
                                            );
                                        }
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    } else {
                                        let mut linp = 0 as *mut sctp_inpcb;
                                        if !stcb.is_null() {
                                            linp = 0 as *mut sctp_inpcb
                                        } else {
                                            linp = inp
                                        }
                                        if !linp.is_null() {
                                            pthread_mutex_lock(&mut (*linp).inp_create_mtx);
                                            if (*inp).sctp_flags & 0x10000000u32 != 0
                                                || (*inp).sctp_flags & 0x20000000u32 != 0
                                            {
                                                pthread_mutex_unlock(&mut (*linp).inp_create_mtx);
                                                current_block = 15767785092075175044;
                                            } else {
                                                current_block = 2358125959230175008;
                                            }
                                        } else {
                                            current_block = 2358125959230175008;
                                        }
                                        match current_block {
                                            15767785092075175044 => {}
                                            _ => {
                                                let mut ret_buf = 0 as *mut mbuf;
                                                if !netp.is_null() {
                                                    let mut locked_stcb = 0 as *mut sctp_tcb;
                                                    locked_stcb = stcb;
                                                    ret_buf = sctp_handle_cookie_echo(
                                                        m,
                                                        iphlen,
                                                        *offset,
                                                        src,
                                                        dst,
                                                        sh,
                                                        ch as *mut sctp_cookie_echo_chunk,
                                                        &mut inp,
                                                        &mut stcb,
                                                        netp,
                                                        auth_skipped,
                                                        auth_offset,
                                                        auth_len,
                                                        &mut locked_stcb,
                                                        vrf_id,
                                                        port,
                                                    );
                                                    if !locked_stcb.is_null() && locked_stcb != stcb
                                                    {
                                                        pthread_mutex_unlock(
                                                            &mut (*locked_stcb).tcb_mtx,
                                                        );
                                                    }
                                                    !stcb.is_null();
                                                } else {
                                                    ret_buf = 0 as *mut mbuf
                                                }
                                                if !linp.is_null() {
                                                    pthread_mutex_unlock(
                                                        &mut (*linp).inp_create_mtx,
                                                    );
                                                }
                                                if ret_buf.is_null() {
                                                    if !stcb.is_null() {
                                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                                    }
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"GAK, null buffer\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    *offset = length;
                                                    return 0 as *mut sctp_tcb;
                                                }
                                                if auth_skipped != 0 {
                                                    got_auth = 1i32;
                                                    auth_skipped = 0i32
                                                }
                                                if !(*stcb).asoc.sent_queue.tqh_first.is_null() {
                                                    let mut chk = 0 as *mut sctp_tmit_chunk;
                                                    chk = (*stcb).asoc.sent_queue.tqh_first;
                                                    sctp_timer_start(
                                                        1i32,
                                                        (*stcb).sctp_ep,
                                                        stcb,
                                                        (*chk).whoTo,
                                                    );
                                                }
                                                current_block = 13422570431586403309;
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                            match current_block {
                                13422570431586403309 => {}
                                _ => {
                                    if !stcb.is_null() {
                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                    }
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                        }
                        10582330624169799780 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_PACKET_DROPPED\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_pktdrop_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !ch.is_null()
                                && !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                            {
                                if (*stcb).asoc.pktdrop_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_packet_dropped(
                                        ch as *mut sctp_pktdrop_chunk,
                                        stcb,
                                        *netp,
                                        if chk_length > contiguous {
                                            contiguous
                                        } else {
                                            chk_length
                                        },
                                    );
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13268550889959046632 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_STREAM_RESET\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || ch.is_null()
                                || (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_stream_reset_tsn_req>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.reconfig_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if sctp_handle_stream_reset(stcb, m, *offset, ch) != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                                current_block = 13422570431586403309;
                            }
                        }
                        13497718421940148126 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_FWD_TSN\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_forward_tsn_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.prsctp_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    let mut abort_flag_0 = 0i32;
                                    *fwd_tsn_seen = 1i32;
                                    if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1fi32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    (*stcb).asoc.last_data_chunk_from =
                                        (*stcb).asoc.last_control_chunk_from;
                                    sctp_handle_forward_tsn(
                                        stcb,
                                        ch as *mut sctp_forward_tsn_chunk,
                                        &mut abort_flag_0,
                                        m,
                                        *offset,
                                    );
                                    if abort_flag_0 != 0 {
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13226217046118304493 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_asconf_ack_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    if system_base_info.sctpsysctl.sctp_logging_level & 0x2000000u32
                                        != 0
                                    {
                                        sctp_misc_ints(
                                            120u8,
                                            (*stcb).asoc.overall_error_count,
                                            0u32,
                                            0x10000000u32,
                                            5531u32,
                                        );
                                    }
                                    (*stcb).asoc.overall_error_count = 0u32;
                                    sctp_handle_asconf_ack(
                                        m,
                                        *offset,
                                        ch as *mut sctp_asconf_ack_chunk,
                                        stcb,
                                        *netp,
                                        &mut abort_no_unlock,
                                    );
                                    if abort_no_unlock != 0 {
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        11399179239179359665 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_asconf(
                                        m,
                                        *offset as libc::c_uint,
                                        src,
                                        ch as *mut sctp_asconf_chunk,
                                        stcb,
                                        (asconf_cnt == 0i32) as libc::c_int,
                                    );
                                    asconf_cnt += 1;
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        3371148184269687219 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_CWR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cwr_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_cwr(ch as *mut sctp_cwr_chunk, stcb, *netp);
                                current_block = 13422570431586403309;
                            }
                        }
                        13594799726619700391 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_ECHO\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_ecne_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_echo(ch as *mut sctp_ecne_chunk, stcb);
                                ecne_seen = 1i32;
                                current_block = 13422570431586403309;
                            }
                        }
                        2781125740367032387 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cookie_ack_chunk>()
                                        as libc::c_ulong
                            {
                                return stcb;
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !(!stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0) {
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1ei32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                }
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_cookie_ack(
                                    ch as *mut sctp_cookie_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        17092723434217905016 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_OP_ERR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                                && sctp_handle_error(ch, stcb, *netp, contiguous) < 0i32
                            {
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            current_block = 13422570431586403309;
                        }
                        6770586402544785651 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_shutdown_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                let mut abort_flag = 0i32;
                                sctp_handle_shutdown(
                                    ch as *mut sctp_shutdown_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_flag,
                                );
                                if abort_flag != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            current_block = 13422570431586403309;
                        }
                        12945290292467802513 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_heartbeat_chunk>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvheartbeatack,
                                1u32,
                            );
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_heartbeat_ack(
                                    ch as *mut sctp_heartbeat_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        5491205026464363454 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                ::std::intrinsics::atomic_xadd(
                                    &mut system_base_info.sctpstat.sctps_recvheartbeat,
                                    1u32,
                                );
                                sctp_send_heartbeat_ack(
                                    stcb,
                                    m,
                                    *offset,
                                    chk_length as libc::c_int,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        7940804887512848672 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"%s\n\x00" as *const u8 as *const libc::c_char,
                                        if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                            b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                        } else {
                                            b"SCTP_NR_SACK\x00" as *const u8 as *const libc::c_char
                                        },
                                    );
                                }
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvsacks,
                                1u32,
                            );
                            if stcb.is_null() {
                                if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0 {
                                    if system_base_info.debug_printf.is_some() {
                                        system_base_info
                                            .debug_printf
                                            .expect("non-null function pointer")(
                                            b"No stcb when processing %s chunk\n\x00" as *const u8
                                                as *const libc::c_char,
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                            } else {
                                                b"SCTP_NR_SACK\x00" as *const u8
                                                    as *const libc::c_char
                                            },
                                        );
                                    }
                                }
                                current_block = 13422570431586403309;
                            } else {
                                if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                    if (chk_length as libc::c_ulong)
                                        < ::std::mem::size_of::<sctp_sack_chunk>() as libc::c_ulong
                                    {
                                        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32
                                            != 0
                                        {
                                            if system_base_info.debug_printf.is_some() {
                                                system_base_info
                                                    .debug_printf
                                                    .expect("non-null function pointer")(
                                                    b"Bad size on SACK chunk, too small\n\x00"
                                                        as *const u8
                                                        as *const libc::c_char,
                                                );
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    } else {
                                        current_block = 17937968408868551711;
                                    }
                                } else if (*stcb).asoc.nrsack_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_nr_sack_chunk>() as libc::c_ulong
                                {
                                    if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0
                                    {
                                        if system_base_info.debug_printf.is_some() {
                                            system_base_info
                                                .debug_printf
                                                .expect("non-null function pointer")(
                                                b"Bad size on NR_SACK chunk, too small\n\x00"
                                                    as *const u8
                                                    as *const libc::c_char,
                                            );
                                        }
                                    }
                                    current_block = 13422570431586403309;
                                } else {
                                    current_block = 17937968408868551711;
                                }
                                match current_block {
                                    6765806975593869225 => {}
                                    13422570431586403309 => {}
                                    _ => {
                                        if !((*stcb).asoc.state & 0x7fi32 == 0x40i32) {
                                            let mut a_rwnd = 0;
                                            let mut cum_ack = 0;
                                            let mut num_seg = 0;
                                            let mut num_nr_seg = 0;
                                            let mut num_dup = 0;
                                            let mut flags = 0;
                                            let mut offset_seg = 0;
                                            let mut offset_dup = 0;
                                            flags = (*ch).chunk_flags;
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                let mut sack = 0 as *mut sctp_sack_chunk;
                                                sack = ch as *mut sctp_sack_chunk;
                                                cum_ack = ntohl((*sack).sack.cum_tsn_ack);
                                                num_seg = ntohs((*sack).sack.num_gap_ack_blks);
                                                num_nr_seg = 0u16;
                                                num_dup = ntohs((*sack).sack.num_dup_tsns);
                                                a_rwnd = ntohl((*sack).sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_sack_chunk>()
                                                        as
                                                        libc::c_ulong).wrapping_add((num_seg
                                                                                         as
                                                                                         libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                         as
                                                                                                                         libc::c_ulong)).wrapping_add((num_dup
                                                                                                                                                           as
                                                                                                                                                           libc::c_ulong).wrapping_mul(::std::mem::size_of::<uint32_t>()
                                                                                                                                                                                           as
                                                                                                                                                                                           libc::c_ulong))
                                                       !=
                                                       chk_length as
                                                           libc::c_ulong {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                           &
                                                           0x1000000u32 !=
                                                           0 {
                                                        if system_base_info.debug_printf.is_some()
                                                           {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"Bad size of SACK chunk\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char);
                                                        }
                                                    }
                                                    current_block =
                                                        13422570431586403309;
                                                } else {
                                                    offset_seg =
                                                        (*offset as
                                                             libc::c_ulong).wrapping_add(::std::mem::size_of::<sctp_sack_chunk>()
                                                                                             as
                                                                                             libc::c_ulong)
                                                            as libc::c_int;
                                                    offset_dup =
                                                        (offset_seg as
                                                             libc::c_ulong).wrapping_add((num_seg
                                                                                              as
                                                                                              libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                              as
                                                                                                                              libc::c_ulong))
                                                            as libc::c_int;
                                                    current_block =
                                                        8752412851861032177;
                                                }
                                            } else {
                                                let mut nr_sack = 0 as *mut sctp_nr_sack_chunk;
                                                nr_sack = ch as *mut sctp_nr_sack_chunk;
                                                cum_ack = ntohl((*nr_sack).nr_sack.cum_tsn_ack);
                                                num_seg =
                                                    ntohs((*nr_sack).nr_sack.num_gap_ack_blks);
                                                num_nr_seg =
                                                    ntohs((*nr_sack).nr_sack.num_nr_gap_ack_blks);
                                                num_dup = ntohs((*nr_sack).nr_sack.num_dup_tsns);
                                                a_rwnd = ntohl((*nr_sack).nr_sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_nr_sack_chunk>()
                                                    as libc::c_ulong)
                                                    .wrapping_add(
                                                        ((num_seg as libc::c_int
                                                            + num_nr_seg as libc::c_int)
                                                            as libc::c_ulong)
                                                            .wrapping_mul(::std::mem::size_of::<
                                                                sctp_gap_ack_block,
                                                            >(
                                                            )
                                                                as libc::c_ulong),
                                                    )
                                                    .wrapping_add(
                                                        (num_dup as libc::c_ulong).wrapping_mul(
                                                            ::std::mem::size_of::<uint32_t>()
                                                                as libc::c_ulong,
                                                        ),
                                                    )
                                                    != chk_length as libc::c_ulong
                                                {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x1000000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"Bad size of NR_SACK chunk\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    current_block = 13422570431586403309;
                                                } else {
                                                    offset_seg = (*offset as libc::c_ulong)
                                                        .wrapping_add(::std::mem::size_of::<
                                                            sctp_nr_sack_chunk,
                                                        >(
                                                        )
                                                            as libc::c_ulong)
                                                        as libc::c_int;
                                                    offset_dup = (offset_seg as libc::c_ulong)
                                                        .wrapping_add(
                                                            ((num_seg as libc::c_int
                                                                + num_nr_seg as libc::c_int)
                                                                as libc::c_ulong)
                                                                .wrapping_mul(
                                                                    ::std::mem::size_of::<
                                                                        sctp_gap_ack_block,
                                                                    >(
                                                                    )
                                                                        as libc::c_ulong,
                                                                ),
                                                        )
                                                        as libc::c_int;
                                                    current_block = 8752412851861032177;
                                                }
                                            }
                                            match current_block {
                                                13422570431586403309 => {}
                                                _ => {
                                                    let mut abort_now = 0i32;
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"%s process cum_ack:%x num_seg:%d a_rwnd:%d\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char,
                                                                                                                              if (*ch).chunk_type
                                                                                                                                     as
                                                                                                                                     libc::c_int
                                                                                                                                     ==
                                                                                                                                     0x3i32
                                                                                                                                 {
                                                                                                                                  b"SCTP_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              } else {
                                                                                                                                  b"SCTP_NR_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              },
                                                                                                                              cum_ack,
                                                                                                                              num_seg
                                                                                                                                  as
                                                                                                                                  libc::c_int,
                                                                                                                              a_rwnd);
                                                        }
                                                    }
                                                    (*stcb).asoc.seen_a_sack_this_pkt = 1u8;
                                                    if (*stcb).asoc.pr_sctp_cnt == 0u32
                                                        && num_seg as libc::c_int == 0i32
                                                        && num_nr_seg as libc::c_int == 0i32
                                                        && (cum_ack < (*stcb).asoc.last_acked_seq
                                                            && (*stcb)
                                                                .asoc
                                                                .last_acked_seq
                                                                .wrapping_sub(cum_ack)
                                                                > (1u32) << 31i32
                                                            || cum_ack
                                                                > (*stcb).asoc.last_acked_seq
                                                                && cum_ack.wrapping_sub(
                                                                    (*stcb).asoc.last_acked_seq,
                                                                ) < (1u32) << 31i32
                                                            || cum_ack
                                                                == (*stcb).asoc.last_acked_seq)
                                                        && (*stcb).asoc.saw_sack_with_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && (*stcb).asoc.saw_sack_with_nr_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && !(*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                    {
                                                        sctp_express_handle_sack(
                                                            stcb,
                                                            cum_ack,
                                                            a_rwnd,
                                                            &mut abort_now,
                                                            ecne_seen,
                                                        );
                                                    } else if !netp.is_null() && !(*netp).is_null()
                                                    {
                                                        sctp_handle_sack(
                                                            m,
                                                            offset_seg,
                                                            offset_dup,
                                                            stcb,
                                                            num_seg,
                                                            num_nr_seg,
                                                            num_dup,
                                                            &mut abort_now,
                                                            flags,
                                                            cum_ack,
                                                            a_rwnd,
                                                            ecne_seen,
                                                        );
                                                    }
                                                    if abort_now != 0 {
                                                        *offset = length;
                                                        return 0 as *mut sctp_tcb;
                                                    }
                                                    if (*stcb).asoc.send_queue.tqh_first.is_null()
                                                        && (*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                        && (*stcb).asoc.stream_queue_cnt == 0u32
                                                    {
                                                        sctp_ulp_notify(
                                                            26u32,
                                                            stcb,
                                                            0u32,
                                                            0 as *mut libc::c_void,
                                                            0i32,
                                                        );
                                                    }
                                                }
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    }
                                }
                            }
                        }
                        2349180396633407496 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_AUTHENTICATION\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null() {
                                if auth_skipped == 0i32 {
                                    auth_offset = *offset as uint32_t;
                                    auth_len = chk_length;
                                    auth_skipped = 1i32
                                }
                                current_block = 13422570431586403309;
                            } else if (*stcb).asoc.auth_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_auth_chunk>() as libc::c_ulong
                                    || chk_length as libc::c_ulong
                                        > (::std::mem::size_of::<sctp_auth_chunk>()
                                            as libc::c_ulong)
                                            .wrapping_add(32u64)
                                {
                                    *offset = length;
                                    return stcb;
                                }
                                if got_auth == 1i32 {
                                    current_block = 13422570431586403309;
                                } else {
                                    got_auth = 1i32;
                                    if ch.is_null()
                                        || sctp_handle_auth(
                                            stcb,
                                            ch as *mut sctp_auth_chunk,
                                            m,
                                            *offset as uint32_t,
                                        ) != 0
                                    {
                                        *offset = length;
                                        return stcb;
                                    } else {
                                        (*stcb).asoc.authenticated = 1u8
                                    }
                                    current_block = 13422570431586403309;
                                }
                            }
                        }
                        _ => {}
                    }
                    match current_block {
                        13422570431586403309 => {}
                        _ => {
                            if (*ch).chunk_type as libc::c_int & 0x40i32 != 0 && !stcb.is_null() {
                                op_err = sctp_get_mbuf_for_msg(
                                    ::std::mem::size_of::<sctp_gen_error_cause>() as libc::c_uint,
                                    0i32,
                                    0x1i32,
                                    1i32,
                                    1i32,
                                );
                                if !op_err.is_null() {
                                    let mut cause = 0 as *mut sctp_gen_error_cause;
                                    let mut len = 0;
                                    len = if (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                        > (length - *offset) as uint32_t
                                    {
                                        (length - *offset) as uint32_t
                                    } else {
                                        (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                    } as libc::c_int;
                                    cause = (*op_err).m_hdr.mh_data as *mut sctp_gen_error_cause;
                                    (*cause).code = htons(0x6u16);
                                    (*cause).length =
                                        htons((len as libc::c_ulong).wrapping_add(
                                            ::std::mem::size_of::<sctp_gen_error_cause>()
                                                as libc::c_ulong,
                                        )
                                            as uint16_t);
                                    (*op_err).m_hdr.mh_len =
                                        ::std::mem::size_of::<sctp_gen_error_cause>()
                                            as libc::c_int;
                                    (*op_err).m_hdr.mh_next = m_copym(m, *offset, len, 0x1i32);
                                    if !(*op_err).m_hdr.mh_next.is_null() {
                                        sctp_queue_op_err(stcb, op_err);
                                    } else {
                                        m_freem(op_err);
                                    }
                                }
                            }
                            if (*ch).chunk_type as libc::c_int & 0x80i32 == 0i32 {
                                *offset = length;
                                return stcb;
                            }
                        }
                    }
                }
                130 => {
                    current_block = 13268550889959046632;
                    match current_block {
                        17766256343850198083 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_COMPLETE, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_complete(
                                    ch as *mut sctp_shutdown_complete_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        12601157616349825580 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT_ACK\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0 {
                                } else {
                                    *offset = length;
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1di32);
                                    }
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                ret = sctp_handle_init_ack(
                                    m,
                                    iphlen,
                                    *offset,
                                    src,
                                    dst,
                                    sh,
                                    ch as *mut sctp_init_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_no_unlock,
                                    vrf_id,
                                )
                            } else {
                                ret = -(1i32)
                            }
                            *offset = length;
                            if abort_no_unlock != 0 {
                                return 0 as *mut sctp_tcb;
                            }
                            if !stcb.is_null() && ret == 0i32 {
                                sctp_chunk_output((*stcb).sctp_ep, stcb, 3i32, 0i32);
                            }
                            return stcb;
                        }
                        16195856799229720522 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                if !stcb.is_null() {
                                    pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                }
                                return 0 as *mut sctp_tcb;
                            }
                            if chk_length > (65535i32 - 2048i32) as libc::c_uint {
                                op_err = sctp_generate_cause(
                                    0x4u16,
                                    b"\x00" as *const u8 as *mut libc::c_char,
                                );
                                sctp_abort_association(
                                    inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id, port,
                                );
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            sctp_handle_init(
                                m,
                                iphlen,
                                *offset,
                                src,
                                dst,
                                sh,
                                ch as *mut sctp_init_chunk,
                                inp,
                                stcb,
                                *netp,
                                &mut abort_no_unlock,
                                vrf_id,
                                port,
                            );
                            *offset = length;
                            if abort_no_unlock == 0 && !stcb.is_null() {
                                pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                            }
                            return 0 as *mut sctp_tcb;
                        }
                        6246479402878884953 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_ack(
                                    ch as *mut sctp_shutdown_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        4558417918157925232 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ABORT, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            *offset = length;
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if sctp_handle_abort(ch as *mut sctp_abort_chunk, stcb, *netp) != 0
                                {
                                    return 0 as *mut sctp_tcb;
                                } else {
                                    return stcb;
                                }
                            } else {
                                return 0 as *mut sctp_tcb;
                            }
                        }
                        9379646460352968115 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ECHO, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && (*stcb).asoc.total_output_queue_size > 0u32 {
                                current_block = 15201865807353435331;
                            } else if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                current_block = 15767785092075175044;
                            } else {
                                current_block = 15201865807353435331;
                            }
                            match current_block {
                                15201865807353435331 => {
                                    if stcb.is_null()
                                        && (!((*inp).sctp_flags & 0x8u32 != 0u32)
                                            || (*inp).sctp_flags & 0x1u32 == 0
                                                && (*(*inp).sctp_socket).so_qlen as libc::c_int
                                                    >= (*(*inp).sctp_socket).so_qlimit
                                                        as libc::c_int)
                                    {
                                        if (*inp).sctp_flags & 0x2u32 != 0
                                            && system_base_info
                                                .sctpsysctl
                                                .sctp_abort_if_one_2_one_hits_limit
                                                != 0
                                        {
                                            op_err = sctp_generate_cause(
                                                0x4u16,
                                                b"\x00" as *const u8 as *mut libc::c_char,
                                            );
                                            sctp_abort_association(
                                                inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id,
                                                port,
                                            );
                                        }
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    } else {
                                        let mut linp = 0 as *mut sctp_inpcb;
                                        if !stcb.is_null() {
                                            linp = 0 as *mut sctp_inpcb
                                        } else {
                                            linp = inp
                                        }
                                        if !linp.is_null() {
                                            pthread_mutex_lock(&mut (*linp).inp_create_mtx);
                                            if (*inp).sctp_flags & 0x10000000u32 != 0
                                                || (*inp).sctp_flags & 0x20000000u32 != 0
                                            {
                                                pthread_mutex_unlock(&mut (*linp).inp_create_mtx);
                                                current_block = 15767785092075175044;
                                            } else {
                                                current_block = 2358125959230175008;
                                            }
                                        } else {
                                            current_block = 2358125959230175008;
                                        }
                                        match current_block {
                                            15767785092075175044 => {}
                                            _ => {
                                                let mut ret_buf = 0 as *mut mbuf;
                                                if !netp.is_null() {
                                                    let mut locked_stcb = 0 as *mut sctp_tcb;
                                                    locked_stcb = stcb;
                                                    ret_buf = sctp_handle_cookie_echo(
                                                        m,
                                                        iphlen,
                                                        *offset,
                                                        src,
                                                        dst,
                                                        sh,
                                                        ch as *mut sctp_cookie_echo_chunk,
                                                        &mut inp,
                                                        &mut stcb,
                                                        netp,
                                                        auth_skipped,
                                                        auth_offset,
                                                        auth_len,
                                                        &mut locked_stcb,
                                                        vrf_id,
                                                        port,
                                                    );
                                                    if !locked_stcb.is_null() && locked_stcb != stcb
                                                    {
                                                        pthread_mutex_unlock(
                                                            &mut (*locked_stcb).tcb_mtx,
                                                        );
                                                    }
                                                    !stcb.is_null();
                                                } else {
                                                    ret_buf = 0 as *mut mbuf
                                                }
                                                if !linp.is_null() {
                                                    pthread_mutex_unlock(
                                                        &mut (*linp).inp_create_mtx,
                                                    );
                                                }
                                                if ret_buf.is_null() {
                                                    if !stcb.is_null() {
                                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                                    }
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"GAK, null buffer\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    *offset = length;
                                                    return 0 as *mut sctp_tcb;
                                                }
                                                if auth_skipped != 0 {
                                                    got_auth = 1i32;
                                                    auth_skipped = 0i32
                                                }
                                                if !(*stcb).asoc.sent_queue.tqh_first.is_null() {
                                                    let mut chk = 0 as *mut sctp_tmit_chunk;
                                                    chk = (*stcb).asoc.sent_queue.tqh_first;
                                                    sctp_timer_start(
                                                        1i32,
                                                        (*stcb).sctp_ep,
                                                        stcb,
                                                        (*chk).whoTo,
                                                    );
                                                }
                                                current_block = 13422570431586403309;
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                            match current_block {
                                13422570431586403309 => {}
                                _ => {
                                    if !stcb.is_null() {
                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                    }
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                        }
                        10582330624169799780 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_PACKET_DROPPED\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_pktdrop_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !ch.is_null()
                                && !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                            {
                                if (*stcb).asoc.pktdrop_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_packet_dropped(
                                        ch as *mut sctp_pktdrop_chunk,
                                        stcb,
                                        *netp,
                                        if chk_length > contiguous {
                                            contiguous
                                        } else {
                                            chk_length
                                        },
                                    );
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13268550889959046632 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_STREAM_RESET\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || ch.is_null()
                                || (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_stream_reset_tsn_req>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.reconfig_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if sctp_handle_stream_reset(stcb, m, *offset, ch) != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                                current_block = 13422570431586403309;
                            }
                        }
                        13497718421940148126 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_FWD_TSN\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_forward_tsn_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.prsctp_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    let mut abort_flag_0 = 0i32;
                                    *fwd_tsn_seen = 1i32;
                                    if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1fi32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    (*stcb).asoc.last_data_chunk_from =
                                        (*stcb).asoc.last_control_chunk_from;
                                    sctp_handle_forward_tsn(
                                        stcb,
                                        ch as *mut sctp_forward_tsn_chunk,
                                        &mut abort_flag_0,
                                        m,
                                        *offset,
                                    );
                                    if abort_flag_0 != 0 {
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13226217046118304493 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_asconf_ack_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    if system_base_info.sctpsysctl.sctp_logging_level & 0x2000000u32
                                        != 0
                                    {
                                        sctp_misc_ints(
                                            120u8,
                                            (*stcb).asoc.overall_error_count,
                                            0u32,
                                            0x10000000u32,
                                            5531u32,
                                        );
                                    }
                                    (*stcb).asoc.overall_error_count = 0u32;
                                    sctp_handle_asconf_ack(
                                        m,
                                        *offset,
                                        ch as *mut sctp_asconf_ack_chunk,
                                        stcb,
                                        *netp,
                                        &mut abort_no_unlock,
                                    );
                                    if abort_no_unlock != 0 {
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        11399179239179359665 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_asconf(
                                        m,
                                        *offset as libc::c_uint,
                                        src,
                                        ch as *mut sctp_asconf_chunk,
                                        stcb,
                                        (asconf_cnt == 0i32) as libc::c_int,
                                    );
                                    asconf_cnt += 1;
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        3371148184269687219 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_CWR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cwr_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_cwr(ch as *mut sctp_cwr_chunk, stcb, *netp);
                                current_block = 13422570431586403309;
                            }
                        }
                        13594799726619700391 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_ECHO\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_ecne_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_echo(ch as *mut sctp_ecne_chunk, stcb);
                                ecne_seen = 1i32;
                                current_block = 13422570431586403309;
                            }
                        }
                        2781125740367032387 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cookie_ack_chunk>()
                                        as libc::c_ulong
                            {
                                return stcb;
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !(!stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0) {
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1ei32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                }
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_cookie_ack(
                                    ch as *mut sctp_cookie_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        17092723434217905016 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_OP_ERR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                                && sctp_handle_error(ch, stcb, *netp, contiguous) < 0i32
                            {
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            current_block = 13422570431586403309;
                        }
                        6770586402544785651 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_shutdown_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                let mut abort_flag = 0i32;
                                sctp_handle_shutdown(
                                    ch as *mut sctp_shutdown_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_flag,
                                );
                                if abort_flag != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            current_block = 13422570431586403309;
                        }
                        12945290292467802513 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_heartbeat_chunk>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvheartbeatack,
                                1u32,
                            );
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_heartbeat_ack(
                                    ch as *mut sctp_heartbeat_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        5491205026464363454 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                ::std::intrinsics::atomic_xadd(
                                    &mut system_base_info.sctpstat.sctps_recvheartbeat,
                                    1u32,
                                );
                                sctp_send_heartbeat_ack(
                                    stcb,
                                    m,
                                    *offset,
                                    chk_length as libc::c_int,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        7940804887512848672 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"%s\n\x00" as *const u8 as *const libc::c_char,
                                        if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                            b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                        } else {
                                            b"SCTP_NR_SACK\x00" as *const u8 as *const libc::c_char
                                        },
                                    );
                                }
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvsacks,
                                1u32,
                            );
                            if stcb.is_null() {
                                if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0 {
                                    if system_base_info.debug_printf.is_some() {
                                        system_base_info
                                            .debug_printf
                                            .expect("non-null function pointer")(
                                            b"No stcb when processing %s chunk\n\x00" as *const u8
                                                as *const libc::c_char,
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                            } else {
                                                b"SCTP_NR_SACK\x00" as *const u8
                                                    as *const libc::c_char
                                            },
                                        );
                                    }
                                }
                                current_block = 13422570431586403309;
                            } else {
                                if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                    if (chk_length as libc::c_ulong)
                                        < ::std::mem::size_of::<sctp_sack_chunk>() as libc::c_ulong
                                    {
                                        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32
                                            != 0
                                        {
                                            if system_base_info.debug_printf.is_some() {
                                                system_base_info
                                                    .debug_printf
                                                    .expect("non-null function pointer")(
                                                    b"Bad size on SACK chunk, too small\n\x00"
                                                        as *const u8
                                                        as *const libc::c_char,
                                                );
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    } else {
                                        current_block = 17937968408868551711;
                                    }
                                } else if (*stcb).asoc.nrsack_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_nr_sack_chunk>() as libc::c_ulong
                                {
                                    if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0
                                    {
                                        if system_base_info.debug_printf.is_some() {
                                            system_base_info
                                                .debug_printf
                                                .expect("non-null function pointer")(
                                                b"Bad size on NR_SACK chunk, too small\n\x00"
                                                    as *const u8
                                                    as *const libc::c_char,
                                            );
                                        }
                                    }
                                    current_block = 13422570431586403309;
                                } else {
                                    current_block = 17937968408868551711;
                                }
                                match current_block {
                                    6765806975593869225 => {}
                                    13422570431586403309 => {}
                                    _ => {
                                        if !((*stcb).asoc.state & 0x7fi32 == 0x40i32) {
                                            let mut a_rwnd = 0;
                                            let mut cum_ack = 0;
                                            let mut num_seg = 0;
                                            let mut num_nr_seg = 0;
                                            let mut num_dup = 0;
                                            let mut flags = 0;
                                            let mut offset_seg = 0;
                                            let mut offset_dup = 0;
                                            flags = (*ch).chunk_flags;
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                let mut sack = 0 as *mut sctp_sack_chunk;
                                                sack = ch as *mut sctp_sack_chunk;
                                                cum_ack = ntohl((*sack).sack.cum_tsn_ack);
                                                num_seg = ntohs((*sack).sack.num_gap_ack_blks);
                                                num_nr_seg = 0u16;
                                                num_dup = ntohs((*sack).sack.num_dup_tsns);
                                                a_rwnd = ntohl((*sack).sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_sack_chunk>()
                                                        as
                                                        libc::c_ulong).wrapping_add((num_seg
                                                                                         as
                                                                                         libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                         as
                                                                                                                         libc::c_ulong)).wrapping_add((num_dup
                                                                                                                                                           as
                                                                                                                                                           libc::c_ulong).wrapping_mul(::std::mem::size_of::<uint32_t>()
                                                                                                                                                                                           as
                                                                                                                                                                                           libc::c_ulong))
                                                       !=
                                                       chk_length as
                                                           libc::c_ulong {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                           &
                                                           0x1000000u32 !=
                                                           0 {
                                                        if system_base_info.debug_printf.is_some()
                                                           {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"Bad size of SACK chunk\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char);
                                                        }
                                                    }
                                                    current_block =
                                                        13422570431586403309;
                                                } else {
                                                    offset_seg =
                                                        (*offset as
                                                             libc::c_ulong).wrapping_add(::std::mem::size_of::<sctp_sack_chunk>()
                                                                                             as
                                                                                             libc::c_ulong)
                                                            as libc::c_int;
                                                    offset_dup =
                                                        (offset_seg as
                                                             libc::c_ulong).wrapping_add((num_seg
                                                                                              as
                                                                                              libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                              as
                                                                                                                              libc::c_ulong))
                                                            as libc::c_int;
                                                    current_block =
                                                        8752412851861032177;
                                                }
                                            } else {
                                                let mut nr_sack = 0 as *mut sctp_nr_sack_chunk;
                                                nr_sack = ch as *mut sctp_nr_sack_chunk;
                                                cum_ack = ntohl((*nr_sack).nr_sack.cum_tsn_ack);
                                                num_seg =
                                                    ntohs((*nr_sack).nr_sack.num_gap_ack_blks);
                                                num_nr_seg =
                                                    ntohs((*nr_sack).nr_sack.num_nr_gap_ack_blks);
                                                num_dup = ntohs((*nr_sack).nr_sack.num_dup_tsns);
                                                a_rwnd = ntohl((*nr_sack).nr_sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_nr_sack_chunk>()
                                                    as libc::c_ulong)
                                                    .wrapping_add(
                                                        ((num_seg as libc::c_int
                                                            + num_nr_seg as libc::c_int)
                                                            as libc::c_ulong)
                                                            .wrapping_mul(::std::mem::size_of::<
                                                                sctp_gap_ack_block,
                                                            >(
                                                            )
                                                                as libc::c_ulong),
                                                    )
                                                    .wrapping_add(
                                                        (num_dup as libc::c_ulong).wrapping_mul(
                                                            ::std::mem::size_of::<uint32_t>()
                                                                as libc::c_ulong,
                                                        ),
                                                    )
                                                    != chk_length as libc::c_ulong
                                                {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x1000000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"Bad size of NR_SACK chunk\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    current_block = 13422570431586403309;
                                                } else {
                                                    offset_seg = (*offset as libc::c_ulong)
                                                        .wrapping_add(::std::mem::size_of::<
                                                            sctp_nr_sack_chunk,
                                                        >(
                                                        )
                                                            as libc::c_ulong)
                                                        as libc::c_int;
                                                    offset_dup = (offset_seg as libc::c_ulong)
                                                        .wrapping_add(
                                                            ((num_seg as libc::c_int
                                                                + num_nr_seg as libc::c_int)
                                                                as libc::c_ulong)
                                                                .wrapping_mul(
                                                                    ::std::mem::size_of::<
                                                                        sctp_gap_ack_block,
                                                                    >(
                                                                    )
                                                                        as libc::c_ulong,
                                                                ),
                                                        )
                                                        as libc::c_int;
                                                    current_block = 8752412851861032177;
                                                }
                                            }
                                            match current_block {
                                                13422570431586403309 => {}
                                                _ => {
                                                    let mut abort_now = 0i32;
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"%s process cum_ack:%x num_seg:%d a_rwnd:%d\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char,
                                                                                                                              if (*ch).chunk_type
                                                                                                                                     as
                                                                                                                                     libc::c_int
                                                                                                                                     ==
                                                                                                                                     0x3i32
                                                                                                                                 {
                                                                                                                                  b"SCTP_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              } else {
                                                                                                                                  b"SCTP_NR_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              },
                                                                                                                              cum_ack,
                                                                                                                              num_seg
                                                                                                                                  as
                                                                                                                                  libc::c_int,
                                                                                                                              a_rwnd);
                                                        }
                                                    }
                                                    (*stcb).asoc.seen_a_sack_this_pkt = 1u8;
                                                    if (*stcb).asoc.pr_sctp_cnt == 0u32
                                                        && num_seg as libc::c_int == 0i32
                                                        && num_nr_seg as libc::c_int == 0i32
                                                        && (cum_ack < (*stcb).asoc.last_acked_seq
                                                            && (*stcb)
                                                                .asoc
                                                                .last_acked_seq
                                                                .wrapping_sub(cum_ack)
                                                                > (1u32) << 31i32
                                                            || cum_ack
                                                                > (*stcb).asoc.last_acked_seq
                                                                && cum_ack.wrapping_sub(
                                                                    (*stcb).asoc.last_acked_seq,
                                                                ) < (1u32) << 31i32
                                                            || cum_ack
                                                                == (*stcb).asoc.last_acked_seq)
                                                        && (*stcb).asoc.saw_sack_with_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && (*stcb).asoc.saw_sack_with_nr_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && !(*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                    {
                                                        sctp_express_handle_sack(
                                                            stcb,
                                                            cum_ack,
                                                            a_rwnd,
                                                            &mut abort_now,
                                                            ecne_seen,
                                                        );
                                                    } else if !netp.is_null() && !(*netp).is_null()
                                                    {
                                                        sctp_handle_sack(
                                                            m,
                                                            offset_seg,
                                                            offset_dup,
                                                            stcb,
                                                            num_seg,
                                                            num_nr_seg,
                                                            num_dup,
                                                            &mut abort_now,
                                                            flags,
                                                            cum_ack,
                                                            a_rwnd,
                                                            ecne_seen,
                                                        );
                                                    }
                                                    if abort_now != 0 {
                                                        *offset = length;
                                                        return 0 as *mut sctp_tcb;
                                                    }
                                                    if (*stcb).asoc.send_queue.tqh_first.is_null()
                                                        && (*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                        && (*stcb).asoc.stream_queue_cnt == 0u32
                                                    {
                                                        sctp_ulp_notify(
                                                            26u32,
                                                            stcb,
                                                            0u32,
                                                            0 as *mut libc::c_void,
                                                            0i32,
                                                        );
                                                    }
                                                }
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    }
                                }
                            }
                        }
                        2349180396633407496 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_AUTHENTICATION\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null() {
                                if auth_skipped == 0i32 {
                                    auth_offset = *offset as uint32_t;
                                    auth_len = chk_length;
                                    auth_skipped = 1i32
                                }
                                current_block = 13422570431586403309;
                            } else if (*stcb).asoc.auth_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_auth_chunk>() as libc::c_ulong
                                    || chk_length as libc::c_ulong
                                        > (::std::mem::size_of::<sctp_auth_chunk>()
                                            as libc::c_ulong)
                                            .wrapping_add(32u64)
                                {
                                    *offset = length;
                                    return stcb;
                                }
                                if got_auth == 1i32 {
                                    current_block = 13422570431586403309;
                                } else {
                                    got_auth = 1i32;
                                    if ch.is_null()
                                        || sctp_handle_auth(
                                            stcb,
                                            ch as *mut sctp_auth_chunk,
                                            m,
                                            *offset as uint32_t,
                                        ) != 0
                                    {
                                        *offset = length;
                                        return stcb;
                                    } else {
                                        (*stcb).asoc.authenticated = 1u8
                                    }
                                    current_block = 13422570431586403309;
                                }
                            }
                        }
                        _ => {}
                    }
                    match current_block {
                        13422570431586403309 => {}
                        _ => {
                            if (*ch).chunk_type as libc::c_int & 0x40i32 != 0 && !stcb.is_null() {
                                op_err = sctp_get_mbuf_for_msg(
                                    ::std::mem::size_of::<sctp_gen_error_cause>() as libc::c_uint,
                                    0i32,
                                    0x1i32,
                                    1i32,
                                    1i32,
                                );
                                if !op_err.is_null() {
                                    let mut cause = 0 as *mut sctp_gen_error_cause;
                                    let mut len = 0;
                                    len = if (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                        > (length - *offset) as uint32_t
                                    {
                                        (length - *offset) as uint32_t
                                    } else {
                                        (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                    } as libc::c_int;
                                    cause = (*op_err).m_hdr.mh_data as *mut sctp_gen_error_cause;
                                    (*cause).code = htons(0x6u16);
                                    (*cause).length =
                                        htons((len as libc::c_ulong).wrapping_add(
                                            ::std::mem::size_of::<sctp_gen_error_cause>()
                                                as libc::c_ulong,
                                        )
                                            as uint16_t);
                                    (*op_err).m_hdr.mh_len =
                                        ::std::mem::size_of::<sctp_gen_error_cause>()
                                            as libc::c_int;
                                    (*op_err).m_hdr.mh_next = m_copym(m, *offset, len, 0x1i32);
                                    if !(*op_err).m_hdr.mh_next.is_null() {
                                        sctp_queue_op_err(stcb, op_err);
                                    } else {
                                        m_freem(op_err);
                                    }
                                }
                            }
                            if (*ch).chunk_type as libc::c_int & 0x80i32 == 0i32 {
                                *offset = length;
                                return stcb;
                            }
                        }
                    }
                }
                129 => {
                    current_block = 10582330624169799780;
                    match current_block {
                        17766256343850198083 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_COMPLETE, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_complete(
                                    ch as *mut sctp_shutdown_complete_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        12601157616349825580 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT_ACK\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0 {
                                } else {
                                    *offset = length;
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1di32);
                                    }
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                ret = sctp_handle_init_ack(
                                    m,
                                    iphlen,
                                    *offset,
                                    src,
                                    dst,
                                    sh,
                                    ch as *mut sctp_init_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_no_unlock,
                                    vrf_id,
                                )
                            } else {
                                ret = -(1i32)
                            }
                            *offset = length;
                            if abort_no_unlock != 0 {
                                return 0 as *mut sctp_tcb;
                            }
                            if !stcb.is_null() && ret == 0i32 {
                                sctp_chunk_output((*stcb).sctp_ep, stcb, 3i32, 0i32);
                            }
                            return stcb;
                        }
                        16195856799229720522 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                if !stcb.is_null() {
                                    pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                }
                                return 0 as *mut sctp_tcb;
                            }
                            if chk_length > (65535i32 - 2048i32) as libc::c_uint {
                                op_err = sctp_generate_cause(
                                    0x4u16,
                                    b"\x00" as *const u8 as *mut libc::c_char,
                                );
                                sctp_abort_association(
                                    inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id, port,
                                );
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            sctp_handle_init(
                                m,
                                iphlen,
                                *offset,
                                src,
                                dst,
                                sh,
                                ch as *mut sctp_init_chunk,
                                inp,
                                stcb,
                                *netp,
                                &mut abort_no_unlock,
                                vrf_id,
                                port,
                            );
                            *offset = length;
                            if abort_no_unlock == 0 && !stcb.is_null() {
                                pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                            }
                            return 0 as *mut sctp_tcb;
                        }
                        6246479402878884953 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_ack(
                                    ch as *mut sctp_shutdown_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        4558417918157925232 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ABORT, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            *offset = length;
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if sctp_handle_abort(ch as *mut sctp_abort_chunk, stcb, *netp) != 0
                                {
                                    return 0 as *mut sctp_tcb;
                                } else {
                                    return stcb;
                                }
                            } else {
                                return 0 as *mut sctp_tcb;
                            }
                        }
                        9379646460352968115 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ECHO, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && (*stcb).asoc.total_output_queue_size > 0u32 {
                                current_block = 15201865807353435331;
                            } else if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                current_block = 15767785092075175044;
                            } else {
                                current_block = 15201865807353435331;
                            }
                            match current_block {
                                15201865807353435331 => {
                                    if stcb.is_null()
                                        && (!((*inp).sctp_flags & 0x8u32 != 0u32)
                                            || (*inp).sctp_flags & 0x1u32 == 0
                                                && (*(*inp).sctp_socket).so_qlen as libc::c_int
                                                    >= (*(*inp).sctp_socket).so_qlimit
                                                        as libc::c_int)
                                    {
                                        if (*inp).sctp_flags & 0x2u32 != 0
                                            && system_base_info
                                                .sctpsysctl
                                                .sctp_abort_if_one_2_one_hits_limit
                                                != 0
                                        {
                                            op_err = sctp_generate_cause(
                                                0x4u16,
                                                b"\x00" as *const u8 as *mut libc::c_char,
                                            );
                                            sctp_abort_association(
                                                inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id,
                                                port,
                                            );
                                        }
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    } else {
                                        let mut linp = 0 as *mut sctp_inpcb;
                                        if !stcb.is_null() {
                                            linp = 0 as *mut sctp_inpcb
                                        } else {
                                            linp = inp
                                        }
                                        if !linp.is_null() {
                                            pthread_mutex_lock(&mut (*linp).inp_create_mtx);
                                            if (*inp).sctp_flags & 0x10000000u32 != 0
                                                || (*inp).sctp_flags & 0x20000000u32 != 0
                                            {
                                                pthread_mutex_unlock(&mut (*linp).inp_create_mtx);
                                                current_block = 15767785092075175044;
                                            } else {
                                                current_block = 2358125959230175008;
                                            }
                                        } else {
                                            current_block = 2358125959230175008;
                                        }
                                        match current_block {
                                            15767785092075175044 => {}
                                            _ => {
                                                let mut ret_buf = 0 as *mut mbuf;
                                                if !netp.is_null() {
                                                    let mut locked_stcb = 0 as *mut sctp_tcb;
                                                    locked_stcb = stcb;
                                                    ret_buf = sctp_handle_cookie_echo(
                                                        m,
                                                        iphlen,
                                                        *offset,
                                                        src,
                                                        dst,
                                                        sh,
                                                        ch as *mut sctp_cookie_echo_chunk,
                                                        &mut inp,
                                                        &mut stcb,
                                                        netp,
                                                        auth_skipped,
                                                        auth_offset,
                                                        auth_len,
                                                        &mut locked_stcb,
                                                        vrf_id,
                                                        port,
                                                    );
                                                    if !locked_stcb.is_null() && locked_stcb != stcb
                                                    {
                                                        pthread_mutex_unlock(
                                                            &mut (*locked_stcb).tcb_mtx,
                                                        );
                                                    }
                                                    !stcb.is_null();
                                                } else {
                                                    ret_buf = 0 as *mut mbuf
                                                }
                                                if !linp.is_null() {
                                                    pthread_mutex_unlock(
                                                        &mut (*linp).inp_create_mtx,
                                                    );
                                                }
                                                if ret_buf.is_null() {
                                                    if !stcb.is_null() {
                                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                                    }
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"GAK, null buffer\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    *offset = length;
                                                    return 0 as *mut sctp_tcb;
                                                }
                                                if auth_skipped != 0 {
                                                    got_auth = 1i32;
                                                    auth_skipped = 0i32
                                                }
                                                if !(*stcb).asoc.sent_queue.tqh_first.is_null() {
                                                    let mut chk = 0 as *mut sctp_tmit_chunk;
                                                    chk = (*stcb).asoc.sent_queue.tqh_first;
                                                    sctp_timer_start(
                                                        1i32,
                                                        (*stcb).sctp_ep,
                                                        stcb,
                                                        (*chk).whoTo,
                                                    );
                                                }
                                                current_block = 13422570431586403309;
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                            match current_block {
                                13422570431586403309 => {}
                                _ => {
                                    if !stcb.is_null() {
                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                    }
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                        }
                        10582330624169799780 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_PACKET_DROPPED\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_pktdrop_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !ch.is_null()
                                && !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                            {
                                if (*stcb).asoc.pktdrop_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_packet_dropped(
                                        ch as *mut sctp_pktdrop_chunk,
                                        stcb,
                                        *netp,
                                        if chk_length > contiguous {
                                            contiguous
                                        } else {
                                            chk_length
                                        },
                                    );
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13268550889959046632 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_STREAM_RESET\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || ch.is_null()
                                || (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_stream_reset_tsn_req>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.reconfig_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if sctp_handle_stream_reset(stcb, m, *offset, ch) != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                                current_block = 13422570431586403309;
                            }
                        }
                        13497718421940148126 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_FWD_TSN\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_forward_tsn_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.prsctp_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    let mut abort_flag_0 = 0i32;
                                    *fwd_tsn_seen = 1i32;
                                    if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1fi32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    (*stcb).asoc.last_data_chunk_from =
                                        (*stcb).asoc.last_control_chunk_from;
                                    sctp_handle_forward_tsn(
                                        stcb,
                                        ch as *mut sctp_forward_tsn_chunk,
                                        &mut abort_flag_0,
                                        m,
                                        *offset,
                                    );
                                    if abort_flag_0 != 0 {
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13226217046118304493 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_asconf_ack_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    if system_base_info.sctpsysctl.sctp_logging_level & 0x2000000u32
                                        != 0
                                    {
                                        sctp_misc_ints(
                                            120u8,
                                            (*stcb).asoc.overall_error_count,
                                            0u32,
                                            0x10000000u32,
                                            5531u32,
                                        );
                                    }
                                    (*stcb).asoc.overall_error_count = 0u32;
                                    sctp_handle_asconf_ack(
                                        m,
                                        *offset,
                                        ch as *mut sctp_asconf_ack_chunk,
                                        stcb,
                                        *netp,
                                        &mut abort_no_unlock,
                                    );
                                    if abort_no_unlock != 0 {
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        11399179239179359665 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_asconf(
                                        m,
                                        *offset as libc::c_uint,
                                        src,
                                        ch as *mut sctp_asconf_chunk,
                                        stcb,
                                        (asconf_cnt == 0i32) as libc::c_int,
                                    );
                                    asconf_cnt += 1;
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        3371148184269687219 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_CWR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cwr_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_cwr(ch as *mut sctp_cwr_chunk, stcb, *netp);
                                current_block = 13422570431586403309;
                            }
                        }
                        13594799726619700391 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_ECHO\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_ecne_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_echo(ch as *mut sctp_ecne_chunk, stcb);
                                ecne_seen = 1i32;
                                current_block = 13422570431586403309;
                            }
                        }
                        2781125740367032387 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cookie_ack_chunk>()
                                        as libc::c_ulong
                            {
                                return stcb;
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !(!stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0) {
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1ei32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                }
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_cookie_ack(
                                    ch as *mut sctp_cookie_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        17092723434217905016 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_OP_ERR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                                && sctp_handle_error(ch, stcb, *netp, contiguous) < 0i32
                            {
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            current_block = 13422570431586403309;
                        }
                        6770586402544785651 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_shutdown_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                let mut abort_flag = 0i32;
                                sctp_handle_shutdown(
                                    ch as *mut sctp_shutdown_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_flag,
                                );
                                if abort_flag != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            current_block = 13422570431586403309;
                        }
                        12945290292467802513 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_heartbeat_chunk>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvheartbeatack,
                                1u32,
                            );
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_heartbeat_ack(
                                    ch as *mut sctp_heartbeat_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        5491205026464363454 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                ::std::intrinsics::atomic_xadd(
                                    &mut system_base_info.sctpstat.sctps_recvheartbeat,
                                    1u32,
                                );
                                sctp_send_heartbeat_ack(
                                    stcb,
                                    m,
                                    *offset,
                                    chk_length as libc::c_int,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        7940804887512848672 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"%s\n\x00" as *const u8 as *const libc::c_char,
                                        if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                            b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                        } else {
                                            b"SCTP_NR_SACK\x00" as *const u8 as *const libc::c_char
                                        },
                                    );
                                }
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvsacks,
                                1u32,
                            );
                            if stcb.is_null() {
                                if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0 {
                                    if system_base_info.debug_printf.is_some() {
                                        system_base_info
                                            .debug_printf
                                            .expect("non-null function pointer")(
                                            b"No stcb when processing %s chunk\n\x00" as *const u8
                                                as *const libc::c_char,
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                            } else {
                                                b"SCTP_NR_SACK\x00" as *const u8
                                                    as *const libc::c_char
                                            },
                                        );
                                    }
                                }
                                current_block = 13422570431586403309;
                            } else {
                                if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                    if (chk_length as libc::c_ulong)
                                        < ::std::mem::size_of::<sctp_sack_chunk>() as libc::c_ulong
                                    {
                                        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32
                                            != 0
                                        {
                                            if system_base_info.debug_printf.is_some() {
                                                system_base_info
                                                    .debug_printf
                                                    .expect("non-null function pointer")(
                                                    b"Bad size on SACK chunk, too small\n\x00"
                                                        as *const u8
                                                        as *const libc::c_char,
                                                );
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    } else {
                                        current_block = 17937968408868551711;
                                    }
                                } else if (*stcb).asoc.nrsack_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_nr_sack_chunk>() as libc::c_ulong
                                {
                                    if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0
                                    {
                                        if system_base_info.debug_printf.is_some() {
                                            system_base_info
                                                .debug_printf
                                                .expect("non-null function pointer")(
                                                b"Bad size on NR_SACK chunk, too small\n\x00"
                                                    as *const u8
                                                    as *const libc::c_char,
                                            );
                                        }
                                    }
                                    current_block = 13422570431586403309;
                                } else {
                                    current_block = 17937968408868551711;
                                }
                                match current_block {
                                    6765806975593869225 => {}
                                    13422570431586403309 => {}
                                    _ => {
                                        if !((*stcb).asoc.state & 0x7fi32 == 0x40i32) {
                                            let mut a_rwnd = 0;
                                            let mut cum_ack = 0;
                                            let mut num_seg = 0;
                                            let mut num_nr_seg = 0;
                                            let mut num_dup = 0;
                                            let mut flags = 0;
                                            let mut offset_seg = 0;
                                            let mut offset_dup = 0;
                                            flags = (*ch).chunk_flags;
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                let mut sack = 0 as *mut sctp_sack_chunk;
                                                sack = ch as *mut sctp_sack_chunk;
                                                cum_ack = ntohl((*sack).sack.cum_tsn_ack);
                                                num_seg = ntohs((*sack).sack.num_gap_ack_blks);
                                                num_nr_seg = 0u16;
                                                num_dup = ntohs((*sack).sack.num_dup_tsns);
                                                a_rwnd = ntohl((*sack).sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_sack_chunk>()
                                                        as
                                                        libc::c_ulong).wrapping_add((num_seg
                                                                                         as
                                                                                         libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                         as
                                                                                                                         libc::c_ulong)).wrapping_add((num_dup
                                                                                                                                                           as
                                                                                                                                                           libc::c_ulong).wrapping_mul(::std::mem::size_of::<uint32_t>()
                                                                                                                                                                                           as
                                                                                                                                                                                           libc::c_ulong))
                                                       !=
                                                       chk_length as
                                                           libc::c_ulong {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                           &
                                                           0x1000000u32 !=
                                                           0 {
                                                        if system_base_info.debug_printf.is_some()
                                                           {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"Bad size of SACK chunk\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char);
                                                        }
                                                    }
                                                    current_block =
                                                        13422570431586403309;
                                                } else {
                                                    offset_seg =
                                                        (*offset as
                                                             libc::c_ulong).wrapping_add(::std::mem::size_of::<sctp_sack_chunk>()
                                                                                             as
                                                                                             libc::c_ulong)
                                                            as libc::c_int;
                                                    offset_dup =
                                                        (offset_seg as
                                                             libc::c_ulong).wrapping_add((num_seg
                                                                                              as
                                                                                              libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                              as
                                                                                                                              libc::c_ulong))
                                                            as libc::c_int;
                                                    current_block =
                                                        8752412851861032177;
                                                }
                                            } else {
                                                let mut nr_sack = 0 as *mut sctp_nr_sack_chunk;
                                                nr_sack = ch as *mut sctp_nr_sack_chunk;
                                                cum_ack = ntohl((*nr_sack).nr_sack.cum_tsn_ack);
                                                num_seg =
                                                    ntohs((*nr_sack).nr_sack.num_gap_ack_blks);
                                                num_nr_seg =
                                                    ntohs((*nr_sack).nr_sack.num_nr_gap_ack_blks);
                                                num_dup = ntohs((*nr_sack).nr_sack.num_dup_tsns);
                                                a_rwnd = ntohl((*nr_sack).nr_sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_nr_sack_chunk>()
                                                    as libc::c_ulong)
                                                    .wrapping_add(
                                                        ((num_seg as libc::c_int
                                                            + num_nr_seg as libc::c_int)
                                                            as libc::c_ulong)
                                                            .wrapping_mul(::std::mem::size_of::<
                                                                sctp_gap_ack_block,
                                                            >(
                                                            )
                                                                as libc::c_ulong),
                                                    )
                                                    .wrapping_add(
                                                        (num_dup as libc::c_ulong).wrapping_mul(
                                                            ::std::mem::size_of::<uint32_t>()
                                                                as libc::c_ulong,
                                                        ),
                                                    )
                                                    != chk_length as libc::c_ulong
                                                {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x1000000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"Bad size of NR_SACK chunk\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    current_block = 13422570431586403309;
                                                } else {
                                                    offset_seg = (*offset as libc::c_ulong)
                                                        .wrapping_add(::std::mem::size_of::<
                                                            sctp_nr_sack_chunk,
                                                        >(
                                                        )
                                                            as libc::c_ulong)
                                                        as libc::c_int;
                                                    offset_dup = (offset_seg as libc::c_ulong)
                                                        .wrapping_add(
                                                            ((num_seg as libc::c_int
                                                                + num_nr_seg as libc::c_int)
                                                                as libc::c_ulong)
                                                                .wrapping_mul(
                                                                    ::std::mem::size_of::<
                                                                        sctp_gap_ack_block,
                                                                    >(
                                                                    )
                                                                        as libc::c_ulong,
                                                                ),
                                                        )
                                                        as libc::c_int;
                                                    current_block = 8752412851861032177;
                                                }
                                            }
                                            match current_block {
                                                13422570431586403309 => {}
                                                _ => {
                                                    let mut abort_now = 0i32;
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"%s process cum_ack:%x num_seg:%d a_rwnd:%d\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char,
                                                                                                                              if (*ch).chunk_type
                                                                                                                                     as
                                                                                                                                     libc::c_int
                                                                                                                                     ==
                                                                                                                                     0x3i32
                                                                                                                                 {
                                                                                                                                  b"SCTP_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              } else {
                                                                                                                                  b"SCTP_NR_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              },
                                                                                                                              cum_ack,
                                                                                                                              num_seg
                                                                                                                                  as
                                                                                                                                  libc::c_int,
                                                                                                                              a_rwnd);
                                                        }
                                                    }
                                                    (*stcb).asoc.seen_a_sack_this_pkt = 1u8;
                                                    if (*stcb).asoc.pr_sctp_cnt == 0u32
                                                        && num_seg as libc::c_int == 0i32
                                                        && num_nr_seg as libc::c_int == 0i32
                                                        && (cum_ack < (*stcb).asoc.last_acked_seq
                                                            && (*stcb)
                                                                .asoc
                                                                .last_acked_seq
                                                                .wrapping_sub(cum_ack)
                                                                > (1u32) << 31i32
                                                            || cum_ack
                                                                > (*stcb).asoc.last_acked_seq
                                                                && cum_ack.wrapping_sub(
                                                                    (*stcb).asoc.last_acked_seq,
                                                                ) < (1u32) << 31i32
                                                            || cum_ack
                                                                == (*stcb).asoc.last_acked_seq)
                                                        && (*stcb).asoc.saw_sack_with_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && (*stcb).asoc.saw_sack_with_nr_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && !(*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                    {
                                                        sctp_express_handle_sack(
                                                            stcb,
                                                            cum_ack,
                                                            a_rwnd,
                                                            &mut abort_now,
                                                            ecne_seen,
                                                        );
                                                    } else if !netp.is_null() && !(*netp).is_null()
                                                    {
                                                        sctp_handle_sack(
                                                            m,
                                                            offset_seg,
                                                            offset_dup,
                                                            stcb,
                                                            num_seg,
                                                            num_nr_seg,
                                                            num_dup,
                                                            &mut abort_now,
                                                            flags,
                                                            cum_ack,
                                                            a_rwnd,
                                                            ecne_seen,
                                                        );
                                                    }
                                                    if abort_now != 0 {
                                                        *offset = length;
                                                        return 0 as *mut sctp_tcb;
                                                    }
                                                    if (*stcb).asoc.send_queue.tqh_first.is_null()
                                                        && (*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                        && (*stcb).asoc.stream_queue_cnt == 0u32
                                                    {
                                                        sctp_ulp_notify(
                                                            26u32,
                                                            stcb,
                                                            0u32,
                                                            0 as *mut libc::c_void,
                                                            0i32,
                                                        );
                                                    }
                                                }
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    }
                                }
                            }
                        }
                        2349180396633407496 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_AUTHENTICATION\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null() {
                                if auth_skipped == 0i32 {
                                    auth_offset = *offset as uint32_t;
                                    auth_len = chk_length;
                                    auth_skipped = 1i32
                                }
                                current_block = 13422570431586403309;
                            } else if (*stcb).asoc.auth_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_auth_chunk>() as libc::c_ulong
                                    || chk_length as libc::c_ulong
                                        > (::std::mem::size_of::<sctp_auth_chunk>()
                                            as libc::c_ulong)
                                            .wrapping_add(32u64)
                                {
                                    *offset = length;
                                    return stcb;
                                }
                                if got_auth == 1i32 {
                                    current_block = 13422570431586403309;
                                } else {
                                    got_auth = 1i32;
                                    if ch.is_null()
                                        || sctp_handle_auth(
                                            stcb,
                                            ch as *mut sctp_auth_chunk,
                                            m,
                                            *offset as uint32_t,
                                        ) != 0
                                    {
                                        *offset = length;
                                        return stcb;
                                    } else {
                                        (*stcb).asoc.authenticated = 1u8
                                    }
                                    current_block = 13422570431586403309;
                                }
                            }
                        }
                        _ => {}
                    }
                    match current_block {
                        13422570431586403309 => {}
                        _ => {
                            if (*ch).chunk_type as libc::c_int & 0x40i32 != 0 && !stcb.is_null() {
                                op_err = sctp_get_mbuf_for_msg(
                                    ::std::mem::size_of::<sctp_gen_error_cause>() as libc::c_uint,
                                    0i32,
                                    0x1i32,
                                    1i32,
                                    1i32,
                                );
                                if !op_err.is_null() {
                                    let mut cause = 0 as *mut sctp_gen_error_cause;
                                    let mut len = 0;
                                    len = if (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                        > (length - *offset) as uint32_t
                                    {
                                        (length - *offset) as uint32_t
                                    } else {
                                        (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                    } as libc::c_int;
                                    cause = (*op_err).m_hdr.mh_data as *mut sctp_gen_error_cause;
                                    (*cause).code = htons(0x6u16);
                                    (*cause).length =
                                        htons((len as libc::c_ulong).wrapping_add(
                                            ::std::mem::size_of::<sctp_gen_error_cause>()
                                                as libc::c_ulong,
                                        )
                                            as uint16_t);
                                    (*op_err).m_hdr.mh_len =
                                        ::std::mem::size_of::<sctp_gen_error_cause>()
                                            as libc::c_int;
                                    (*op_err).m_hdr.mh_next = m_copym(m, *offset, len, 0x1i32);
                                    if !(*op_err).m_hdr.mh_next.is_null() {
                                        sctp_queue_op_err(stcb, op_err);
                                    } else {
                                        m_freem(op_err);
                                    }
                                }
                            }
                            if (*ch).chunk_type as libc::c_int & 0x80i32 == 0i32 {
                                *offset = length;
                                return stcb;
                            }
                        }
                    }
                }
                15 => {
                    current_block = 2349180396633407496;
                    match current_block {
                        17766256343850198083 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_COMPLETE, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_complete(
                                    ch as *mut sctp_shutdown_complete_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        12601157616349825580 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT_ACK\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0 {
                                } else {
                                    *offset = length;
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1di32);
                                    }
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                ret = sctp_handle_init_ack(
                                    m,
                                    iphlen,
                                    *offset,
                                    src,
                                    dst,
                                    sh,
                                    ch as *mut sctp_init_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_no_unlock,
                                    vrf_id,
                                )
                            } else {
                                ret = -(1i32)
                            }
                            *offset = length;
                            if abort_no_unlock != 0 {
                                return 0 as *mut sctp_tcb;
                            }
                            if !stcb.is_null() && ret == 0i32 {
                                sctp_chunk_output((*stcb).sctp_ep, stcb, 3i32, 0i32);
                            }
                            return stcb;
                        }
                        16195856799229720522 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                if !stcb.is_null() {
                                    pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                }
                                return 0 as *mut sctp_tcb;
                            }
                            if chk_length > (65535i32 - 2048i32) as libc::c_uint {
                                op_err = sctp_generate_cause(
                                    0x4u16,
                                    b"\x00" as *const u8 as *mut libc::c_char,
                                );
                                sctp_abort_association(
                                    inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id, port,
                                );
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            sctp_handle_init(
                                m,
                                iphlen,
                                *offset,
                                src,
                                dst,
                                sh,
                                ch as *mut sctp_init_chunk,
                                inp,
                                stcb,
                                *netp,
                                &mut abort_no_unlock,
                                vrf_id,
                                port,
                            );
                            *offset = length;
                            if abort_no_unlock == 0 && !stcb.is_null() {
                                pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                            }
                            return 0 as *mut sctp_tcb;
                        }
                        6246479402878884953 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_ack(
                                    ch as *mut sctp_shutdown_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        4558417918157925232 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ABORT, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            *offset = length;
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if sctp_handle_abort(ch as *mut sctp_abort_chunk, stcb, *netp) != 0
                                {
                                    return 0 as *mut sctp_tcb;
                                } else {
                                    return stcb;
                                }
                            } else {
                                return 0 as *mut sctp_tcb;
                            }
                        }
                        9379646460352968115 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ECHO, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && (*stcb).asoc.total_output_queue_size > 0u32 {
                                current_block = 15201865807353435331;
                            } else if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                current_block = 15767785092075175044;
                            } else {
                                current_block = 15201865807353435331;
                            }
                            match current_block {
                                15201865807353435331 => {
                                    if stcb.is_null()
                                        && (!((*inp).sctp_flags & 0x8u32 != 0u32)
                                            || (*inp).sctp_flags & 0x1u32 == 0
                                                && (*(*inp).sctp_socket).so_qlen as libc::c_int
                                                    >= (*(*inp).sctp_socket).so_qlimit
                                                        as libc::c_int)
                                    {
                                        if (*inp).sctp_flags & 0x2u32 != 0
                                            && system_base_info
                                                .sctpsysctl
                                                .sctp_abort_if_one_2_one_hits_limit
                                                != 0
                                        {
                                            op_err = sctp_generate_cause(
                                                0x4u16,
                                                b"\x00" as *const u8 as *mut libc::c_char,
                                            );
                                            sctp_abort_association(
                                                inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id,
                                                port,
                                            );
                                        }
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    } else {
                                        let mut linp = 0 as *mut sctp_inpcb;
                                        if !stcb.is_null() {
                                            linp = 0 as *mut sctp_inpcb
                                        } else {
                                            linp = inp
                                        }
                                        if !linp.is_null() {
                                            pthread_mutex_lock(&mut (*linp).inp_create_mtx);
                                            if (*inp).sctp_flags & 0x10000000u32 != 0
                                                || (*inp).sctp_flags & 0x20000000u32 != 0
                                            {
                                                pthread_mutex_unlock(&mut (*linp).inp_create_mtx);
                                                current_block = 15767785092075175044;
                                            } else {
                                                current_block = 2358125959230175008;
                                            }
                                        } else {
                                            current_block = 2358125959230175008;
                                        }
                                        match current_block {
                                            15767785092075175044 => {}
                                            _ => {
                                                let mut ret_buf = 0 as *mut mbuf;
                                                if !netp.is_null() {
                                                    let mut locked_stcb = 0 as *mut sctp_tcb;
                                                    locked_stcb = stcb;
                                                    ret_buf = sctp_handle_cookie_echo(
                                                        m,
                                                        iphlen,
                                                        *offset,
                                                        src,
                                                        dst,
                                                        sh,
                                                        ch as *mut sctp_cookie_echo_chunk,
                                                        &mut inp,
                                                        &mut stcb,
                                                        netp,
                                                        auth_skipped,
                                                        auth_offset,
                                                        auth_len,
                                                        &mut locked_stcb,
                                                        vrf_id,
                                                        port,
                                                    );
                                                    if !locked_stcb.is_null() && locked_stcb != stcb
                                                    {
                                                        pthread_mutex_unlock(
                                                            &mut (*locked_stcb).tcb_mtx,
                                                        );
                                                    }
                                                    !stcb.is_null();
                                                } else {
                                                    ret_buf = 0 as *mut mbuf
                                                }
                                                if !linp.is_null() {
                                                    pthread_mutex_unlock(
                                                        &mut (*linp).inp_create_mtx,
                                                    );
                                                }
                                                if ret_buf.is_null() {
                                                    if !stcb.is_null() {
                                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                                    }
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"GAK, null buffer\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    *offset = length;
                                                    return 0 as *mut sctp_tcb;
                                                }
                                                if auth_skipped != 0 {
                                                    got_auth = 1i32;
                                                    auth_skipped = 0i32
                                                }
                                                if !(*stcb).asoc.sent_queue.tqh_first.is_null() {
                                                    let mut chk = 0 as *mut sctp_tmit_chunk;
                                                    chk = (*stcb).asoc.sent_queue.tqh_first;
                                                    sctp_timer_start(
                                                        1i32,
                                                        (*stcb).sctp_ep,
                                                        stcb,
                                                        (*chk).whoTo,
                                                    );
                                                }
                                                current_block = 13422570431586403309;
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                            match current_block {
                                13422570431586403309 => {}
                                _ => {
                                    if !stcb.is_null() {
                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                    }
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                        }
                        10582330624169799780 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_PACKET_DROPPED\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_pktdrop_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !ch.is_null()
                                && !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                            {
                                if (*stcb).asoc.pktdrop_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_packet_dropped(
                                        ch as *mut sctp_pktdrop_chunk,
                                        stcb,
                                        *netp,
                                        if chk_length > contiguous {
                                            contiguous
                                        } else {
                                            chk_length
                                        },
                                    );
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13268550889959046632 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_STREAM_RESET\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || ch.is_null()
                                || (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_stream_reset_tsn_req>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.reconfig_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if sctp_handle_stream_reset(stcb, m, *offset, ch) != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                                current_block = 13422570431586403309;
                            }
                        }
                        13497718421940148126 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_FWD_TSN\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_forward_tsn_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.prsctp_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    let mut abort_flag_0 = 0i32;
                                    *fwd_tsn_seen = 1i32;
                                    if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1fi32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    (*stcb).asoc.last_data_chunk_from =
                                        (*stcb).asoc.last_control_chunk_from;
                                    sctp_handle_forward_tsn(
                                        stcb,
                                        ch as *mut sctp_forward_tsn_chunk,
                                        &mut abort_flag_0,
                                        m,
                                        *offset,
                                    );
                                    if abort_flag_0 != 0 {
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13226217046118304493 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_asconf_ack_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    if system_base_info.sctpsysctl.sctp_logging_level & 0x2000000u32
                                        != 0
                                    {
                                        sctp_misc_ints(
                                            120u8,
                                            (*stcb).asoc.overall_error_count,
                                            0u32,
                                            0x10000000u32,
                                            5531u32,
                                        );
                                    }
                                    (*stcb).asoc.overall_error_count = 0u32;
                                    sctp_handle_asconf_ack(
                                        m,
                                        *offset,
                                        ch as *mut sctp_asconf_ack_chunk,
                                        stcb,
                                        *netp,
                                        &mut abort_no_unlock,
                                    );
                                    if abort_no_unlock != 0 {
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        11399179239179359665 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_asconf(
                                        m,
                                        *offset as libc::c_uint,
                                        src,
                                        ch as *mut sctp_asconf_chunk,
                                        stcb,
                                        (asconf_cnt == 0i32) as libc::c_int,
                                    );
                                    asconf_cnt += 1;
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        3371148184269687219 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_CWR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cwr_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_cwr(ch as *mut sctp_cwr_chunk, stcb, *netp);
                                current_block = 13422570431586403309;
                            }
                        }
                        13594799726619700391 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_ECHO\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_ecne_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_echo(ch as *mut sctp_ecne_chunk, stcb);
                                ecne_seen = 1i32;
                                current_block = 13422570431586403309;
                            }
                        }
                        2781125740367032387 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cookie_ack_chunk>()
                                        as libc::c_ulong
                            {
                                return stcb;
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !(!stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0) {
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1ei32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                }
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_cookie_ack(
                                    ch as *mut sctp_cookie_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        17092723434217905016 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_OP_ERR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                                && sctp_handle_error(ch, stcb, *netp, contiguous) < 0i32
                            {
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            current_block = 13422570431586403309;
                        }
                        6770586402544785651 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_shutdown_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                let mut abort_flag = 0i32;
                                sctp_handle_shutdown(
                                    ch as *mut sctp_shutdown_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_flag,
                                );
                                if abort_flag != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            current_block = 13422570431586403309;
                        }
                        12945290292467802513 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_heartbeat_chunk>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvheartbeatack,
                                1u32,
                            );
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_heartbeat_ack(
                                    ch as *mut sctp_heartbeat_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        5491205026464363454 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                ::std::intrinsics::atomic_xadd(
                                    &mut system_base_info.sctpstat.sctps_recvheartbeat,
                                    1u32,
                                );
                                sctp_send_heartbeat_ack(
                                    stcb,
                                    m,
                                    *offset,
                                    chk_length as libc::c_int,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        7940804887512848672 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"%s\n\x00" as *const u8 as *const libc::c_char,
                                        if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                            b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                        } else {
                                            b"SCTP_NR_SACK\x00" as *const u8 as *const libc::c_char
                                        },
                                    );
                                }
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvsacks,
                                1u32,
                            );
                            if stcb.is_null() {
                                if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0 {
                                    if system_base_info.debug_printf.is_some() {
                                        system_base_info
                                            .debug_printf
                                            .expect("non-null function pointer")(
                                            b"No stcb when processing %s chunk\n\x00" as *const u8
                                                as *const libc::c_char,
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                            } else {
                                                b"SCTP_NR_SACK\x00" as *const u8
                                                    as *const libc::c_char
                                            },
                                        );
                                    }
                                }
                                current_block = 13422570431586403309;
                            } else {
                                if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                    if (chk_length as libc::c_ulong)
                                        < ::std::mem::size_of::<sctp_sack_chunk>() as libc::c_ulong
                                    {
                                        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32
                                            != 0
                                        {
                                            if system_base_info.debug_printf.is_some() {
                                                system_base_info
                                                    .debug_printf
                                                    .expect("non-null function pointer")(
                                                    b"Bad size on SACK chunk, too small\n\x00"
                                                        as *const u8
                                                        as *const libc::c_char,
                                                );
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    } else {
                                        current_block = 17937968408868551711;
                                    }
                                } else if (*stcb).asoc.nrsack_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_nr_sack_chunk>() as libc::c_ulong
                                {
                                    if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0
                                    {
                                        if system_base_info.debug_printf.is_some() {
                                            system_base_info
                                                .debug_printf
                                                .expect("non-null function pointer")(
                                                b"Bad size on NR_SACK chunk, too small\n\x00"
                                                    as *const u8
                                                    as *const libc::c_char,
                                            );
                                        }
                                    }
                                    current_block = 13422570431586403309;
                                } else {
                                    current_block = 17937968408868551711;
                                }
                                match current_block {
                                    6765806975593869225 => {}
                                    13422570431586403309 => {}
                                    _ => {
                                        if !((*stcb).asoc.state & 0x7fi32 == 0x40i32) {
                                            let mut a_rwnd = 0;
                                            let mut cum_ack = 0;
                                            let mut num_seg = 0;
                                            let mut num_nr_seg = 0;
                                            let mut num_dup = 0;
                                            let mut flags = 0;
                                            let mut offset_seg = 0;
                                            let mut offset_dup = 0;
                                            flags = (*ch).chunk_flags;
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                let mut sack = 0 as *mut sctp_sack_chunk;
                                                sack = ch as *mut sctp_sack_chunk;
                                                cum_ack = ntohl((*sack).sack.cum_tsn_ack);
                                                num_seg = ntohs((*sack).sack.num_gap_ack_blks);
                                                num_nr_seg = 0u16;
                                                num_dup = ntohs((*sack).sack.num_dup_tsns);
                                                a_rwnd = ntohl((*sack).sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_sack_chunk>()
                                                        as
                                                        libc::c_ulong).wrapping_add((num_seg
                                                                                         as
                                                                                         libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                         as
                                                                                                                         libc::c_ulong)).wrapping_add((num_dup
                                                                                                                                                           as
                                                                                                                                                           libc::c_ulong).wrapping_mul(::std::mem::size_of::<uint32_t>()
                                                                                                                                                                                           as
                                                                                                                                                                                           libc::c_ulong))
                                                       !=
                                                       chk_length as
                                                           libc::c_ulong {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                           &
                                                           0x1000000u32 !=
                                                           0 {
                                                        if system_base_info.debug_printf.is_some()
                                                           {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"Bad size of SACK chunk\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char);
                                                        }
                                                    }
                                                    current_block =
                                                        13422570431586403309;
                                                } else {
                                                    offset_seg =
                                                        (*offset as
                                                             libc::c_ulong).wrapping_add(::std::mem::size_of::<sctp_sack_chunk>()
                                                                                             as
                                                                                             libc::c_ulong)
                                                            as libc::c_int;
                                                    offset_dup =
                                                        (offset_seg as
                                                             libc::c_ulong).wrapping_add((num_seg
                                                                                              as
                                                                                              libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                              as
                                                                                                                              libc::c_ulong))
                                                            as libc::c_int;
                                                    current_block =
                                                        8752412851861032177;
                                                }
                                            } else {
                                                let mut nr_sack = 0 as *mut sctp_nr_sack_chunk;
                                                nr_sack = ch as *mut sctp_nr_sack_chunk;
                                                cum_ack = ntohl((*nr_sack).nr_sack.cum_tsn_ack);
                                                num_seg =
                                                    ntohs((*nr_sack).nr_sack.num_gap_ack_blks);
                                                num_nr_seg =
                                                    ntohs((*nr_sack).nr_sack.num_nr_gap_ack_blks);
                                                num_dup = ntohs((*nr_sack).nr_sack.num_dup_tsns);
                                                a_rwnd = ntohl((*nr_sack).nr_sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_nr_sack_chunk>()
                                                    as libc::c_ulong)
                                                    .wrapping_add(
                                                        ((num_seg as libc::c_int
                                                            + num_nr_seg as libc::c_int)
                                                            as libc::c_ulong)
                                                            .wrapping_mul(::std::mem::size_of::<
                                                                sctp_gap_ack_block,
                                                            >(
                                                            )
                                                                as libc::c_ulong),
                                                    )
                                                    .wrapping_add(
                                                        (num_dup as libc::c_ulong).wrapping_mul(
                                                            ::std::mem::size_of::<uint32_t>()
                                                                as libc::c_ulong,
                                                        ),
                                                    )
                                                    != chk_length as libc::c_ulong
                                                {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x1000000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"Bad size of NR_SACK chunk\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    current_block = 13422570431586403309;
                                                } else {
                                                    offset_seg = (*offset as libc::c_ulong)
                                                        .wrapping_add(::std::mem::size_of::<
                                                            sctp_nr_sack_chunk,
                                                        >(
                                                        )
                                                            as libc::c_ulong)
                                                        as libc::c_int;
                                                    offset_dup = (offset_seg as libc::c_ulong)
                                                        .wrapping_add(
                                                            ((num_seg as libc::c_int
                                                                + num_nr_seg as libc::c_int)
                                                                as libc::c_ulong)
                                                                .wrapping_mul(
                                                                    ::std::mem::size_of::<
                                                                        sctp_gap_ack_block,
                                                                    >(
                                                                    )
                                                                        as libc::c_ulong,
                                                                ),
                                                        )
                                                        as libc::c_int;
                                                    current_block = 8752412851861032177;
                                                }
                                            }
                                            match current_block {
                                                13422570431586403309 => {}
                                                _ => {
                                                    let mut abort_now = 0i32;
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"%s process cum_ack:%x num_seg:%d a_rwnd:%d\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char,
                                                                                                                              if (*ch).chunk_type
                                                                                                                                     as
                                                                                                                                     libc::c_int
                                                                                                                                     ==
                                                                                                                                     0x3i32
                                                                                                                                 {
                                                                                                                                  b"SCTP_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              } else {
                                                                                                                                  b"SCTP_NR_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              },
                                                                                                                              cum_ack,
                                                                                                                              num_seg
                                                                                                                                  as
                                                                                                                                  libc::c_int,
                                                                                                                              a_rwnd);
                                                        }
                                                    }
                                                    (*stcb).asoc.seen_a_sack_this_pkt = 1u8;
                                                    if (*stcb).asoc.pr_sctp_cnt == 0u32
                                                        && num_seg as libc::c_int == 0i32
                                                        && num_nr_seg as libc::c_int == 0i32
                                                        && (cum_ack < (*stcb).asoc.last_acked_seq
                                                            && (*stcb)
                                                                .asoc
                                                                .last_acked_seq
                                                                .wrapping_sub(cum_ack)
                                                                > (1u32) << 31i32
                                                            || cum_ack
                                                                > (*stcb).asoc.last_acked_seq
                                                                && cum_ack.wrapping_sub(
                                                                    (*stcb).asoc.last_acked_seq,
                                                                ) < (1u32) << 31i32
                                                            || cum_ack
                                                                == (*stcb).asoc.last_acked_seq)
                                                        && (*stcb).asoc.saw_sack_with_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && (*stcb).asoc.saw_sack_with_nr_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && !(*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                    {
                                                        sctp_express_handle_sack(
                                                            stcb,
                                                            cum_ack,
                                                            a_rwnd,
                                                            &mut abort_now,
                                                            ecne_seen,
                                                        );
                                                    } else if !netp.is_null() && !(*netp).is_null()
                                                    {
                                                        sctp_handle_sack(
                                                            m,
                                                            offset_seg,
                                                            offset_dup,
                                                            stcb,
                                                            num_seg,
                                                            num_nr_seg,
                                                            num_dup,
                                                            &mut abort_now,
                                                            flags,
                                                            cum_ack,
                                                            a_rwnd,
                                                            ecne_seen,
                                                        );
                                                    }
                                                    if abort_now != 0 {
                                                        *offset = length;
                                                        return 0 as *mut sctp_tcb;
                                                    }
                                                    if (*stcb).asoc.send_queue.tqh_first.is_null()
                                                        && (*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                        && (*stcb).asoc.stream_queue_cnt == 0u32
                                                    {
                                                        sctp_ulp_notify(
                                                            26u32,
                                                            stcb,
                                                            0u32,
                                                            0 as *mut libc::c_void,
                                                            0i32,
                                                        );
                                                    }
                                                }
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    }
                                }
                            }
                        }
                        2349180396633407496 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_AUTHENTICATION\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null() {
                                if auth_skipped == 0i32 {
                                    auth_offset = *offset as uint32_t;
                                    auth_len = chk_length;
                                    auth_skipped = 1i32
                                }
                                current_block = 13422570431586403309;
                            } else if (*stcb).asoc.auth_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_auth_chunk>() as libc::c_ulong
                                    || chk_length as libc::c_ulong
                                        > (::std::mem::size_of::<sctp_auth_chunk>()
                                            as libc::c_ulong)
                                            .wrapping_add(32u64)
                                {
                                    *offset = length;
                                    return stcb;
                                }
                                if got_auth == 1i32 {
                                    current_block = 13422570431586403309;
                                } else {
                                    got_auth = 1i32;
                                    if ch.is_null()
                                        || sctp_handle_auth(
                                            stcb,
                                            ch as *mut sctp_auth_chunk,
                                            m,
                                            *offset as uint32_t,
                                        ) != 0
                                    {
                                        *offset = length;
                                        return stcb;
                                    } else {
                                        (*stcb).asoc.authenticated = 1u8
                                    }
                                    current_block = 13422570431586403309;
                                }
                            }
                        }
                        _ => {}
                    }
                    match current_block {
                        13422570431586403309 => {}
                        _ => {
                            if (*ch).chunk_type as libc::c_int & 0x40i32 != 0 && !stcb.is_null() {
                                op_err = sctp_get_mbuf_for_msg(
                                    ::std::mem::size_of::<sctp_gen_error_cause>() as libc::c_uint,
                                    0i32,
                                    0x1i32,
                                    1i32,
                                    1i32,
                                );
                                if !op_err.is_null() {
                                    let mut cause = 0 as *mut sctp_gen_error_cause;
                                    let mut len = 0;
                                    len = if (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                        > (length - *offset) as uint32_t
                                    {
                                        (length - *offset) as uint32_t
                                    } else {
                                        (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                    } as libc::c_int;
                                    cause = (*op_err).m_hdr.mh_data as *mut sctp_gen_error_cause;
                                    (*cause).code = htons(0x6u16);
                                    (*cause).length =
                                        htons((len as libc::c_ulong).wrapping_add(
                                            ::std::mem::size_of::<sctp_gen_error_cause>()
                                                as libc::c_ulong,
                                        )
                                            as uint16_t);
                                    (*op_err).m_hdr.mh_len =
                                        ::std::mem::size_of::<sctp_gen_error_cause>()
                                            as libc::c_int;
                                    (*op_err).m_hdr.mh_next = m_copym(m, *offset, len, 0x1i32);
                                    if !(*op_err).m_hdr.mh_next.is_null() {
                                        sctp_queue_op_err(stcb, op_err);
                                    } else {
                                        m_freem(op_err);
                                    }
                                }
                            }
                            if (*ch).chunk_type as libc::c_int & 0x80i32 == 0i32 {
                                *offset = length;
                                return stcb;
                            }
                        }
                    }
                }
                _ => {
                    current_block = 6765806975593869225;
                    match current_block {
                        17766256343850198083 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_COMPLETE, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_complete(
                                    ch as *mut sctp_shutdown_complete_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        12601157616349825580 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT_ACK\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0 {
                                } else {
                                    *offset = length;
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1di32);
                                    }
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                ret = sctp_handle_init_ack(
                                    m,
                                    iphlen,
                                    *offset,
                                    src,
                                    dst,
                                    sh,
                                    ch as *mut sctp_init_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_no_unlock,
                                    vrf_id,
                                )
                            } else {
                                ret = -(1i32)
                            }
                            *offset = length;
                            if abort_no_unlock != 0 {
                                return 0 as *mut sctp_tcb;
                            }
                            if !stcb.is_null() && ret == 0i32 {
                                sctp_chunk_output((*stcb).sctp_ep, stcb, 3i32, 0i32);
                            }
                            return stcb;
                        }
                        16195856799229720522 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_INIT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if num_chunks > 1i32
                                || length - *offset
                                    > ((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
                                        as libc::c_int
                            {
                                *offset = length;
                                if !stcb.is_null() {
                                    pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                }
                                return 0 as *mut sctp_tcb;
                            }
                            if chk_length > (65535i32 - 2048i32) as libc::c_uint {
                                op_err = sctp_generate_cause(
                                    0x4u16,
                                    b"\x00" as *const u8 as *mut libc::c_char,
                                );
                                sctp_abort_association(
                                    inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id, port,
                                );
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            sctp_handle_init(
                                m,
                                iphlen,
                                *offset,
                                src,
                                dst,
                                sh,
                                ch as *mut sctp_init_chunk,
                                inp,
                                stcb,
                                *netp,
                                &mut abort_no_unlock,
                                vrf_id,
                                port,
                            );
                            *offset = length;
                            if abort_no_unlock == 0 && !stcb.is_null() {
                                pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                            }
                            return 0 as *mut sctp_tcb;
                        }
                        6246479402878884953 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_shutdown_ack(
                                    ch as *mut sctp_shutdown_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            *offset = length;
                            return 0 as *mut sctp_tcb;
                        }
                        4558417918157925232 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ABORT, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            *offset = length;
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if sctp_handle_abort(ch as *mut sctp_abort_chunk, stcb, *netp) != 0
                                {
                                    return 0 as *mut sctp_tcb;
                                } else {
                                    return stcb;
                                }
                            } else {
                                return 0 as *mut sctp_tcb;
                            }
                        }
                        9379646460352968115 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ECHO, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if !stcb.is_null() && (*stcb).asoc.total_output_queue_size > 0u32 {
                                current_block = 15201865807353435331;
                            } else if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                current_block = 15767785092075175044;
                            } else {
                                current_block = 15201865807353435331;
                            }
                            match current_block {
                                15201865807353435331 => {
                                    if stcb.is_null()
                                        && (!((*inp).sctp_flags & 0x8u32 != 0u32)
                                            || (*inp).sctp_flags & 0x1u32 == 0
                                                && (*(*inp).sctp_socket).so_qlen as libc::c_int
                                                    >= (*(*inp).sctp_socket).so_qlimit
                                                        as libc::c_int)
                                    {
                                        if (*inp).sctp_flags & 0x2u32 != 0
                                            && system_base_info
                                                .sctpsysctl
                                                .sctp_abort_if_one_2_one_hits_limit
                                                != 0
                                        {
                                            op_err = sctp_generate_cause(
                                                0x4u16,
                                                b"\x00" as *const u8 as *mut libc::c_char,
                                            );
                                            sctp_abort_association(
                                                inp, stcb, m, iphlen, src, dst, sh, op_err, vrf_id,
                                                port,
                                            );
                                        }
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    } else {
                                        let mut linp = 0 as *mut sctp_inpcb;
                                        if !stcb.is_null() {
                                            linp = 0 as *mut sctp_inpcb
                                        } else {
                                            linp = inp
                                        }
                                        if !linp.is_null() {
                                            pthread_mutex_lock(&mut (*linp).inp_create_mtx);
                                            if (*inp).sctp_flags & 0x10000000u32 != 0
                                                || (*inp).sctp_flags & 0x20000000u32 != 0
                                            {
                                                pthread_mutex_unlock(&mut (*linp).inp_create_mtx);
                                                current_block = 15767785092075175044;
                                            } else {
                                                current_block = 2358125959230175008;
                                            }
                                        } else {
                                            current_block = 2358125959230175008;
                                        }
                                        match current_block {
                                            15767785092075175044 => {}
                                            _ => {
                                                let mut ret_buf = 0 as *mut mbuf;
                                                if !netp.is_null() {
                                                    let mut locked_stcb = 0 as *mut sctp_tcb;
                                                    locked_stcb = stcb;
                                                    ret_buf = sctp_handle_cookie_echo(
                                                        m,
                                                        iphlen,
                                                        *offset,
                                                        src,
                                                        dst,
                                                        sh,
                                                        ch as *mut sctp_cookie_echo_chunk,
                                                        &mut inp,
                                                        &mut stcb,
                                                        netp,
                                                        auth_skipped,
                                                        auth_offset,
                                                        auth_len,
                                                        &mut locked_stcb,
                                                        vrf_id,
                                                        port,
                                                    );
                                                    if !locked_stcb.is_null() && locked_stcb != stcb
                                                    {
                                                        pthread_mutex_unlock(
                                                            &mut (*locked_stcb).tcb_mtx,
                                                        );
                                                    }
                                                    !stcb.is_null();
                                                } else {
                                                    ret_buf = 0 as *mut mbuf
                                                }
                                                if !linp.is_null() {
                                                    pthread_mutex_unlock(
                                                        &mut (*linp).inp_create_mtx,
                                                    );
                                                }
                                                if ret_buf.is_null() {
                                                    if !stcb.is_null() {
                                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                                    }
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"GAK, null buffer\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    *offset = length;
                                                    return 0 as *mut sctp_tcb;
                                                }
                                                if auth_skipped != 0 {
                                                    got_auth = 1i32;
                                                    auth_skipped = 0i32
                                                }
                                                if !(*stcb).asoc.sent_queue.tqh_first.is_null() {
                                                    let mut chk = 0 as *mut sctp_tmit_chunk;
                                                    chk = (*stcb).asoc.sent_queue.tqh_first;
                                                    sctp_timer_start(
                                                        1i32,
                                                        (*stcb).sctp_ep,
                                                        stcb,
                                                        (*chk).whoTo,
                                                    );
                                                }
                                                current_block = 13422570431586403309;
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                            match current_block {
                                13422570431586403309 => {}
                                _ => {
                                    if !stcb.is_null() {
                                        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                                    }
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                        }
                        10582330624169799780 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_PACKET_DROPPED\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_pktdrop_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !ch.is_null()
                                && !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                            {
                                if (*stcb).asoc.pktdrop_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_packet_dropped(
                                        ch as *mut sctp_pktdrop_chunk,
                                        stcb,
                                        *netp,
                                        if chk_length > contiguous {
                                            contiguous
                                        } else {
                                            chk_length
                                        },
                                    );
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13268550889959046632 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_STREAM_RESET\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || ch.is_null()
                                || (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_stream_reset_tsn_req>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.reconfig_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if sctp_handle_stream_reset(stcb, m, *offset, ch) != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                                current_block = 13422570431586403309;
                            }
                        }
                        13497718421940148126 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_FWD_TSN\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_forward_tsn_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.prsctp_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    let mut abort_flag_0 = 0i32;
                                    *fwd_tsn_seen = 1i32;
                                    if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1fi32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    (*stcb).asoc.last_data_chunk_from =
                                        (*stcb).asoc.last_control_chunk_from;
                                    sctp_handle_forward_tsn(
                                        stcb,
                                        ch as *mut sctp_forward_tsn_chunk,
                                        &mut abort_flag_0,
                                        m,
                                        *offset,
                                    );
                                    if abort_flag_0 != 0 {
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        13226217046118304493 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if (chk_length as libc::c_ulong)
                                < ::std::mem::size_of::<sctp_asconf_ack_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    if system_base_info.sctpsysctl.sctp_logging_level & 0x2000000u32
                                        != 0
                                    {
                                        sctp_misc_ints(
                                            120u8,
                                            (*stcb).asoc.overall_error_count,
                                            0u32,
                                            0x10000000u32,
                                            5531u32,
                                        );
                                    }
                                    (*stcb).asoc.overall_error_count = 0u32;
                                    sctp_handle_asconf_ack(
                                        m,
                                        *offset,
                                        ch as *mut sctp_asconf_ack_chunk,
                                        stcb,
                                        *netp,
                                        &mut abort_no_unlock,
                                    );
                                    if abort_no_unlock != 0 {
                                        return 0 as *mut sctp_tcb;
                                    }
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        11399179239179359665 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ASCONF\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() {
                                if (*stcb).asoc.asconf_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else {
                                    sctp_handle_asconf(
                                        m,
                                        *offset as libc::c_uint,
                                        src,
                                        ch as *mut sctp_asconf_chunk,
                                        stcb,
                                        (asconf_cnt == 0i32) as libc::c_int,
                                    );
                                    asconf_cnt += 1;
                                    current_block = 13422570431586403309;
                                }
                            } else {
                                current_block = 13422570431586403309;
                            }
                        }
                        3371148184269687219 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_CWR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cwr_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_cwr(ch as *mut sctp_cwr_chunk, stcb, *netp);
                                current_block = 13422570431586403309;
                            }
                        }
                        13594799726619700391 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_ECN_ECHO\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_ecne_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if (*stcb).asoc.ecn_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                sctp_handle_ecn_echo(ch as *mut sctp_ecne_chunk, stcb);
                                ecne_seen = 1i32;
                                current_block = 13422570431586403309;
                            }
                        }
                        2781125740367032387 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_COOKIE_ACK, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_cookie_ack_chunk>()
                                        as libc::c_ulong
                            {
                                return stcb;
                            }
                            if (*inp).sctp_flags & 0x10000000u32 != 0 {
                                if !(!stcb.is_null() && (*stcb).asoc.total_output_queue_size != 0) {
                                    if !stcb.is_null() {
                                        sctp_free_assoc(inp, stcb, 0i32, 0x10000000i32 + 0x1ei32);
                                        *offset = length;
                                        return 0 as *mut sctp_tcb;
                                    }
                                }
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_cookie_ack(
                                    ch as *mut sctp_cookie_ack_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        17092723434217905016 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_OP_ERR\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null()
                                && !netp.is_null()
                                && !(*netp).is_null()
                                && sctp_handle_error(ch, stcb, *netp, contiguous) < 0i32
                            {
                                *offset = length;
                                return 0 as *mut sctp_tcb;
                            }
                            current_block = 13422570431586403309;
                        }
                        6770586402544785651 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_SHUTDOWN, stcb %p\n\x00" as *const u8
                                            as *const libc::c_char,
                                        stcb as *mut libc::c_void,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_shutdown_chunk>() as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            if !netp.is_null() && !(*netp).is_null() {
                                let mut abort_flag = 0i32;
                                sctp_handle_shutdown(
                                    ch as *mut sctp_shutdown_chunk,
                                    stcb,
                                    *netp,
                                    &mut abort_flag,
                                );
                                if abort_flag != 0 {
                                    *offset = length;
                                    return 0 as *mut sctp_tcb;
                                }
                            }
                            current_block = 13422570431586403309;
                        }
                        12945290292467802513 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT_ACK\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null()
                                || chk_length as libc::c_ulong
                                    != ::std::mem::size_of::<sctp_heartbeat_chunk>()
                                        as libc::c_ulong
                            {
                                *offset = length;
                                return stcb;
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvheartbeatack,
                                1u32,
                            );
                            if !netp.is_null() && !(*netp).is_null() {
                                sctp_handle_heartbeat_ack(
                                    ch as *mut sctp_heartbeat_chunk,
                                    stcb,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        5491205026464363454 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_HEARTBEAT\n\x00" as *const u8 as *const libc::c_char,
                                    );
                                }
                            }
                            if !stcb.is_null() && !netp.is_null() && !(*netp).is_null() {
                                ::std::intrinsics::atomic_xadd(
                                    &mut system_base_info.sctpstat.sctps_recvheartbeat,
                                    1u32,
                                );
                                sctp_send_heartbeat_ack(
                                    stcb,
                                    m,
                                    *offset,
                                    chk_length as libc::c_int,
                                    *netp,
                                );
                            }
                            current_block = 13422570431586403309;
                        }
                        7940804887512848672 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"%s\n\x00" as *const u8 as *const libc::c_char,
                                        if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                            b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                        } else {
                                            b"SCTP_NR_SACK\x00" as *const u8 as *const libc::c_char
                                        },
                                    );
                                }
                            }
                            ::std::intrinsics::atomic_xadd(
                                &mut system_base_info.sctpstat.sctps_recvsacks,
                                1u32,
                            );
                            if stcb.is_null() {
                                if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0 {
                                    if system_base_info.debug_printf.is_some() {
                                        system_base_info
                                            .debug_printf
                                            .expect("non-null function pointer")(
                                            b"No stcb when processing %s chunk\n\x00" as *const u8
                                                as *const libc::c_char,
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                b"SCTP_SACK\x00" as *const u8 as *const libc::c_char
                                            } else {
                                                b"SCTP_NR_SACK\x00" as *const u8
                                                    as *const libc::c_char
                                            },
                                        );
                                    }
                                }
                                current_block = 13422570431586403309;
                            } else {
                                if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                    if (chk_length as libc::c_ulong)
                                        < ::std::mem::size_of::<sctp_sack_chunk>() as libc::c_ulong
                                    {
                                        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32
                                            != 0
                                        {
                                            if system_base_info.debug_printf.is_some() {
                                                system_base_info
                                                    .debug_printf
                                                    .expect("non-null function pointer")(
                                                    b"Bad size on SACK chunk, too small\n\x00"
                                                        as *const u8
                                                        as *const libc::c_char,
                                                );
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    } else {
                                        current_block = 17937968408868551711;
                                    }
                                } else if (*stcb).asoc.nrsack_supported as libc::c_int == 0i32 {
                                    current_block = 6765806975593869225;
                                } else if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_nr_sack_chunk>() as libc::c_ulong
                                {
                                    if system_base_info.sctpsysctl.sctp_debug_on & 0x1000000u32 != 0
                                    {
                                        if system_base_info.debug_printf.is_some() {
                                            system_base_info
                                                .debug_printf
                                                .expect("non-null function pointer")(
                                                b"Bad size on NR_SACK chunk, too small\n\x00"
                                                    as *const u8
                                                    as *const libc::c_char,
                                            );
                                        }
                                    }
                                    current_block = 13422570431586403309;
                                } else {
                                    current_block = 17937968408868551711;
                                }
                                match current_block {
                                    6765806975593869225 => {}
                                    13422570431586403309 => {}
                                    _ => {
                                        if !((*stcb).asoc.state & 0x7fi32 == 0x40i32) {
                                            let mut a_rwnd = 0;
                                            let mut cum_ack = 0;
                                            let mut num_seg = 0;
                                            let mut num_nr_seg = 0;
                                            let mut num_dup = 0;
                                            let mut flags = 0;
                                            let mut offset_seg = 0;
                                            let mut offset_dup = 0;
                                            flags = (*ch).chunk_flags;
                                            if (*ch).chunk_type as libc::c_int == 0x3i32 {
                                                let mut sack = 0 as *mut sctp_sack_chunk;
                                                sack = ch as *mut sctp_sack_chunk;
                                                cum_ack = ntohl((*sack).sack.cum_tsn_ack);
                                                num_seg = ntohs((*sack).sack.num_gap_ack_blks);
                                                num_nr_seg = 0u16;
                                                num_dup = ntohs((*sack).sack.num_dup_tsns);
                                                a_rwnd = ntohl((*sack).sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_sack_chunk>()
                                                        as
                                                        libc::c_ulong).wrapping_add((num_seg
                                                                                         as
                                                                                         libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                         as
                                                                                                                         libc::c_ulong)).wrapping_add((num_dup
                                                                                                                                                           as
                                                                                                                                                           libc::c_ulong).wrapping_mul(::std::mem::size_of::<uint32_t>()
                                                                                                                                                                                           as
                                                                                                                                                                                           libc::c_ulong))
                                                       !=
                                                       chk_length as
                                                           libc::c_ulong {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                           &
                                                           0x1000000u32 !=
                                                           0 {
                                                        if system_base_info.debug_printf.is_some()
                                                           {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"Bad size of SACK chunk\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char);
                                                        }
                                                    }
                                                    current_block =
                                                        13422570431586403309;
                                                } else {
                                                    offset_seg =
                                                        (*offset as
                                                             libc::c_ulong).wrapping_add(::std::mem::size_of::<sctp_sack_chunk>()
                                                                                             as
                                                                                             libc::c_ulong)
                                                            as libc::c_int;
                                                    offset_dup =
                                                        (offset_seg as
                                                             libc::c_ulong).wrapping_add((num_seg
                                                                                              as
                                                                                              libc::c_ulong).wrapping_mul(::std::mem::size_of::<sctp_gap_ack_block>()
                                                                                                                              as
                                                                                                                              libc::c_ulong))
                                                            as libc::c_int;
                                                    current_block =
                                                        8752412851861032177;
                                                }
                                            } else {
                                                let mut nr_sack = 0 as *mut sctp_nr_sack_chunk;
                                                nr_sack = ch as *mut sctp_nr_sack_chunk;
                                                cum_ack = ntohl((*nr_sack).nr_sack.cum_tsn_ack);
                                                num_seg =
                                                    ntohs((*nr_sack).nr_sack.num_gap_ack_blks);
                                                num_nr_seg =
                                                    ntohs((*nr_sack).nr_sack.num_nr_gap_ack_blks);
                                                num_dup = ntohs((*nr_sack).nr_sack.num_dup_tsns);
                                                a_rwnd = ntohl((*nr_sack).nr_sack.a_rwnd);
                                                if (::std::mem::size_of::<sctp_nr_sack_chunk>()
                                                    as libc::c_ulong)
                                                    .wrapping_add(
                                                        ((num_seg as libc::c_int
                                                            + num_nr_seg as libc::c_int)
                                                            as libc::c_ulong)
                                                            .wrapping_mul(::std::mem::size_of::<
                                                                sctp_gap_ack_block,
                                                            >(
                                                            )
                                                                as libc::c_ulong),
                                                    )
                                                    .wrapping_add(
                                                        (num_dup as libc::c_ulong).wrapping_mul(
                                                            ::std::mem::size_of::<uint32_t>()
                                                                as libc::c_ulong,
                                                        ),
                                                    )
                                                    != chk_length as libc::c_ulong
                                                {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x1000000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"Bad size of NR_SACK chunk\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    current_block = 13422570431586403309;
                                                } else {
                                                    offset_seg = (*offset as libc::c_ulong)
                                                        .wrapping_add(::std::mem::size_of::<
                                                            sctp_nr_sack_chunk,
                                                        >(
                                                        )
                                                            as libc::c_ulong)
                                                        as libc::c_int;
                                                    offset_dup = (offset_seg as libc::c_ulong)
                                                        .wrapping_add(
                                                            ((num_seg as libc::c_int
                                                                + num_nr_seg as libc::c_int)
                                                                as libc::c_ulong)
                                                                .wrapping_mul(
                                                                    ::std::mem::size_of::<
                                                                        sctp_gap_ack_block,
                                                                    >(
                                                                    )
                                                                        as libc::c_ulong,
                                                                ),
                                                        )
                                                        as libc::c_int;
                                                    current_block = 8752412851861032177;
                                                }
                                            }
                                            match current_block {
                                                13422570431586403309 => {}
                                                _ => {
                                                    let mut abort_now = 0i32;
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect("non-null function pointer")(b"%s process cum_ack:%x num_seg:%d a_rwnd:%d\n\x00"
                                                                                                                                  as
                                                                                                                                  *const u8
                                                                                                                                  as
                                                                                                                                  *const libc::c_char,
                                                                                                                              if (*ch).chunk_type
                                                                                                                                     as
                                                                                                                                     libc::c_int
                                                                                                                                     ==
                                                                                                                                     0x3i32
                                                                                                                                 {
                                                                                                                                  b"SCTP_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              } else {
                                                                                                                                  b"SCTP_NR_SACK\x00"
                                                                                                                                      as
                                                                                                                                      *const u8
                                                                                                                                      as
                                                                                                                                      *const libc::c_char
                                                                                                                              },
                                                                                                                              cum_ack,
                                                                                                                              num_seg
                                                                                                                                  as
                                                                                                                                  libc::c_int,
                                                                                                                              a_rwnd);
                                                        }
                                                    }
                                                    (*stcb).asoc.seen_a_sack_this_pkt = 1u8;
                                                    if (*stcb).asoc.pr_sctp_cnt == 0u32
                                                        && num_seg as libc::c_int == 0i32
                                                        && num_nr_seg as libc::c_int == 0i32
                                                        && (cum_ack < (*stcb).asoc.last_acked_seq
                                                            && (*stcb)
                                                                .asoc
                                                                .last_acked_seq
                                                                .wrapping_sub(cum_ack)
                                                                > (1u32) << 31i32
                                                            || cum_ack
                                                                > (*stcb).asoc.last_acked_seq
                                                                && cum_ack.wrapping_sub(
                                                                    (*stcb).asoc.last_acked_seq,
                                                                ) < (1u32) << 31i32
                                                            || cum_ack
                                                                == (*stcb).asoc.last_acked_seq)
                                                        && (*stcb).asoc.saw_sack_with_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && (*stcb).asoc.saw_sack_with_nr_frags
                                                            as libc::c_int
                                                            == 0i32
                                                        && !(*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                    {
                                                        sctp_express_handle_sack(
                                                            stcb,
                                                            cum_ack,
                                                            a_rwnd,
                                                            &mut abort_now,
                                                            ecne_seen,
                                                        );
                                                    } else if !netp.is_null() && !(*netp).is_null()
                                                    {
                                                        sctp_handle_sack(
                                                            m,
                                                            offset_seg,
                                                            offset_dup,
                                                            stcb,
                                                            num_seg,
                                                            num_nr_seg,
                                                            num_dup,
                                                            &mut abort_now,
                                                            flags,
                                                            cum_ack,
                                                            a_rwnd,
                                                            ecne_seen,
                                                        );
                                                    }
                                                    if abort_now != 0 {
                                                        *offset = length;
                                                        return 0 as *mut sctp_tcb;
                                                    }
                                                    if (*stcb).asoc.send_queue.tqh_first.is_null()
                                                        && (*stcb)
                                                            .asoc
                                                            .sent_queue
                                                            .tqh_first
                                                            .is_null()
                                                        && (*stcb).asoc.stream_queue_cnt == 0u32
                                                    {
                                                        sctp_ulp_notify(
                                                            26u32,
                                                            stcb,
                                                            0u32,
                                                            0 as *mut libc::c_void,
                                                            0i32,
                                                        );
                                                    }
                                                }
                                            }
                                        }
                                        current_block = 13422570431586403309;
                                    }
                                }
                            }
                        }
                        2349180396633407496 => {
                            if system_base_info.sctpsysctl.sctp_debug_on & 0x4000u32 != 0 {
                                if system_base_info.debug_printf.is_some() {
                                    system_base_info
                                        .debug_printf
                                        .expect("non-null function pointer")(
                                        b"SCTP_AUTHENTICATION\n\x00" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            if stcb.is_null() {
                                if auth_skipped == 0i32 {
                                    auth_offset = *offset as uint32_t;
                                    auth_len = chk_length;
                                    auth_skipped = 1i32
                                }
                                current_block = 13422570431586403309;
                            } else if (*stcb).asoc.auth_supported as libc::c_int == 0i32 {
                                current_block = 6765806975593869225;
                            } else {
                                if (chk_length as libc::c_ulong)
                                    < ::std::mem::size_of::<sctp_auth_chunk>() as libc::c_ulong
                                    || chk_length as libc::c_ulong
                                        > (::std::mem::size_of::<sctp_auth_chunk>()
                                            as libc::c_ulong)
                                            .wrapping_add(32u64)
                                {
                                    *offset = length;
                                    return stcb;
                                }
                                if got_auth == 1i32 {
                                    current_block = 13422570431586403309;
                                } else {
                                    got_auth = 1i32;
                                    if ch.is_null()
                                        || sctp_handle_auth(
                                            stcb,
                                            ch as *mut sctp_auth_chunk,
                                            m,
                                            *offset as uint32_t,
                                        ) != 0
                                    {
                                        *offset = length;
                                        return stcb;
                                    } else {
                                        (*stcb).asoc.authenticated = 1u8
                                    }
                                    current_block = 13422570431586403309;
                                }
                            }
                        }
                        _ => {}
                    }
                    match current_block {
                        13422570431586403309 => {}
                        _ => {
                            if (*ch).chunk_type as libc::c_int & 0x40i32 != 0 && !stcb.is_null() {
                                op_err = sctp_get_mbuf_for_msg(
                                    ::std::mem::size_of::<sctp_gen_error_cause>() as libc::c_uint,
                                    0i32,
                                    0x1i32,
                                    1i32,
                                    1i32,
                                );
                                if !op_err.is_null() {
                                    let mut cause = 0 as *mut sctp_gen_error_cause;
                                    let mut len = 0;
                                    len = if (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                        > (length - *offset) as uint32_t
                                    {
                                        (length - *offset) as uint32_t
                                    } else {
                                        (chk_length.wrapping_add(3u32) >> 2i32) << 2i32
                                    } as libc::c_int;
                                    cause = (*op_err).m_hdr.mh_data as *mut sctp_gen_error_cause;
                                    (*cause).code = htons(0x6u16);
                                    (*cause).length =
                                        htons((len as libc::c_ulong).wrapping_add(
                                            ::std::mem::size_of::<sctp_gen_error_cause>()
                                                as libc::c_ulong,
                                        )
                                            as uint16_t);
                                    (*op_err).m_hdr.mh_len =
                                        ::std::mem::size_of::<sctp_gen_error_cause>()
                                            as libc::c_int;
                                    (*op_err).m_hdr.mh_next = m_copym(m, *offset, len, 0x1i32);
                                    if !(*op_err).m_hdr.mh_next.is_null() {
                                        sctp_queue_op_err(stcb, op_err);
                                    } else {
                                        m_freem(op_err);
                                    }
                                }
                            }
                            if (*ch).chunk_type as libc::c_int & 0x80i32 == 0i32 {
                                *offset = length;
                                return stcb;
                            }
                        }
                    }
                }
            }
        }
        /* skip this chunk... it's already auth'd */
        /* get the next chunk */
        *offset = (*offset as libc::c_uint)
            .wrapping_add((chk_length.wrapping_add(3u32) >> 2i32) << 2i32)
            as libc::c_int;
        if *offset >= length {
            break;
        }
        ch = sctp_m_getptr(
            m,
            *offset,
            ::std::mem::size_of::<sctp_chunkhdr>() as libc::c_int,
            chunk_buf.as_mut_ptr(),
        ) as *mut sctp_chunkhdr;
        if ch.is_null() {
            *offset = length;
            return stcb;
        }
    }
    /* no more data left in the mbuf chain */
    if asconf_cnt > 0i32 && !stcb.is_null() {
        sctp_send_asconf_ack(stcb);
    }
    return stcb;
}
/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 2001-2007, by Cisco Systems, Inc. All rights reserved.
 * Copyright (c) 2008-2012, by Randall Stewart. All rights reserved.
 * Copyright (c) 2008-2012, by Michael Tuexen. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * a) Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * b) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the distribution.
 *
 * c) Neither the name of Cisco Systems, Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * common input chunk processing (v4 and v6)
 */
#[no_mangle]
pub unsafe extern "C" fn sctp_common_input_processing(
    mut mm: *mut *mut mbuf,
    mut iphlen: libc::c_int,
    mut offset: libc::c_int,
    mut length: libc::c_int,
    mut src: *mut sockaddr,
    mut dst: *mut sockaddr,
    mut sh: *mut sctphdr,
    mut ch: *mut sctp_chunkhdr,
    mut compute_crc: uint8_t,
    mut ecn_bits: uint8_t,
    mut vrf_id: uint32_t,
    mut port: uint16_t,
) {
    let mut current_block: u64;
    let mut inp = 0 as *mut sctp_inpcb;
    let mut inp_decr = 0 as *mut sctp_inpcb;
    let mut stcb = 0 as *mut sctp_tcb;
    let mut net = 0 as *mut sctp_nets;
    let mut upcall_socket = 0 as *mut socket;
    let mut m = *mm;

    ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_recvdatagrams, 1u32);
    if compute_crc as libc::c_int != 0i32 {
        let mut check = 0;
        let mut calc_check = 0;
        check = (*sh).checksum;
        (*sh).checksum = 0u32;
        calc_check = sctp_calculate_cksum(m, iphlen as uint32_t);
        (*sh).checksum = check;
        if calc_check != check {
            if system_base_info.sctpsysctl.sctp_debug_on & 0x1000u32 != 0 {
                if system_base_info.debug_printf.is_some() {
                    system_base_info.debug_printf.expect("non-null function pointer")(b"Bad CSUM on SCTP packet calc_check:%x check:%x  m:%p mlen:%d iphlen:%d\n\x00"
                                                                                          as
                                                                                          *const u8
                                                                                          as
                                                                                          *const libc::c_char,
                                                                                      calc_check,
                                                                                      check,
                                                                                      m
                                                                                          as
                                                                                          *mut libc::c_void,
                                                                                      length,
                                                                                      iphlen);
                }
            }
            stcb =
                sctp_findassociation_addr(m, offset, src, dst, sh, ch, &mut inp, &mut net, vrf_id);
            if (*ch).chunk_type as libc::c_int != 0x1i32
                && !net.is_null()
                && (*net).port as libc::c_int != port as libc::c_int
            {
                if (*net).port as libc::c_int == 0i32 {
                    /* UDP encapsulation turned on. */
                    (*net).mtu = ((*net).mtu as libc::c_ulong)
                        .wrapping_sub(::std::mem::size_of::<udphdr>() as libc::c_ulong)
                        as uint32_t;
                    if (*stcb).asoc.smallest_mtu > (*net).mtu {
                        sctp_pathmtu_adjustment(stcb, (*net).mtu as uint16_t);
                    }
                } else if port as libc::c_int == 0i32 {
                    /* UDP encapsulation turned off. */
                    (*net).mtu = ((*net).mtu as libc::c_ulong)
                        .wrapping_add(::std::mem::size_of::<udphdr>() as libc::c_ulong)
                        as uint32_t
                    /* XXX Update smallest_mtu */
                }
                (*net).port = port
            }
            if !inp.is_null() && !stcb.is_null() {
                sctp_send_packet_dropped(stcb, net, m, length, iphlen, 1i32);
                sctp_chunk_output(inp, stcb, 2i32, 0i32);
            } else if !inp.is_null() && stcb.is_null() {
                inp_decr = inp
            }
            ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_badsum, 1u32);
            ::std::intrinsics::atomic_xadd(
                &mut system_base_info.sctpstat.sctps_checksumerrors,
                1u32,
            );
            current_block = 12421478865789499693;
        } else {
            current_block = 12997042908615822766;
        }
    } else {
        current_block = 12997042908615822766;
    }
    match current_block {
        12997042908615822766 =>
        /* Destination port of 0 is illegal, based on RFC4960. */
        {
            if (*sh).dest_port as libc::c_int == 0i32 {
                ::std::intrinsics::atomic_xadd(&mut system_base_info.sctpstat.sctps_hdrops, 1u32);
            } else {
                let mut op_err = 0 as *mut mbuf;
                stcb = sctp_findassociation_addr(
                    m, offset, src, dst, sh, ch, &mut inp, &mut net, vrf_id,
                );
                if (*ch).chunk_type as libc::c_int != 0x1i32
                    && !net.is_null()
                    && (*net).port as libc::c_int != port as libc::c_int
                {
                    if (*net).port as libc::c_int == 0i32 {
                        /* UDP encapsulation turned on. */
                        (*net).mtu = ((*net).mtu as libc::c_ulong)
                            .wrapping_sub(::std::mem::size_of::<udphdr>() as libc::c_ulong)
                            as uint32_t;
                        if (*stcb).asoc.smallest_mtu > (*net).mtu {
                            sctp_pathmtu_adjustment(stcb, (*net).mtu as uint16_t);
                        }
                    } else if port as libc::c_int == 0i32 {
                        /* UDP encapsulation turned off. */
                        (*net).mtu = ((*net).mtu as libc::c_ulong)
                            .wrapping_add(::std::mem::size_of::<udphdr>() as libc::c_ulong)
                            as uint32_t
                        /* XXX Update smallest_mtu */
                    }
                    (*net).port = port
                }
                if inp.is_null() {
                    ::std::intrinsics::atomic_xadd(
                        &mut system_base_info.sctpstat.sctps_noport,
                        1u32,
                    );
                    if (*ch).chunk_type as libc::c_int == 0x8i32 {
                        sctp_send_shutdown_complete2(src, dst, sh, vrf_id, port);
                    } else if !((*ch).chunk_type as libc::c_int == 0xei32) {
                        if (*ch).chunk_type as libc::c_int != 0x6i32 {
                            if system_base_info.sctpsysctl.sctp_blackhole == 0u32
                                || system_base_info.sctpsysctl.sctp_blackhole == 1u32
                                    && (*ch).chunk_type as libc::c_int != 0x1i32
                            {
                                op_err = sctp_generate_cause(
                                    system_base_info.sctpsysctl.sctp_diag_info_code as uint16_t,
                                    b"Out of the blue\x00" as *const u8 as *mut libc::c_char,
                                );
                                sctp_send_abort(
                                    m, iphlen, src, dst, sh, 0u32, op_err, vrf_id, port,
                                );
                            }
                        }
                    }
                } else {
                    let mut msg = [0; 128];
                    if stcb.is_null() {
                        inp_decr = inp
                    }
                    if system_base_info.sctpsysctl.sctp_debug_on & 0x1000u32 != 0 {
                        if system_base_info.debug_printf.is_some() {
                            system_base_info.debug_printf.expect("non-null function pointer")(b"Ok, Common input processing called, m:%p iphlen:%d offset:%d length:%d stcb:%p\n\x00"
                                                                                                  as
                                                                                                  *const u8
                                                                                                  as
                                                                                                  *const libc::c_char,
                                                                                              m
                                                                                                  as
                                                                                                  *mut libc::c_void,
                                                                                              iphlen,
                                                                                              offset,
                                                                                              length,
                                                                                              stcb
                                                                                                  as
                                                                                                  *mut libc::c_void);
                        }
                    }
                    if !stcb.is_null() {
                        /* always clear this before beginning a packet */
                        (*stcb).asoc.authenticated = 0u8;
                        (*stcb).asoc.seen_a_sack_this_pkt = 0u8;
                        if system_base_info.sctpsysctl.sctp_debug_on & 0x1000u32 != 0 {
                            if system_base_info.debug_printf.is_some() {
                                system_base_info
                                    .debug_printf
                                    .expect("non-null function pointer")(
                                    b"stcb:%p state:%x\n\x00" as *const u8 as *const libc::c_char,
                                    stcb as *mut libc::c_void,
                                    (*stcb).asoc.state,
                                );
                            }
                        }
                        if (*stcb).asoc.state & 0x800i32 != 0 || (*stcb).asoc.state & 0x200i32 != 0
                        {
                            /*-
                             * If we hit here, we had a ref count
                             * up when the assoc was aborted and the
                             * timer is clearing out the assoc, we should
                             * NOT respond to any packet.. its OOTB.
                             */
                            pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
                            stcb = 0 as *mut sctp_tcb;
                            snprintf(msg.as_mut_ptr(),
                                     ::std::mem::size_of::<[libc::c_char; 128]>()
                                         as libc::c_ulong,
                                     b"OOTB, %s:%d at %s\x00" as *const u8 as
                                         *const libc::c_char,
                                     b"/usr/local/google/home/winniexiao/chromium/src/third_party/usrsctp/usrsctplib/usrsctplib/netinet/sctp_input.c\x00"
                                         as *const u8 as *const libc::c_char,
                                     5888i32,
                                     (*::std::mem::transmute::<&[u8; 29],
                                                               &[libc::c_char; 29]>(b"sctp_common_input_processing\x00")).as_ptr());
                            op_err = sctp_generate_cause(
                                system_base_info.sctpsysctl.sctp_diag_info_code as uint16_t,
                                msg.as_mut_ptr(),
                            );
                            sctp_handle_ootb(
                                m, iphlen, offset, src, dst, sh, inp, op_err, vrf_id, port,
                            );
                            current_block = 12421478865789499693;
                        } else {
                            current_block = 13003737910779602957;
                        }
                    } else {
                        current_block = 13003737910779602957;
                    }
                    match current_block {
                        12421478865789499693 => {}
                        _ => {
                            let mut fwd_tsn_seen = 0i32;
                            if !stcb.is_null()
                                && (*(*stcb).sctp_ep).sctp_flags & 0x10000000u32 == 0
                                && !(*stcb).sctp_socket.is_null()
                            {
                                if !(*(*stcb).sctp_socket).so_head.is_null() {
                                    upcall_socket = (*(*stcb).sctp_socket).so_head
                                } else {
                                    upcall_socket = (*stcb).sctp_socket
                                }
                                pthread_mutex_lock(&mut (*upcall_socket).so_rcv.sb_mtx);
                                (*upcall_socket).so_count += 1;
                                pthread_mutex_unlock(&mut (*upcall_socket).so_rcv.sb_mtx);
                            }
                            if (*ch).chunk_type as libc::c_int != 0i32
                                && (*ch).chunk_type as libc::c_int != 0x40i32
                            {
                                /* process the control portion of the SCTP packet */
                                /* sa_ignore NO_NULL_CHK */
                                stcb = sctp_process_control(
                                    m,
                                    iphlen,
                                    &mut offset,
                                    length,
                                    src,
                                    dst,
                                    sh,
                                    ch,
                                    inp,
                                    stcb,
                                    &mut net,
                                    &mut fwd_tsn_seen,
                                    vrf_id,
                                    port,
                                );
                                if !stcb.is_null() {
                                    /* This covers us if the cookie-echo was there
                                     * and it changes our INP.
                                     */
                                    inp = (*stcb).sctp_ep;
                                    if (*ch).chunk_type as libc::c_int != 0x1i32
                                        && !net.is_null()
                                        && (*net).port as libc::c_int != port as libc::c_int
                                    {
                                        if (*net).port as libc::c_int == 0i32 {
                                            /* UDP encapsulation turned on. */
                                            (*net).mtu = ((*net).mtu as libc::c_ulong)
                                                .wrapping_sub(::std::mem::size_of::<udphdr>()
                                                    as libc::c_ulong)
                                                as uint32_t;
                                            if (*stcb).asoc.smallest_mtu > (*net).mtu {
                                                sctp_pathmtu_adjustment(
                                                    stcb,
                                                    (*net).mtu as uint16_t,
                                                );
                                            }
                                        } else if port as libc::c_int == 0i32 {
                                            /* UDP encapsulation turned off. */
                                            (*net).mtu = ((*net).mtu as libc::c_ulong)
                                                .wrapping_add(::std::mem::size_of::<udphdr>()
                                                    as libc::c_ulong)
                                                as uint32_t
                                            /* XXX Update smallest_mtu */
                                        }
                                        (*net).port = port
                                    }
                                }
                                current_block = 9838996637140935403;
                            } else if !stcb.is_null()
                                && (if (*stcb).asoc.local_auth_chunks.is_null() {
                                    0i32
                                } else {
                                    ((*(*stcb).asoc.local_auth_chunks).chunks[0usize]
                                        as libc::c_int
                                        != 0i32) as libc::c_int
                                }) != 0
                            {
                                /*
                                 * no control chunks, so pre-process DATA chunks (these
                                 * checks are taken care of by control processing)
                                 */
                                /*
                                 * if DATA only packet, and auth is required, then punt...
                                 * can't have authenticated without any AUTH (control)
                                 * chunks
                                 */
                                /* "silently" ignore */
                                ::std::intrinsics::atomic_xadd(
                                    &mut system_base_info.sctpstat.sctps_recvauthmissing,
                                    1u32,
                                );
                                current_block = 12421478865789499693;
                            } else if stcb.is_null() {
                                /* out of the blue DATA chunk */
                                snprintf(msg.as_mut_ptr(),
                                         ::std::mem::size_of::<[libc::c_char; 128]>()
                                             as libc::c_ulong,
                                         b"OOTB, %s:%d at %s\x00" as *const u8
                                             as *const libc::c_char,
                                         b"/usr/local/google/home/winniexiao/chromium/src/third_party/usrsctp/usrsctplib/usrsctplib/netinet/sctp_input.c\x00"
                                             as *const u8 as
                                             *const libc::c_char,
                                         5971i32,
                                         (*::std::mem::transmute::<&[u8; 29],
                                                                   &[libc::c_char; 29]>(b"sctp_common_input_processing\x00")).as_ptr());
                                op_err = sctp_generate_cause(
                                    system_base_info.sctpsysctl.sctp_diag_info_code as uint16_t,
                                    msg.as_mut_ptr(),
                                );
                                sctp_handle_ootb(
                                    m, iphlen, offset, src, dst, sh, inp, op_err, vrf_id, port,
                                );
                                current_block = 12421478865789499693;
                            } else if (*stcb).asoc.my_vtag != ntohl((*sh).v_tag) {
                                /* v_tag mismatch! */
                                ::std::intrinsics::atomic_xadd(
                                    &mut system_base_info.sctpstat.sctps_badvtag,
                                    1u32,
                                );
                                current_block = 12421478865789499693;
                            } else {
                                current_block = 9838996637140935403;
                            }
                            match current_block {
                                12421478865789499693 => {}
                                _ => {
                                    if !stcb.is_null() {
                                        if upcall_socket.is_null()
                                            && (*(*stcb).sctp_ep).sctp_flags & 0x10000000u32 == 0
                                            && !(*stcb).sctp_socket.is_null()
                                        {
                                            if !(*(*stcb).sctp_socket).so_head.is_null() {
                                                upcall_socket = (*(*stcb).sctp_socket).so_head
                                            } else {
                                                upcall_socket = (*stcb).sctp_socket
                                            }
                                            pthread_mutex_lock(&mut (*upcall_socket).so_rcv.sb_mtx);
                                            (*upcall_socket).so_count += 1;
                                            pthread_mutex_unlock(
                                                &mut (*upcall_socket).so_rcv.sb_mtx,
                                            );
                                        }
                                        /*
                                         * DATA chunk processing
                                         */
                                        /* plow through the data chunks while length > offset */
                                        /*
                                         * Rest should be DATA only.  Check authentication state if AUTH for
                                         * DATA is required.
                                         */
                                        if length > offset
                                            && !stcb.is_null()
                                            && (if (*stcb).asoc.local_auth_chunks.is_null() {
                                                0i32
                                            } else {
                                                ((*(*stcb).asoc.local_auth_chunks).chunks[0usize]
                                                    as libc::c_int
                                                    != 0i32)
                                                    as libc::c_int
                                            }) != 0
                                            && (*stcb).asoc.authenticated == 0
                                        {
                                            /* "silently" ignore */
                                            ::std::intrinsics::atomic_xadd(
                                                &mut system_base_info
                                                    .sctpstat
                                                    .sctps_recvauthmissing,
                                                1u32,
                                            );
                                            if system_base_info.sctpsysctl.sctp_debug_on & 0x400u32
                                                != 0
                                            {
                                                if system_base_info.debug_printf.is_some() {
                                                    system_base_info
                                                        .debug_printf
                                                        .expect("non-null function pointer")(
                                                        b"Data chunk requires AUTH, skipped\n\x00"
                                                            as *const u8
                                                            as *const libc::c_char,
                                                    );
                                                }
                                            }
                                            current_block = 1855476810607665536;
                                        } else {
                                            let mut high_tsn = 0;
                                            let mut data_processed = 0i32;
                                            if length > offset {
                                                let mut retval = 0;
                                                /*
                                                 * Anything important needs to have been m_copy'ed in
                                                 * process_data
                                                 */
                                                match (*stcb).asoc.state & 0x7fi32 {
                                                    4 => {
                                                        current_block = 2508233535837710749;
                                                        match current_block {
                                                            9939481037457836954 => {
                                                                /*
                                                                 * First check to make sure our state is correct. We would
                                                                 * not get here unless we really did have a tag, so we don't
                                                                 * abort if this happens, just dump the chunk silently.
                                                                 */
                                                                /*
                                                                 * We consider OOTB any data sent during asoc setup.
                                                                 */
                                                                snprintf(msg.as_mut_ptr(),
                                                                         ::std::mem::size_of::<[libc::c_char; 128]>()
                                                                             as
                                                                             libc::c_ulong,
                                                                         b"OOTB, %s:%d at %s\x00"
                                                                             as
                                                                             *const u8
                                                                             as
                                                                             *const libc::c_char,
                                                                         b"/usr/local/google/home/winniexiao/chromium/src/third_party/usrsctp/usrsctplib/usrsctplib/netinet/sctp_input.c\x00"
                                                                             as
                                                                             *const u8
                                                                             as
                                                                             *const libc::c_char,
                                                                         6057i32,
                                                                         (*::std::mem::transmute::<&[u8; 29],
                                                                                                   &[libc::c_char; 29]>(b"sctp_common_input_processing\x00")).as_ptr());
                                                                op_err = sctp_generate_cause(
                                                                    system_base_info
                                                                        .sctpsysctl
                                                                        .sctp_diag_info_code
                                                                        as uint16_t,
                                                                    msg.as_mut_ptr(),
                                                                );
                                                                sctp_handle_ootb(
                                                                    m, iphlen, offset, src, dst,
                                                                    sh, inp, op_err, vrf_id, port,
                                                                );
                                                                current_block =
                                                                    12421478865789499693;
                                                            }
                                                            2508233535837710749 => {
                                                                /*
                                                                 * we consider data with valid tags in this state
                                                                 * shows us the cookie-ack was lost. Imply it was
                                                                 * there.
                                                                 */
                                                                sctp_handle_cookie_ack(ch
                                                                                           as
                                                                                           *mut sctp_cookie_ack_chunk,
                                                                                       stcb,
                                                                                       net);
                                                                current_block =
                                                                    13598848910332274892;
                                                            }
                                                            8048488660607665034 =>
                                                            /* should not happen */
                                                            {
                                                                current_block = 8591739767839194136;
                                                            }
                                                            _ => {}
                                                        }
                                                        match current_block {
                                                            12421478865789499693 => {}
                                                            _ => {
                                                                match current_block {
                                                                    8591739767839194136 =>
                                                                    /* should not happen */
                                                                    {
                                                                        current_block =
                                                                            12421478865789499693;
                                                                    }
                                                                    _ =>
                                                                    /*sa_ignore NOTREACHED*/
                                                                    /* plow through the data chunks while length > offset */
                                                                    {
                                                                        retval = sctp_process_data(
                                                                            mm,
                                                                            iphlen,
                                                                            &mut offset,
                                                                            length,
                                                                            inp,
                                                                            stcb,
                                                                            net,
                                                                            &mut high_tsn,
                                                                        );
                                                                        if retval == 2i32 {
                                                                            /*
                                                                             * The association aborted, NO UNLOCK needed since
                                                                             * the association is destroyed.
                                                                             */
                                                                            stcb =
                                                                                0 as *mut sctp_tcb;
                                                                            current_block
                                                                                =
                                                                                12421478865789499693;
                                                                        } else {
                                                                            data_processed = 1i32;
                                                                            current_block
                                                                                =
                                                                                11814324130289762492;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    2 => {
                                                        current_block = 9939481037457836954;
                                                        match current_block {
                                                            9939481037457836954 => {
                                                                snprintf(msg.as_mut_ptr(),
                                                                         ::std::mem::size_of::<[libc::c_char; 128]>()
                                                                             as
                                                                             libc::c_ulong,
                                                                         b"OOTB, %s:%d at %s\x00"
                                                                             as
                                                                             *const u8
                                                                             as
                                                                             *const libc::c_char,
                                                                         b"/usr/local/google/home/winniexiao/chromium/src/third_party/usrsctp/usrsctplib/usrsctplib/netinet/sctp_input.c\x00"
                                                                             as
                                                                             *const u8
                                                                             as
                                                                             *const libc::c_char,
                                                                         6057i32,
                                                                         (*::std::mem::transmute::<&[u8; 29],
                                                                                                   &[libc::c_char; 29]>(b"sctp_common_input_processing\x00")).as_ptr());
                                                                op_err = sctp_generate_cause(
                                                                    system_base_info
                                                                        .sctpsysctl
                                                                        .sctp_diag_info_code
                                                                        as uint16_t,
                                                                    msg.as_mut_ptr(),
                                                                );
                                                                sctp_handle_ootb(
                                                                    m, iphlen, offset, src, dst,
                                                                    sh, inp, op_err, vrf_id, port,
                                                                );
                                                                current_block =
                                                                    12421478865789499693;
                                                            }
                                                            2508233535837710749 => {
                                                                sctp_handle_cookie_ack(ch
                                                                                           as
                                                                                           *mut sctp_cookie_ack_chunk,
                                                                                       stcb,
                                                                                       net);
                                                                current_block =
                                                                    13598848910332274892;
                                                            }
                                                            8048488660607665034 => {
                                                                current_block = 8591739767839194136;
                                                            }
                                                            _ => {}
                                                        }
                                                        match current_block {
                                                            12421478865789499693 => {}
                                                            _ => match current_block {
                                                                8591739767839194136 => {
                                                                    current_block =
                                                                        12421478865789499693;
                                                                }
                                                                _ => {
                                                                    retval = sctp_process_data(
                                                                        mm,
                                                                        iphlen,
                                                                        &mut offset,
                                                                        length,
                                                                        inp,
                                                                        stcb,
                                                                        net,
                                                                        &mut high_tsn,
                                                                    );
                                                                    if retval == 2i32 {
                                                                        stcb = 0 as *mut sctp_tcb;
                                                                        current_block =
                                                                            12421478865789499693;
                                                                    } else {
                                                                        data_processed = 1i32;
                                                                        current_block =
                                                                            11814324130289762492;
                                                                    }
                                                                }
                                                            },
                                                        }
                                                    }
                                                    0 => {
                                                        current_block = 8048488660607665034;
                                                        match current_block {
                                                            9939481037457836954 => {
                                                                snprintf(msg.as_mut_ptr(),
                                                                         ::std::mem::size_of::<[libc::c_char; 128]>()
                                                                             as
                                                                             libc::c_ulong,
                                                                         b"OOTB, %s:%d at %s\x00"
                                                                             as
                                                                             *const u8
                                                                             as
                                                                             *const libc::c_char,
                                                                         b"/usr/local/google/home/winniexiao/chromium/src/third_party/usrsctp/usrsctplib/usrsctplib/netinet/sctp_input.c\x00"
                                                                             as
                                                                             *const u8
                                                                             as
                                                                             *const libc::c_char,
                                                                         6057i32,
                                                                         (*::std::mem::transmute::<&[u8; 29],
                                                                                                   &[libc::c_char; 29]>(b"sctp_common_input_processing\x00")).as_ptr());
                                                                op_err = sctp_generate_cause(
                                                                    system_base_info
                                                                        .sctpsysctl
                                                                        .sctp_diag_info_code
                                                                        as uint16_t,
                                                                    msg.as_mut_ptr(),
                                                                );
                                                                sctp_handle_ootb(
                                                                    m, iphlen, offset, src, dst,
                                                                    sh, inp, op_err, vrf_id, port,
                                                                );
                                                                current_block =
                                                                    12421478865789499693;
                                                            }
                                                            2508233535837710749 => {
                                                                sctp_handle_cookie_ack(ch
                                                                                           as
                                                                                           *mut sctp_cookie_ack_chunk,
                                                                                       stcb,
                                                                                       net);
                                                                current_block =
                                                                    13598848910332274892;
                                                            }
                                                            8048488660607665034 => {
                                                                current_block = 8591739767839194136;
                                                            }
                                                            _ => {}
                                                        }
                                                        match current_block {
                                                            12421478865789499693 => {}
                                                            _ => match current_block {
                                                                8591739767839194136 => {
                                                                    current_block =
                                                                        12421478865789499693;
                                                                }
                                                                _ => {
                                                                    retval = sctp_process_data(
                                                                        mm,
                                                                        iphlen,
                                                                        &mut offset,
                                                                        length,
                                                                        inp,
                                                                        stcb,
                                                                        net,
                                                                        &mut high_tsn,
                                                                    );
                                                                    if retval == 2i32 {
                                                                        stcb = 0 as *mut sctp_tcb;
                                                                        current_block =
                                                                            12421478865789499693;
                                                                    } else {
                                                                        data_processed = 1i32;
                                                                        current_block =
                                                                            11814324130289762492;
                                                                    }
                                                                }
                                                            },
                                                        }
                                                    }
                                                    1 => {
                                                        current_block = 8591739767839194136;
                                                        match current_block {
                                                            9939481037457836954 => {
                                                                snprintf(msg.as_mut_ptr(),
                                                                         ::std::mem::size_of::<[libc::c_char; 128]>()
                                                                             as
                                                                             libc::c_ulong,
                                                                         b"OOTB, %s:%d at %s\x00"
                                                                             as
                                                                             *const u8
                                                                             as
                                                                             *const libc::c_char,
                                                                         b"/usr/local/google/home/winniexiao/chromium/src/third_party/usrsctp/usrsctplib/usrsctplib/netinet/sctp_input.c\x00"
                                                                             as
                                                                             *const u8
                                                                             as
                                                                             *const libc::c_char,
                                                                         6057i32,
                                                                         (*::std::mem::transmute::<&[u8; 29],
                                                                                                   &[libc::c_char; 29]>(b"sctp_common_input_processing\x00")).as_ptr());
                                                                op_err = sctp_generate_cause(
                                                                    system_base_info
                                                                        .sctpsysctl
                                                                        .sctp_diag_info_code
                                                                        as uint16_t,
                                                                    msg.as_mut_ptr(),
                                                                );
                                                                sctp_handle_ootb(
                                                                    m, iphlen, offset, src, dst,
                                                                    sh, inp, op_err, vrf_id, port,
                                                                );
                                                                current_block =
                                                                    12421478865789499693;
                                                            }
                                                            2508233535837710749 => {
                                                                sctp_handle_cookie_ack(ch
                                                                                           as
                                                                                           *mut sctp_cookie_ack_chunk,
                                                                                       stcb,
                                                                                       net);
                                                                current_block =
                                                                    13598848910332274892;
                                                            }
                                                            8048488660607665034 => {
                                                                current_block = 8591739767839194136;
                                                            }
                                                            _ => {}
                                                        }
                                                        match current_block {
                                                            12421478865789499693 => {}
                                                            _ => match current_block {
                                                                8591739767839194136 => {
                                                                    current_block =
                                                                        12421478865789499693;
                                                                }
                                                                _ => {
                                                                    retval = sctp_process_data(
                                                                        mm,
                                                                        iphlen,
                                                                        &mut offset,
                                                                        length,
                                                                        inp,
                                                                        stcb,
                                                                        net,
                                                                        &mut high_tsn,
                                                                    );
                                                                    if retval == 2i32 {
                                                                        stcb = 0 as *mut sctp_tcb;
                                                                        current_block =
                                                                            12421478865789499693;
                                                                    } else {
                                                                        data_processed = 1i32;
                                                                        current_block =
                                                                            11814324130289762492;
                                                                    }
                                                                }
                                                            },
                                                        }
                                                    }
                                                    8 | 16 => {
                                                        current_block = 13598848910332274892;
                                                        match current_block {
                                                            9939481037457836954 => {
                                                                snprintf(msg.as_mut_ptr(),
                                                                         ::std::mem::size_of::<[libc::c_char; 128]>()
                                                                             as
                                                                             libc::c_ulong,
                                                                         b"OOTB, %s:%d at %s\x00"
                                                                             as
                                                                             *const u8
                                                                             as
                                                                             *const libc::c_char,
                                                                         b"/usr/local/google/home/winniexiao/chromium/src/third_party/usrsctp/usrsctplib/usrsctplib/netinet/sctp_input.c\x00"
                                                                             as
                                                                             *const u8
                                                                             as
                                                                             *const libc::c_char,
                                                                         6057i32,
                                                                         (*::std::mem::transmute::<&[u8; 29],
                                                                                                   &[libc::c_char; 29]>(b"sctp_common_input_processing\x00")).as_ptr());
                                                                op_err = sctp_generate_cause(
                                                                    system_base_info
                                                                        .sctpsysctl
                                                                        .sctp_diag_info_code
                                                                        as uint16_t,
                                                                    msg.as_mut_ptr(),
                                                                );
                                                                sctp_handle_ootb(
                                                                    m, iphlen, offset, src, dst,
                                                                    sh, inp, op_err, vrf_id, port,
                                                                );
                                                                current_block =
                                                                    12421478865789499693;
                                                            }
                                                            2508233535837710749 => {
                                                                sctp_handle_cookie_ack(ch
                                                                                           as
                                                                                           *mut sctp_cookie_ack_chunk,
                                                                                       stcb,
                                                                                       net);
                                                                current_block =
                                                                    13598848910332274892;
                                                            }
                                                            8048488660607665034 => {
                                                                current_block = 8591739767839194136;
                                                            }
                                                            _ => {}
                                                        }
                                                        match current_block {
                                                            12421478865789499693 => {}
                                                            _ => match current_block {
                                                                8591739767839194136 => {
                                                                    current_block =
                                                                        12421478865789499693;
                                                                }
                                                                _ => {
                                                                    retval = sctp_process_data(
                                                                        mm,
                                                                        iphlen,
                                                                        &mut offset,
                                                                        length,
                                                                        inp,
                                                                        stcb,
                                                                        net,
                                                                        &mut high_tsn,
                                                                    );
                                                                    if retval == 2i32 {
                                                                        stcb = 0 as *mut sctp_tcb;
                                                                        current_block =
                                                                            12421478865789499693;
                                                                    } else {
                                                                        data_processed = 1i32;
                                                                        current_block =
                                                                            11814324130289762492;
                                                                    }
                                                                }
                                                            },
                                                        }
                                                    }
                                                    32 | 64 | _ => {
                                                        current_block = 12421478865789499693;
                                                    }
                                                }
                                            } else {
                                                current_block = 11814324130289762492;
                                            }
                                            match current_block {
                                                12421478865789499693 => {}
                                                _ => {
                                                    /* take care of ecn */
                                                    if data_processed == 1i32
                                                        && (*stcb).asoc.ecn_supported as libc::c_int
                                                            == 1i32
                                                        && ecn_bits as libc::c_int & 0x3i32
                                                            == 0x3i32
                                                    {
                                                        /* Yep, we need to add a ECNE */
                                                        sctp_send_ecn_echo(stcb, net, high_tsn);
                                                    }
                                                    if data_processed == 0i32 && fwd_tsn_seen != 0 {
                                                        let mut was_a_gap = 0;
                                                        let mut highest_tsn = 0;
                                                        if (*stcb).asoc.highest_tsn_inside_nr_map
                                                            < (*stcb).asoc.highest_tsn_inside_map
                                                            && (*stcb)
                                                                .asoc
                                                                .highest_tsn_inside_map
                                                                .wrapping_sub(
                                                                    (*stcb)
                                                                        .asoc
                                                                        .highest_tsn_inside_nr_map,
                                                                )
                                                                > (1u32) << 31i32
                                                            || (*stcb)
                                                                .asoc
                                                                .highest_tsn_inside_nr_map
                                                                > (*stcb)
                                                                    .asoc
                                                                    .highest_tsn_inside_map
                                                                && (*stcb)
                                                                    .asoc
                                                                    .highest_tsn_inside_nr_map
                                                                    .wrapping_sub(
                                                                        (*stcb)
                                                                            .asoc
                                                                            .highest_tsn_inside_map,
                                                                    )
                                                                    < (1u32) << 31i32
                                                        {
                                                            highest_tsn = (*stcb)
                                                                .asoc
                                                                .highest_tsn_inside_nr_map
                                                        } else {
                                                            highest_tsn =
                                                                (*stcb).asoc.highest_tsn_inside_map
                                                        }
                                                        was_a_gap = (highest_tsn
                                                            < (*stcb).asoc.cumulative_tsn
                                                            && (*stcb)
                                                                .asoc
                                                                .cumulative_tsn
                                                                .wrapping_sub(highest_tsn)
                                                                > (1u32) << 31i32
                                                            || highest_tsn
                                                                > (*stcb).asoc.cumulative_tsn
                                                                && highest_tsn.wrapping_sub(
                                                                    (*stcb).asoc.cumulative_tsn,
                                                                ) < (1u32) << 31i32)
                                                            as libc::c_int;
                                                        (*stcb).asoc.send_sack = 1u8;
                                                        sctp_sack_check(stcb, was_a_gap);
                                                    } else if fwd_tsn_seen != 0 {
                                                        (*stcb).asoc.send_sack = 1u8
                                                    }
                                                    current_block = 1855476810607665536;
                                                }
                                            }
                                        }
                                        match current_block {
                                            12421478865789499693 => {}
                                            _ =>
                                            /* trigger send of any chunks in queue... */
                                            {
                                                let mut un_sent = 0;
                                                let mut cnt_ctrl_ready = 0i32;
                                                if system_base_info.sctpsysctl.sctp_debug_on
                                                    & 0x1000u32
                                                    != 0
                                                {
                                                    if system_base_info.debug_printf.is_some() {
                                                        system_base_info.debug_printf.expect("non-null function pointer")(b"Check for chunk output prw:%d tqe:%d tf=%d\n\x00"
                                                                                                                              as
                                                                                                                              *const u8
                                                                                                                              as
                                                                                                                              *const libc::c_char,
                                                                                                                          (*stcb).asoc.peers_rwnd,
                                                                                                                          ((*stcb).asoc.control_send_queue.tqh_first
                                                                                                                               ==

                                                                                                                               0
                                                                                                                                   as
                                                                                                                                   *mut sctp_tmit_chunk)
                                                                                                                              as
                                                                                                                              libc::c_int,
                                                                                                                          (*stcb).asoc.total_flight);
                                                    }
                                                }
                                                un_sent = (*stcb)
                                                    .asoc
                                                    .total_output_queue_size
                                                    .wrapping_sub((*stcb).asoc.total_flight)
                                                    as libc::c_int;
                                                if !(*stcb)
                                                    .asoc
                                                    .control_send_queue
                                                    .tqh_first
                                                    .is_null()
                                                {
                                                    cnt_ctrl_ready = (*stcb).asoc.ctrl_queue_cnt
                                                        - (*stcb).asoc.ecn_echo_cnt_onq
                                                            as libc::c_int
                                                }
                                                if !(*stcb)
                                                    .asoc
                                                    .asconf_send_queue
                                                    .tqh_first
                                                    .is_null()
                                                    || cnt_ctrl_ready != 0
                                                    || (*stcb).asoc.trigger_reset as libc::c_int
                                                        != 0
                                                    || un_sent != 0
                                                        && ((*stcb).asoc.peers_rwnd > 0u32
                                                            || (*stcb).asoc.peers_rwnd <= 0u32
                                                                && (*stcb).asoc.total_flight
                                                                    == 0u32)
                                                {
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"Calling chunk OUTPUT\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                    sctp_chunk_output(inp, stcb, 3i32, 0i32);
                                                    if system_base_info.sctpsysctl.sctp_debug_on
                                                        & 0x4000u32
                                                        != 0
                                                    {
                                                        if system_base_info.debug_printf.is_some() {
                                                            system_base_info.debug_printf.expect(
                                                                "non-null function pointer",
                                                            )(
                                                                b"chunk OUTPUT returns\n\x00"
                                                                    as *const u8
                                                                    as *const libc::c_char,
                                                            );
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }
    /* This is a peer error */
    if !stcb.is_null() {
        pthread_mutex_unlock(&mut (*stcb).tcb_mtx);
    }
    if !upcall_socket.is_null() {
        if (*upcall_socket).so_upcall.is_some() {
            if (*upcall_socket).so_rcv.sb_cc as libc::c_int >= (*upcall_socket).so_rcv.sb_lowat
                || (*upcall_socket).so_rcv.sb_state as libc::c_int & 0x20i32 != 0
                || !(*upcall_socket).so_comp.tqh_first.is_null()
                || (*upcall_socket).so_error as libc::c_int != 0
                || ((if (*upcall_socket)
                    .so_snd
                    .sb_hiwat
                    .wrapping_sub((*upcall_socket).so_snd.sb_cc)
                    as libc::c_int
                    > (*upcall_socket)
                        .so_snd
                        .sb_mbmax
                        .wrapping_sub((*upcall_socket).so_snd.sb_mbcnt)
                        as libc::c_int
                {
                    (*upcall_socket)
                        .so_snd
                        .sb_mbmax
                        .wrapping_sub((*upcall_socket).so_snd.sb_mbcnt)
                        as libc::c_int
                } else {
                    (*upcall_socket)
                        .so_snd
                        .sb_hiwat
                        .wrapping_sub((*upcall_socket).so_snd.sb_cc)
                        as libc::c_int
                }) as libc::c_long
                    >= (*upcall_socket).so_snd.sb_lowat as libc::c_long
                    && (*upcall_socket).so_state as libc::c_int & 0x2i32 != 0
                    || (*upcall_socket).so_snd.sb_state as libc::c_int & 0x10i32 != 0
                    || (*upcall_socket).so_error as libc::c_int != 0)
                || (*upcall_socket).so_error as libc::c_int != 0
            {
                Some(
                    (*upcall_socket)
                        .so_upcall
                        .expect("non-null function pointer"),
                )
                .expect("non-null function pointer")(
                    upcall_socket,
                    (*upcall_socket).so_upcallarg,
                    0x1i32,
                );
            }
        }
        pthread_mutex_lock(&mut accept_mtx);
        pthread_mutex_lock(&mut (*upcall_socket).so_rcv.sb_mtx);
        (*upcall_socket).so_count -= 1;
        if (*upcall_socket).so_count == 0i32 {
            sofree(upcall_socket);
        } else {
            pthread_mutex_unlock(&mut (*upcall_socket).so_rcv.sb_mtx);
            pthread_mutex_unlock(&mut accept_mtx);
        }
    }
    if !inp_decr.is_null() {
        /* reduce ref-count */
        pthread_mutex_lock(&mut (*inp_decr).inp_mtx);
        ::std::intrinsics::atomic_xadd(&mut (*inp_decr).refcount, -(1i32));
        pthread_mutex_unlock(&mut (*inp_decr).inp_mtx);
    };
}
